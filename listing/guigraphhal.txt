; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list -c --asm --interleave -o.\FLASH\guigraphhal.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\guigraphhal.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -I.\src\gui -I.\src\gui\guiCore -I.\src\gui\guiWidgets -I.\src\gui\guiGraphics -I.\src\gui\utils -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\guigraphhal.crf src\gui\guiGraphics\guiGraphHAL.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  LCD_SetPixelOutputMode PROC
;;;30     //-------------------------------------------------------//
;;;31     void LCD_SetPixelOutputMode(uint8_t newMode)
000000  2200              MOVS     r2,#0
;;;32     {
;;;33         switch (newMode)
;;;34         {
;;;35             case PIXEL_MODE_AND:
;;;36                 pixel_and_mask = 0x00;
000002  49a0              LDR      r1,|L1.644|
000004  2801              CMP      r0,#1                 ;33
000006  d008              BEQ      |L1.26|
;;;37                 pixel_or_mask = 0x00;
;;;38                 pixel_xor_mask = 0x00;
;;;39                 break;
;;;40             case PIXEL_MODE_OR:
;;;41                 pixel_and_mask = 0xFF;
000008  23ff              MOVS     r3,#0xff
00000a  2802              CMP      r0,#2                 ;33
00000c  d009              BEQ      |L1.34|
00000e  2803              CMP      r0,#3                 ;33
000010  d00b              BEQ      |L1.42|
;;;42                 pixel_or_mask = 0xFF;
;;;43                 pixel_xor_mask = 0x00;
;;;44                 break;
;;;45             case PIXEL_MODE_XOR:
;;;46                 pixel_and_mask = 0xFF;
;;;47                 pixel_or_mask = 0x00;
;;;48                 pixel_xor_mask = 0xFF;
;;;49                 break;
;;;50             default:    // PIXEL_MODE_REWRITE:
;;;51                 pixel_and_mask = 0x00;
000012  704a              STRB     r2,[r1,#1]
;;;52                 pixel_or_mask = 0xFF;
000014  708b              STRB     r3,[r1,#2]
;;;53                 pixel_xor_mask = 0x00;
000016  70ca              STRB     r2,[r1,#3]
;;;54                 break;
;;;55         }
;;;56     }
000018  4770              BX       lr
                  |L1.26|
00001a  704a              STRB     r2,[r1,#1]            ;36
00001c  708a              STRB     r2,[r1,#2]            ;37
00001e  70ca              STRB     r2,[r1,#3]            ;38
000020  4770              BX       lr
                  |L1.34|
000022  704b              STRB     r3,[r1,#1]            ;41
000024  708b              STRB     r3,[r1,#2]            ;42
000026  70ca              STRB     r2,[r1,#3]            ;43
000028  4770              BX       lr
                  |L1.42|
00002a  704b              STRB     r3,[r1,#1]            ;46
00002c  708a              STRB     r2,[r1,#2]            ;47
00002e  70cb              STRB     r3,[r1,#3]            ;48
000030  4770              BX       lr
;;;57     
                          ENDP

                  LCD_SetLineStyle PROC
;;;62     //-------------------------------------------------------//
;;;63     void LCD_SetLineStyle(uint8_t newStyle)
000032  4994              LDR      r1,|L1.644|
;;;64     {
;;;65         if (newStyle != LCD_lineStyle)
000034  780a              LDRB     r2,[r1,#0]  ; LCD_lineStyle
000036  4290              CMP      r0,r2
000038  d000              BEQ      |L1.60|
;;;66         {
;;;67             LCD_lineStyle = newStyle;
00003a  7008              STRB     r0,[r1,#0]
                  |L1.60|
;;;68         }
;;;69     }
00003c  4770              BX       lr
;;;70     
                          ENDP

                  LCD_FillWholeBuffer PROC
;;;78     //-------------------------------------------------------//
;;;79     void LCD_FillWholeBuffer(uint8_t pixelValue)
00003e  b100              CBZ      r0,|L1.66|
;;;80     {
;;;81         uint16_t i;
;;;82         if (pixelValue) pixelValue = 0xFF;
000040  20ff              MOVS     r0,#0xff
                  |L1.66|
;;;83     
;;;84         for (i=0;i<LCD_BUFFER_SIZE;i++)
000042  2100              MOVS     r1,#0
;;;85         {
;;;86             lcdBuffer[i] = pixelValue;
000044  4a90              LDR      r2,|L1.648|
000046  f44f63d8          MOV      r3,#0x6c0             ;84
                  |L1.74|
00004a  5450              STRB     r0,[r2,r1]
00004c  1c49              ADDS     r1,r1,#1              ;84
00004e  b289              UXTH     r1,r1                 ;84
000050  4299              CMP      r1,r3                 ;84
000052  d3fa              BCC      |L1.74|
;;;87         }
;;;88     }
000054  4770              BX       lr
;;;89     
                          ENDP

                  LCD_PutPixel PROC
;;;99     //-------------------------------------------------------//
;;;100    void LCD_PutPixel (uint8_t x_pos, uint8_t y_pos, uint8_t pixelValue)
000056  b5f0              PUSH     {r4-r7,lr}
;;;101    {
;;;102        int16_t buffer_index;
;;;103        uint8_t data, bit_mask;
;;;104        if (pixelValue) pixelValue = 0xFF;
000058  b102              CBZ      r2,|L1.92|
00005a  22ff              MOVS     r2,#0xff
                  |L1.92|
;;;105        // Get byte index
;;;106        #ifdef SOFT_HORIZ_REVERSED
;;;107            buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + LCD_XSIZE - 1 - x_pos;
;;;108        #else
;;;109            buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + x_pos;
00005c  08cb              LSRS     r3,r1,#3
00005e  eb030343          ADD      r3,r3,r3,LSL #1
000062  eb001383          ADD      r3,r0,r3,LSL #6
;;;110        #endif
;;;111        // Bit mask defines changed pixel
;;;112        bit_mask = 1 << (y_pos % 8);
000066  f0010107          AND      r1,r1,#7
00006a  2001              MOVS     r0,#1
00006c  4088              LSLS     r0,r0,r1
;;;113        // Modify data byte
;;;114        data = (uint8_t)lcdBuffer[buffer_index];
00006e  4e86              LDR      r6,|L1.648|
000070  5cf5              LDRB     r5,[r6,r3]
;;;115        data &= pixelValue | ~bit_mask | pixel_and_mask;
000072  4984              LDR      r1,|L1.644|
000074  ea620400          ORN      r4,r2,r0
000078  784f              LDRB     r7,[r1,#1]  ; pixel_and_mask
00007a  433c              ORRS     r4,r4,r7
00007c  402c              ANDS     r4,r4,r5
;;;116        data |= pixelValue & bit_mask & pixel_or_mask;
00007e  4002              ANDS     r2,r2,r0
000080  7888              LDRB     r0,[r1,#2]  ; pixel_or_mask
000082  4010              ANDS     r0,r0,r2
000084  4320              ORRS     r0,r0,r4
;;;117        data ^= pixelValue & bit_mask & pixel_xor_mask;
000086  78c9              LDRB     r1,[r1,#3]  ; pixel_xor_mask
000088  400a              ANDS     r2,r2,r1
00008a  4042              EORS     r2,r2,r0
;;;118        lcdBuffer[buffer_index] = data;
00008c  54f2              STRB     r2,[r6,r3]
;;;119    }
00008e  bdf0              POP      {r4-r7,pc}
;;;120    
                          ENDP

                  LCD_DrawHorLine PROC
;;;130    //-------------------------------------------------------//
;;;131    void LCD_DrawHorLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t pixelValue)
000090  e92d4ff0          PUSH     {r4-r11,lr}
;;;132    {
;;;133        uint16_t buffer_index;
;;;134        int8_t buffer_increment;
;;;135        uint8_t data, bit_mask;
;;;136        uint8_t pixelInversed;
;;;137        uint8_t dashCompare;
;;;138        uint8_t dashPeriod;
;;;139        uint8_t dashCounter = 0;
000094  2400              MOVS     r4,#0
;;;140    
;;;141        if (pixelValue) pixelValue = 0xFF;
000096  b103              CBZ      r3,|L1.154|
000098  23ff              MOVS     r3,#0xff
                  |L1.154|
;;;142    
;;;143        switch(LCD_lineStyle)
00009a  f8dfa1e8          LDR      r10,|L1.644|
00009e  f89a5000          LDRB     r5,[r10,#0]  ; LCD_lineStyle
0000a2  2d20              CMP      r5,#0x20
0000a4  d010              BEQ      |L1.200|
0000a6  2d30              CMP      r5,#0x30
0000a8  d011              BEQ      |L1.206|
;;;144        {
;;;145            case LINE_STYLE_DASHED:
;;;146                dashPeriod = LCD_DASH_PERIOD;
;;;147                dashCompare = LCD_DASH_COMPARE;
;;;148                break;
;;;149            case LINE_STYLE_DOTTED:
;;;150                dashPeriod = LCD_DOT_PERIOD;
;;;151                dashCompare = LCD_DOT_COMPARE;
;;;152                break;
;;;153             default: //LINE_STYLE_SOLID:
;;;154                dashPeriod = 10;
0000aa  260a              MOVS     r6,#0xa
;;;155                dashCompare = 10;   // arbitrary, but >= dashPeriod
0000ac  250a              MOVS     r5,#0xa
                  |L1.174|
;;;156                break;
;;;157        }
;;;158    
;;;159        // Get byte index
;;;160        #ifdef SOFT_HORIZ_REVERSED
;;;161            buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + LCD_XSIZE - 1 - x_pos;
;;;162            buffer_increment = -1;
;;;163        #else
;;;164            buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + x_pos;
0000ae  08cf              LSRS     r7,r1,#3
0000b0  eb070747          ADD      r7,r7,r7,LSL #1
0000b4  eb001087          ADD      r0,r0,r7,LSL #6
;;;165            buffer_increment = 1;
0000b8  f04f0b01          MOV      r11,#1
;;;166        #endif
;;;167        // Bit mask defines changed pixel
;;;168        bit_mask = 1 << (y_pos % 8);
0000bc  f0010707          AND      r7,r1,#7
0000c0  2101              MOVS     r1,#1
0000c2  40b9              LSLS     r1,r1,r7
0000c4  b2cf              UXTB     r7,r1
;;;169        while(length)
0000c6  e02e              B        |L1.294|
                  |L1.200|
0000c8  2607              MOVS     r6,#7                 ;146
0000ca  2505              MOVS     r5,#5                 ;147
0000cc  e7ef              B        |L1.174|
                  |L1.206|
0000ce  2604              MOVS     r6,#4                 ;150
0000d0  2502              MOVS     r5,#2                 ;151
0000d2  e7ec              B        |L1.174|
                  |L1.212|
;;;170        {
;;;171            pixelInversed = (dashCounter < dashCompare) ? pixelValue : ~pixelValue;
0000d4  42ac              CMP      r4,r5
0000d6  d201              BCS      |L1.220|
0000d8  4619              MOV      r1,r3
0000da  e000              B        |L1.222|
                  |L1.220|
0000dc  43d9              MVNS     r1,r3
                  |L1.222|
;;;172    
;;;173            // Modify data byte
;;;174            data = (uint8_t)lcdBuffer[buffer_index];
0000de  f8dfe1a8          LDR      lr,|L1.648|
0000e2  f81ec000          LDRB     r12,[lr,r0]
;;;175            data &= pixelInversed | ~bit_mask | pixel_and_mask;
0000e6  f89a9001          LDRB     r9,[r10,#1]  ; pixel_and_mask
0000ea  ea610807          ORN      r8,r1,r7
0000ee  ea480809          ORR      r8,r8,r9
0000f2  ea08090c          AND      r9,r8,r12
;;;176            data |= pixelInversed & bit_mask & pixel_or_mask;
0000f6  f89ac002          LDRB     r12,[r10,#2]  ; pixel_or_mask
0000fa  4039              ANDS     r1,r1,r7
0000fc  ea010c0c          AND      r12,r1,r12
000100  ea4c0c09          ORR      r12,r12,r9
;;;177            data ^= pixelInversed & bit_mask & pixel_xor_mask;
000104  f89a8003          LDRB     r8,[r10,#3]  ; pixel_xor_mask
000108  ea010108          AND      r1,r1,r8
00010c  ea81010c          EOR      r1,r1,r12
;;;178            lcdBuffer[buffer_index] = data;
000110  f80e1000          STRB     r1,[lr,r0]
;;;179            buffer_index += buffer_increment;
000114  4458              ADD      r0,r0,r11
000116  b280              UXTH     r0,r0
;;;180            length--;
000118  1e52              SUBS     r2,r2,#1
00011a  b2d2              UXTB     r2,r2
;;;181    
;;;182            dashCounter++;
00011c  1c64              ADDS     r4,r4,#1
00011e  b2e4              UXTB     r4,r4
;;;183            if (dashCounter == dashPeriod)
000120  42b4              CMP      r4,r6
000122  d100              BNE      |L1.294|
;;;184                dashCounter = 0;
000124  2400              MOVS     r4,#0
                  |L1.294|
000126  2a00              CMP      r2,#0                 ;169
000128  d1d4              BNE      |L1.212|
                  |L1.298|
;;;185        }
;;;186    }
00012a  e8bd8ff0          POP      {r4-r11,pc}
;;;187    
                          ENDP

                  LCD_DrawVertLine PROC
;;;196    //-------------------------------------------------------//
;;;197    void LCD_DrawVertLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t pixelValue)
00012e  e92d4ff0          PUSH     {r4-r11,lr}
;;;198    {
000132  4683              MOV      r11,r0
000134  4689              MOV      r9,r1
000136  4615              MOV      r5,r2
000138  461e              MOV      r6,r3
;;;199        uint8_t dashCompare;
;;;200        uint8_t dashPeriod;
;;;201        uint8_t dashCounter = 0;
00013a  2400              MOVS     r4,#0
;;;202        uint8_t pixelInversed;
;;;203    
;;;204        if (pixelValue) pixelValue = 0xFF;
00013c  b106              CBZ      r6,|L1.320|
00013e  26ff              MOVS     r6,#0xff
                  |L1.320|
;;;205    
;;;206        switch(LCD_lineStyle)
000140  4850              LDR      r0,|L1.644|
000142  7800              LDRB     r0,[r0,#0]  ; LCD_lineStyle
000144  2820              CMP      r0,#0x20
000146  d007              BEQ      |L1.344|
000148  2830              CMP      r0,#0x30
00014a  d009              BEQ      |L1.352|
;;;207        {
;;;208            case LINE_STYLE_DASHED:
;;;209                dashPeriod = LCD_DASH_PERIOD;
;;;210                dashCompare = LCD_DASH_COMPARE;
;;;211                break;
;;;212            case LINE_STYLE_DOTTED:
;;;213                dashPeriod = LCD_DOT_PERIOD;
;;;214                dashCompare = LCD_DOT_COMPARE;
;;;215                break;
;;;216             default: //LINE_STYLE_SOLID:
;;;217                dashPeriod = 10;
00014c  f04f080a          MOV      r8,#0xa
;;;218                dashCompare = 10;   // arbitrary, but >= dashPeriod
000150  270a              MOVS     r7,#0xa
                  |L1.338|
;;;219                break;
;;;220        }
;;;221    
;;;222        while(length)
;;;223        {
;;;224            pixelInversed = (dashCounter < dashCompare) ? pixelValue : ~pixelValue;
000152  ea6f0a06          MVN      r10,r6
;;;225    
;;;226            LCD_PutPixel(x_pos, y_pos, pixelInversed);
;;;227            y_pos++;
;;;228            length--;
;;;229    
;;;230            dashCounter++;
;;;231            if (dashCounter == dashPeriod)
;;;232                dashCounter = 0;
000156  e01c              B        |L1.402|
                  |L1.344|
000158  f04f0807          MOV      r8,#7                 ;209
00015c  2705              MOVS     r7,#5                 ;210
00015e  e7f8              B        |L1.338|
                  |L1.352|
000160  f04f0804          MOV      r8,#4                 ;213
000164  2702              MOVS     r7,#2                 ;214
000166  e7f4              B        |L1.338|
                  |L1.360|
000168  42bc              CMP      r4,r7                 ;224
00016a  d201              BCS      |L1.368|
00016c  4630              MOV      r0,r6                 ;224
00016e  e000              B        |L1.370|
                  |L1.368|
000170  4650              MOV      r0,r10                ;224
                  |L1.370|
000172  b2c2              UXTB     r2,r0                 ;224
000174  4649              MOV      r1,r9                 ;226
000176  4658              MOV      r0,r11                ;226
000178  f7fffffe          BL       LCD_PutPixel
00017c  f1090901          ADD      r9,r9,#1              ;227
000180  f00909ff          AND      r9,r9,#0xff           ;227
000184  1e6d              SUBS     r5,r5,#1              ;228
000186  b2ed              UXTB     r5,r5                 ;228
000188  1c64              ADDS     r4,r4,#1              ;230
00018a  b2e4              UXTB     r4,r4                 ;230
00018c  4544              CMP      r4,r8                 ;231
00018e  d100              BNE      |L1.402|
000190  2400              MOVS     r4,#0
                  |L1.402|
000192  2d00              CMP      r5,#0                 ;222
000194  d1e8              BNE      |L1.360|
;;;233        }
;;;234    }
000196  e7c8              B        |L1.298|
;;;235    
                          ENDP

                  LCD_DrawImage PROC
;;;346    //-------------------------------------------------------//
;;;347    void LCD_DrawImage(const uint8_t* img, uint8_t x_pos, uint8_t y_pos, uint8_t width, uint8_t height, uint8_t mode)
000198  e92d4fff          PUSH     {r0-r11,lr}
;;;348    {
00019c  b081              SUB      sp,sp,#4
00019e  e9dd930e          LDRD     r9,r3,[sp,#0x38]
;;;349        uint16_t vertical_bits_remain, counter_inc; // counter_inc - uint8_t ? FIXME
;;;350        uint16_t picture_index, buffer_index;
;;;351        uint16_t start_buffer_index;
;;;352        uint16_t i;
;;;353        uint16_t img_shift;
;;;354        uint8_t bit_mask, temp;
;;;355        uint8_t offset = y_pos % 8;
0001a2  f0020c07          AND      r12,r2,#7
;;;356        /*
;;;357            img != 0, mode = 1 - print text as black
;;;358                => mode = 0x00
;;;359            img != 0, mode = 0 - print text as white
;;;360                => mode = 0xFF
;;;361            img = 0, mode = 1 - fill with black
;;;362                => mode = 0x00
;;;363            img = 0, mode = 0 - fill with white
;;;364                => mode = 0xFF
;;;365        */
;;;366        mode = (mode) ? 0x00 : 0xFF;
0001a6  b10b              CBZ      r3,|L1.428|
0001a8  2300              MOVS     r3,#0
0001aa  e000              B        |L1.430|
                  |L1.428|
0001ac  23ff              MOVS     r3,#0xff
                  |L1.430|
0001ae  930f              STR      r3,[sp,#0x3c]
;;;367    
;;;368        #ifdef SOFT_HORIZ_REVERSED
;;;369            start_buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + LCD_XSIZE - 1 - x_pos;
;;;370        #else
;;;371            start_buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + x_pos;
0001b0  08d2              LSRS     r2,r2,#3
0001b2  eb020242          ADD      r2,r2,r2,LSL #1
0001b6  eb011182          ADD      r1,r1,r2,LSL #6
0001ba  9100              STR      r1,[sp,#0]
;;;372        #endif
;;;373    
;;;374        //-------------//
;;;375    
;;;376        // X-loop
;;;377        for (i=0;i<width;i++)
0001bc  2600              MOVS     r6,#0
0001be  e05c              B        |L1.634|
                  |L1.448|
;;;378        {
;;;379                img_shift = 0;
0001c0  f04f0800          MOV      r8,#0
;;;380                picture_index = i;
0001c4  4637              MOV      r7,r6
;;;381                #ifdef SOFT_HORIZ_REVERSED
;;;382                    buffer_index =  start_buffer_index - i;
;;;383                #else
;;;384                    buffer_index =  start_buffer_index + i;
0001c6  9900              LDR      r1,[sp,#0]
0001c8  4431              ADD      r1,r1,r6
0001ca  b28c              UXTH     r4,r1
;;;385                #endif
;;;386                vertical_bits_remain = height;
0001cc  4649              MOV      r1,r9
;;;387                bit_mask = -(1<<offset);
0001ce  2201              MOVS     r2,#1
0001d0  fa02f20c          LSL      r2,r2,r12
0001d4  4252              RSBS     r2,r2,#0
0001d6  b2d3              UXTB     r3,r2
;;;388    
;;;389                if (offset + height < 8 )
0001d8  eb0c0209          ADD      r2,r12,r9
0001dc  2a08              CMP      r2,#8
0001de  d206              BCS      |L1.494|
;;;390                {
;;;391                    temp = (1<<(offset + height))-1;
0001e0  2501              MOVS     r5,#1
0001e2  4095              LSLS     r5,r5,r2
0001e4  1e6d              SUBS     r5,r5,#1
0001e6  b2ea              UXTB     r2,r5
;;;392                    bit_mask &= temp;
0001e8  4013              ANDS     r3,r3,r2
;;;393                    counter_inc = height;
0001ea  464a              MOV      r2,r9
0001ec  e041              B        |L1.626|
                  |L1.494|
;;;394                }
;;;395                else
;;;396                {
;;;397                    counter_inc = 8-offset;
0001ee  f1cc0208          RSB      r2,r12,#8
0001f2  b292              UXTH     r2,r2
0001f4  e03d              B        |L1.626|
                  |L1.502|
;;;398                }
;;;399    
;;;400                // Y-loop
;;;401                while(vertical_bits_remain)
;;;402                {
;;;403                    if (img != 0)
0001f6  b108              CBZ      r0,|L1.508|
;;;404                        temp = img[picture_index];                  // get image byte
0001f8  5dc5              LDRB     r5,[r0,r7]
0001fa  e000              B        |L1.510|
                  |L1.508|
;;;405                    else
;;;406                        temp = 0xFF;
0001fc  25ff              MOVS     r5,#0xff
                  |L1.510|
;;;407                    temp ^= mode;
0001fe  f8dda03c          LDR      r10,[sp,#0x3c]
000202  ea85050a          EOR      r5,r5,r10
;;;408                    img_shift |= temp << offset;					// add shifted value to the 16-bit accumulator
000206  fa05f50c          LSL      r5,r5,r12
00020a  ea450508          ORR      r5,r5,r8
00020e  b2ad              UXTH     r5,r5
;;;409    
;;;410                    temp = (uint8_t)lcdBuffer[buffer_index];     // get old value
000210  f8df8074          LDR      r8,|L1.648|
000214  f818e004          LDRB     lr,[r8,r4]
;;;411                    // Modify data byte
;;;412                    // Bit mask defines changed pixel
;;;413                    temp &= img_shift | ~bit_mask | pixel_and_mask;
000218  f8dfa068          LDR      r10,|L1.644|
00021c  ea650b03          ORN      r11,r5,r3
000220  f89a8001          LDRB     r8,[r10,#1]  ; pixel_and_mask
000224  ea4b0b08          ORR      r11,r11,r8
000228  ea0b0b0e          AND      r11,r11,lr
;;;414                    temp |= img_shift & bit_mask & pixel_or_mask;
00022c  ea050803          AND      r8,r5,r3
000230  f89a3002          LDRB     r3,[r10,#2]  ; pixel_or_mask
000234  ea080303          AND      r3,r8,r3
000238  ea43030b          ORR      r3,r3,r11
;;;415                    temp ^= img_shift & bit_mask & pixel_xor_mask;
00023c  f89aa003          LDRB     r10,[r10,#3]  ; pixel_xor_mask
000240  ea08080a          AND      r8,r8,r10
000244  ea880803          EOR      r8,r8,r3
;;;416                    lcdBuffer[buffer_index] = temp;              // write new value back
000248  4b0f              LDR      r3,|L1.648|
00024a  f8038004          STRB     r8,[r3,r4]
;;;417    
;;;418                    img_shift = img_shift >> 8;						// shift 16-bit register
00024e  ea4f2815          LSR      r8,r5,#8
;;;419                    buffer_index += LCD_XSIZE;
000252  34c0              ADDS     r4,r4,#0xc0
000254  b2a4              UXTH     r4,r4
;;;420                    picture_index += width;
000256  9b04              LDR      r3,[sp,#0x10]
000258  443b              ADD      r3,r3,r7
00025a  b29f              UXTH     r7,r3
;;;421    
;;;422                    vertical_bits_remain -= counter_inc;
00025c  1a89              SUBS     r1,r1,r2
00025e  b289              UXTH     r1,r1
;;;423                    if (vertical_bits_remain >= 8)
000260  2908              CMP      r1,#8
000262  d301              BCC      |L1.616|
;;;424                        counter_inc = 8;
000264  2208              MOVS     r2,#8
000266  e000              B        |L1.618|
                  |L1.616|
;;;425                    else
;;;426                        counter_inc = vertical_bits_remain;
000268  460a              MOV      r2,r1
                  |L1.618|
;;;427                    bit_mask = (1 << counter_inc)-1;
00026a  2301              MOVS     r3,#1
00026c  4093              LSLS     r3,r3,r2
00026e  1e5b              SUBS     r3,r3,#1
000270  b2db              UXTB     r3,r3
                  |L1.626|
000272  2900              CMP      r1,#0                 ;401
000274  d1bf              BNE      |L1.502|
000276  1c76              ADDS     r6,r6,#1              ;377
000278  b2b6              UXTH     r6,r6                 ;377
                  |L1.634|
00027a  9904              LDR      r1,[sp,#0x10]         ;377
00027c  428e              CMP      r6,r1                 ;377
00027e  d39f              BCC      |L1.448|
;;;428                }
;;;429        }
;;;430    }
000280  b005              ADD      sp,sp,#0x14
000282  e752              B        |L1.298|
;;;431    
                          ENDP

                  |L1.644|
                          DCD      ||.data||
                  |L1.648|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  lcdBuffer
                          %        1728

                          AREA ||.data||, DATA, ALIGN=0

                  LCD_lineStyle
000000  00                DCB      0x00
                  pixel_and_mask
000001  00                DCB      0x00
                  pixel_or_mask
000002  00                DCB      0x00
                  pixel_xor_mask
000003  00                DCB      0x00
