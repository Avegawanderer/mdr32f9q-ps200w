; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\port.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\port.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\port.crf ..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\port.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  prvTaskExitError PROC
;;;222    
;;;223    static void prvTaskExitError( void )
000000  f7fffffe          BL       ulPortSetInterruptMask
;;;224    {
;;;225    	/* A function that implements a task must not exit or attempt to return to
;;;226    	its caller as there is nothing to return to.  If a task wants to exit it 
;;;227    	should instead call vTaskDelete( NULL ).
;;;228    	
;;;229    	Artificially force an assert() to be triggered if configASSERT() is 
;;;230    	defined, then stop here so application writers can catch the error. */
;;;231    	configASSERT( uxCriticalNesting == ~0UL );
;;;232    	portDISABLE_INTERRUPTS();	
;;;233    	for( ;; );
000004  bf00              NOP      
                  |L1.6|
000006  e7fe              B        |L1.6|
;;;234    }
;;;235    /*-----------------------------------------------------------*/
                          ENDP

                  pxPortInitialiseStack PROC
;;;203     */
;;;204    portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
000008  1f00              SUBS     r0,r0,#4
;;;205    {
;;;206    	/* Simulate the stack frame as it would be created by a context switch
;;;207    	interrupt. */
;;;208    	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
;;;209    	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
00000a  f04f7380          MOV      r3,#0x1000000
00000e  6003              STR      r3,[r0,#0]
;;;210    	pxTopOfStack--;
000010  1f00              SUBS     r0,r0,#4
;;;211    	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
000012  6001              STR      r1,[r0,#0]
;;;212    	pxTopOfStack--;
000014  1f00              SUBS     r0,r0,#4
;;;213    	*pxTopOfStack = ( portSTACK_TYPE ) prvTaskExitError;	/* LR */
000016  4b2b              LDR      r3,|L1.196|
000018  6003              STR      r3,[r0,#0]
;;;214    
;;;215    	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
00001a  3814              SUBS     r0,r0,#0x14
;;;216    	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
00001c  6002              STR      r2,[r0,#0]
;;;217    	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
00001e  3820              SUBS     r0,r0,#0x20
;;;218    
;;;219    	return pxTopOfStack;
;;;220    }
000020  4770              BX       lr
;;;221    /*-----------------------------------------------------------*/
                          ENDP

                  vPortSetupTimerInterrupt PROC
;;;587    
;;;588    	void vPortSetupTimerInterrupt( void )
000022  f64f10ff          MOV      r0,#0xf9ff
;;;589    	{
;;;590    		/* Calculate the constants required to configure the tick interrupt. */
;;;591    		#if configUSE_TICKLESS_IDLE == 1
;;;592    		{
;;;593    			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
;;;594    			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
;;;595    			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
;;;596    		}
;;;597    		#endif /* configUSE_TICKLESS_IDLE */
;;;598    
;;;599    		/* Configure SysTick to interrupt at the requested rate. */
;;;600    		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
000026  f04f21e0          MOV      r1,#0xe000e000
00002a  6148              STR      r0,[r1,#0x14]
;;;601    		portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
00002c  2007              MOVS     r0,#7
00002e  6108              STR      r0,[r1,#0x10]
;;;602    	}
000030  4770              BX       lr
;;;603    
                          ENDP

                  xPortStartScheduler PROC
;;;273     */
;;;274    portBASE_TYPE xPortStartScheduler( void )
000032  b510              PUSH     {r4,lr}
;;;275    {
;;;276    	#if( configASSERT_DEFINED == 1 )
;;;277    	{
;;;278    		volatile unsigned long ulOriginalPriority;
;;;279    		volatile char * const pcFirstUserPriorityRegister = ( char * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
;;;280    		volatile unsigned char ucMaxPriorityValue;
;;;281    
;;;282    		/* Determine the maximum priority from which ISR safe FreeRTOS API
;;;283    		functions can be called.  ISR safe functions are those that end in
;;;284    		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
;;;285    		ensure interrupt entry is as fast and simple as possible.
;;;286    
;;;287    		Save the interrupt priority value that is about to be clobbered. */
;;;288    		ulOriginalPriority = *pcFirstUserPriorityRegister;
;;;289    
;;;290    		/* Determine the number of priority bits available.  First write to all
;;;291    		possible bits. */
;;;292    		*pcFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
;;;293    
;;;294    		/* Read the value back to see how many bits stuck. */
;;;295    		ucMaxPriorityValue = *pcFirstUserPriorityRegister;
;;;296    
;;;297    		/* Use the same mask on the maximum system call priority. */
;;;298    		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
;;;299    
;;;300    		/* Calculate the maximum acceptable priority group value for the number
;;;301    		of bits read back. */
;;;302    		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
;;;303    		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
;;;304    		{
;;;305    			ulMaxPRIGROUPValue--;
;;;306    			ucMaxPriorityValue <<= ( unsigned char ) 0x01;
;;;307    		}
;;;308    
;;;309    		/* Shift the priority group value back to its position within the AIRCR
;;;310    		register. */
;;;311    		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
;;;312    		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
;;;313    
;;;314    		/* Restore the clobbered interrupt priority register to its original
;;;315    		value. */
;;;316    		*pcFirstUserPriorityRegister = ulOriginalPriority;
;;;317    	}
;;;318    	#endif /* conifgASSERT_DEFINED */
;;;319    
;;;320    	/* Make PendSV and SysTick the lowest priority interrupts. */
;;;321    	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
000034  4824              LDR      r0,|L1.200|
000036  6800              LDR      r0,[r0,#0]
000038  f440007f          ORR      r0,r0,#0xff0000
00003c  4922              LDR      r1,|L1.200|
00003e  6008              STR      r0,[r1,#0]
;;;322    	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
000040  4608              MOV      r0,r1
000042  6800              LDR      r0,[r0,#0]
000044  f040407f          ORR      r0,r0,#0xff000000
000048  6008              STR      r0,[r1,#0]
;;;323    
;;;324    	/* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;325    	here already. */
;;;326    	vPortSetupTimerInterrupt();
00004a  f7fffffe          BL       vPortSetupTimerInterrupt
;;;327    
;;;328    	/* Initialise the critical nesting count ready for the first task. */
;;;329    	uxCriticalNesting = 0;
00004e  2000              MOVS     r0,#0
000050  491e              LDR      r1,|L1.204|
000052  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;330    
;;;331    	/* Start the first task. */
;;;332    	prvStartFirstTask();
000054  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvStartFirstTask
;;;333    
;;;334    	/* Should not get here! */
;;;335    	return 0;
000058  2000              MOVS     r0,#0
;;;336    }
00005a  bd10              POP      {r4,pc}
;;;337    /*-----------------------------------------------------------*/
                          ENDP

                  vPortEndScheduler PROC
;;;338    
;;;339    void vPortEndScheduler( void )
00005c  4770              BX       lr
;;;340    {
;;;341    	/* It is unlikely that the CM3 port will require this function as there
;;;342    	is nothing to return to.  */
;;;343    }
;;;344    /*-----------------------------------------------------------*/
                          ENDP

                  vPortYield PROC
;;;345    
;;;346    void vPortYield( void )
00005e  f04f5080          MOV      r0,#0x10000000
;;;347    {
;;;348    	/* Set a PendSV to request a context switch. */
;;;349    	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
000062  4919              LDR      r1,|L1.200|
000064  391c              SUBS     r1,r1,#0x1c
000066  6008              STR      r0,[r1,#0]
;;;350    
;;;351    	/* Barriers are normally not required but do ensure the code is completely
;;;352    	within the specified behaviour for the architecture. */
;;;353    	__dsb( portSY_FULL_READ_WRITE );
000068  f3bf8f4f          DSB      
;;;354    	__isb( portSY_FULL_READ_WRITE );
00006c  f3bf8f6f          ISB      
;;;355    }
000070  4770              BX       lr
;;;356    /*-----------------------------------------------------------*/
                          ENDP

                  vPortEnterCritical PROC
;;;357    
;;;358    void vPortEnterCritical( void )
000072  b510              PUSH     {r4,lr}
;;;359    {
;;;360    	portDISABLE_INTERRUPTS();
000074  f7fffffe          BL       ulPortSetInterruptMask
;;;361    	uxCriticalNesting++;
000078  4814              LDR      r0,|L1.204|
00007a  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
00007c  1c40              ADDS     r0,r0,#1
00007e  4913              LDR      r1,|L1.204|
000080  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;362    	__dsb( portSY_FULL_READ_WRITE );
000082  f3bf8f4f          DSB      
;;;363    	__isb( portSY_FULL_READ_WRITE );
000086  f3bf8f6f          ISB      
;;;364    }
00008a  bd10              POP      {r4,pc}
;;;365    /*-----------------------------------------------------------*/
                          ENDP

                  vPortExitCritical PROC
;;;366    
;;;367    void vPortExitCritical( void )
00008c  b510              PUSH     {r4,lr}
;;;368    {
;;;369    	uxCriticalNesting--;
00008e  480f              LDR      r0,|L1.204|
000090  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000092  1e40              SUBS     r0,r0,#1
000094  490d              LDR      r1,|L1.204|
000096  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;370    	if( uxCriticalNesting == 0 )
000098  4608              MOV      r0,r1
00009a  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
00009c  b910              CBNZ     r0,|L1.164|
;;;371    	{
;;;372    		portENABLE_INTERRUPTS();
00009e  2000              MOVS     r0,#0
0000a0  f7fffffe          BL       vPortClearInterruptMask
                  |L1.164|
;;;373    	}
;;;374    }
0000a4  bd10              POP      {r4,pc}
;;;375    /*-----------------------------------------------------------*/
                          ENDP

                  SysTick_Handler PROC
;;;409    
;;;410    void xPortSysTickHandler( void )
0000a6  b510              PUSH     {r4,lr}
;;;411    {
;;;412    	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
;;;413    	executes all interrupts must be unmasked.  There is therefore no need to
;;;414    	save and then restore the interrupt mask value as its value is already
;;;415    	known. */
;;;416    	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
0000a8  f7fffffe          BL       ulPortSetInterruptMask
;;;417    	{
;;;418    		/* Increment the RTOS tick. */
;;;419    		if( xTaskIncrementTick() != pdFALSE )
0000ac  f7fffffe          BL       xTaskIncrementTick
0000b0  b120              CBZ      r0,|L1.188|
;;;420    		{
;;;421    			/* A context switch is required.  Context switching is performed in
;;;422    			the PendSV interrupt.  Pend the PendSV interrupt. */
;;;423    			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
0000b2  f04f5080          MOV      r0,#0x10000000
0000b6  4904              LDR      r1,|L1.200|
0000b8  391c              SUBS     r1,r1,#0x1c
0000ba  6008              STR      r0,[r1,#0]
                  |L1.188|
;;;424    		}
;;;425    	}
;;;426    	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
0000bc  2000              MOVS     r0,#0
0000be  f7fffffe          BL       vPortClearInterruptMask
;;;427    }
0000c2  bd10              POP      {r4,pc}
;;;428    /*-----------------------------------------------------------*/
                          ENDP

                  |L1.196|
                          DCD      prvTaskExitError
                  |L1.200|
                          DCD      0xe000ed20
                  |L1.204|
                          DCD      uxCriticalNesting

                          AREA ||.data||, DATA, ALIGN=2

                  uxCriticalNesting
                          DCD      0xaaaaaaaa

;*** Start embedded assembler ***

#line 1 "..\\Library\\FreeRTOSV7.5.3\\FreeRTOS\\Source\\portable\\RVDS\\ARM_CM3\\port.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |SVC_Handler|
#line 237
|SVC_Handler| PROC
#line 238

 PRESERVE8

 ldr r3, =pxCurrentTCB  
 ldr r1, [r3]  
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0  
 mov r0, #0
 msr basepri, r0
 orr r14, #0xd
 bx r14
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvStartFirstTask|
#line 253
|__asm___6_port_c_39a90d8d__prvStartFirstTask| PROC
#line 254

 PRESERVE8

 
 ldr r0, =0xE000ED08
 ldr r0, [r0]
 ldr r0, [r0]
 
 msr msp, r0
 
 cpsie i
 
 svc 0
 nop
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |PendSV_Handler|
#line 377
|PendSV_Handler| PROC
#line 378

 extern uxCriticalNesting
 extern pxCurrentTCB
 extern vTaskSwitchContext

 PRESERVE8

 mrs r0, psp

 ldr r3, =pxCurrentTCB  
 ldr r2, [r3]

 stmdb r0!, {r4-r11}  
 str r0, [r2]  

 stmdb sp!, {r3, r14}
 mov r0, #191
 msr basepri, r0
 bl vTaskSwitchContext
 mov r0, #0
 msr basepri, r0
 ldmia sp!, {r3, r14}

 ldr r1, [r3]
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0
 bx r14
 nop
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |ulPortSetInterruptMask|
#line 607
|ulPortSetInterruptMask| PROC
#line 608

 PRESERVE8

 mrs r0, basepri
 mov r1, #191
 msr basepri, r1
 bx r14
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |vPortClearInterruptMask|
#line 618
|vPortClearInterruptMask| PROC
#line 619

 PRESERVE8

 msr basepri, r0
 bx r14
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |vPortGetIPSR|
#line 627
|vPortGetIPSR| PROC
#line 628

 PRESERVE8
 
 mrs r0, ipsr
 bx r14
	ENDP

;*** End   embedded assembler ***
