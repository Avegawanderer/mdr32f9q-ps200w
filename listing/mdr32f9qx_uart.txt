; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\mdr32f9qx_uart.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\mdr32f9qx_uart.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\mdr32f9qx_uart.crf ..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UART_DeInit PROC
;;;73       */
;;;74     void UART_DeInit(MDR_UART_TypeDef* UARTx)
000000  2100              MOVS     r1,#0
;;;75     {
;;;76       /* Check the parameters */
;;;77       assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;78     
;;;79       /* Clear UART CR */
;;;80       UARTx->CR = 0;
000002  6301              STR      r1,[r0,#0x30]
;;;81       UARTx->LCR_H = 0;
000004  62c1              STR      r1,[r0,#0x2c]
;;;82       UARTx->RSR_ECR = 0;
000006  6041              STR      r1,[r0,#4]
;;;83       UARTx->FR = UART_FLAG_TXFE | UART_FLAG_RXFE;
000008  2290              MOVS     r2,#0x90
00000a  6182              STR      r2,[r0,#0x18]
;;;84       UARTx->ILPR = 0;
00000c  6201              STR      r1,[r0,#0x20]
;;;85       UARTx->IBRD = 0;
00000e  6241              STR      r1,[r0,#0x24]
;;;86       UARTx->FBRD = 0;
000010  6281              STR      r1,[r0,#0x28]
;;;87       UARTx->IFLS = UART_IT_FIFO_LVL_8words;
000012  2202              MOVS     r2,#2
000014  6342              STR      r2,[r0,#0x34]
;;;88       UARTx->IMSC = 0;
000016  6381              STR      r1,[r0,#0x38]
;;;89       UARTx->DMACR = 0;
000018  6481              STR      r1,[r0,#0x48]
;;;90       /* Set UART CR[RXE] and UART CR[TXE] bits */
;;;91       UARTx->CR = UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE;
00001a  f44f7140          MOV      r1,#0x300
00001e  6301              STR      r1,[r0,#0x30]
;;;92     }
000020  4770              BX       lr
;;;93     
                          ENDP

                  UART_Init PROC
;;;103      */
;;;104    BaudRateStatus UART_Init(MDR_UART_TypeDef* UARTx, UART_InitTypeDef* UART_InitStruct)
000022  b570              PUSH     {r4-r6,lr}
;;;105    {
000024  b086              SUB      sp,sp,#0x18
000026  4604              MOV      r4,r0
000028  460d              MOV      r5,r1
;;;106      uint32_t tmpreg, cpuclock;
;;;107      uint32_t realspeed, speederror;
;;;108      uint32_t divider;
;;;109      uint32_t integerdivider;
;;;110      uint32_t fractionaldivider;
;;;111      RST_CLK_FreqTypeDef RST_CLK_Clocks;
;;;112    
;;;113      /* Check the parameters */
;;;114      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;115      assert_param(IS_UART_BAUDRATE(UART_InitStruct->UART_BaudRate));
;;;116      assert_param(IS_UART_WORD_LENGTH(UART_InitStruct->UART_WordLength));
;;;117      assert_param(IS_UART_STOPBITS(UART_InitStruct->UART_StopBits));
;;;118      assert_param(IS_UART_PARITY(UART_InitStruct->UART_Parity));
;;;119      assert_param(IS_UART_FIFOMODE(UART_InitStruct->UART_FIFOMode));
;;;120      assert_param(IS_UART_HARDWARE_FLOW_CONTROL(UART_InitStruct->UART_HardwareFlowControl));
;;;121    
;;;122      /* Configure the UART Baud Rate */
;;;123      RST_CLK_GetClocksFreq(&RST_CLK_Clocks);
00002a  a801              ADD      r0,sp,#4
00002c  f7fffffe          BL       RST_CLK_GetClocksFreq
;;;124      cpuclock = RST_CLK_Clocks.CPU_CLK_Frequency;
000030  9801              LDR      r0,[sp,#4]
;;;125    
;;;126      tmpreg = MDR_RST_CLK->UART_CLOCK;
000032  4968              LDR      r1,|L1.468|
000034  6a89              LDR      r1,[r1,#0x28]
;;;127    
;;;128      if (UARTx == MDR_UART1)
000036  4b68              LDR      r3,|L1.472|
;;;129      {
;;;130        cpuclock /= (1 << (tmpreg & UART1_BRG_Mask));
000038  2201              MOVS     r2,#1
00003a  429c              CMP      r4,r3                 ;128
00003c  d105              BNE      |L1.74|
00003e  f0010107          AND      r1,r1,#7
000042  408a              LSLS     r2,r2,r1
000044  fbb0f0f2          UDIV     r0,r0,r2
000048  e007              B        |L1.90|
                  |L1.74|
;;;131      }
;;;132      else if (UARTx == MDR_UART2)
00004a  4b64              LDR      r3,|L1.476|
00004c  429c              CMP      r4,r3
00004e  d104              BNE      |L1.90|
;;;133      {
;;;134        cpuclock /= (1 << ((tmpreg & UART2_BRG_Mask) >> UART2_BRG_Offs));
000050  f3c12102          UBFX     r1,r1,#8,#3
000054  408a              LSLS     r2,r2,r1
000056  fbb0f0f2          UDIV     r0,r0,r2
                  |L1.90|
;;;135      }
;;;136    
;;;137      /* Determine the integer part */
;;;138      divider = cpuclock / (UART_InitStruct->UART_BaudRate >> 2);
00005a  682a              LDR      r2,[r5,#0]
00005c  0891              LSRS     r1,r2,#2
00005e  fbb0f3f1          UDIV     r3,r0,r1
;;;139      integerdivider = divider >> 6;
000062  0999              LSRS     r1,r3,#6
;;;140      /* Determine the fractional part */
;;;141      fractionaldivider = (divider & FBRD_Fract_Mask);
000064  f003033f          AND      r3,r3,#0x3f
;;;142      /* Determine the speed error */
;;;143      realspeed = (cpuclock * 4) / ((integerdivider * 64) + fractionaldivider);
000068  0080              LSLS     r0,r0,#2
00006a  eb031681          ADD      r6,r3,r1,LSL #6
00006e  fbb0f0f6          UDIV     r0,r0,r6
;;;144      speederror = ((realspeed - UART_InitStruct->UART_BaudRate) * 128) / UART_InitStruct->UART_BaudRate;
000072  1a80              SUBS     r0,r0,r2
000074  01c0              LSLS     r0,r0,#7
000076  fbb0f0f2          UDIV     r0,r0,r2
;;;145      if (speederror > 2)
00007a  2802              CMP      r0,#2
00007c  d902              BLS      |L1.132|
;;;146      {
;;;147        return BaudRateInvalid;
00007e  2000              MOVS     r0,#0
                  |L1.128|
;;;148      }
;;;149      /* Write UART Baud Rate */
;;;150      UARTx->IBRD = integerdivider;
;;;151      UARTx->FBRD = fractionaldivider;
;;;152    
;;;153      /* UART LCR_H configuration */
;;;154      /* Set the WLEN bits according to UART_WordLength value */
;;;155      /* Set STP2 bit according to UART_StopBits value */
;;;156      /* Set PEN, EPS and SPS bits according to UART_Parity value */
;;;157      /* Set FEN bit according to UART_FIFOMode value */
;;;158      tmpreg = UARTx->LCR_H;
;;;159      tmpreg |= UART_InitStruct->UART_WordLength | UART_InitStruct->UART_StopBits |
;;;160                             UART_InitStruct->UART_Parity | UART_InitStruct->UART_FIFOMode;
;;;161      UARTx->LCR_H = tmpreg;
;;;162    
;;;163      /* UART CR configuration */
;;;164      tmpreg = UARTx->CR;
;;;165      /* Clear UART CR Flow control bits */
;;;166      tmpreg &= ~CR_FC_Mask;
;;;167      /* Set UART CR Flow control bits */
;;;168      tmpreg |= UART_InitStruct->UART_HardwareFlowControl;
;;;169      /* Write to UART CR */
;;;170      UARTx->CR = tmpreg;
;;;171    
;;;172      return BaudRateValid;
;;;173    }
000080  b006              ADD      sp,sp,#0x18
000082  bd70              POP      {r4-r6,pc}
                  |L1.132|
000084  6261              STR      r1,[r4,#0x24]         ;150
000086  62a3              STR      r3,[r4,#0x28]         ;151
000088  6ae0              LDR      r0,[r4,#0x2c]         ;158
00008a  88a9              LDRH     r1,[r5,#4]            ;159
00008c  88ea              LDRH     r2,[r5,#6]            ;159
00008e  896b              LDRH     r3,[r5,#0xa]          ;159
000090  4311              ORRS     r1,r1,r2              ;159
000092  892a              LDRH     r2,[r5,#8]            ;159
000094  431a              ORRS     r2,r2,r3              ;159
000096  4311              ORRS     r1,r1,r2              ;159
000098  4301              ORRS     r1,r1,r0              ;159
00009a  62e1              STR      r1,[r4,#0x2c]         ;161
00009c  6b20              LDR      r0,[r4,#0x30]         ;164
00009e  f64f7180          MOV      r1,#0xff80            ;166
0000a2  4388              BICS     r0,r0,r1              ;166
0000a4  89a9              LDRH     r1,[r5,#0xc]          ;168
0000a6  4301              ORRS     r1,r1,r0              ;168
0000a8  6321              STR      r1,[r4,#0x30]         ;170
0000aa  2001              MOVS     r0,#1                 ;172
0000ac  e7e8              B        |L1.128|
;;;174    
                          ENDP

                  UART_StructInit PROC
;;;180      */
;;;181    void UART_StructInit(UART_InitTypeDef* UART_InitStruct)
0000ae  f44f5116          MOV      r1,#0x2580
;;;182    {
;;;183      /* UART_InitStruct members default value */
;;;184      UART_InitStruct->UART_BaudRate = 9600;
0000b2  6001              STR      r1,[r0,#0]
;;;185      UART_InitStruct->UART_WordLength = UART_WordLength5b;
0000b4  2100              MOVS     r1,#0
0000b6  8081              STRH     r1,[r0,#4]
;;;186      UART_InitStruct->UART_StopBits = UART_StopBits1;
0000b8  80c1              STRH     r1,[r0,#6]
;;;187      UART_InitStruct->UART_Parity = UART_Parity_No;
0000ba  8101              STRH     r1,[r0,#8]
;;;188      UART_InitStruct->UART_FIFOMode = UART_FIFO_OFF;
0000bc  8141              STRH     r1,[r0,#0xa]
;;;189      UART_InitStruct->UART_HardwareFlowControl = UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE;
0000be  f44f7140          MOV      r1,#0x300
0000c2  8181              STRH     r1,[r0,#0xc]
;;;190    }
0000c4  4770              BX       lr
;;;191    
                          ENDP

                  UART_Cmd PROC
;;;200      */
;;;201    void UART_Cmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
0000c6  b121              CBZ      r1,|L1.210|
;;;202    {
;;;203      /* Check the parameters */
;;;204      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;205      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;206    
;;;207      if (NewState != DISABLE)
;;;208      {
;;;209        /* Enable the selected UART by setting the UARTEN bit in the CR register */
;;;210        UARTx->CR |= CR_EN_Set;
0000c8  6b01              LDR      r1,[r0,#0x30]
0000ca  f0410101          ORR      r1,r1,#1
0000ce  6301              STR      r1,[r0,#0x30]
;;;211      }
;;;212      else
;;;213      {
;;;214        /* Disable the selected UART by clearing the UARTEN bit in the CR register */
;;;215        UARTx->CR &= CR_EN_Reset;
;;;216      }
;;;217    }
0000d0  4770              BX       lr
                  |L1.210|
0000d2  6b01              LDR      r1,[r0,#0x30]         ;215
0000d4  f64f72fe          MOV      r2,#0xfffe            ;215
0000d8  4011              ANDS     r1,r1,r2              ;215
0000da  6301              STR      r1,[r0,#0x30]         ;215
0000dc  4770              BX       lr
;;;218    
                          ENDP

                  UART_ITConfig PROC
;;;240      */
;;;241    void UART_ITConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT, FunctionalState NewState)
0000de  b11a              CBZ      r2,|L1.232|
;;;242    {
;;;243      /* Check the parameters */
;;;244      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;245      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;246      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;247    
;;;248      if (NewState != DISABLE)
;;;249      {
;;;250        UARTx->IMSC |= UART_IT;
0000e0  6b82              LDR      r2,[r0,#0x38]
0000e2  430a              ORRS     r2,r2,r1
0000e4  6382              STR      r2,[r0,#0x38]
;;;251      }
;;;252      else
;;;253      {
;;;254        UARTx->IMSC &= ~UART_IT;
;;;255      }
;;;256    }
0000e6  4770              BX       lr
                  |L1.232|
0000e8  6b82              LDR      r2,[r0,#0x38]         ;254
0000ea  438a              BICS     r2,r2,r1              ;254
0000ec  6382              STR      r2,[r0,#0x38]         ;254
0000ee  4770              BX       lr
;;;257    
                          ENDP

                  UART_GetITStatus PROC
;;;277      */
;;;278    ITStatus UART_GetITStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
0000f0  6bc0              LDR      r0,[r0,#0x3c]
;;;279    {
;;;280      ITStatus bitstatus;
;;;281    
;;;282      /* Check the parameters */
;;;283      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;284      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;285    
;;;286      if ((UARTx->RIS & UART_IT) == UART_IT)
0000f2  4381              BICS     r1,r1,r0
0000f4  d001              BEQ      |L1.250|
;;;287      {
;;;288        bitstatus = SET;
;;;289      }
;;;290      else
;;;291      {
;;;292        bitstatus = RESET;
0000f6  2000              MOVS     r0,#0
;;;293      }
;;;294    
;;;295      return bitstatus;
;;;296    }
0000f8  4770              BX       lr
                  |L1.250|
0000fa  2001              MOVS     r0,#1                 ;288
0000fc  4770              BX       lr
;;;297    
                          ENDP

                  UART_GetITStatusMasked PROC
;;;317      */
;;;318    ITStatus UART_GetITStatusMasked(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
0000fe  6c00              LDR      r0,[r0,#0x40]
;;;319    {
;;;320      ITStatus bitstatus;
;;;321    
;;;322      /* Check the parameters */
;;;323      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;324      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;325    
;;;326      if (UARTx->MIS & UART_IT)
000100  4208              TST      r0,r1
000102  d001              BEQ      |L1.264|
;;;327      {
;;;328        bitstatus = SET;
000104  2001              MOVS     r0,#1
;;;329      }
;;;330      else
;;;331      {
;;;332        bitstatus = RESET;
;;;333      }
;;;334    
;;;335      return bitstatus;
;;;336    }
000106  4770              BX       lr
                  |L1.264|
000108  2000              MOVS     r0,#0                 ;332
00010a  4770              BX       lr
;;;337    
                          ENDP

                  UART_ClearITPendingBit PROC
;;;357      */
;;;358    void UART_ClearITPendingBit(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
00010c  6c42              LDR      r2,[r0,#0x44]
;;;359    {
;;;360      /* Check the parameters */
;;;361      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;362      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;363    
;;;364      UARTx->ICR |= UART_IT;
00010e  430a              ORRS     r2,r2,r1
000110  6442              STR      r2,[r0,#0x44]
;;;365    }
000112  4770              BX       lr
;;;366    
                          ENDP

                  UART_DMAConfig PROC
;;;387      */
;;;388    void UART_DMAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT_RB_LVL, uint32_t UART_IT_TB_LVL)
000114  ea4201c1          ORR      r1,r2,r1,LSL #3
;;;389    {
;;;390      /* Check the parameters */
;;;391      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;392      assert_param(IS_UART_IT_FIFO_LVL(UART_IT_RB_LVL));
;;;393      assert_param(IS_UART_IT_FIFO_LVL(UART_IT_TB_LVL));
;;;394    
;;;395      UARTx->IFLS = (UART_IT_RB_LVL << 3) | UART_IT_TB_LVL;
000118  6341              STR      r1,[r0,#0x34]
;;;396    }
00011a  4770              BX       lr
;;;397    
                          ENDP

                  UART_DMACmd PROC
;;;412      */
;;;413    void UART_DMACmd(MDR_UART_TypeDef* UARTx, uint32_t UART_DMAReq, FunctionalState NewState)
00011c  b11a              CBZ      r2,|L1.294|
;;;414    {
;;;415      /* Check the parameters */
;;;416      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;417      assert_param(IS_UART_DMAREQ(UART_DMAReq));
;;;418      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;419    
;;;420      if (NewState != DISABLE)
;;;421      {
;;;422        /* Enable the DMA transfer for selected requests and DMAONERR bit
;;;423           in the UART DMACR register */
;;;424        UARTx->DMACR |= UART_DMAReq;
00011e  6c82              LDR      r2,[r0,#0x48]
000120  430a              ORRS     r2,r2,r1
000122  6482              STR      r2,[r0,#0x48]
;;;425      }
;;;426      else
;;;427      {
;;;428        /* Disable the DMA transfer for selected requests and DMAONERR bit
;;;429           in the UART DMACR register */
;;;430        UARTx->DMACR &= (uint16_t)~UART_DMAReq;
;;;431      }
;;;432    }
000124  4770              BX       lr
                  |L1.294|
000126  6c82              LDR      r2,[r0,#0x48]         ;430
000128  43c9              MVNS     r1,r1                 ;430
00012a  b289              UXTH     r1,r1                 ;430
00012c  400a              ANDS     r2,r2,r1              ;430
00012e  6482              STR      r2,[r0,#0x48]         ;430
000130  4770              BX       lr
;;;433    
                          ENDP

                  UART_SendData PROC
;;;441      */
;;;442    void UART_SendData(MDR_UART_TypeDef* UARTx, uint16_t Data)
000132  f3c10108          UBFX     r1,r1,#0,#9
;;;443    {
;;;444      /* Check the parameters */
;;;445      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;446      assert_param(IS_UART_DATA(Data));
;;;447    
;;;448      /* Transmit Data */
;;;449      UARTx->DR = (Data & (uint16_t)0x01FF);
000136  6001              STR      r1,[r0,#0]
;;;450    }
000138  4770              BX       lr
;;;451    
                          ENDP

                  UART_ReceiveData PROC
;;;458      */
;;;459    uint16_t UART_ReceiveData(MDR_UART_TypeDef* UARTx)
00013a  6800              LDR      r0,[r0,#0]
;;;460    {
;;;461      /* Check the parameters */
;;;462      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;463    
;;;464      /* Receive Data */
;;;465      return (uint16_t)(UARTx->DR);
00013c  b280              UXTH     r0,r0
;;;466    }
00013e  4770              BX       lr
;;;467    
                          ENDP

                  UART_BreakLine PROC
;;;476      */
;;;477    void UART_BreakLine(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
000140  b121              CBZ      r1,|L1.332|
;;;478    {
;;;479      /* Check the parameters */
;;;480      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;481      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;482    
;;;483      if (NewState != DISABLE)
;;;484      {
;;;485        /* Set BRK bit in the UART LCR_H register */
;;;486        UARTx->LCR_H |= LCR_H_BRK_Set;
000142  6ac1              LDR      r1,[r0,#0x2c]
000144  f0410101          ORR      r1,r1,#1
000148  62c1              STR      r1,[r0,#0x2c]
;;;487      }
;;;488      else
;;;489      {
;;;490        /* Reset BRK bit in the UART LCR_H register */
;;;491        UARTx->LCR_H |= LCR_H_BRK_Reset;
;;;492      }
;;;493    }
00014a  4770              BX       lr
                  |L1.332|
00014c  6ac1              LDR      r1,[r0,#0x2c]         ;491
00014e  f64f72fe          MOV      r2,#0xfffe            ;491
000152  4311              ORRS     r1,r1,r2              ;491
000154  62c1              STR      r1,[r0,#0x2c]         ;491
000156  4770              BX       lr
;;;494    
                          ENDP

                  UART_IrDAConfig PROC
;;;505      */
;;;506    void UART_IrDAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IrDAMode)
000158  b530              PUSH     {r4,r5,lr}
;;;507    {
00015a  b085              SUB      sp,sp,#0x14
00015c  4604              MOV      r4,r0
00015e  460d              MOV      r5,r1
;;;508      uint32_t cpuclock;
;;;509      RST_CLK_FreqTypeDef RST_CLK_Clocks;
;;;510    
;;;511      /* Check the parameters */
;;;512      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;513      assert_param(IS_UART_IRDA_MODE(UART_IrDAMode));
;;;514    
;;;515      if (UART_IrDAMode == UART_IrDAMode_LowPower)
000160  2d04              CMP      r5,#4
000162  d108              BNE      |L1.374|
;;;516      {
;;;517        /* Configure the UART ILPR */
;;;518        RST_CLK_GetClocksFreq(&RST_CLK_Clocks);
000164  4668              MOV      r0,sp
000166  f7fffffe          BL       RST_CLK_GetClocksFreq
;;;519        cpuclock = RST_CLK_Clocks.CPU_CLK_Frequency;
00016a  9800              LDR      r0,[sp,#0]
;;;520        UARTx->ILPR = cpuclock / IrLPBaud16;
00016c  f44f11e1          MOV      r1,#0x1c2000
000170  fbb0f0f1          UDIV     r0,r0,r1
000174  6220              STR      r0,[r4,#0x20]
                  |L1.374|
;;;521      }
;;;522      UARTx->CR |= UART_IrDAMode;
000176  6b20              LDR      r0,[r4,#0x30]
000178  4328              ORRS     r0,r0,r5
00017a  6320              STR      r0,[r4,#0x30]
;;;523    }
00017c  b005              ADD      sp,sp,#0x14
00017e  bd30              POP      {r4,r5,pc}
;;;524    
                          ENDP

                  UART_IrDACmd PROC
;;;533      */
;;;534    void UART_IrDACmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
000180  b121              CBZ      r1,|L1.396|
;;;535    {
;;;536      /* Check the parameters */
;;;537      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;538      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;539    
;;;540      if (NewState != DISABLE)
;;;541      {
;;;542        /* Set SIREN bit in the UART CR register */
;;;543        UARTx->CR |= CR_SIREN_Set;
000182  6b01              LDR      r1,[r0,#0x30]
000184  f0410102          ORR      r1,r1,#2
000188  6301              STR      r1,[r0,#0x30]
;;;544      }
;;;545      else
;;;546      {
;;;547        /* Reset SIREN bit in the UART CR register */
;;;548        UARTx->CR |= CR_SIREN_Reset;
;;;549      }
;;;550    }
00018a  4770              BX       lr
                  |L1.396|
00018c  6b01              LDR      r1,[r0,#0x30]         ;548
00018e  f64f72fd          MOV      r2,#0xfffd            ;548
000192  4311              ORRS     r1,r1,r2              ;548
000194  6301              STR      r1,[r0,#0x30]         ;548
000196  4770              BX       lr
;;;551    
                          ENDP

                  UART_GetFlagStatus PROC
;;;569      */
;;;570    FlagStatus UART_GetFlagStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_FLAG)
000198  6980              LDR      r0,[r0,#0x18]
;;;571    {
;;;572      FlagStatus bitstatus;
;;;573    
;;;574      /* Check the parameters */
;;;575      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;576      assert_param(IS_UART_FLAG(UART_FLAG));
;;;577    
;;;578      if (UARTx->FR & UART_FLAG)
00019a  4208              TST      r0,r1
00019c  d001              BEQ      |L1.418|
;;;579      {
;;;580        bitstatus = SET;
00019e  2001              MOVS     r0,#1
;;;581      }
;;;582      else
;;;583      {
;;;584        bitstatus = RESET;
;;;585      }
;;;586      return bitstatus;
;;;587    }
0001a0  4770              BX       lr
                  |L1.418|
0001a2  2000              MOVS     r0,#0                 ;584
0001a4  4770              BX       lr
;;;588    
                          ENDP

                  UART_BRGInit PROC
;;;606      */
;;;607    void UART_BRGInit(MDR_UART_TypeDef* UARTx, uint32_t UART_BRG)
0001a6  b510              PUSH     {r4,lr}
;;;608    {
;;;609      uint32_t tmpreg;
;;;610    
;;;611      /* Check the parameters */
;;;612      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;613      assert_param(IS_UART_CLOCK_BRG(UART_BRG));
;;;614    
;;;615      tmpreg = MDR_RST_CLK->UART_CLOCK;
0001a8  4b0a              LDR      r3,|L1.468|
0001aa  6a9a              LDR      r2,[r3,#0x28]
;;;616    
;;;617      if (UARTx == MDR_UART1)
0001ac  4c0a              LDR      r4,|L1.472|
0001ae  42a0              CMP      r0,r4
0001b0  d105              BNE      |L1.446|
;;;618      {
;;;619        tmpreg |= RST_CLK_UART_CLOCK_UART1_CLK_EN;
0001b2  f0427080          ORR      r0,r2,#0x1000000
;;;620        tmpreg &= ~RST_CLK_UART_CLOCK_UART1_BRG_Msk;
0001b6  f02002ff          BIC      r2,r0,#0xff
;;;621        tmpreg |= UART_BRG;
0001ba  430a              ORRS     r2,r2,r1
0001bc  e008              B        |L1.464|
                  |L1.446|
;;;622      }
;;;623      else if (UARTx == MDR_UART2)
0001be  4c07              LDR      r4,|L1.476|
0001c0  42a0              CMP      r0,r4
0001c2  d105              BNE      |L1.464|
;;;624      {
;;;625        tmpreg |= RST_CLK_UART_CLOCK_UART2_CLK_EN;
0001c4  f0427000          ORR      r0,r2,#0x2000000
;;;626        tmpreg &= ~RST_CLK_UART_CLOCK_UART2_BRG_Msk;
0001c8  f420407f          BIC      r0,r0,#0xff00
;;;627        tmpreg |= (UART_BRG << 8);
0001cc  ea402201          ORR      r2,r0,r1,LSL #8
                  |L1.464|
;;;628      }
;;;629      MDR_RST_CLK->UART_CLOCK = tmpreg;
0001d0  629a              STR      r2,[r3,#0x28]
;;;630    }
0001d2  bd10              POP      {r4,pc}
;;;631    
                          ENDP

                  |L1.468|
                          DCD      0x40020000
                  |L1.472|
                          DCD      0x40030000
                  |L1.476|
                          DCD      0x40038000

;*** Start embedded assembler ***

#line 1 "..\\Library\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_uart.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_MDR32F9Qx_uart_c_c95a8597____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_MDR32F9Qx_uart_c_c95a8597____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_MDR32F9Qx_uart_c_c95a8597____REVSH|
#line 130
|__asm___16_MDR32F9Qx_uart_c_c95a8597____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
