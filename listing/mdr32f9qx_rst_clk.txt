; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\mdr32f9qx_rst_clk.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\mdr32f9qx_rst_clk.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\mdr32f9qx_rst_clk.crf ..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_rst_clk.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RST_CLK_PCLKcmd PROC
;;;958      */
;;;959    void RST_CLK_PCLKcmd(uint32_t RST_CLK_PCLK, FunctionalState NewState)
000000  b129              CBZ      r1,|L1.14|
;;;960    {
;;;961      /* Check the parameters */
;;;962      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;963      assert_param(IS_RST_CLK_PCLK(RST_CLK_PCLK));
;;;964      if (NewState != DISABLE)
;;;965      {
;;;966        MDR_RST_CLK->PER_CLOCK |= RST_CLK_PCLK;
000002  4af9              LDR      r2,|L1.1000|
000004  69d2              LDR      r2,[r2,#0x1c]
000006  4302              ORRS     r2,r2,r0
000008  4bf7              LDR      r3,|L1.1000|
00000a  61da              STR      r2,[r3,#0x1c]
00000c  e004              B        |L1.24|
                  |L1.14|
;;;967      }
;;;968      else
;;;969      {
;;;970        MDR_RST_CLK->PER_CLOCK &= ~RST_CLK_PCLK;
00000e  4af6              LDR      r2,|L1.1000|
000010  69d2              LDR      r2,[r2,#0x1c]
000012  4382              BICS     r2,r2,r0
000014  4bf4              LDR      r3,|L1.1000|
000016  61da              STR      r2,[r3,#0x1c]
                  |L1.24|
;;;971      }
;;;972    }
000018  4770              BX       lr
;;;973    
                          ENDP

                  RST_CLK_CPUclkSelection PROC
;;;614      */
;;;615    void RST_CLK_CPUclkSelection(uint32_t CPU_CLK)
00001a  4601              MOV      r1,r0
;;;616    {
;;;617      uint32_t temp;
;;;618    
;;;619      /* Check the parameters */
;;;620      assert_param(IS_RST_CPU_CLK(CPU_CLK));
;;;621    
;;;622      temp = MDR_RST_CLK->CPU_CLOCK;
00001c  4af2              LDR      r2,|L1.1000|
00001e  68d0              LDR      r0,[r2,#0xc]
;;;623      /* Clear CPU_C3_SEL bits */
;;;624      temp &= CPU_HCLK_SELclr;
000020  f4207040          BIC      r0,r0,#0x300
;;;625      /* Set the CPU_C3_SEL bits */
;;;626      temp |= CPU_CLK;
000024  4308              ORRS     r0,r0,r1
;;;627      /* Store the new value */
;;;628      MDR_RST_CLK->CPU_CLOCK = temp;
000026  60d0              STR      r0,[r2,#0xc]
;;;629    }
000028  4770              BX       lr
;;;630    
                          ENDP

                  RST_CLK_GetFlagStatus PROC
;;;1183     */
;;;1184   FlagStatus RST_CLK_GetFlagStatus(uint32_t RST_CLK_FLAG)
00002a  b510              PUSH     {r4,lr}
;;;1185   {
00002c  4601              MOV      r1,r0
;;;1186     uint32_t statusreg;
;;;1187     FlagStatus bitstatus;
;;;1188   
;;;1189     /* Check the parameters */
;;;1190     assert_param(IS_RST_CLK_FLAG(RST_CLK_FLAG));
;;;1191   
;;;1192     /* Get the register */
;;;1193     if ((FLAG_SFR_MASK & RST_CLK_FLAG) == (uint32_t)0x20) /* The flag to check is in CLOCK_STATUS register */
00002e  f00103e0          AND      r3,r1,#0xe0
000032  2b20              CMP      r3,#0x20
000034  d102              BNE      |L1.60|
;;;1194     {
;;;1195       statusreg = MDR_RST_CLK->CLOCK_STATUS;
000036  4bec              LDR      r3,|L1.1000|
000038  681a              LDR      r2,[r3,#0]
00003a  e001              B        |L1.64|
                  |L1.60|
;;;1196     }
;;;1197     else                                                  /* The flag to check is in REG_0F register */
;;;1198     {
;;;1199       statusreg = MDR_BKP->REG_0F;
00003c  4beb              LDR      r3,|L1.1004|
00003e  6bda              LDR      r2,[r3,#0x3c]
                  |L1.64|
;;;1200     }
;;;1201   
;;;1202     /* Get the flag status on proper position */
;;;1203     if ((statusreg & ((uint32_t)1 << (RST_CLK_FLAG & FLAG_MASK))) != (uint32_t)0x00)
000040  f001041f          AND      r4,r1,#0x1f
000044  2301              MOVS     r3,#1
000046  40a3              LSLS     r3,r3,r4
000048  4213              TST      r3,r2
00004a  d001              BEQ      |L1.80|
;;;1204     {
;;;1205       bitstatus = SET;
00004c  2001              MOVS     r0,#1
00004e  e000              B        |L1.82|
                  |L1.80|
;;;1206     }
;;;1207     else
;;;1208     {
;;;1209       bitstatus = RESET;
000050  2000              MOVS     r0,#0
                  |L1.82|
;;;1210     }
;;;1211   
;;;1212     /* Return the flag status */
;;;1213     return bitstatus;
;;;1214   }
000052  bd10              POP      {r4,pc}
;;;1215   
                          ENDP

                  RST_CLK_HSIstatus PROC
;;;373      */
;;;374    ErrorStatus RST_CLK_HSIstatus(void)
000054  b570              PUSH     {r4-r6,lr}
;;;375    {
;;;376      __IO uint32_t startCounter = 0;
000056  2600              MOVS     r6,#0
;;;377      ErrorStatus state;
;;;378      FlagStatus flag;
;;;379    
;;;380      /* Wait until HSI is ready or time out is occure */
;;;381      do
000058  bf00              NOP      
                  |L1.90|
;;;382      {
;;;383        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY);
00005a  2017              MOVS     r0,#0x17
00005c  f7fffffe          BL       RST_CLK_GetFlagStatus
000060  4605              MOV      r5,r0
;;;384        startCounter++;
000062  1c76              ADDS     r6,r6,#1
;;;385      } while ((startCounter < HSIonTimeOut) && (flag == RESET));
000064  f5b66fc0          CMP      r6,#0x600
000068  d201              BCS      |L1.110|
00006a  2d00              CMP      r5,#0
00006c  d0f5              BEQ      |L1.90|
                  |L1.110|
;;;386    
;;;387      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY) != RESET)
00006e  2017              MOVS     r0,#0x17
000070  f7fffffe          BL       RST_CLK_GetFlagStatus
000074  b108              CBZ      r0,|L1.122|
;;;388      {
;;;389        state = SUCCESS;
000076  2401              MOVS     r4,#1
000078  e000              B        |L1.124|
                  |L1.122|
;;;390      }
;;;391      else
;;;392      {
;;;393        state = ERROR;
00007a  2400              MOVS     r4,#0
                  |L1.124|
;;;394      }
;;;395      return state;
00007c  4620              MOV      r0,r4
;;;396    }
00007e  bd70              POP      {r4-r6,pc}
;;;397    
                          ENDP

                  RST_CLK_HSIcmd PROC
;;;340      */
;;;341    void RST_CLK_HSIcmd(FunctionalState NewState)
000080  49db              LDR      r1,|L1.1008|
;;;342    {
;;;343      /* Check the parameters */
;;;344      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;345    
;;;346      *(__IO uint32_t *) HSION_BB = (uint32_t)NewState;
000082  f04f4284          MOV      r2,#0x42000000
000086  eb021141          ADD      r1,r2,r1,LSL #5
00008a  6588              STR      r0,[r1,#0x58]
;;;347    }
00008c  4770              BX       lr
;;;348    
                          ENDP

                  RST_CLK_WarmDeInit PROC
;;;183      */
;;;184    void RST_CLK_WarmDeInit(void)
00008e  b500              PUSH     {lr}
;;;185    {
;;;186      /* Prepare HSI clk */
;;;187      RST_CLK_HSIcmd(ENABLE);
000090  2001              MOVS     r0,#1
000092  f7fffffe          BL       RST_CLK_HSIcmd
;;;188      RST_CLK_HSIstatus();
000096  f7fffffe          BL       RST_CLK_HSIstatus
;;;189      RST_CLK_CPUclkSelection(RST_CLK_CPUclkHSI);
00009a  2000              MOVS     r0,#0
00009c  f7fffffe          BL       RST_CLK_CPUclkSelection
;;;190    
;;;191      /* Reset CPU_CLOCK bits */
;;;192      MDR_RST_CLK->CPU_CLOCK   &= (uint32_t)0x00000000;
0000a0  48d1              LDR      r0,|L1.1000|
0000a2  68c0              LDR      r0,[r0,#0xc]
0000a4  2000              MOVS     r0,#0
0000a6  49d0              LDR      r1,|L1.1000|
0000a8  60c8              STR      r0,[r1,#0xc]
;;;193    
;;;194      /* Reset PLL_CONTROL bits */
;;;195      MDR_RST_CLK->PLL_CONTROL &= (uint32_t)0x00000000;
0000aa  4608              MOV      r0,r1
0000ac  6840              LDR      r0,[r0,#4]
0000ae  2000              MOVS     r0,#0
0000b0  6048              STR      r0,[r1,#4]
;;;196    
;;;197      /* Reset HSEON and HSEBYP bits */
;;;198      MDR_RST_CLK->HS_CONTROL  &= (uint32_t)0x00000000;
0000b2  4608              MOV      r0,r1
0000b4  6880              LDR      r0,[r0,#8]
0000b6  2000              MOVS     r0,#0
0000b8  6088              STR      r0,[r1,#8]
;;;199    
;;;200      /* Reset USB_CLOCK bits */
;;;201      MDR_RST_CLK->USB_CLOCK   &= (uint32_t)0x00000000;
0000ba  4608              MOV      r0,r1
0000bc  6900              LDR      r0,[r0,#0x10]
0000be  2000              MOVS     r0,#0
0000c0  6108              STR      r0,[r1,#0x10]
;;;202    
;;;203      /* Reset ADC_MCO_CLOCK bits */
;;;204      MDR_RST_CLK->ADC_MCO_CLOCK   &= (uint32_t)0x00000000;
0000c2  4608              MOV      r0,r1
0000c4  6940              LDR      r0,[r0,#0x14]
0000c6  2000              MOVS     r0,#0
0000c8  6148              STR      r0,[r1,#0x14]
;;;205    
;;;206      /* Reset RTC_CLOCK bits */
;;;207      MDR_RST_CLK->RTC_CLOCK   &= (uint32_t)0x00000000;
0000ca  4608              MOV      r0,r1
0000cc  6980              LDR      r0,[r0,#0x18]
0000ce  2000              MOVS     r0,#0
0000d0  6188              STR      r0,[r1,#0x18]
;;;208    
;;;209      /* Reset all clock but RTC_CLK bit */
;;;210      MDR_RST_CLK->PER_CLOCK   = (uint32_t)PCLK_BIT(MDR_RST_CLK_BASE) | (uint32_t)PCLK_BIT(MDR_BKP_BASE);
0000d2  48c8              LDR      r0,|L1.1012|
0000d4  61c8              STR      r0,[r1,#0x1c]
;;;211    }
0000d6  bd00              POP      {pc}
;;;212    
                          ENDP

                  RST_CLK_DeInit PROC
;;;168      */
;;;169    void RST_CLK_DeInit(void)
0000d8  b500              PUSH     {lr}
;;;170    {
;;;171      RST_CLK_WarmDeInit();
0000da  f7fffffe          BL       RST_CLK_WarmDeInit
;;;172      /* Reset REG_0F bits to zero but HSION bit */
;;;173      RST_CLK_PCLKcmd(RST_CLK_PCLK_BKP, ENABLE);
0000de  2101              MOVS     r1,#1
0000e0  06c8              LSLS     r0,r1,#27
0000e2  f7fffffe          BL       RST_CLK_PCLKcmd
;;;174      MDR_BKP->REG_0F |= (uint32_t)((1<<22)|(1<<15)); /* HSION & LSION */
0000e6  48c1              LDR      r0,|L1.1004|
0000e8  6bc0              LDR      r0,[r0,#0x3c]
0000ea  f4400081          ORR      r0,r0,#0x408000
0000ee  49bf              LDR      r1,|L1.1004|
0000f0  63c8              STR      r0,[r1,#0x3c]
;;;175      MDR_BKP->REG_0F &= (uint32_t)((1<<22)|(1<<15));
0000f2  4608              MOV      r0,r1
0000f4  6bc0              LDR      r0,[r0,#0x3c]
0000f6  f4000081          AND      r0,r0,#0x408000
0000fa  63c8              STR      r0,[r1,#0x3c]
;;;176    }
0000fc  bd00              POP      {pc}
;;;177    
                          ENDP

                  RST_CLK_HSEconfig PROC
;;;220      */
;;;221    void RST_CLK_HSEconfig(uint32_t RST_CLK_HSE)
0000fe  49ba              LDR      r1,|L1.1000|
;;;222    {
;;;223      /* Check the parameters */
;;;224      assert_param(IS_RST_CLK_HSE(RST_CLK_HSE));
;;;225      /* Reset HSEON and HSEBYP bits before configuring the HSE */
;;;226      MDR_RST_CLK->HS_CONTROL &= ~((uint32_t)(RST_CLK_HSE_ON | RST_CLK_HSE_Bypass));
000100  6889              LDR      r1,[r1,#8]
000102  f0210103          BIC      r1,r1,#3
000106  4ab8              LDR      r2,|L1.1000|
000108  6091              STR      r1,[r2,#8]
;;;227      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;228      switch (RST_CLK_HSE)
00010a  2801              CMP      r0,#1
00010c  d002              BEQ      |L1.276|
00010e  2802              CMP      r0,#2
000110  d10e              BNE      |L1.304|
000112  e006              B        |L1.290|
                  |L1.276|
;;;229      {
;;;230        case RST_CLK_HSE_ON:
;;;231          /* Set HSEON bit */
;;;232          MDR_RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON;
000114  49b4              LDR      r1,|L1.1000|
000116  6889              LDR      r1,[r1,#8]
000118  f0410101          ORR      r1,r1,#1
00011c  4ab2              LDR      r2,|L1.1000|
00011e  6091              STR      r1,[r2,#8]
;;;233          break;
000120  e007              B        |L1.306|
                  |L1.290|
;;;234    
;;;235        case RST_CLK_HSE_Bypass:
;;;236          /* Set HSEBYP and HSEON bits */
;;;237          MDR_RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON | RST_CLK_HSE_Bypass;
000122  49b1              LDR      r1,|L1.1000|
000124  6889              LDR      r1,[r1,#8]
000126  f0410103          ORR      r1,r1,#3
00012a  4aaf              LDR      r2,|L1.1000|
00012c  6091              STR      r1,[r2,#8]
;;;238          break;
00012e  e000              B        |L1.306|
                  |L1.304|
;;;239    
;;;240        default:
;;;241          break;
000130  bf00              NOP      
                  |L1.306|
000132  bf00              NOP                            ;233
;;;242      }
;;;243    }
000134  4770              BX       lr
;;;244    
                          ENDP

                  RST_CLK_HSEstatus PROC
;;;249      */
;;;250    ErrorStatus RST_CLK_HSEstatus(void)
000136  b570              PUSH     {r4-r6,lr}
;;;251    {
;;;252      __IO uint32_t startCounter = 0;
000138  2600              MOVS     r6,#0
;;;253      ErrorStatus state;
;;;254      FlagStatus flag;
;;;255    
;;;256      /* Wait until HSE is ready or time out is occure */
;;;257      do
00013a  bf00              NOP      
                  |L1.316|
;;;258      {
;;;259        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY);
00013c  2022              MOVS     r0,#0x22
00013e  f7fffffe          BL       RST_CLK_GetFlagStatus
000142  4605              MOV      r5,r0
;;;260        startCounter++;
000144  1c76              ADDS     r6,r6,#1
;;;261      } while ((startCounter < HSEonTimeOut) && (flag == RESET));
000146  f5b66fc0          CMP      r6,#0x600
00014a  d201              BCS      |L1.336|
00014c  2d00              CMP      r5,#0
00014e  d0f5              BEQ      |L1.316|
                  |L1.336|
;;;262    
;;;263      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY) != RESET)
000150  2022              MOVS     r0,#0x22
000152  f7fffffe          BL       RST_CLK_GetFlagStatus
000156  b108              CBZ      r0,|L1.348|
;;;264      {
;;;265        state = SUCCESS;
000158  2401              MOVS     r4,#1
00015a  e000              B        |L1.350|
                  |L1.348|
;;;266      }
;;;267      else
;;;268      {
;;;269        state = ERROR;
00015c  2400              MOVS     r4,#0
                  |L1.350|
;;;270      }
;;;271      return state;
00015e  4620              MOV      r0,r4
;;;272    }
000160  bd70              POP      {r4-r6,pc}
;;;273    
                          ENDP

                  RST_CLK_LSEconfig PROC
;;;281      */
;;;282    void RST_CLK_LSEconfig(uint32_t RST_CLK_LSE)
000162  49a2              LDR      r1,|L1.1004|
;;;283    {
;;;284      /* Check the parameters */
;;;285      assert_param(IS_RST_CLK_LSE(RST_CLK_LSE));
;;;286      /* Reset LSEON and LSEBYP bits before configuring the LSE */
;;;287      MDR_BKP->REG_0F &= ~((uint32_t)(RST_CLK_LSE_ON | RST_CLK_LSE_Bypass));
000164  6bc9              LDR      r1,[r1,#0x3c]
000166  f0210103          BIC      r1,r1,#3
00016a  4aa0              LDR      r2,|L1.1004|
00016c  63d1              STR      r1,[r2,#0x3c]
;;;288      switch (RST_CLK_LSE)
00016e  2801              CMP      r0,#1
000170  d002              BEQ      |L1.376|
000172  2802              CMP      r0,#2
000174  d10e              BNE      |L1.404|
000176  e006              B        |L1.390|
                  |L1.376|
;;;289      {
;;;290        case RST_CLK_LSE_ON:
;;;291          /* Set LSEON bit */
;;;292          MDR_BKP->REG_0F |= RST_CLK_LSE_ON;
000178  499c              LDR      r1,|L1.1004|
00017a  6bc9              LDR      r1,[r1,#0x3c]
00017c  f0410101          ORR      r1,r1,#1
000180  4a9a              LDR      r2,|L1.1004|
000182  63d1              STR      r1,[r2,#0x3c]
;;;293          break;
000184  e007              B        |L1.406|
                  |L1.390|
;;;294    
;;;295        case RST_CLK_LSE_Bypass:
;;;296          /* Set LSEBYP and LSEON bits */
;;;297          MDR_BKP->REG_0F |= (RST_CLK_LSE_ON | RST_CLK_LSE_Bypass);
000186  4999              LDR      r1,|L1.1004|
000188  6bc9              LDR      r1,[r1,#0x3c]
00018a  f0410103          ORR      r1,r1,#3
00018e  4a97              LDR      r2,|L1.1004|
000190  63d1              STR      r1,[r2,#0x3c]
;;;298          break;
000192  e000              B        |L1.406|
                  |L1.404|
;;;299    
;;;300        default:
;;;301          break;
000194  bf00              NOP      
                  |L1.406|
000196  bf00              NOP                            ;293
;;;302      }
;;;303    }
000198  4770              BX       lr
;;;304    
                          ENDP

                  RST_CLK_LSEstatus PROC
;;;309      */
;;;310    ErrorStatus RST_CLK_LSEstatus(void)
00019a  b570              PUSH     {r4-r6,lr}
;;;311    {
;;;312      __IO uint32_t startCounter = 0;
00019c  2600              MOVS     r6,#0
;;;313      ErrorStatus state;
;;;314      FlagStatus flag;
;;;315    
;;;316     /* Wait until LSE is ready or time out is occure */
;;;317     do
00019e  bf00              NOP      
                  |L1.416|
;;;318      {
;;;319        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY);
0001a0  200d              MOVS     r0,#0xd
0001a2  f7fffffe          BL       RST_CLK_GetFlagStatus
0001a6  4605              MOV      r5,r0
;;;320        startCounter++;
0001a8  1c76              ADDS     r6,r6,#1
;;;321      } while ((startCounter < LSEonTimeOut) && (flag == RESET));
0001aa  f5b66fc0          CMP      r6,#0x600
0001ae  d201              BCS      |L1.436|
0001b0  2d00              CMP      r5,#0
0001b2  d0f5              BEQ      |L1.416|
                  |L1.436|
;;;322    
;;;323      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY) != RESET)
0001b4  200d              MOVS     r0,#0xd
0001b6  f7fffffe          BL       RST_CLK_GetFlagStatus
0001ba  b108              CBZ      r0,|L1.448|
;;;324      {
;;;325        state = SUCCESS;
0001bc  2401              MOVS     r4,#1
0001be  e000              B        |L1.450|
                  |L1.448|
;;;326      }
;;;327      else
;;;328      {
;;;329        state = ERROR;
0001c0  2400              MOVS     r4,#0
                  |L1.450|
;;;330      }
;;;331      return state;
0001c2  4620              MOV      r0,r4
;;;332    }
0001c4  bd70              POP      {r4-r6,pc}
;;;333    
                          ENDP

                  RST_CLK_HSIadjust PROC
;;;354      */
;;;355    void RST_CLK_HSIadjust(uint32_t HSItrimValue)
0001c6  4601              MOV      r1,r0
;;;356    {
;;;357      uint32_t temp;
;;;358      /* Check the parameters */
;;;359      assert_param(IS_RCC_CLK_HSI_TRIM_VALUE(HSItrimValue));
;;;360      temp = MDR_BKP->REG_0F;
0001c8  4a88              LDR      r2,|L1.1004|
0001ca  6bd0              LDR      r0,[r2,#0x3c]
;;;361      /* Clear HSITRIM[5:0] bits */
;;;362      temp &= ~HSITRIM_MASK;
0001cc  f020507c          BIC      r0,r0,#0x3f000000
;;;363      /* Set the HSITRIM[5:0] bits according to HSItrimValue value */
;;;364      temp |= (uint32_t)HSItrimValue << HSITRIM_OFFSET;
0001d0  ea406001          ORR      r0,r0,r1,LSL #24
;;;365      /* Store the new value */
;;;366      MDR_BKP->REG_0F = temp;
0001d4  63d0              STR      r0,[r2,#0x3c]
;;;367    }
0001d6  4770              BX       lr
;;;368    
                          ENDP

                  RST_CLK_LSIcmd PROC
;;;404      */
;;;405    void RST_CLK_LSIcmd(FunctionalState NewState)
0001d8  4985              LDR      r1,|L1.1008|
;;;406    {
;;;407      /* Check the parameters */
;;;408      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;409    
;;;410      *(__IO uint32_t *) LSION_BB = (uint32_t)NewState;
0001da  f04f4284          MOV      r2,#0x42000000
0001de  eb021141          ADD      r1,r2,r1,LSL #5
0001e2  63c8              STR      r0,[r1,#0x3c]
;;;411    }
0001e4  4770              BX       lr
;;;412    
                          ENDP

                  RST_CLK_LSIadjust PROC
;;;418      */
;;;419    void RST_CLK_LSIadjust(uint32_t LSItrimValue)
0001e6  4601              MOV      r1,r0
;;;420    {
;;;421      uint32_t temp;
;;;422      /* Check the parameters */
;;;423      assert_param(IS_RCC_CLK_LSI_TRIM_VALUE(LSItrimValue));
;;;424      temp = MDR_BKP->REG_0F;
0001e8  4a80              LDR      r2,|L1.1004|
0001ea  6bd0              LDR      r0,[r2,#0x3c]
;;;425      /* Clear LSITRIM[4:0] bits */
;;;426      temp &= ~LSITRIM_MASK;
0001ec  f42010f8          BIC      r0,r0,#0x1f0000
;;;427      /* Set the LSITRIM[4:0] bits according to LSItrimValue value */
;;;428      temp |= (uint32_t)LSItrimValue << LSITRIM_OFFSET;
0001f0  ea404001          ORR      r0,r0,r1,LSL #16
;;;429      /* Store the new value */
;;;430      MDR_BKP->REG_0F = temp;
0001f4  63d0              STR      r0,[r2,#0x3c]
;;;431    }
0001f6  4770              BX       lr
;;;432    
                          ENDP

                  RST_CLK_LSIstatus PROC
;;;437      */
;;;438    ErrorStatus RST_CLK_LSIstatus(void)
0001f8  b570              PUSH     {r4-r6,lr}
;;;439    {
;;;440      __IO uint32_t startCounter = 0;
0001fa  2600              MOVS     r6,#0
;;;441      ErrorStatus state;
;;;442      FlagStatus flag;
;;;443    
;;;444      /* Wait until LSI is ready or time out is occure */
;;;445      do
0001fc  bf00              NOP      
                  |L1.510|
;;;446      {
;;;447        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY);
0001fe  2015              MOVS     r0,#0x15
000200  f7fffffe          BL       RST_CLK_GetFlagStatus
000204  4605              MOV      r5,r0
;;;448        startCounter++;
000206  1c76              ADDS     r6,r6,#1
;;;449      } while ((startCounter < LSIonTimeOut) && (flag == RESET));
000208  f5b66fc0          CMP      r6,#0x600
00020c  d201              BCS      |L1.530|
00020e  2d00              CMP      r5,#0
000210  d0f5              BEQ      |L1.510|
                  |L1.530|
;;;450    
;;;451      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY) != RESET)
000212  2015              MOVS     r0,#0x15
000214  f7fffffe          BL       RST_CLK_GetFlagStatus
000218  b108              CBZ      r0,|L1.542|
;;;452      {
;;;453        state = SUCCESS;
00021a  2401              MOVS     r4,#1
00021c  e000              B        |L1.544|
                  |L1.542|
;;;454      }
;;;455      else
;;;456      {
;;;457        state = ERROR;
00021e  2400              MOVS     r4,#0
                  |L1.544|
;;;458      }
;;;459      return (state);
000220  4620              MOV      r0,r4
;;;460    }
000222  bd70              POP      {r4-r6,pc}
;;;461    
                          ENDP

                  RST_CLK_CPU_PLLconfig PROC
;;;488      */
;;;489    void RST_CLK_CPU_PLLconfig(uint32_t RST_CLK_CPU_PLLsource, uint32_t RST_CLK_CPU_PLLmul)
000224  b530              PUSH     {r4,r5,lr}
;;;490    {
000226  4602              MOV      r2,r0
;;;491      uint32_t temp;
;;;492    
;;;493      /* Check the parameters */
;;;494      assert_param(IS_RST_CLK_CPU_PLL_SOURCE(RST_CLK_CPU_PLLsource));
;;;495      assert_param(IS_RST_CLK_CPU_PLL_MUL(RST_CLK_CPU_PLLmul));
;;;496    
;;;497      /* Select CPUPLL source */
;;;498      temp = MDR_RST_CLK->CPU_CLOCK;
000228  4b6f              LDR      r3,|L1.1000|
00022a  68d8              LDR      r0,[r3,#0xc]
;;;499      /* Clear CPU_C1_SEL bits */
;;;500      temp &= CPU_C1_SELclr;
00022c  f0200003          BIC      r0,r0,#3
;;;501      /* Set the CPU_C1_SEL bits */
;;;502      temp |= RST_CLK_CPU_PLLsource;
000230  4310              ORRS     r0,r0,r2
;;;503      /* Store the new value */
;;;504      MDR_RST_CLK->CPU_CLOCK = temp;
000232  60d8              STR      r0,[r3,#0xc]
;;;505    
;;;506      /* Set CPUPLL multiplier */
;;;507      temp = MDR_RST_CLK->PLL_CONTROL;
000234  6858              LDR      r0,[r3,#4]
;;;508      /* Clear PLLMUL[3:0] bits */
;;;509      temp &= PLLCPUmulclr;
000236  f4206070          BIC      r0,r0,#0xf00
;;;510      /* Set the PLLMUL[3:0] bits */
;;;511      temp |= (RST_CLK_CPU_PLLmul<<PLLCPUMUL_OFFSET);
00023a  ea402001          ORR      r0,r0,r1,LSL #8
;;;512      /* Store the new value */
;;;513      MDR_RST_CLK->PLL_CONTROL = temp;
00023e  6058              STR      r0,[r3,#4]
;;;514    
;;;515      if ( *(__IO uint32_t *) PLLCPUON_BB)
000240  4b6d              LDR      r3,|L1.1016|
000242  f04f4484          MOV      r4,#0x42000000
000246  eb041343          ADD      r3,r4,r3,LSL #5
00024a  689b              LDR      r3,[r3,#8]
00024c  b15b              CBZ      r3,|L1.614|
;;;516      {
;;;517         *(__IO uint32_t *) PLLCPUPLD_BB = (uint32_t)0x01;
00024e  2401              MOVS     r4,#1
000250  4b69              LDR      r3,|L1.1016|
000252  f04f4584          MOV      r5,#0x42000000
000256  eb051343          ADD      r3,r5,r3,LSL #5
00025a  60dc              STR      r4,[r3,#0xc]
;;;518         *(__IO uint32_t *) PLLCPUPLD_BB = (uint32_t)0x00;
00025c  2400              MOVS     r4,#0
00025e  4b66              LDR      r3,|L1.1016|
000260  eb051343          ADD      r3,r5,r3,LSL #5
000264  60dc              STR      r4,[r3,#0xc]
                  |L1.614|
;;;519      }
;;;520    }
000266  bd30              POP      {r4,r5,pc}
;;;521    
                          ENDP

                  RST_CLK_CPU_PLLuse PROC
;;;526      */
;;;527    void RST_CLK_CPU_PLLuse(FunctionalState UsePLL)
000268  4963              LDR      r1,|L1.1016|
;;;528    {
;;;529      /* Check the parameters */
;;;530      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;531    
;;;532      *(__IO uint32_t *) CPU_C2_SEL_BB = (uint32_t)UsePLL;
00026a  3108              ADDS     r1,r1,#8
00026c  f04f4284          MOV      r2,#0x42000000
000270  eb021141          ADD      r1,r2,r1,LSL #5
000274  6088              STR      r0,[r1,#8]
;;;533    }
000276  4770              BX       lr
;;;534    
                          ENDP

                  RST_CLK_CPU_PLLcmd PROC
;;;539      */
;;;540    void RST_CLK_CPU_PLLcmd(FunctionalState NewState)
000278  495f              LDR      r1,|L1.1016|
;;;541    {
;;;542      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;543    
;;;544      *(__IO uint32_t *) PLLCPUON_BB = (uint32_t)NewState;
00027a  f04f4284          MOV      r2,#0x42000000
00027e  eb021141          ADD      r1,r2,r1,LSL #5
000282  6088              STR      r0,[r1,#8]
;;;545    }
000284  4770              BX       lr
;;;546    
                          ENDP

                  RST_CLK_CPU_PLLstatus PROC
;;;551      */
;;;552    ErrorStatus RST_CLK_CPU_PLLstatus(void)
000286  b570              PUSH     {r4-r6,lr}
;;;553    {
;;;554      __IO uint32_t startCounter = 0;
000288  2600              MOVS     r6,#0
;;;555      ErrorStatus state;
;;;556      FlagStatus flag;
;;;557    
;;;558      /* Wait until CPUPLL is ready or time out is occure */
;;;559      do
00028a  bf00              NOP      
                  |L1.652|
;;;560      {
;;;561        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY);
00028c  2021              MOVS     r0,#0x21
00028e  f7fffffe          BL       RST_CLK_GetFlagStatus
000292  4605              MOV      r5,r0
;;;562        startCounter++;
000294  1c76              ADDS     r6,r6,#1
;;;563      } while ((startCounter < PLLCPUonTimeOut) && (flag == RESET));
000296  f5b66fc0          CMP      r6,#0x600
00029a  d201              BCS      |L1.672|
00029c  2d00              CMP      r5,#0
00029e  d0f5              BEQ      |L1.652|
                  |L1.672|
;;;564    
;;;565      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY) != RESET)
0002a0  2021              MOVS     r0,#0x21
0002a2  f7fffffe          BL       RST_CLK_GetFlagStatus
0002a6  b108              CBZ      r0,|L1.684|
;;;566      {
;;;567        state = SUCCESS;
0002a8  2401              MOVS     r4,#1
0002aa  e000              B        |L1.686|
                  |L1.684|
;;;568      }
;;;569      else
;;;570      {
;;;571        state = ERROR;
0002ac  2400              MOVS     r4,#0
                  |L1.686|
;;;572      }
;;;573      return state;
0002ae  4620              MOV      r0,r4
;;;574    }
0002b0  bd70              POP      {r4-r6,pc}
;;;575    
                          ENDP

                  RST_CLK_CPUclkPrescaler PROC
;;;589      */
;;;590    void RST_CLK_CPUclkPrescaler(uint32_t CPUclkDivValue)
0002b2  4601              MOV      r1,r0
;;;591    {
;;;592      uint32_t temp;
;;;593    
;;;594      /* Check the parameters */
;;;595      assert_param(IS_RST_CLK_CPUclkDIV(CPUclkDivValue));
;;;596    
;;;597      temp = MDR_RST_CLK->CPU_CLOCK;
0002b4  4a4c              LDR      r2,|L1.1000|
0002b6  68d0              LDR      r0,[r2,#0xc]
;;;598      /* Clear CPU_C3_SEL bits */
;;;599      temp &= CPU_C3_SELclr;
0002b8  f02000f0          BIC      r0,r0,#0xf0
;;;600      /* Set the CPU_C3_SEL bits */
;;;601      temp |= (CPUclkDivValue << RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos);
0002bc  ea401001          ORR      r0,r0,r1,LSL #4
;;;602      /* Store the new value */
;;;603      MDR_RST_CLK->CPU_CLOCK = temp;
0002c0  60d0              STR      r0,[r2,#0xc]
;;;604    }
0002c2  4770              BX       lr
;;;605    
                          ENDP

                  RST_CLK_USB_PLLconfig PROC
;;;657      */
;;;658    void RST_CLK_USB_PLLconfig(uint32_t RST_CLK_USB_PLLsource, uint32_t RST_CLK_USB_PLLmul)
0002c4  b530              PUSH     {r4,r5,lr}
;;;659    {
0002c6  4602              MOV      r2,r0
;;;660      uint32_t temp;
;;;661    
;;;662      /* Check the parameters */
;;;663      assert_param(IS_RST_CLK_USB_PLL_SOURCE(RST_CLK_USB_PLLsource));
;;;664      assert_param(IS_RST_CLK_USB_PLL_MUL(RST_CLK_USB_PLLmul));
;;;665    
;;;666      /* Select USBPLL source */
;;;667      temp = MDR_RST_CLK->USB_CLOCK;
0002c8  4b47              LDR      r3,|L1.1000|
0002ca  6918              LDR      r0,[r3,#0x10]
;;;668      /* Clear USB_C1_SEL bits */
;;;669      temp &= USB_C1_SELclr;
0002cc  f0200003          BIC      r0,r0,#3
;;;670      /* Set the USB_C1_SEL bits */
;;;671      temp |= RST_CLK_USB_PLLsource;
0002d0  4310              ORRS     r0,r0,r2
;;;672      /* Store the new value */
;;;673      MDR_RST_CLK->USB_CLOCK = temp;
0002d2  6118              STR      r0,[r3,#0x10]
;;;674    
;;;675      /* Set USBPLL multiplier */
;;;676      temp = MDR_RST_CLK->PLL_CONTROL;
0002d4  6858              LDR      r0,[r3,#4]
;;;677      /* Clear PLLMUL[3:0] bits */
;;;678      temp &= PLLUSBmulclr;
0002d6  f02000f0          BIC      r0,r0,#0xf0
;;;679      /* Set the PLLMUL[3:0] bits */
;;;680      temp |= (RST_CLK_USB_PLLmul<<PLLUSBMUL_OFFSET);
0002da  ea401001          ORR      r0,r0,r1,LSL #4
;;;681      /* Store the new value */
;;;682      MDR_RST_CLK->PLL_CONTROL = temp;
0002de  6058              STR      r0,[r3,#4]
;;;683    
;;;684      if ( *(__IO uint32_t *) PLLUSBON_BB)
0002e0  4b45              LDR      r3,|L1.1016|
0002e2  f04f4484          MOV      r4,#0x42000000
0002e6  eb041343          ADD      r3,r4,r3,LSL #5
0002ea  681b              LDR      r3,[r3,#0]
0002ec  b15b              CBZ      r3,|L1.774|
;;;685      {
;;;686        *(__IO uint32_t *) PLLUSBRLD_BB  = (uint32_t)0x01;
0002ee  2401              MOVS     r4,#1
0002f0  4b41              LDR      r3,|L1.1016|
0002f2  f04f4584          MOV      r5,#0x42000000
0002f6  eb051343          ADD      r3,r5,r3,LSL #5
0002fa  605c              STR      r4,[r3,#4]
;;;687        *(__IO uint32_t *) PLLUSBRLD_BB  = (uint32_t)0x00;
0002fc  2400              MOVS     r4,#0
0002fe  4b3e              LDR      r3,|L1.1016|
000300  eb051343          ADD      r3,r5,r3,LSL #5
000304  605c              STR      r4,[r3,#4]
                  |L1.774|
;;;688      }
;;;689    }
000306  bd30              POP      {r4,r5,pc}
;;;690    
                          ENDP

                  RST_CLK_USB_PLLuse PROC
;;;695      */
;;;696    void RST_CLK_USB_PLLuse(FunctionalState UsePLL)
000308  493b              LDR      r1,|L1.1016|
;;;697    {
;;;698      /* Check the parameters */
;;;699      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;700    
;;;701      *(__IO uint32_t *) USB_C2_SEL_BB = (uint32_t)UsePLL;
00030a  310c              ADDS     r1,r1,#0xc
00030c  f04f4284          MOV      r2,#0x42000000
000310  eb021141          ADD      r1,r2,r1,LSL #5
000314  6088              STR      r0,[r1,#8]
;;;702    }
000316  4770              BX       lr
;;;703    
                          ENDP

                  RST_CLK_USB_PLLcmd PROC
;;;708      */
;;;709    void RST_CLK_USB_PLLcmd(FunctionalState NewState)
000318  4937              LDR      r1,|L1.1016|
;;;710    {
;;;711      /* Check the parameters */
;;;712      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;713    
;;;714      *(__IO uint32_t *) PLLUSBON_BB = (uint32_t)NewState;
00031a  f04f4284          MOV      r2,#0x42000000
00031e  eb021141          ADD      r1,r2,r1,LSL #5
000322  6008              STR      r0,[r1,#0]
;;;715    }
000324  4770              BX       lr
;;;716    
                          ENDP

                  RST_CLK_USB_PLLstatus PROC
;;;721      */
;;;722    ErrorStatus RST_CLK_USB_PLLstatus(void)
000326  b570              PUSH     {r4-r6,lr}
;;;723    {
;;;724      __IO uint32_t startCounter = 0;
000328  2600              MOVS     r6,#0
;;;725      ErrorStatus state;
;;;726      FlagStatus flag;
;;;727    
;;;728      /* Wait until USBPLL is ready or time out is occure */
;;;729      do
00032a  bf00              NOP      
                  |L1.812|
;;;730      {
;;;731        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY);
00032c  2020              MOVS     r0,#0x20
00032e  f7fffffe          BL       RST_CLK_GetFlagStatus
000332  4605              MOV      r5,r0
;;;732        startCounter++;
000334  1c76              ADDS     r6,r6,#1
;;;733      } while ((startCounter < PLLUSBonTimeOut) && (flag == RESET));
000336  f5b66fc0          CMP      r6,#0x600
00033a  d201              BCS      |L1.832|
00033c  2d00              CMP      r5,#0
00033e  d0f5              BEQ      |L1.812|
                  |L1.832|
;;;734    
;;;735      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY) != RESET)
000340  2020              MOVS     r0,#0x20
000342  f7fffffe          BL       RST_CLK_GetFlagStatus
000346  b108              CBZ      r0,|L1.844|
;;;736      {
;;;737        state = SUCCESS;
000348  2401              MOVS     r4,#1
00034a  e000              B        |L1.846|
                  |L1.844|
;;;738      }
;;;739      else
;;;740      {
;;;741        state = ERROR;
00034c  2400              MOVS     r4,#0
                  |L1.846|
;;;742      }
;;;743      return state;
00034e  4620              MOV      r0,r4
;;;744    }
000350  bd70              POP      {r4-r6,pc}
;;;745    
                          ENDP

                  RST_CLK_USBclkPrescaler PROC
;;;752      */
;;;753    void RST_CLK_USBclkPrescaler(FunctionalState NewState)
000352  4929              LDR      r1,|L1.1016|
;;;754    {
;;;755      /* Check the parameters */
;;;756      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;757    
;;;758      *(__IO uint32_t *) USB_CLK_EN_BB = (uint32_t)NewState;
000354  310c              ADDS     r1,r1,#0xc
000356  f04f4284          MOV      r2,#0x42000000
00035a  eb021141          ADD      r1,r2,r1,LSL #5
00035e  6208              STR      r0,[r1,#0x20]
;;;759    }
000360  4770              BX       lr
;;;760    
                          ENDP

                  RST_CLK_USBclkEnable PROC
;;;767      */
;;;768    void RST_CLK_USBclkEnable(FunctionalState NewState)
000362  4925              LDR      r1,|L1.1016|
;;;769    {
;;;770      /* Check the parameters */
;;;771      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;772    
;;;773      *(__IO uint32_t *) USB_C3_SEL_BB = (uint32_t)NewState;
000364  310c              ADDS     r1,r1,#0xc
000366  f04f4284          MOV      r2,#0x42000000
00036a  eb021141          ADD      r1,r2,r1,LSL #5
00036e  6108              STR      r0,[r1,#0x10]
;;;774    }
000370  4770              BX       lr
;;;775    
                          ENDP

                  RST_CLK_ADCclkSelection PROC
;;;787      */
;;;788    void RST_CLK_ADCclkSelection(uint32_t ADC_CLK)
000372  4601              MOV      r1,r0
;;;789    {
;;;790      uint32_t temp;
;;;791    
;;;792      /* Check the parameters */
;;;793      assert_param(IS_RST_CLK_ADCclk(ADC_CLK));
;;;794    
;;;795      /* Select ADC_CLK source */
;;;796      temp = MDR_RST_CLK->ADC_MCO_CLOCK;
000374  4a1c              LDR      r2,|L1.1000|
000376  6950              LDR      r0,[r2,#0x14]
;;;797      /* Clear ADC_C1,C2 SEL bits */
;;;798      temp &= ADC_C12_SELclr;
000378  f0200033          BIC      r0,r0,#0x33
;;;799      /* Set the ADC_C1,C2 SEL bits */
;;;800      temp |= ADC_CLK;
00037c  4308              ORRS     r0,r0,r1
;;;801      /* Store the new value */
;;;802      MDR_RST_CLK->ADC_MCO_CLOCK = temp;
00037e  6150              STR      r0,[r2,#0x14]
;;;803    }
000380  4770              BX       lr
;;;804    
                          ENDP

                  RST_CLK_ADCclkPrescaler PROC
;;;819      */
;;;820    void RST_CLK_ADCclkPrescaler(uint32_t ADCclkDivValue)
000382  4601              MOV      r1,r0
;;;821    {
;;;822      uint32_t temp;
;;;823    
;;;824      /* Check the parameters */
;;;825      assert_param(IS_RST_CLK_ADCclkDivValue(ADCclkDivValue));
;;;826    
;;;827      temp = MDR_RST_CLK->ADC_MCO_CLOCK;
000384  4a18              LDR      r2,|L1.1000|
000386  6950              LDR      r0,[r2,#0x14]
;;;828      /* Clear ADC_C3_SEL bits */
;;;829      temp &= ADC_C3_SELclr;
000388  f4206070          BIC      r0,r0,#0xf00
;;;830      /* Set the ADC_C3_SEL bits */
;;;831      temp |= ADCclkDivValue<<ADC_C3_SEL_OFFSET;
00038c  ea402001          ORR      r0,r0,r1,LSL #8
;;;832      /* Store the new value */
;;;833      MDR_RST_CLK->ADC_MCO_CLOCK = temp;
000390  6150              STR      r0,[r2,#0x14]
;;;834    }
000392  4770              BX       lr
;;;835    
                          ENDP

                  RST_CLK_ADCclkEnable PROC
;;;842      */
;;;843    void RST_CLK_ADCclkEnable(FunctionalState NewState)
000394  4918              LDR      r1,|L1.1016|
;;;844    {
;;;845      /* Check the parameters */
;;;846      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;847    
;;;848      *(__IO uint32_t *) ADC_CLK_EN_BB = (uint32_t)NewState;
000396  3110              ADDS     r1,r1,#0x10
000398  f04f4284          MOV      r2,#0x42000000
00039c  eb021141          ADD      r1,r2,r1,LSL #5
0003a0  6348              STR      r0,[r1,#0x34]
;;;849    }
0003a2  4770              BX       lr
;;;850    
                          ENDP

                  RST_CLK_HSIclkPrescaler PROC
;;;865      */
;;;866    void RST_CLK_HSIclkPrescaler(uint32_t HSIclkDivValue)
0003a4  4601              MOV      r1,r0
;;;867    {
;;;868      uint32_t temp;
;;;869    
;;;870      /* Check the parameters */
;;;871      assert_param(IS_RST_CLK_HSIclkDivValue(HSIclkDivValue));
;;;872    
;;;873      temp = MDR_RST_CLK->RTC_CLOCK;
0003a6  4a10              LDR      r2,|L1.1000|
0003a8  6990              LDR      r0,[r2,#0x18]
;;;874      /* Clear HSI_SEL bits */
;;;875      temp &= HSI_SELclr;
0003aa  f02000f0          BIC      r0,r0,#0xf0
;;;876      /* Set the HSI_SEL bits */
;;;877      temp |= HSIclkDivValue<<HSI_SEL_OFFSET;
0003ae  ea401001          ORR      r0,r0,r1,LSL #4
;;;878      /* Store the new value */
;;;879      MDR_RST_CLK->RTC_CLOCK = temp;
0003b2  6190              STR      r0,[r2,#0x18]
;;;880    }
0003b4  4770              BX       lr
;;;881    
                          ENDP

                  RST_CLK_RTC_HSIclkEnable PROC
;;;888      */
;;;889    void RST_CLK_RTC_HSIclkEnable(FunctionalState NewState)
0003b6  4910              LDR      r1,|L1.1016|
;;;890    {
;;;891      /* Check the parameters */
;;;892      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;893    
;;;894      *(__IO uint32_t *) HSI_RTC_EN_BB = (uint32_t)NewState;
0003b8  3114              ADDS     r1,r1,#0x14
0003ba  f04f4284          MOV      r2,#0x42000000
0003be  eb021141          ADD      r1,r2,r1,LSL #5
0003c2  6248              STR      r0,[r1,#0x24]
;;;895    }
0003c4  4770              BX       lr
;;;896    
                          ENDP

                  RST_CLK_HSEclkPrescaler PROC
;;;911      */
;;;912    void RST_CLK_HSEclkPrescaler(uint32_t HSEclkDivValue)
0003c6  4601              MOV      r1,r0
;;;913    {
;;;914      uint32_t temp;
;;;915    
;;;916      /* Check the parameters */
;;;917      assert_param(IS_RST_CLK_HSEclkDivValue(HSEclkDivValue));
;;;918    
;;;919      temp = MDR_RST_CLK->RTC_CLOCK;
0003c8  4a07              LDR      r2,|L1.1000|
0003ca  6990              LDR      r0,[r2,#0x18]
;;;920      /* Clear HSE_SEL bits */
;;;921      temp &= HSE_SELclr;
0003cc  f020000f          BIC      r0,r0,#0xf
;;;922      /* Set the HSE_SEL bits */
;;;923      temp |= HSEclkDivValue<<HSE_SEL_OFFSET;
0003d0  4308              ORRS     r0,r0,r1
;;;924      /* Store the new value */
;;;925      MDR_RST_CLK->RTC_CLOCK = temp;
0003d2  6190              STR      r0,[r2,#0x18]
;;;926    }
0003d4  4770              BX       lr
;;;927    
                          ENDP

                  RST_CLK_RTC_HSEclkEnable PROC
;;;934      */
;;;935    void RST_CLK_RTC_HSEclkEnable(FunctionalState NewState)
0003d6  4908              LDR      r1,|L1.1016|
;;;936    {
;;;937      /* Check the parameters */
;;;938      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;939    
;;;940      *(__IO uint32_t *) HSE_RTC_EN_BB = (uint32_t)NewState;
0003d8  3114              ADDS     r1,r1,#0x14
0003da  f04f4284          MOV      r2,#0x42000000
0003de  eb021141          ADD      r1,r2,r1,LSL #5
0003e2  6208              STR      r0,[r1,#0x20]
;;;941    }
0003e4  4770              BX       lr
0003e6  0000              DCW      0x0000
                  |L1.1000|
                          DCD      0x40020000
                  |L1.1004|
                          DCD      0x400d8000
                  |L1.1008|
                          DCD      0x000d803c
                  |L1.1012|
                          DCD      0x08000010
                  |L1.1016|
                          DCD      0x00020004
                          ENDP

                  RST_CLK_GetClocksFreq PROC
;;;980      */
;;;981    void RST_CLK_GetClocksFreq(RST_CLK_FreqTypeDef* RST_CLK_Clocks)
0003fc  e92d4ffc          PUSH     {r2-r11,lr}
;;;982    {
000400  4601              MOV      r1,r0
;;;983      uint32_t cpu_c1_freq, cpu_c2_freq, cpu_c3_freq;
;;;984      uint32_t usb_c1_freq, usb_c2_freq, usb_c3_freq;
;;;985      uint32_t adc_c1_freq, adc_c2_freq, adc_c3_freq;
;;;986      uint32_t hsi_c1_freq, hse_c1_freq;
;;;987      uint32_t pll_mul;
;;;988      uint32_t temp;
;;;989    
;;;990      /* Check the parameter */
;;;991      assert_param(RST_CLK_Clocks != 0);
;;;992    
;;;993      /* Compute CPU_CLK, USB_CLK, ADC_CLK, RTCHSI, RTCHSE clocks frequencies */
;;;994    
;;;995      /* Compute CPU_CLK frequency */
;;;996    
;;;997      /* Determine CPU_C1 frequency */
;;;998      if (*(__IO uint32_t *) CPU_C1_SEL1_BB)
000402  f8dfb27c          LDR      r11,|L1.1664|
000406  f04f4e84          MOV      lr,#0x42000000
00040a  eb0e1b4b          ADD      r11,lr,r11,LSL #5
00040e  f8dbb004          LDR      r11,[r11,#4]
000412  f1bb0f00          CMP      r11,#0
000416  d001              BEQ      |L1.1052|
;;;999      {
;;;1000       cpu_c1_freq = HSE_Value;
000418  4b9a              LDR      r3,|L1.1668|
00041a  e000              B        |L1.1054|
                  |L1.1052|
;;;1001     }
;;;1002     else
;;;1003     {
;;;1004       cpu_c1_freq = HSI_Value;
00041c  4b9a              LDR      r3,|L1.1672|
                  |L1.1054|
;;;1005     }
;;;1006   
;;;1007     if (*(__IO uint32_t *) CPU_C1_SEL0_BB)
00041e  f8dfb260          LDR      r11,|L1.1664|
000422  f04f4e84          MOV      lr,#0x42000000
000426  eb0e1b4b          ADD      r11,lr,r11,LSL #5
00042a  f8dbb000          LDR      r11,[r11,#0]
00042e  f1bb0f00          CMP      r11,#0
000432  d000              BEQ      |L1.1078|
;;;1008     {
;;;1009       cpu_c1_freq /= 2;
000434  085b              LSRS     r3,r3,#1
                  |L1.1078|
;;;1010     }
;;;1011   
;;;1012     /* Determine CPU_C2 frequency */
;;;1013     cpu_c2_freq = cpu_c1_freq;
000436  461c              MOV      r4,r3
;;;1014   
;;;1015     if (*(__IO uint32_t *) CPU_C2_SEL_BB != 0)
000438  f8dfb244          LDR      r11,|L1.1664|
00043c  f04f4e84          MOV      lr,#0x42000000
000440  eb0e1b4b          ADD      r11,lr,r11,LSL #5
000444  f8dbb008          LDR      r11,[r11,#8]
000448  f1bb0f00          CMP      r11,#0
00044c  d00d              BEQ      |L1.1130|
;;;1016     {
;;;1017       /* Determine CPU PLL output frequency */
;;;1018       pll_mul = ((MDR_RST_CLK->PLL_CONTROL >> RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos) & (uint32_t)0x0F) + 1;
00044e  f8dfb23c          LDR      r11,|L1.1676|
000452  f8dbb004          LDR      r11,[r11,#4]
000456  f3cb2b03          UBFX     r11,r11,#8,#4
00045a  f10b0b01          ADD      r11,r11,#1
00045e  f8cdb000          STR      r11,[sp,#0]
;;;1019       cpu_c2_freq *= pll_mul;
000462  f8ddb000          LDR      r11,[sp,#0]
000466  fb04f40b          MUL      r4,r4,r11
                  |L1.1130|
;;;1020     }
;;;1021   
;;;1022     /*Select CPU_CLK from HSI, CPU_C3, LSE, LSI cases */
;;;1023     switch ((MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_HCLK_SEL_Pos) & (uint32_t)0x03)
00046a  f8dfb220          LDR      r11,|L1.1676|
00046e  f8dbb00c          LDR      r11,[r11,#0xc]
000472  f3cb2b01          UBFX     r11,r11,#8,#2
000476  f1bb0f00          CMP      r11,#0
00047a  d006              BEQ      |L1.1162|
00047c  f1bb0f01          CMP      r11,#1
000480  d008              BEQ      |L1.1172|
000482  f1bb0f02          CMP      r11,#2
000486  d126              BNE      |L1.1238|
000488  e020              B        |L1.1228|
                  |L1.1162|
;;;1024     {
;;;1025       case 0 :
;;;1026         /* HSI */
;;;1027         RST_CLK_Clocks->CPU_CLK_Frequency = HSI_Value;
00048a  f8dfb1fc          LDR      r11,|L1.1672|
00048e  f8c1b000          STR      r11,[r1,#0]
;;;1028         break;
000492  e025              B        |L1.1248|
                  |L1.1172|
;;;1029       case 1 :
;;;1030         /* CPU_C3 */
;;;1031         /* Determine CPU_C3 frequency */
;;;1032         if (( MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos & (uint32_t)0x08) == 0x00)
000494  f8dfb1f4          LDR      r11,|L1.1676|
000498  f8dbb00c          LDR      r11,[r11,#0xc]
00049c  f04f0e08          MOV      lr,#8
0004a0  ea1e1f1b          TST      lr,r11,LSR #4
0004a4  d101              BNE      |L1.1194|
;;;1033         {
;;;1034           cpu_c3_freq = cpu_c2_freq;
0004a6  46a0              MOV      r8,r4
0004a8  e00d              B        |L1.1222|
                  |L1.1194|
;;;1035         }
;;;1036         else
;;;1037         {
;;;1038           cpu_c3_freq = cpu_c2_freq/(1 << ((MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos & (uint32_t)0x07) + 1));
0004aa  f8dfb1e0          LDR      r11,|L1.1676|
0004ae  f8dbb00c          LDR      r11,[r11,#0xc]
0004b2  f3cb1b02          UBFX     r11,r11,#4,#3
0004b6  f10b0b01          ADD      r11,r11,#1
0004ba  f04f0e01          MOV      lr,#1
0004be  fa0efe0b          LSL      lr,lr,r11
0004c2  fbb4f8fe          UDIV     r8,r4,lr
                  |L1.1222|
;;;1039         }
;;;1040         RST_CLK_Clocks->CPU_CLK_Frequency = cpu_c3_freq;
0004c6  f8c18000          STR      r8,[r1,#0]
;;;1041         break;
0004ca  e009              B        |L1.1248|
                  |L1.1228|
;;;1042       case 2 :
;;;1043         /* LSE */
;;;1044         RST_CLK_Clocks->CPU_CLK_Frequency = LSE_Value;
0004cc  f44f4b00          MOV      r11,#0x8000
0004d0  f8c1b000          STR      r11,[r1,#0]
;;;1045         break;
0004d4  e004              B        |L1.1248|
                  |L1.1238|
;;;1046       default : /* case 3 */
;;;1047         /* LSI */
;;;1048         RST_CLK_Clocks->CPU_CLK_Frequency = LSI_Value;
0004d6  f6494b40          MOV      r11,#0x9c40
0004da  f8c1b000          STR      r11,[r1,#0]
;;;1049         break;
0004de  bf00              NOP      
                  |L1.1248|
0004e0  bf00              NOP                            ;1028
;;;1050     }
;;;1051   
;;;1052     /* Compute USB_CLK frequency */
;;;1053   
;;;1054     /* Determine USB_C1 frequency */
;;;1055     if (*(__IO uint32_t *) USB_C1_SEL1_BB)
0004e2  f8dfb19c          LDR      r11,|L1.1664|
0004e6  f10b0b04          ADD      r11,r11,#4
0004ea  f04f4e84          MOV      lr,#0x42000000
0004ee  eb0e1b4b          ADD      r11,lr,r11,LSL #5
0004f2  f8dbb004          LDR      r11,[r11,#4]
0004f6  f1bb0f00          CMP      r11,#0
0004fa  d001              BEQ      |L1.1280|
;;;1056     {
;;;1057       usb_c1_freq = HSE_Value;
0004fc  4d61              LDR      r5,|L1.1668|
0004fe  e000              B        |L1.1282|
                  |L1.1280|
;;;1058     }
;;;1059     else
;;;1060     {
;;;1061       usb_c1_freq = HSI_Value;
000500  4d61              LDR      r5,|L1.1672|
                  |L1.1282|
;;;1062     }
;;;1063   
;;;1064     if (*(__IO uint32_t *) USB_C1_SEL0_BB)
000502  f8dfb17c          LDR      r11,|L1.1664|
000506  f10b0b04          ADD      r11,r11,#4
00050a  f04f4e84          MOV      lr,#0x42000000
00050e  eb0e1b4b          ADD      r11,lr,r11,LSL #5
000512  f8dbb000          LDR      r11,[r11,#0]
000516  f1bb0f00          CMP      r11,#0
00051a  d000              BEQ      |L1.1310|
;;;1065     {
;;;1066       usb_c1_freq /= 2;
00051c  086d              LSRS     r5,r5,#1
                  |L1.1310|
;;;1067     }
;;;1068   
;;;1069     /* Determine USB_C2 frequency */
;;;1070     usb_c2_freq = usb_c1_freq;
00051e  462f              MOV      r7,r5
;;;1071   
;;;1072     if (*(__IO uint32_t *) USB_C2_SEL_BB != 0)
000520  f8dfb15c          LDR      r11,|L1.1664|
000524  f10b0b04          ADD      r11,r11,#4
000528  f04f4e84          MOV      lr,#0x42000000
00052c  eb0e1b4b          ADD      r11,lr,r11,LSL #5
000530  f8dbb008          LDR      r11,[r11,#8]
000534  f1bb0f00          CMP      r11,#0
000538  d00d              BEQ      |L1.1366|
;;;1073     {
;;;1074       /* Determine USB PLL output frequency */
;;;1075       pll_mul = ((MDR_RST_CLK->PLL_CONTROL >> RST_CLK_PLL_CONTROL_PLL_USB_MUL_Pos) & (uint32_t)0x0F) + 1;
00053a  f8dfb150          LDR      r11,|L1.1676|
00053e  f8dbb004          LDR      r11,[r11,#4]
000542  f3cb1b03          UBFX     r11,r11,#4,#4
000546  f10b0b01          ADD      r11,r11,#1
00054a  f8cdb000          STR      r11,[sp,#0]
;;;1076       usb_c2_freq *= pll_mul;
00054e  f8ddb000          LDR      r11,[sp,#0]
000552  fb07f70b          MUL      r7,r7,r11
                  |L1.1366|
;;;1077     }
;;;1078   
;;;1079     /* Determine USB_C3 frequency */
;;;1080     usb_c3_freq = usb_c2_freq;
000556  46b9              MOV      r9,r7
;;;1081     if (*(__IO uint32_t *) USB_C3_SEL_BB != 0)
000558  f8dfb124          LDR      r11,|L1.1664|
00055c  f10b0b04          ADD      r11,r11,#4
000560  f04f4e84          MOV      lr,#0x42000000
000564  eb0e1b4b          ADD      r11,lr,r11,LSL #5
000568  f8dbb010          LDR      r11,[r11,#0x10]
00056c  f1bb0f00          CMP      r11,#0
000570  d001              BEQ      |L1.1398|
;;;1082     {
;;;1083       usb_c3_freq /= 2;
000572  ea4f0959          LSR      r9,r9,#1
                  |L1.1398|
;;;1084     }
;;;1085   
;;;1086     RST_CLK_Clocks->USB_CLK_Frequency = usb_c3_freq;
000576  f8c19004          STR      r9,[r1,#4]
;;;1087   
;;;1088     /* Compute RTCHSI_CLK frequency */
;;;1089     temp = MDR_RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSI_SEL_Pos;
00057a  f8dfb110          LDR      r11,|L1.1676|
00057e  f8dbb018          LDR      r11,[r11,#0x18]
000582  ea4f101b          LSR      r0,r11,#4
;;;1090     if ((temp & 0x08U) == 0)
000586  f0100f08          TST      r0,#8
00058a  d102              BNE      |L1.1426|
;;;1091     {
;;;1092       hsi_c1_freq = HSI_Value;
00058c  f8dfc0f8          LDR      r12,|L1.1672|
000590  e00b              B        |L1.1450|
                  |L1.1426|
;;;1093     }
;;;1094     else
;;;1095     {
;;;1096       temp = 1 << ((temp & 0x07U) + 1);
000592  f0000b07          AND      r11,r0,#7
000596  f10b0b01          ADD      r11,r11,#1
00059a  f04f0e01          MOV      lr,#1
00059e  fa0ef00b          LSL      r0,lr,r11
;;;1097       hsi_c1_freq = HSI_Value/temp;
0005a2  f8dfb0e4          LDR      r11,|L1.1672|
0005a6  fbbbfcf0          UDIV     r12,r11,r0
                  |L1.1450|
;;;1098     }
;;;1099     RST_CLK_Clocks->RTCHSI_Frequency = hsi_c1_freq;
0005aa  f8c1c00c          STR      r12,[r1,#0xc]
;;;1100   
;;;1101     /* Compute RTCHSE_CLK frequency */
;;;1102     temp = MDR_RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSE_SEL_Pos;
0005ae  f8dfb0dc          LDR      r11,|L1.1676|
0005b2  f8db0018          LDR      r0,[r11,#0x18]
;;;1103     if ((temp & 0x08U) == 0)
0005b6  f0100f08          TST      r0,#8
0005ba  d104              BNE      |L1.1478|
;;;1104     {
;;;1105       hse_c1_freq = HSE_Value;
0005bc  f8dfb0c4          LDR      r11,|L1.1668|
0005c0  f8cdb004          STR      r11,[sp,#4]
0005c4  e00d              B        |L1.1506|
                  |L1.1478|
;;;1106     }
;;;1107     else
;;;1108     {
;;;1109       temp = 1 << ((temp & 0x07U) + 1);
0005c6  f0000b07          AND      r11,r0,#7
0005ca  f10b0b01          ADD      r11,r11,#1
0005ce  f04f0e01          MOV      lr,#1
0005d2  fa0ef00b          LSL      r0,lr,r11
;;;1110       hse_c1_freq = HSE_Value/temp;
0005d6  f8dfb0ac          LDR      r11,|L1.1668|
0005da  fbbbfbf0          UDIV     r11,r11,r0
0005de  f8cdb004          STR      r11,[sp,#4]
                  |L1.1506|
;;;1111     }
;;;1112     RST_CLK_Clocks->RTCHSE_Frequency = hse_c1_freq;
0005e2  f8ddb004          LDR      r11,[sp,#4]
0005e6  f8c1b010          STR      r11,[r1,#0x10]
;;;1113   
;;;1114     /* Compute ADC_CLK frequency */
;;;1115   
;;;1116     /* Select ADC_C1 from CPU_C1, LSI, USB_C1, CPU_C2, USB_C2 cases */
;;;1117     switch ((MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Pos) & (uint32_t)0x03)
0005ea  f8dfb0a0          LDR      r11,|L1.1676|
0005ee  f8dbb014          LDR      r11,[r11,#0x14]
0005f2  f01b0b03          ANDS     r11,r11,#3
0005f6  d006              BEQ      |L1.1542|
0005f8  f1bb0f01          CMP      r11,#1
0005fc  d005              BEQ      |L1.1546|
0005fe  f1bb0f02          CMP      r11,#2
000602  d106              BNE      |L1.1554|
000604  e003              B        |L1.1550|
                  |L1.1542|
;;;1118     {
;;;1119       case 0 :
;;;1120         /* CPU_C1 */
;;;1121         adc_c1_freq = cpu_c1_freq;
000606  461e              MOV      r6,r3
;;;1122         break;
000608  e005              B        |L1.1558|
                  |L1.1546|
;;;1123       case 1 :
;;;1124         /* USB_C1 */
;;;1125         adc_c1_freq = usb_c1_freq;
00060a  462e              MOV      r6,r5
;;;1126         break;
00060c  e003              B        |L1.1558|
                  |L1.1550|
;;;1127       case 2 :
;;;1128         /* CPU_C2 */
;;;1129         adc_c1_freq = cpu_c2_freq;
00060e  4626              MOV      r6,r4
;;;1130         break;
000610  e001              B        |L1.1558|
                  |L1.1554|
;;;1131       default : /* case 3 */
;;;1132         /* USB_C2 */
;;;1133         adc_c1_freq = usb_c2_freq;
000612  463e              MOV      r6,r7
;;;1134         break;
000614  bf00              NOP      
                  |L1.1558|
000616  bf00              NOP                            ;1122
;;;1135     }
;;;1136   
;;;1137     /* Select ADC_C2 from LSE, LSI, ADC_C1, HSI_C1 cases */
;;;1138     switch ((MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Pos) & (uint32_t)0x03)
000618  f8dfb070          LDR      r11,|L1.1676|
00061c  f8dbb014          LDR      r11,[r11,#0x14]
000620  f3cb1b01          UBFX     r11,r11,#4,#2
000624  f1bb0f00          CMP      r11,#0
000628  d006              BEQ      |L1.1592|
00062a  f1bb0f01          CMP      r11,#1
00062e  d006              BEQ      |L1.1598|
000630  f1bb0f02          CMP      r11,#2
000634  d108              BNE      |L1.1608|
000636  e005              B        |L1.1604|
                  |L1.1592|
;;;1139     {
;;;1140       case 0 :
;;;1141         /* LSE */
;;;1142         adc_c2_freq = LSE_Value;
000638  f44f4200          MOV      r2,#0x8000
;;;1143         break;
00063c  e006              B        |L1.1612|
                  |L1.1598|
;;;1144       case 1 :
;;;1145         /* LSI */
;;;1146         adc_c2_freq = LSI_Value;
00063e  f6494240          MOV      r2,#0x9c40
;;;1147         break;
000642  e003              B        |L1.1612|
                  |L1.1604|
;;;1148       case 2 :
;;;1149         /* ADC_C1 */
;;;1150         adc_c2_freq = adc_c1_freq;
000644  4632              MOV      r2,r6
;;;1151         break;
000646  e001              B        |L1.1612|
                  |L1.1608|
;;;1152       default : /* case 3 */
;;;1153         /* HSI_C1 */
;;;1154         adc_c2_freq = hsi_c1_freq;
000648  4662              MOV      r2,r12
;;;1155         break;
00064a  bf00              NOP      
                  |L1.1612|
00064c  bf00              NOP                            ;1143
;;;1156     }
;;;1157   
;;;1158     temp = MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Pos;
00064e  f8dfb03c          LDR      r11,|L1.1676|
000652  f8dbb014          LDR      r11,[r11,#0x14]
000656  ea4f201b          LSR      r0,r11,#8
;;;1159     if ((temp & 0x08U) == 0)
00065a  f0100f08          TST      r0,#8
00065e  d101              BNE      |L1.1636|
;;;1160     {
;;;1161       adc_c3_freq = adc_c2_freq;
000660  4692              MOV      r10,r2
000662  e009              B        |L1.1656|
                  |L1.1636|
;;;1162     }
;;;1163     else
;;;1164     {
;;;1165       temp = 1 << ((temp & 0x07U) + 1);
000664  f0000b07          AND      r11,r0,#7
000668  f10b0b01          ADD      r11,r11,#1
00066c  f04f0e01          MOV      lr,#1
000670  fa0ef00b          LSL      r0,lr,r11
;;;1166       adc_c3_freq = adc_c2_freq/temp;
000674  fbb2faf0          UDIV     r10,r2,r0
                  |L1.1656|
;;;1167     }
;;;1168   
;;;1169     RST_CLK_Clocks->ADC_CLK_Frequency = adc_c3_freq;
000678  f8c1a008          STR      r10,[r1,#8]
;;;1170   }
00067c  e8bd8ffc          POP      {r2-r11,pc}
;;;1171   
                          ENDP

                  |L1.1664|
                          DCD      0x0002000c
                  |L1.1668|
                          DCD      0x003d0900
                  |L1.1672|
                          DCD      0x007a1200
                  |L1.1676|
                          DCD      0x40020000

;*** Start embedded assembler ***

#line 1 "..\\Library\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_rst_clk.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REVSH|
#line 130
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
