; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\adc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\adc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\adc.crf src\adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  vTaskADC PROC
;;;27     
;;;28     void vTaskADC(void *pvParameters) 
000000  b508              PUSH     {r3,lr}
;;;29     {
;;;30     	uint32_t msg;
;;;31     	
;;;32     	// Initialize
;;;33     	xQueueADC = xQueueCreate( 5, sizeof( uint32_t ) );		// Queue can contain 5 elements of type uint32_t
000002  2200              MOVS     r2,#0
000004  2104              MOVS     r1,#4
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       xQueueGenericCreate
00000c  4980              LDR      r1,|L1.528|
00000e  6008              STR      r0,[r1,#0]  ; xQueueADC
;;;34     	if( xQueueADC == 0 )
000010  4608              MOV      r0,r1
000012  6800              LDR      r0,[r0,#0]  ; xQueueADC
000014  b908              CBNZ     r0,|L1.26|
;;;35     	{
;;;36     		// Queue was not created and must not be used.
;;;37     		while(1);
000016  bf00              NOP      
                  |L1.24|
000018  e7fe              B        |L1.24|
                  |L1.26|
;;;38     	}
;;;39     	vSemaphoreCreateBinary( xSemaphoreADC );
00001a  2203              MOVS     r2,#3
00001c  2100              MOVS     r1,#0
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       xQueueGenericCreate
000024  497b              LDR      r1,|L1.532|
000026  6008              STR      r0,[r1,#0]  ; xSemaphoreADC
000028  4608              MOV      r0,r1
00002a  6800              LDR      r0,[r0,#0]  ; xSemaphoreADC
00002c  b130              CBZ      r0,|L1.60|
00002e  2300              MOVS     r3,#0
000030  461a              MOV      r2,r3
000032  4619              MOV      r1,r3
000034  4877              LDR      r0,|L1.532|
000036  6800              LDR      r0,[r0,#0]  ; xSemaphoreADC
000038  f7fffffe          BL       xQueueGenericSend
                  |L1.60|
;;;40     	if( xSemaphoreADC == 0 )
00003c  4875              LDR      r0,|L1.532|
00003e  6800              LDR      r0,[r0,#0]  ; xSemaphoreADC
000040  b908              CBNZ     r0,|L1.70|
;;;41         {
;;;42             while(1);
000042  bf00              NOP      
                  |L1.68|
000044  e7fe              B        |L1.68|
                  |L1.70|
;;;43         }
;;;44     	
;;;45     	while(1)
000046  e042              B        |L1.206|
                  |L1.72|
;;;46     	{
;;;47     		xQueueReceive(xQueueADC, &msg, portMAX_DELAY);
000048  2300              MOVS     r3,#0
00004a  1e5a              SUBS     r2,r3,#1
00004c  4669              MOV      r1,sp
00004e  4870              LDR      r0,|L1.528|
000050  6800              LDR      r0,[r0,#0]  ; xQueueADC
000052  f7fffffe          BL       xQueueGenericReceive
;;;48     		switch (msg)
000056  9800              LDR      r0,[sp,#0]
000058  2801              CMP      r0,#1
00005a  d137              BNE      |L1.204|
;;;49     		{
;;;50     			case ADC_GET_ALL_NORMAL:
;;;51     				// Send command to low-level task - must be atomic operations
;;;52     				ctrl_ADCProcess = CMD_ADC_START_VOLTAGE | CMD_ADC_START_CURRENT;
00005c  2003              MOVS     r0,#3
00005e  496e              LDR      r1,|L1.536|
000060  7008              STRB     r0,[r1,#0]
;;;53     				
;;;54     				//while(ctrl_ADCProcess)	// TODO - use semaphore
;;;55     					//vTaskDelay(2);
;;;56     				xSemaphoreTake(xSemaphoreADC, portMAX_DELAY);
000062  2300              MOVS     r3,#0
000064  1f02              SUBS     r2,r0,#4
000066  4619              MOV      r1,r3
000068  486a              LDR      r0,|L1.532|
00006a  6800              LDR      r0,[r0,#0]  ; xSemaphoreADC
00006c  f7fffffe          BL       xQueueGenericReceive
;;;57     			
;;;58     				// Process adc samples
;;;59     				voltage_adc = adc_voltage_counts>>2;
000070  486a              LDR      r0,|L1.540|
000072  8800              LDRH     r0,[r0,#0]  ; adc_voltage_counts
000074  1080              ASRS     r0,r0,#2
000076  496a              LDR      r1,|L1.544|
000078  8008              STRH     r0,[r1,#0]
;;;60     				voltage_adc *= 5;
00007a  4608              MOV      r0,r1
00007c  8800              LDRH     r0,[r0,#0]  ; voltage_adc
00007e  eb000080          ADD      r0,r0,r0,LSL #2
000082  8008              STRH     r0,[r1,#0]
;;;61     				
;;;62     				current_adc = adc_current_counts>>2;
000084  4867              LDR      r0,|L1.548|
000086  8800              LDRH     r0,[r0,#0]  ; adc_current_counts
000088  1080              ASRS     r0,r0,#2
00008a  4967              LDR      r1,|L1.552|
00008c  8008              STRH     r0,[r1,#0]
;;;63     				if (regulation_setting_p -> current_limit == CURRENT_LIM_HIGH)
00008e  4867              LDR      r0,|L1.556|
000090  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000092  7c40              LDRB     r0,[r0,#0x11]
000094  2801              CMP      r0,#1
000096  d107              BNE      |L1.168|
;;;64     					current_adc *= 10;
000098  4608              MOV      r0,r1
00009a  8800              LDRH     r0,[r0,#0]  ; current_adc
00009c  eb000080          ADD      r0,r0,r0,LSL #2
0000a0  0440              LSLS     r0,r0,#17
0000a2  0c00              LSRS     r0,r0,#16
0000a4  8008              STRH     r0,[r1,#0]
0000a6  e005              B        |L1.180|
                  |L1.168|
;;;65     				else
;;;66     					current_adc *= 5;
0000a8  485f              LDR      r0,|L1.552|
0000aa  8800              LDRH     r0,[r0,#0]  ; current_adc
0000ac  eb000080          ADD      r0,r0,r0,LSL #2
0000b0  495d              LDR      r1,|L1.552|
0000b2  8008              STRH     r0,[r1,#0]
                  |L1.180|
;;;67     				
;;;68     				power_adc = voltage_adc * current_adc / 1000;
0000b4  485a              LDR      r0,|L1.544|
0000b6  8800              LDRH     r0,[r0,#0]  ; voltage_adc
0000b8  495b              LDR      r1,|L1.552|
0000ba  8809              LDRH     r1,[r1,#0]  ; current_adc
0000bc  4348              MULS     r0,r1,r0
0000be  f44f717a          MOV      r1,#0x3e8
0000c2  fb90f0f1          SDIV     r0,r0,r1
0000c6  495a              LDR      r1,|L1.560|
0000c8  6008              STR      r0,[r1,#0]  ; power_adc
;;;69     			
;;;70     				break;
0000ca  bf00              NOP      
                  |L1.204|
0000cc  bf00              NOP      
                  |L1.206|
0000ce  e7bb              B        |L1.72|
;;;71     			
;;;72     			
;;;73     		}
;;;74     		
;;;75     	}
;;;76     	
;;;77     }
;;;78     
                          ENDP

                  Converter_HW_ADCProcess PROC
;;;89     //---------------------------------------------//
;;;90     void Converter_HW_ADCProcess(void)
0000d0  b510              PUSH     {r4,lr}
;;;91     {
;;;92     	static uint8_t state_ADCProcess = STATE_ADC_IDLE;
;;;93     	static uint8_t adc_cmd;
;;;94     	static uint8_t adc_counter;
;;;95     	
;;;96     	
;;;97     	// Process ADC FSM-based controller
;;;98     	switch (state_ADCProcess)
0000d2  4858              LDR      r0,|L1.564|
0000d4  7800              LDRB     r0,[r0,#0]  ; state_ADCProcess
0000d6  2803              CMP      r0,#3
0000d8  d052              BEQ      |L1.384|
0000da  dc05              BGT      |L1.232|
0000dc  b148              CBZ      r0,|L1.242|
0000de  2801              CMP      r0,#1
0000e0  d012              BEQ      |L1.264|
0000e2  2802              CMP      r0,#2
                  |L1.228|
0000e4  d170              BNE      |L1.456|
0000e6  e041              B        |L1.364|
                  |L1.232|
0000e8  2810              CMP      r0,#0x10
0000ea  d063              BEQ      |L1.436|
0000ec  2811              CMP      r0,#0x11
0000ee  d1f9              BNE      |L1.228|
0000f0  e06b              B        |L1.458|
                  |L1.242|
;;;99     	{
;;;100    		case STATE_ADC_IDLE:
;;;101    			adc_cmd = ctrl_ADCProcess;
0000f2  4849              LDR      r0,|L1.536|
0000f4  7800              LDRB     r0,[r0,#0]  ; ctrl_ADCProcess
0000f6  4950              LDR      r1,|L1.568|
0000f8  7008              STRB     r0,[r1,#0]
;;;102    			if (adc_cmd)
0000fa  4608              MOV      r0,r1
0000fc  7800              LDRB     r0,[r0,#0]  ; adc_cmd
0000fe  b110              CBZ      r0,|L1.262|
;;;103    				state_ADCProcess = STATE_ADC_DISPATCH;
000100  2001              MOVS     r0,#1
000102  494c              LDR      r1,|L1.564|
000104  7008              STRB     r0,[r1,#0]
                  |L1.262|
;;;104    			break;
000106  e080              B        |L1.522|
                  |L1.264|
;;;105    		case STATE_ADC_DISPATCH:
;;;106    			if ((adc_cmd & (CMD_ADC_START_VOLTAGE | CMD_ADC_START_DISCON)) == CMD_ADC_START_VOLTAGE)
000108  484b              LDR      r0,|L1.568|
00010a  7800              LDRB     r0,[r0,#0]  ; adc_cmd
00010c  f0000005          AND      r0,r0,#5
000110  2801              CMP      r0,#1
000112  d10c              BNE      |L1.302|
;;;107    			{
;;;108    				// Normal voltage measure 
;;;109    				adc_cmd &= ~(CMD_ADC_START_VOLTAGE | CMD_ADC_START_DISCON);
000114  4848              LDR      r0,|L1.568|
000116  7800              LDRB     r0,[r0,#0]  ; adc_cmd
000118  f0200005          BIC      r0,r0,#5
00011c  4946              LDR      r1,|L1.568|
00011e  7008              STRB     r0,[r1,#0]
;;;110    				state_ADCProcess = STATE_ADC_NORMAL_START_U;
000120  2002              MOVS     r0,#2
000122  4944              LDR      r1,|L1.564|
000124  7008              STRB     r0,[r1,#0]
;;;111    				adc_voltage_counts = 0;
000126  2000              MOVS     r0,#0
000128  493c              LDR      r1,|L1.540|
00012a  8008              STRH     r0,[r1,#0]
00012c  e01d              B        |L1.362|
                  |L1.302|
;;;112    			}
;;;113    			else if (adc_cmd & CMD_ADC_START_CURRENT)
00012e  4842              LDR      r0,|L1.568|
000130  7800              LDRB     r0,[r0,#0]  ; adc_cmd
000132  f0100f02          TST      r0,#2
000136  d00c              BEQ      |L1.338|
;;;114    			{
;;;115    				// Current measure
;;;116    				adc_cmd &= ~CMD_ADC_START_CURRENT;
000138  483f              LDR      r0,|L1.568|
00013a  7800              LDRB     r0,[r0,#0]  ; adc_cmd
00013c  f0200002          BIC      r0,r0,#2
000140  493d              LDR      r1,|L1.568|
000142  7008              STRB     r0,[r1,#0]
;;;117    				state_ADCProcess = STATE_ADC_START_I;
000144  2010              MOVS     r0,#0x10
000146  493b              LDR      r1,|L1.564|
000148  7008              STRB     r0,[r1,#0]
;;;118    				adc_current_counts = 0;
00014a  2000              MOVS     r0,#0
00014c  4935              LDR      r1,|L1.548|
00014e  8008              STRH     r0,[r1,#0]
000150  e00b              B        |L1.362|
                  |L1.338|
;;;119    			}
;;;120    			else
;;;121    			{
;;;122    				state_ADCProcess = STATE_ADC_IDLE;
000152  2000              MOVS     r0,#0
000154  4937              LDR      r1,|L1.564|
000156  7008              STRB     r0,[r1,#0]
;;;123    				ctrl_ADCProcess = 0;						// Can be used as flag
000158  492f              LDR      r1,|L1.536|
00015a  7008              STRB     r0,[r1,#0]
;;;124    				xSemaphoreGiveFromISR( xSemaphoreADC, 0 );	// We dont care for exact timing of ADC task
00015c  2300              MOVS     r3,#0
00015e  461a              MOV      r2,r3
000160  4619              MOV      r1,r3
000162  482c              LDR      r0,|L1.532|
000164  6800              LDR      r0,[r0,#0]  ; xSemaphoreADC
000166  f7fffffe          BL       xQueueGenericSendFromISR
                  |L1.362|
;;;125    			}
;;;126    			break;
00016a  e04e              B        |L1.522|
                  |L1.364|
;;;127    		case STATE_ADC_NORMAL_START_U:
;;;128    			// TODO: use DMA for this purpose
;;;129    			ADC1_SetChannel(ADC_CHANNEL_VOLTAGE);
00016c  2004              MOVS     r0,#4
00016e  f7fffffe          BL       ADC1_SetChannel
;;;130    			adc_counter = 4;
000172  2004              MOVS     r0,#4
000174  4931              LDR      r1,|L1.572|
000176  7008              STRB     r0,[r1,#0]
;;;131    			state_ADCProcess = STATE_ADC_NORMAL_REPEAT_U;
000178  2003              MOVS     r0,#3
00017a  492e              LDR      r1,|L1.564|
00017c  7008              STRB     r0,[r1,#0]
;;;132    			break;
00017e  e044              B        |L1.522|
                  |L1.384|
;;;133    		case STATE_ADC_NORMAL_REPEAT_U:
;;;134    			if (adc_counter < 4)
000180  482e              LDR      r0,|L1.572|
000182  7800              LDRB     r0,[r0,#0]  ; adc_counter
000184  2804              CMP      r0,#4
000186  da06              BGE      |L1.406|
;;;135    				adc_voltage_counts += ADC1_GetResult();
000188  f7fffffe          BL       ADC1_GetResult
00018c  4923              LDR      r1,|L1.540|
00018e  8809              LDRH     r1,[r1,#0]  ; adc_voltage_counts
000190  4408              ADD      r0,r0,r1
000192  4922              LDR      r1,|L1.540|
000194  8008              STRH     r0,[r1,#0]
                  |L1.406|
;;;136    			if (adc_counter != 0)
000196  4829              LDR      r0,|L1.572|
000198  7800              LDRB     r0,[r0,#0]  ; adc_counter
00019a  b138              CBZ      r0,|L1.428|
;;;137    			{
;;;138    				ADC1_Start();
00019c  f7fffffe          BL       ADC1_Start
;;;139    				adc_counter--;
0001a0  4826              LDR      r0,|L1.572|
0001a2  7800              LDRB     r0,[r0,#0]  ; adc_counter
0001a4  1e40              SUBS     r0,r0,#1
0001a6  4925              LDR      r1,|L1.572|
0001a8  7008              STRB     r0,[r1,#0]
0001aa  e002              B        |L1.434|
                  |L1.428|
;;;140    			}
;;;141    			else
;;;142    			{
;;;143    				state_ADCProcess = STATE_ADC_DISPATCH;
0001ac  2001              MOVS     r0,#1
0001ae  4921              LDR      r1,|L1.564|
0001b0  7008              STRB     r0,[r1,#0]
                  |L1.434|
;;;144    			}
;;;145    			break;
0001b2  e02a              B        |L1.522|
                  |L1.436|
;;;146    		case STATE_ADC_START_I:
;;;147    			// TODO: use DMA for this purpose
;;;148    			ADC1_SetChannel(ADC_CHANNEL_CURRENT);
0001b4  2007              MOVS     r0,#7
0001b6  f7fffffe          BL       ADC1_SetChannel
;;;149    			adc_counter = 4;
0001ba  2004              MOVS     r0,#4
0001bc  491f              LDR      r1,|L1.572|
0001be  7008              STRB     r0,[r1,#0]
;;;150    			state_ADCProcess = STATE_ADC_NORMAL_REPEAT_I;
0001c0  2011              MOVS     r0,#0x11
0001c2  491c              LDR      r1,|L1.564|
0001c4  7008              STRB     r0,[r1,#0]
;;;151    			break;
0001c6  e020              B        |L1.522|
                  |L1.456|
0001c8  e01b              B        |L1.514|
                  |L1.458|
;;;152    		case STATE_ADC_NORMAL_REPEAT_I:
;;;153    			if (adc_counter < 4)
0001ca  481c              LDR      r0,|L1.572|
0001cc  7800              LDRB     r0,[r0,#0]  ; adc_counter
0001ce  2804              CMP      r0,#4
0001d0  da06              BGE      |L1.480|
;;;154    				adc_current_counts += ADC1_GetResult();
0001d2  f7fffffe          BL       ADC1_GetResult
0001d6  4913              LDR      r1,|L1.548|
0001d8  8809              LDRH     r1,[r1,#0]  ; adc_current_counts
0001da  4408              ADD      r0,r0,r1
0001dc  4911              LDR      r1,|L1.548|
0001de  8008              STRH     r0,[r1,#0]
                  |L1.480|
;;;155    			ADC1_Start();
0001e0  f7fffffe          BL       ADC1_Start
;;;156    			if (adc_counter != 0)
0001e4  4815              LDR      r0,|L1.572|
0001e6  7800              LDRB     r0,[r0,#0]  ; adc_counter
0001e8  b138              CBZ      r0,|L1.506|
;;;157    			{
;;;158    				ADC1_Start();
0001ea  f7fffffe          BL       ADC1_Start
;;;159    				adc_counter--;
0001ee  4813              LDR      r0,|L1.572|
0001f0  7800              LDRB     r0,[r0,#0]  ; adc_counter
0001f2  1e40              SUBS     r0,r0,#1
0001f4  4911              LDR      r1,|L1.572|
0001f6  7008              STRB     r0,[r1,#0]
0001f8  e002              B        |L1.512|
                  |L1.506|
;;;160    			}
;;;161    			else
;;;162    			{
;;;163    				state_ADCProcess = STATE_ADC_DISPATCH;
0001fa  2001              MOVS     r0,#1
0001fc  490d              LDR      r1,|L1.564|
0001fe  7008              STRB     r0,[r1,#0]
                  |L1.512|
;;;164    			}
;;;165    			break;
000200  e003              B        |L1.522|
                  |L1.514|
;;;166    		default:
;;;167    			state_ADCProcess = STATE_ADC_IDLE;
000202  2000              MOVS     r0,#0
000204  490b              LDR      r1,|L1.564|
000206  7008              STRB     r0,[r1,#0]
;;;168    			break;
000208  bf00              NOP      
                  |L1.522|
00020a  bf00              NOP                            ;104
;;;169    	}
;;;170    	
;;;171    	
;;;172    	
;;;173    	/*
;;;174    		//...
;;;175    		
;;;176    		// Disable converter for ADC
;;;177    		cmd_ADC_to_HWProcess = STATE_HW_OFF_BY_ADC;			// Will disallow converter operation
;;;178    		
;;;179    		//...
;;;180    		
;;;181    		// Enable converter for ADC
;;;182    		cmd_ADC_to_HWProcess = CMD_HW_ON_BY_ADC;			// Will allow converter operation
;;;183    	*/
;;;184    	
;;;185    
;;;186    }
00020c  bd10              POP      {r4,pc}
;;;187    
                          ENDP

00020e  0000              DCW      0x0000
                  |L1.528|
                          DCD      xQueueADC
                  |L1.532|
                          DCD      xSemaphoreADC
                  |L1.536|
                          DCD      ctrl_ADCProcess
                  |L1.540|
                          DCD      adc_voltage_counts
                  |L1.544|
                          DCD      voltage_adc
                  |L1.548|
                          DCD      adc_current_counts
                  |L1.552|
                          DCD      current_adc
                  |L1.556|
                          DCD      regulation_setting_p
                  |L1.560|
                          DCD      power_adc
                  |L1.564|
                          DCD      state_ADCProcess
                  |L1.568|
                          DCD      adc_cmd
                  |L1.572|
                          DCD      adc_counter

                          AREA ||.data||, DATA, ALIGN=2

                  ctrl_ADCProcess
000000  00                DCB      0x00
                  state_ADCProcess
000001  00                DCB      0x00
                  adc_cmd
000002  00                DCB      0x00
                  adc_counter
000003  00                DCB      0x00
                  voltage_adc
000004  0000              DCB      0x00,0x00
                  current_adc
000006  0000              DCB      0x00,0x00
                  power_adc
                          DCD      0x00000000
                  adc_voltage_counts
00000c  0000              DCB      0x00,0x00
                  adc_current_counts
00000e  0000              DCB      0x00,0x00
                  xQueueADC
                          DCD      0x00000000
                  xSemaphoreADC
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "src\\adc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_adc_c_vTaskADC____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_adc_c_vTaskADC____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_adc_c_vTaskADC____REVSH|
#line 130
|__asm___5_adc_c_vTaskADC____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
