; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\adc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\adc.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -I.\src\gui -I.\src\gui\guiCore -I.\src\gui\guiWidgets -I.\src\gui\guiGraphics -I.\src\gui\utils -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\adc.crf src\adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  vTaskADC PROC
;;;31     
;;;32     void vTaskADC(void *pvParameters) 
000000  b508              PUSH     {r3,lr}
;;;33     {
;;;34     	uint32_t msg;
;;;35     	
;;;36     	// Initialize
;;;37     	xQueueADC = xQueueCreate( 5, sizeof( uint32_t ) );		// Queue can contain 5 elements of type uint32_t
000002  2200              MOVS     r2,#0
000004  2104              MOVS     r1,#4
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       xQueueGenericCreate
00000c  4c5e              LDR      r4,|L1.392|
00000e  6160              STR      r0,[r4,#0x14]  ; xQueueADC
;;;38     	if( xQueueADC == 0 )
000010  b180              CBZ      r0,|L1.52|
;;;39     	{
;;;40     		// Queue was not created and must not be used.
;;;41     		while(1);
;;;42     	}
;;;43     	vSemaphoreCreateBinary( xSemaphoreADC );
000012  2203              MOVS     r2,#3
000014  2100              MOVS     r1,#0
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       xQueueGenericCreate
00001c  61a0              STR      r0,[r4,#0x18]  ; xSemaphoreADC
00001e  b120              CBZ      r0,|L1.42|
000020  2300              MOVS     r3,#0
000022  461a              MOV      r2,r3
000024  4619              MOV      r1,r3
000026  f7fffffe          BL       xQueueGenericSend
                  |L1.42|
;;;44     	if( xSemaphoreADC == 0 )
00002a  69a0              LDR      r0,[r4,#0x18]  ; xSemaphoreADC
00002c  b118              CBZ      r0,|L1.54|
;;;45         {
;;;46             while(1);
;;;47         }
;;;48     	
;;;49     	while(1)
;;;50     	{
;;;51     		xQueueReceive(xQueueADC, &msg, portMAX_DELAY);
;;;52     		switch (msg)
;;;53     		{
;;;54     			case ADC_GET_ALL_NORMAL:
;;;55     				// Send command to low-level task - must be atomic operations
;;;56     				ctrl_ADCProcess = CMD_ADC_START_VOLTAGE | CMD_ADC_START_CURRENT;
;;;57     				
;;;58     				//while(ctrl_ADCProcess)	// TODO - use semaphore
;;;59     					//vTaskDelay(2);
;;;60     				xSemaphoreTake(xSemaphoreADC, portMAX_DELAY);
00002e  f04f35ff          MOV      r5,#0xffffffff
000032  e02b              B        |L1.140|
                  |L1.52|
000034  e7fe              B        |L1.52|
                  |L1.54|
000036  e7fe              B        |L1.54|
                  |L1.56|
000038  2003              MOVS     r0,#3                 ;56
00003a  7020              STRB     r0,[r4,#0]            ;56
00003c  2300              MOVS     r3,#0
00003e  462a              MOV      r2,r5
000040  4619              MOV      r1,r3
000042  69a0              LDR      r0,[r4,#0x18]  ; xSemaphoreADC
000044  f7fffffe          BL       xQueueGenericReceive
;;;61     			
;;;62     				// Process adc samples
;;;63     				voltage_adc = adc_voltage_counts>>2;
000048  8920              LDRH     r0,[r4,#8]  ; adc_voltage_counts
00004a  0880              LSRS     r0,r0,#2
;;;64     				voltage_adc *= 5;
00004c  eb000080          ADD      r0,r0,r0,LSL #2
000050  b281              UXTH     r1,r0
000052  80a1              STRH     r1,[r4,#4]
;;;65     				
;;;66     				current_adc = adc_current_counts>>2;
000054  8960              LDRH     r0,[r4,#0xa]  ; adc_current_counts
000056  0880              LSRS     r0,r0,#2
000058  80e0              STRH     r0,[r4,#6]
;;;67     				if (regulation_setting_p -> current_limit == CURRENT_LIM_HIGH)
00005a  4a4c              LDR      r2,|L1.396|
00005c  6812              LDR      r2,[r2,#0]  ; regulation_setting_p
00005e  7c52              LDRB     r2,[r2,#0x11]
000060  2a01              CMP      r2,#1
000062  d01d              BEQ      |L1.160|
;;;68     					current_adc *= 10;
;;;69     				else
;;;70     					current_adc *= 5;
000064  eb000080          ADD      r0,r0,r0,LSL #2
000068  80e0              STRH     r0,[r4,#6]
                  |L1.106|
;;;71     				
;;;72     				power_adc = voltage_adc * current_adc / 1000;
00006a  88e0              LDRH     r0,[r4,#6]  ; current_adc
00006c  4341              MULS     r1,r0,r1
00006e  f44f707a          MOV      r0,#0x3e8
000072  fb91f0f0          SDIV     r0,r1,r0
000076  60e0              STR      r0,[r4,#0xc]  ; power_adc
;;;73     				
;;;74     				// Send notification to GUI
;;;75     				gui_msg = GUI_TASK_UPDATE_VOLTAGE_CURRENT;
000078  2010              MOVS     r0,#0x10
00007a  6120              STR      r0,[r4,#0x10]  ; gui_msg
;;;76     				xQueueSendToBack(xQueueGUI, &gui_msg, 0);
00007c  4844              LDR      r0,|L1.400|
00007e  4942              LDR      r1,|L1.392|
000080  2300              MOVS     r3,#0
000082  461a              MOV      r2,r3
000084  3110              ADDS     r1,r1,#0x10
000086  6800              LDR      r0,[r0,#0]  ; xQueueGUI
000088  f7fffffe          BL       xQueueGenericSend
                  |L1.140|
00008c  2300              MOVS     r3,#0                 ;51
00008e  462a              MOV      r2,r5                 ;51
000090  4669              MOV      r1,sp                 ;51
000092  6960              LDR      r0,[r4,#0x14]         ;51  ; xQueueADC
000094  f7fffffe          BL       xQueueGenericReceive
000098  9800              LDR      r0,[sp,#0]            ;52
00009a  2801              CMP      r0,#1                 ;52
00009c  d1f6              BNE      |L1.140|
00009e  e7cb              B        |L1.56|
                  |L1.160|
0000a0  eb000080          ADD      r0,r0,r0,LSL #2       ;68
0000a4  0040              LSLS     r0,r0,#1              ;68
0000a6  80e0              STRH     r0,[r4,#6]            ;68
0000a8  e7df              B        |L1.106|
;;;77     			
;;;78     				break;
;;;79     			
;;;80     			
;;;81     		}
;;;82     		
;;;83     	}
;;;84     	
;;;85     }
;;;86     
                          ENDP

                  Converter_HW_ADCProcess PROC
;;;97     //---------------------------------------------//
;;;98     void Converter_HW_ADCProcess(void)
0000aa  b570              PUSH     {r4-r6,lr}
;;;99     {
;;;100    	static uint8_t state_ADCProcess = STATE_ADC_IDLE;
;;;101    	static uint8_t adc_cmd;
;;;102    	static uint8_t adc_counter;
;;;103    	
;;;104    	
;;;105    	// Process ADC FSM-based controller
;;;106    	switch (state_ADCProcess)
0000ac  4c36              LDR      r4,|L1.392|
0000ae  2200              MOVS     r2,#0
0000b0  4621              MOV      r1,r4
0000b2  7860              LDRB     r0,[r4,#1]  ; state_ADCProcess
;;;107    	{
;;;108    		case STATE_ADC_IDLE:
;;;109    			adc_cmd = ctrl_ADCProcess;
;;;110    			if (adc_cmd)
;;;111    				state_ADCProcess = STATE_ADC_DISPATCH;
0000b4  2501              MOVS     r5,#1
;;;112    			break;
;;;113    		case STATE_ADC_DISPATCH:
;;;114    			if ((adc_cmd & (CMD_ADC_START_VOLTAGE | CMD_ADC_START_DISCON)) == CMD_ADC_START_VOLTAGE)
;;;115    			{
;;;116    				// Normal voltage measure 
;;;117    				adc_cmd &= ~(CMD_ADC_START_VOLTAGE | CMD_ADC_START_DISCON);
;;;118    				state_ADCProcess = STATE_ADC_NORMAL_START_U;
;;;119    				adc_voltage_counts = 0;
;;;120    			}
;;;121    			else if (adc_cmd & CMD_ADC_START_CURRENT)
;;;122    			{
;;;123    				// Current measure
;;;124    				adc_cmd &= ~CMD_ADC_START_CURRENT;
;;;125    				state_ADCProcess = STATE_ADC_START_I;
;;;126    				adc_current_counts = 0;
;;;127    			}
;;;128    			else
;;;129    			{
;;;130    				state_ADCProcess = STATE_ADC_IDLE;
;;;131    				ctrl_ADCProcess = 0;						// Can be used as flag
;;;132    				xSemaphoreGiveFromISR( xSemaphoreADC, 0 );	// We dont care for exact timing of ADC task
;;;133    			}
;;;134    			break;
;;;135    		case STATE_ADC_NORMAL_START_U:
;;;136    			// TODO: use DMA for this purpose
;;;137    			ADC1_SetChannel(ADC_CHANNEL_VOLTAGE);
0000b6  2604              MOVS     r6,#4
0000b8  78c9              LDRB     r1,[r1,#3]            ;106
0000ba  2803              CMP      r0,#3                 ;106
0000bc  d038              BEQ      |L1.304|
0000be  dc05              BGT      |L1.204|
0000c0  b150              CBZ      r0,|L1.216|
0000c2  2801              CMP      r0,#1                 ;106
0000c4  d00e              BEQ      |L1.228|
0000c6  2802              CMP      r0,#2                 ;106
0000c8  d104              BNE      |L1.212|
0000ca  e02a              B        |L1.290|
                  |L1.204|
0000cc  2810              CMP      r0,#0x10              ;106
0000ce  d040              BEQ      |L1.338|
0000d0  2811              CMP      r0,#0x11              ;106
0000d2  d045              BEQ      |L1.352|
                  |L1.212|
;;;138    			adc_counter = 4;
;;;139    			state_ADCProcess = STATE_ADC_NORMAL_REPEAT_U;
;;;140    			break;
;;;141    		case STATE_ADC_NORMAL_REPEAT_U:
;;;142    			if (adc_counter < 4)
;;;143    				adc_voltage_counts += ADC1_GetResult();
;;;144    			if (adc_counter != 0)
;;;145    			{
;;;146    				ADC1_Start();
;;;147    				adc_counter--;
;;;148    			}
;;;149    			else
;;;150    			{
;;;151    				state_ADCProcess = STATE_ADC_DISPATCH;
;;;152    			}
;;;153    			break;
;;;154    		case STATE_ADC_START_I:
;;;155    			// TODO: use DMA for this purpose
;;;156    			ADC1_SetChannel(ADC_CHANNEL_CURRENT);
;;;157    			adc_counter = 4;
;;;158    			state_ADCProcess = STATE_ADC_NORMAL_REPEAT_I;
;;;159    			break;
;;;160    		case STATE_ADC_NORMAL_REPEAT_I:
;;;161    			if (adc_counter < 4)
;;;162    				adc_current_counts += ADC1_GetResult();
;;;163    			ADC1_Start();
;;;164    			if (adc_counter != 0)
;;;165    			{
;;;166    				ADC1_Start();
;;;167    				adc_counter--;
;;;168    			}
;;;169    			else
;;;170    			{
;;;171    				state_ADCProcess = STATE_ADC_DISPATCH;
;;;172    			}
;;;173    			break;
;;;174    		default:
;;;175    			state_ADCProcess = STATE_ADC_IDLE;
0000d4  7062              STRB     r2,[r4,#1]
                  |L1.214|
;;;176    			break;
;;;177    	}
;;;178    	
;;;179    	
;;;180    	
;;;181    	/*
;;;182    		//...
;;;183    		
;;;184    		// Disable converter for ADC
;;;185    		cmd_ADC_to_HWProcess = STATE_HW_OFF_BY_ADC;			// Will disallow converter operation
;;;186    		
;;;187    		//...
;;;188    		
;;;189    		// Enable converter for ADC
;;;190    		cmd_ADC_to_HWProcess = CMD_HW_ON_BY_ADC;			// Will allow converter operation
;;;191    	*/
;;;192    	
;;;193    
;;;194    }
0000d6  bd70              POP      {r4-r6,pc}
                  |L1.216|
0000d8  7820              LDRB     r0,[r4,#0]            ;109  ; ctrl_ADCProcess
0000da  70a0              STRB     r0,[r4,#2]            ;109
0000dc  2800              CMP      r0,#0                 ;110
0000de  d0fa              BEQ      |L1.214|
0000e0  7065              STRB     r5,[r4,#1]            ;111
0000e2  bd70              POP      {r4-r6,pc}
                  |L1.228|
0000e4  78a0              LDRB     r0,[r4,#2]            ;114  ; adc_cmd
0000e6  f0000105          AND      r1,r0,#5              ;114
0000ea  2901              CMP      r1,#1                 ;114
0000ec  d008              BEQ      |L1.256|
0000ee  0781              LSLS     r1,r0,#30             ;121
0000f0  d50d              BPL      |L1.270|
0000f2  f0200002          BIC      r0,r0,#2              ;124
0000f6  70a0              STRB     r0,[r4,#2]            ;124
0000f8  2010              MOVS     r0,#0x10              ;125
0000fa  7060              STRB     r0,[r4,#1]            ;125
0000fc  8162              STRH     r2,[r4,#0xa]          ;126
0000fe  bd70              POP      {r4-r6,pc}
                  |L1.256|
000100  f0200005          BIC      r0,r0,#5              ;117
000104  70a0              STRB     r0,[r4,#2]            ;117
000106  2002              MOVS     r0,#2                 ;118
000108  7060              STRB     r0,[r4,#1]            ;118
00010a  8122              STRH     r2,[r4,#8]            ;119
00010c  bd70              POP      {r4-r6,pc}
                  |L1.270|
00010e  7062              STRB     r2,[r4,#1]            ;130
000110  7022              STRB     r2,[r4,#0]            ;131
000112  69a0              LDR      r0,[r4,#0x18]         ;132  ; xSemaphoreADC
000114  e8bd4070          POP      {r4-r6,lr}            ;132
000118  2300              MOVS     r3,#0                 ;132
00011a  461a              MOV      r2,r3                 ;132
00011c  4619              MOV      r1,r3                 ;132
00011e  f7ffbffe          B.W      xQueueGenericSendFromISR
                  |L1.290|
000122  2004              MOVS     r0,#4                 ;137
000124  f7fffffe          BL       ADC1_SetChannel
000128  70e6              STRB     r6,[r4,#3]            ;138
00012a  2003              MOVS     r0,#3                 ;139
00012c  7060              STRB     r0,[r4,#1]            ;139
00012e  bd70              POP      {r4-r6,pc}
                  |L1.304|
000130  2904              CMP      r1,#4                 ;142
000132  d204              BCS      |L1.318|
000134  f7fffffe          BL       ADC1_GetResult
000138  8921              LDRH     r1,[r4,#8]            ;143  ; adc_voltage_counts
00013a  4408              ADD      r0,r0,r1              ;143
00013c  8120              STRH     r0,[r4,#8]            ;143
                  |L1.318|
00013e  78e0              LDRB     r0,[r4,#3]            ;144  ; adc_counter
000140  b128              CBZ      r0,|L1.334|
000142  f7fffffe          BL       ADC1_Start
000146  78e0              LDRB     r0,[r4,#3]            ;147  ; adc_counter
000148  1e40              SUBS     r0,r0,#1              ;147
00014a  70e0              STRB     r0,[r4,#3]            ;147
00014c  bd70              POP      {r4-r6,pc}
                  |L1.334|
00014e  7065              STRB     r5,[r4,#1]            ;151
000150  bd70              POP      {r4-r6,pc}
                  |L1.338|
000152  2007              MOVS     r0,#7                 ;156
000154  f7fffffe          BL       ADC1_SetChannel
000158  70e6              STRB     r6,[r4,#3]            ;157
00015a  2011              MOVS     r0,#0x11              ;158
00015c  7060              STRB     r0,[r4,#1]            ;158
00015e  bd70              POP      {r4-r6,pc}
                  |L1.352|
000160  2904              CMP      r1,#4                 ;161
000162  d204              BCS      |L1.366|
000164  f7fffffe          BL       ADC1_GetResult
000168  8961              LDRH     r1,[r4,#0xa]          ;162  ; adc_current_counts
00016a  4408              ADD      r0,r0,r1              ;162
00016c  8160              STRH     r0,[r4,#0xa]          ;162
                  |L1.366|
00016e  f7fffffe          BL       ADC1_Start
000172  78e0              LDRB     r0,[r4,#3]            ;164  ; adc_counter
000174  b128              CBZ      r0,|L1.386|
000176  f7fffffe          BL       ADC1_Start
00017a  78e0              LDRB     r0,[r4,#3]            ;167  ; adc_counter
00017c  1e40              SUBS     r0,r0,#1              ;167
00017e  70e0              STRB     r0,[r4,#3]            ;167
000180  bd70              POP      {r4-r6,pc}
                  |L1.386|
000182  7065              STRB     r5,[r4,#1]            ;171
000184  bd70              POP      {r4-r6,pc}
;;;195    
                          ENDP

000186  0000              DCW      0x0000
                  |L1.392|
                          DCD      ||.data||
                  |L1.396|
                          DCD      regulation_setting_p
                  |L1.400|
                          DCD      xQueueGUI

                          AREA ||.data||, DATA, ALIGN=2

                  ctrl_ADCProcess
000000  00                DCB      0x00
                  state_ADCProcess
000001  00                DCB      0x00
                  adc_cmd
000002  00                DCB      0x00
                  adc_counter
000003  00                DCB      0x00
                  voltage_adc
000004  0000              DCB      0x00,0x00
                  current_adc
000006  0000              DCB      0x00,0x00
                  adc_voltage_counts
000008  0000              DCB      0x00,0x00
                  adc_current_counts
00000a  0000              DCB      0x00,0x00
                  power_adc
                          DCD      0x00000000
                  gui_msg
                          DCD      0x00000000
                  xQueueADC
                          DCD      0x00000000
                  xSemaphoreADC
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "src\\adc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_adc_c_vTaskADC____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_adc_c_vTaskADC____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_adc_c_vTaskADC____REVSH|
#line 130
|__asm___5_adc_c_vTaskADC____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
