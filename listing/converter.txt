; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\converter.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\converter.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\converter.crf src\converter.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CheckSetVoltageRange PROC
;;;68     
;;;69     static uint16_t CheckSetVoltageRange(int32_t new_set_voltage, uint8_t *err_code)
000000  4602              MOV      r2,r0
;;;70     {
;;;71     	uint8_t error = VCHECK_OK;
000002  2301              MOVS     r3,#1
;;;72     
;;;73     	// First check soft limits
;;;74     	if (regulation_setting_p->soft_voltage_range_enable)
000004  48f8              LDR      r0,|L1.1000|
000006  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000008  7c00              LDRB     r0,[r0,#0x10]
00000a  b190              CBZ      r0,|L1.50|
;;;75     	{
;;;76     		if (new_set_voltage < (int32_t)regulation_setting_p->soft_min_voltage)
00000c  48f6              LDR      r0,|L1.1000|
00000e  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000010  8940              LDRH     r0,[r0,#0xa]
000012  4290              CMP      r0,r2
000014  dd04              BLE      |L1.32|
;;;77     		{
;;;78     			new_set_voltage = (int32_t)regulation_setting_p->soft_min_voltage;
000016  48f4              LDR      r0,|L1.1000|
000018  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
00001a  8942              LDRH     r2,[r0,#0xa]
;;;79     			error = VCHECK_SOFT_MIN;
00001c  2305              MOVS     r3,#5
00001e  e008              B        |L1.50|
                  |L1.32|
;;;80     		}
;;;81     		else if (new_set_voltage > (int32_t)regulation_setting_p->soft_max_voltage)
000020  48f1              LDR      r0,|L1.1000|
000022  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000024  8900              LDRH     r0,[r0,#8]
000026  4290              CMP      r0,r2
000028  da03              BGE      |L1.50|
;;;82     		{
;;;83     			new_set_voltage = (int32_t)regulation_setting_p->soft_max_voltage;
00002a  48ef              LDR      r0,|L1.1000|
00002c  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
00002e  8902              LDRH     r2,[r0,#8]
;;;84     			error = VCHECK_SOFT_MAX;
000030  2304              MOVS     r3,#4
                  |L1.50|
;;;85     		}
;;;86     	}
;;;87     	
;;;88     	// Check absolute limits
;;;89     	if (new_set_voltage < (int32_t)regulation_setting_p->MIN_VOLTAGE)
000032  48ed              LDR      r0,|L1.1000|
000034  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000036  88c0              LDRH     r0,[r0,#6]
000038  4290              CMP      r0,r2
00003a  dd04              BLE      |L1.70|
;;;90     	{
;;;91     		new_set_voltage = (int32_t)regulation_setting_p->MIN_VOLTAGE;
00003c  48ea              LDR      r0,|L1.1000|
00003e  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000040  88c2              LDRH     r2,[r0,#6]
;;;92     		error = VCHECK_ABS_MIN;
000042  2303              MOVS     r3,#3
000044  e008              B        |L1.88|
                  |L1.70|
;;;93     	}
;;;94     	else if (new_set_voltage > (int32_t)regulation_setting_p->MAX_VOLTAGE)
000046  48e8              LDR      r0,|L1.1000|
000048  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
00004a  8880              LDRH     r0,[r0,#4]
00004c  4290              CMP      r0,r2
00004e  da03              BGE      |L1.88|
;;;95     	{
;;;96     		new_set_voltage = (int32_t)regulation_setting_p->MAX_VOLTAGE;
000050  48e5              LDR      r0,|L1.1000|
000052  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000054  8882              LDRH     r2,[r0,#4]
;;;97     		error = VCHECK_ABS_MAX;
000056  2302              MOVS     r3,#2
                  |L1.88|
;;;98     	}
;;;99     	
;;;100    	*err_code = error;
000058  700b              STRB     r3,[r1,#0]
;;;101    	return (uint16_t)new_set_voltage;
00005a  b290              UXTH     r0,r2
;;;102    }
00005c  4770              BX       lr
;;;103    
                          ENDP

                  CheckSetCurrentRange PROC
;;;104    
;;;105    static uint16_t CheckSetCurrentRange(int32_t new_set_current, uint8_t *err_code)
00005e  b530              PUSH     {r4,r5,lr}
;;;106    {
000060  4602              MOV      r2,r0
000062  460c              MOV      r4,r1
;;;107    	int32_t max_current;
;;;108    	int32_t min_current;	
;;;109    	uint8_t error = CCHECK_OK;
000064  2508              MOVS     r5,#8
;;;110    	
;;;111    	if (regulation_setting_p->current_limit == CURRENT_LIM_HIGH)
000066  48e0              LDR      r0,|L1.1000|
000068  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
00006a  7c40              LDRB     r0,[r0,#0x11]
00006c  2801              CMP      r0,#1
00006e  d106              BNE      |L1.126|
;;;112    	{
;;;113    		max_current = regulation_setting_p->HIGH_LIM_MAX_CURRENT;
000070  48dd              LDR      r0,|L1.1000|
000072  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000074  8b01              LDRH     r1,[r0,#0x18]
;;;114    		min_current = regulation_setting_p->HIGH_LIM_MIN_CURRENT;
000076  48dc              LDR      r0,|L1.1000|
000078  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
00007a  8b43              LDRH     r3,[r0,#0x1a]
00007c  e005              B        |L1.138|
                  |L1.126|
;;;115    	}
;;;116    	else
;;;117    	{
;;;118    		max_current = regulation_setting_p->LOW_LIM_MAX_CURRENT;
00007e  48da              LDR      r0,|L1.1000|
000080  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000082  8a81              LDRH     r1,[r0,#0x14]
;;;119    		min_current = regulation_setting_p->LOW_LIM_MIN_CURRENT;
000084  48d8              LDR      r0,|L1.1000|
000086  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000088  8ac3              LDRH     r3,[r0,#0x16]
                  |L1.138|
;;;120    	}
;;;121    	
;;;122    	// First check soft limits
;;;123    	if (regulation_setting_p->soft_current_range_enable)
00008a  48d7              LDR      r0,|L1.1000|
00008c  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
00008e  f8900024          LDRB     r0,[r0,#0x24]
000092  b190              CBZ      r0,|L1.186|
;;;124    	{
;;;125    		if (new_set_current < (int32_t)regulation_setting_p->soft_min_current)
000094  48d4              LDR      r0,|L1.1000|
000096  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000098  8bc0              LDRH     r0,[r0,#0x1e]
00009a  4290              CMP      r0,r2
00009c  dd04              BLE      |L1.168|
;;;126    		{
;;;127    			new_set_current = (int32_t)regulation_setting_p->soft_min_current;
00009e  48d2              LDR      r0,|L1.1000|
0000a0  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
0000a2  8bc2              LDRH     r2,[r0,#0x1e]
;;;128    			error = CCHECK_SOFT_MIN;
0000a4  250c              MOVS     r5,#0xc
0000a6  e008              B        |L1.186|
                  |L1.168|
;;;129    		}
;;;130    		else if (new_set_current > (int32_t)regulation_setting_p->soft_max_current)
0000a8  48cf              LDR      r0,|L1.1000|
0000aa  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
0000ac  8b80              LDRH     r0,[r0,#0x1c]
0000ae  4290              CMP      r0,r2
0000b0  da03              BGE      |L1.186|
;;;131    		{
;;;132    			new_set_current = (int32_t)regulation_setting_p->soft_max_current;
0000b2  48cd              LDR      r0,|L1.1000|
0000b4  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
0000b6  8b82              LDRH     r2,[r0,#0x1c]
;;;133    			error = CCHECK_SOFT_MAX;
0000b8  250b              MOVS     r5,#0xb
                  |L1.186|
;;;134    		}	
;;;135    	}
;;;136    	
;;;137    	// Check absolute limits - this will overwrite possibly incorrect soft limits
;;;138    	// This can happen for exapmle, if soft_min = 35A and current limit is switched to 20A
;;;139    	if (new_set_current < min_current)
0000ba  429a              CMP      r2,r3
0000bc  da02              BGE      |L1.196|
;;;140    	{
;;;141    		new_set_current = min_current;
0000be  461a              MOV      r2,r3
;;;142    		error = CCHECK_ABS_MIN;
0000c0  250a              MOVS     r5,#0xa
0000c2  e003              B        |L1.204|
                  |L1.196|
;;;143    	}
;;;144    	else if (new_set_current > max_current)
0000c4  428a              CMP      r2,r1
0000c6  dd01              BLE      |L1.204|
;;;145    	{
;;;146    		new_set_current = max_current;
0000c8  460a              MOV      r2,r1
;;;147    		error = CCHECK_ABS_MAX;
0000ca  2509              MOVS     r5,#9
                  |L1.204|
;;;148    	}
;;;149    	
;;;150    	*err_code = error;
0000cc  7025              STRB     r5,[r4,#0]
;;;151    	return (uint16_t)new_set_current;
0000ce  b290              UXTH     r0,r2
;;;152    }
0000d0  bd30              POP      {r4,r5,pc}
;;;153    
                          ENDP

                  Converter_SetSoftLimit PROC
;;;154    
;;;155    uint8_t Converter_SetSoftLimit(int32_t new_limit, converter_regulation_t *reg_p, uint8_t mode)
0000d2  b5f0              PUSH     {r4-r7,lr}
;;;156    {
0000d4  4605              MOV      r5,r0
0000d6  4616              MOV      r6,r2
;;;157    	uint8_t err_code = SLIM_OK;
0000d8  2010              MOVS     r0,#0x10
;;;158    	uint16_t *lim_p;
;;;159    	int32_t minimum;
;;;160    	int32_t maximum;
;;;161    	
;;;162    	switch (mode)
0000da  2e01              CMP      r6,#1
0000dc  d006              BEQ      |L1.236|
0000de  2e02              CMP      r6,#2
0000e0  d009              BEQ      |L1.246|
0000e2  2e03              CMP      r6,#3
0000e4  d00c              BEQ      |L1.256|
0000e6  2e04              CMP      r6,#4
0000e8  d114              BNE      |L1.276|
0000ea  e00e              B        |L1.266|
                  |L1.236|
;;;163    	{
;;;164    		case SET_LOW_VOLTAGE_SOFT_LIMIT:
;;;165    			lim_p = &reg_p->soft_min_voltage;
0000ec  f101040a          ADD      r4,r1,#0xa
;;;166    			minimum = reg_p->SOFT_MIN_VOLTAGE_LIMIT;
0000f0  89ca              LDRH     r2,[r1,#0xe]
;;;167    			maximum = reg_p->soft_max_voltage;
0000f2  890b              LDRH     r3,[r1,#8]
;;;168    			break;
0000f4  e00e              B        |L1.276|
                  |L1.246|
;;;169    		case SET_HIGH_VOLTAGE_SOFT_LIMIT:
;;;170    			lim_p = &reg_p->soft_max_voltage;
0000f6  f1010408          ADD      r4,r1,#8
;;;171    			minimum = reg_p->soft_min_voltage;
0000fa  894a              LDRH     r2,[r1,#0xa]
;;;172    			maximum = reg_p->SOFT_MAX_VOLTAGE_LIMIT;
0000fc  898b              LDRH     r3,[r1,#0xc]
;;;173    			break;
0000fe  e009              B        |L1.276|
                  |L1.256|
;;;174    		case SET_LOW_CURRENT_SOFT_LIMIT:
;;;175    			lim_p = &reg_p->soft_min_current;
000100  f101041e          ADD      r4,r1,#0x1e
;;;176    			minimum = reg_p->SOFT_MIN_CURRENT_LIMIT;
000104  8c4a              LDRH     r2,[r1,#0x22]
;;;177    			maximum = reg_p->soft_max_current;
000106  8b8b              LDRH     r3,[r1,#0x1c]
;;;178    			break;
000108  e004              B        |L1.276|
                  |L1.266|
;;;179    		case SET_HIGH_CURRENT_SOFT_LIMIT:
;;;180    			lim_p = &reg_p->soft_max_current;
00010a  f101041c          ADD      r4,r1,#0x1c
;;;181    			minimum = reg_p->soft_min_current;
00010e  8bca              LDRH     r2,[r1,#0x1e]
;;;182    			maximum = reg_p->SOFT_MAX_CURRENT_LIMIT;
000110  8c0b              LDRH     r3,[r1,#0x20]
;;;183    			break;
000112  bf00              NOP      
                  |L1.276|
000114  bf00              NOP                            ;168
;;;184    	}
;;;185    	
;;;186    	if (new_limit < minimum)
000116  4295              CMP      r5,r2
000118  da02              BGE      |L1.288|
;;;187    	{
;;;188    		new_limit = minimum;
00011a  4615              MOV      r5,r2
;;;189    		err_code = SLIM_MIN;
00011c  2011              MOVS     r0,#0x11
00011e  e003              B        |L1.296|
                  |L1.288|
;;;190    	}
;;;191    	else if (new_limit > maximum)
000120  429d              CMP      r5,r3
000122  dd01              BLE      |L1.296|
;;;192    	{
;;;193    		new_limit = maximum;
000124  461d              MOV      r5,r3
;;;194    		err_code = SLIM_MAX;
000126  2012              MOVS     r0,#0x12
                  |L1.296|
;;;195    	}
;;;196    	*lim_p = (uint16_t)new_limit;
000128  8025              STRH     r5,[r4,#0]
;;;197    	
;;;198    	return err_code;
;;;199    }
00012a  bdf0              POP      {r4-r7,pc}
;;;200    
                          ENDP

                  apply_regulation PROC
;;;201    
;;;202    static void apply_regulation(void)
00012c  b510              PUSH     {r4,lr}
;;;203    {
;;;204    	uint16_t temp;
;;;205    	
;;;206    	// Apply voltage - same for both 5V and 12V channels
;;;207    	temp = regulation_setting_p -> set_voltage;
00012e  48ae              LDR      r0,|L1.1000|
000130  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000132  8844              LDRH     r4,[r0,#2]
;;;208    	temp /= 5;
000134  2005              MOVS     r0,#5
000136  fb94f0f0          SDIV     r0,r4,r0
00013a  b284              UXTH     r4,r0
;;;209    	SetVoltagePWMPeriod(temp);		// FIXME - we are setting not period but duty
00013c  4620              MOV      r0,r4
00013e  f7fffffe          BL       SetVoltagePWMPeriod
;;;210    	
;;;211    	// Apply current different for 20A and 40A limits
;;;212    	temp = regulation_setting_p -> set_current;
000142  48a9              LDR      r0,|L1.1000|
000144  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000146  8a40              LDRH     r0,[r0,#0x12]
000148  4604              MOV      r4,r0
;;;213    	temp = (regulation_setting_p -> current_limit == CURRENT_LIM_HIGH) ? temp / 2 : temp;
00014a  49a7              LDR      r1,|L1.1000|
00014c  6809              LDR      r1,[r1,#0]  ; regulation_setting_p
00014e  7c49              LDRB     r1,[r1,#0x11]
000150  2901              CMP      r1,#1
000152  d104              BNE      |L1.350|
000154  4620              MOV      r0,r4
000156  eb0071d0          ADD      r1,r0,r0,LSR #31
00015a  1049              ASRS     r1,r1,#1
00015c  e000              B        |L1.352|
                  |L1.350|
00015e  4621              MOV      r1,r4
                  |L1.352|
000160  b28c              UXTH     r4,r1
;;;214    	temp /= 5;
000162  2005              MOVS     r0,#5
000164  fb94f0f0          SDIV     r0,r4,r0
000168  b284              UXTH     r4,r0
;;;215    	SetCurrentPWMPeriod(temp);		// FIXME - we are setting not period but duty
00016a  4620              MOV      r0,r4
00016c  f7fffffe          BL       SetCurrentPWMPeriod
;;;216    }
000170  bd10              POP      {r4,pc}
;;;217    
                          ENDP

                  Converter_Init PROC
;;;224    
;;;225    void Converter_Init(uint8_t default_channel)
000172  b510              PUSH     {r4,lr}
;;;226    {
000174  4604              MOV      r4,r0
;;;227    	// Converter is powered off.
;;;228    	// TODO: add restore from EEPROM
;;;229    	
;;;230    	// Common
;;;231    	channel_5v_setting.CHANNEL = CHANNEL_5V;
000176  2001              MOVS     r0,#1
000178  499c              LDR      r1,|L1.1004|
00017a  7008              STRB     r0,[r1,#0]
;;;232    	channel_5v_setting.load_state = LOAD_ENABLE;							// dummy - load at 5V channel can not be disabled
00017c  2000              MOVS     r0,#0
00017e  7048              STRB     r0,[r1,#1]
;;;233    	// Voltage
;;;234    	channel_5v_setting.set_voltage = 5000;
000180  f2413088          MOV      r0,#0x1388
000184  8048              STRH     r0,[r1,#2]
;;;235    	channel_5v_setting.MAX_VOLTAGE = CONV_MAX_VOLTAGE_5V_CHANNEL;			// Maximum voltage setting for channel
000186  0040              LSLS     r0,r0,#1
000188  8088              STRH     r0,[r1,#4]
;;;236    	channel_5v_setting.MIN_VOLTAGE = CONV_MIN_VOLTAGE_5V_CHANNEL;			// Minimum voltage setting for channel
00018a  2000              MOVS     r0,#0
00018c  80c8              STRH     r0,[r1,#6]
;;;237    	channel_5v_setting.soft_max_voltage = 8000;
00018e  f44f50fa          MOV      r0,#0x1f40
000192  8108              STRH     r0,[r1,#8]
;;;238    	channel_5v_setting.soft_min_voltage = 3000;
000194  f64030b8          MOV      r0,#0xbb8
000198  8148              STRH     r0,[r1,#0xa]
;;;239    	channel_5v_setting.SOFT_MAX_VOLTAGE_LIMIT = 10000;						// Maximum soft voltage limit
00019a  f2427010          MOV      r0,#0x2710
00019e  8188              STRH     r0,[r1,#0xc]
;;;240    	channel_5v_setting.SOFT_MIN_VOLTAGE_LIMIT = 0;							// Minimum soft voltage limit
0001a0  2000              MOVS     r0,#0
0001a2  81c8              STRH     r0,[r1,#0xe]
;;;241    	channel_5v_setting.soft_voltage_range_enable = 0;
0001a4  7408              STRB     r0,[r1,#0x10]
;;;242    	// Current
;;;243    	channel_5v_setting.current_limit = CURRENT_LIM_LOW;
0001a6  7448              STRB     r0,[r1,#0x11]
;;;244    	channel_5v_setting.set_current = 4000;
0001a8  f44f607a          MOV      r0,#0xfa0
0001ac  8248              STRH     r0,[r1,#0x12]
;;;245    	channel_5v_setting.LOW_LIM_MAX_CURRENT = CONV_LOW_LIM_MAX_CURRENT;		// Low limit (20A) maximum current setting
0001ae  f6446020          MOV      r0,#0x4e20
0001b2  8288              STRH     r0,[r1,#0x14]
;;;246    	channel_5v_setting.LOW_LIM_MIN_CURRENT = CONV_MIN_CURRENT;				// Low limit (20A) min current setting
0001b4  2000              MOVS     r0,#0
0001b6  82c8              STRH     r0,[r1,#0x16]
;;;247    	channel_5v_setting.HIGH_LIM_MAX_CURRENT = CONV_HIGH_LIM_MAX_CURRENT;	// High limit (40A) maximum current setting
0001b8  f6494040          MOV      r0,#0x9c40
0001bc  8308              STRH     r0,[r1,#0x18]
;;;248    	channel_5v_setting.HIGH_LIM_MIN_CURRENT = CONV_MIN_CURRENT;				// High limit (40A) min current setting
0001be  2000              MOVS     r0,#0
0001c0  8348              STRH     r0,[r1,#0x1a]
;;;249    	channel_5v_setting.soft_max_current = 37000;
0001c2  f2490088          MOV      r0,#0x9088
0001c6  8388              STRH     r0,[r1,#0x1c]
;;;250    	channel_5v_setting.soft_min_current = 30000;
0001c8  f2475030          MOV      r0,#0x7530
0001cc  83c8              STRH     r0,[r1,#0x1e]
;;;251    	channel_5v_setting.SOFT_MAX_CURRENT_LIMIT = 40000;						// Maximum soft current limit
0001ce  f6494040          MOV      r0,#0x9c40
0001d2  8408              STRH     r0,[r1,#0x20]
;;;252    	channel_5v_setting.SOFT_MIN_CURRENT_LIMIT = 0;							// Minimum soft current limit
0001d4  2000              MOVS     r0,#0
0001d6  8448              STRH     r0,[r1,#0x22]
;;;253    	channel_5v_setting.soft_current_range_enable = 0;
0001d8  f8810024          STRB     r0,[r1,#0x24]
;;;254    	
;;;255    	
;;;256    	
;;;257    	// Common
;;;258    	channel_12v_setting.CHANNEL = CHANNEL_12V;
0001dc  4984              LDR      r1,|L1.1008|
0001de  7008              STRB     r0,[r1,#0]
;;;259    	channel_12v_setting.load_state = LOAD_ENABLE;
0001e0  7048              STRB     r0,[r1,#1]
;;;260    	// Voltage
;;;261    	channel_12v_setting.set_voltage = 12000;
0001e2  f64260e0          MOV      r0,#0x2ee0
0001e6  8048              STRH     r0,[r1,#2]
;;;262    	channel_12v_setting.MAX_VOLTAGE = CONV_MAX_VOLTAGE_12V_CHANNEL;			// Maximum voltage setting for channel
0001e8  f6446020          MOV      r0,#0x4e20
0001ec  8088              STRH     r0,[r1,#4]
;;;263    	channel_12v_setting.MIN_VOLTAGE = CONV_MIN_VOLTAGE_12V_CHANNEL;			// Minimum voltage setting for channel
0001ee  2000              MOVS     r0,#0
0001f0  80c8              STRH     r0,[r1,#6]
;;;264    	channel_12v_setting.soft_max_voltage = 16000;
0001f2  f44f507a          MOV      r0,#0x3e80
0001f6  8108              STRH     r0,[r1,#8]
;;;265    	channel_12v_setting.soft_min_voltage = 1500;
0001f8  f24050dc          MOV      r0,#0x5dc
0001fc  8148              STRH     r0,[r1,#0xa]
;;;266    	channel_12v_setting.SOFT_MAX_VOLTAGE_LIMIT = 20000;						// Maximum soft voltage limit
0001fe  f6446020          MOV      r0,#0x4e20
000202  8188              STRH     r0,[r1,#0xc]
;;;267    	channel_12v_setting.SOFT_MIN_VOLTAGE_LIMIT = 0;							// Minimum soft voltage limit
000204  2000              MOVS     r0,#0
000206  81c8              STRH     r0,[r1,#0xe]
;;;268    	channel_12v_setting.soft_voltage_range_enable = 0;
000208  7408              STRB     r0,[r1,#0x10]
;;;269    	// Current
;;;270    	channel_12v_setting.current_limit = CURRENT_LIM_LOW;
00020a  7448              STRB     r0,[r1,#0x11]
;;;271    	channel_12v_setting.set_current = 2000;
00020c  f44f60fa          MOV      r0,#0x7d0
000210  8248              STRH     r0,[r1,#0x12]
;;;272    	channel_12v_setting.LOW_LIM_MAX_CURRENT = CONV_LOW_LIM_MAX_CURRENT;		// Low limit (20A) maximum current setting
000212  f6446020          MOV      r0,#0x4e20
000216  8288              STRH     r0,[r1,#0x14]
;;;273    	channel_12v_setting.LOW_LIM_MIN_CURRENT = CONV_MIN_CURRENT;				// Low limit (20A) min current setting
000218  2000              MOVS     r0,#0
00021a  82c8              STRH     r0,[r1,#0x16]
;;;274    	channel_12v_setting.HIGH_LIM_MAX_CURRENT = CONV_LOW_LIM_MAX_CURRENT;	// High limit (40A) maximum current setting
00021c  f6446020          MOV      r0,#0x4e20
000220  8308              STRH     r0,[r1,#0x18]
;;;275    	channel_12v_setting.HIGH_LIM_MIN_CURRENT = CONV_MIN_CURRENT;			// High limit (40A) min current setting
000222  2000              MOVS     r0,#0
000224  8348              STRH     r0,[r1,#0x1a]
;;;276    	channel_12v_setting.soft_max_current = 18000;
000226  f2446050          MOV      r0,#0x4650
00022a  8388              STRH     r0,[r1,#0x1c]
;;;277    	channel_12v_setting.soft_min_current = 6000;
00022c  f2417070          MOV      r0,#0x1770
000230  83c8              STRH     r0,[r1,#0x1e]
;;;278    	channel_12v_setting.SOFT_MAX_CURRENT_LIMIT = 20000;						// Maximum soft current limit
000232  f6446020          MOV      r0,#0x4e20
000236  8408              STRH     r0,[r1,#0x20]
;;;279    	channel_12v_setting.SOFT_MIN_CURRENT_LIMIT = 0;							// Minimum soft current limit
000238  2000              MOVS     r0,#0
00023a  8448              STRH     r0,[r1,#0x22]
;;;280    	channel_12v_setting.soft_current_range_enable = 0;
00023c  f8810024          STRB     r0,[r1,#0x24]
;;;281    	
;;;282    	// 
;;;283    	if (default_channel == CHANNEL_12V)
000240  b91c              CBNZ     r4,|L1.586|
;;;284    		regulation_setting_p = &channel_12v_setting;
000242  4608              MOV      r0,r1
000244  4968              LDR      r1,|L1.1000|
000246  6008              STR      r0,[r1,#0]  ; regulation_setting_p
000248  e002              B        |L1.592|
                  |L1.586|
;;;285    	else
;;;286    		regulation_setting_p = &channel_5v_setting;
00024a  4868              LDR      r0,|L1.1004|
00024c  4966              LDR      r1,|L1.1000|
00024e  6008              STR      r0,[r1,#0]  ; regulation_setting_p
                  |L1.592|
;;;287    	
;;;288    	
;;;289    	// Apply controls
;;;290    	//__disable_irq();
;;;291    	SetFeedbackChannel(regulation_setting_p->CHANNEL);		// PORTF can be accessed from ISR
000250  4965              LDR      r1,|L1.1000|
000252  6809              LDR      r1,[r1,#0]  ; regulation_setting_p
000254  7808              LDRB     r0,[r1,#0]
000256  f7fffffe          BL       SetFeedbackChannel
;;;292    	//__enable_irq();
;;;293    	SetCurrentLimit(regulation_setting_p->current_limit);
00025a  4963              LDR      r1,|L1.1000|
00025c  6809              LDR      r1,[r1,#0]  ; regulation_setting_p
00025e  7c48              LDRB     r0,[r1,#0x11]
000260  f7fffffe          BL       SetCurrentLimit
;;;294    	SetOutputLoad(channel_12v_setting.load_state);
000264  4962              LDR      r1,|L1.1008|
000266  7848              LDRB     r0,[r1,#1]  ; channel_12v_setting
000268  f7fffffe          BL       SetOutputLoad
;;;295    }
00026c  bd10              POP      {r4,pc}
;;;296    
                          ENDP

                  analyzeAndResetHWErrorState PROC
;;;300    
;;;301    static uint32_t analyzeAndResetHWErrorState(void)
00026e  4961              LDR      r1,|L1.1012|
;;;302    {
;;;303    	uint32_t state_flags;
;;;304    	if (state_HWProcess & STATE_HW_OVERLOADED)		
000270  7809              LDRB     r1,[r1,#0]  ; state_HWProcess
000272  f0110f04          TST      r1,#4
000276  d009              BEQ      |L1.652|
;;;305    	{
;;;306    		ctrl_HWProcess = CMD_HW_RESET_OVERLOAD;		
000278  2104              MOVS     r1,#4
00027a  4a5f              LDR      r2,|L1.1016|
00027c  7011              STRB     r1,[r2,#0]
;;;307    		while(ctrl_HWProcess);
00027e  bf00              NOP      
                  |L1.640|
000280  495d              LDR      r1,|L1.1016|
000282  7809              LDRB     r1,[r1,#0]  ; ctrl_HWProcess
000284  2900              CMP      r1,#0
000286  d1fb              BNE      |L1.640|
;;;308    		state_flags = CONV_OVERLOAD;	
000288  2010              MOVS     r0,#0x10
00028a  e000              B        |L1.654|
                  |L1.652|
;;;309    	}
;;;310    	// Add more if necessary
;;;311    	else
;;;312    	{
;;;313    		state_flags = 0;
00028c  2000              MOVS     r0,#0
                  |L1.654|
;;;314    	}
;;;315    	return state_flags;
;;;316    }
00028e  4770              BX       lr
;;;317    
                          ENDP

                  disableConverterAndCheckHWState PROC
;;;318    static uint32_t disableConverterAndCheckHWState(void)
000290  b510              PUSH     {r4,lr}
;;;319    {
;;;320    	uint32_t new_state;
;;;321    	
;;;322    #if CMD_HAS_PRIORITY == 1
;;;323    	// If error status is generated simultaneously with OFF command,
;;;324    	// converter will be turned off and no error status will be shown
;;;325    	ctrl_HWProcess = CMD_HW_OFF | CMD_HW_RESET_OVERLOAD;	// Turn off converter and suppress error status (if any)
;;;326    	while(ctrl_HWProcess);
;;;327    	new_state = CONV_OFF;		
;;;328    	
;;;329    #elif ERROR_HAS_PRIORITY == 1
;;;330    	// If error status is generated simultaneously with OFF command,
;;;331    	// converter will be turned off, but error status will be indicated
;;;332    	ctrl_HWProcess = CMD_HW_OFF;					// Turn converter off
000292  2002              MOVS     r0,#2
000294  4958              LDR      r1,|L1.1016|
000296  7008              STRB     r0,[r1,#0]
;;;333    	while(ctrl_HWProcess);
000298  bf00              NOP      
                  |L1.666|
00029a  4857              LDR      r0,|L1.1016|
00029c  7800              LDRB     r0,[r0,#0]  ; ctrl_HWProcess
00029e  2800              CMP      r0,#0
0002a0  d1fb              BNE      |L1.666|
;;;334    	new_state = CONV_OFF;	
0002a2  2401              MOVS     r4,#1
;;;335    	new_state |= analyzeAndResetHWErrorState();	
0002a4  f7fffffe          BL       analyzeAndResetHWErrorState
0002a8  4304              ORRS     r4,r4,r0
;;;336    						
;;;337    #endif
;;;338    	return new_state;
0002aa  4620              MOV      r0,r4
;;;339    }
0002ac  bd10              POP      {r4,pc}
;;;340    
                          ENDP

                  vTaskConverter PROC
;;;346    //---------------------------------------------//
;;;347    void vTaskConverter(void *pvParameters) 
0002ae  b086              SUB      sp,sp,#0x18
;;;348    {
;;;349    	conveter_message_t msg;
;;;350    	
;;;351    	uint8_t err_code;
;;;352    	uint32_t adc_msg;
;;;353    	
;;;354    	// Initialize
;;;355    	xQueueConverter = xQueueCreate( 5, sizeof( conveter_message_t ) );		// Queue can contain 5 elements of type conveter_message_t
0002b0  2200              MOVS     r2,#0
0002b2  210c              MOVS     r1,#0xc
0002b4  2005              MOVS     r0,#5
0002b6  f7fffffe          BL       xQueueGenericCreate
0002ba  4950              LDR      r1,|L1.1020|
0002bc  6008              STR      r0,[r1,#0]  ; xQueueConverter
;;;356    	if( xQueueConverter == 0 )
0002be  4608              MOV      r0,r1
0002c0  6800              LDR      r0,[r0,#0]  ; xQueueConverter
0002c2  b908              CBNZ     r0,|L1.712|
;;;357    	{
;;;358    		// Queue was not created and must not be used.
;;;359    		while(1);
0002c4  bf00              NOP      
                  |L1.710|
0002c6  e7fe              B        |L1.710|
                  |L1.712|
;;;360    	}
;;;361    	
;;;362    	
;;;363    	
;;;364    	while(1)
0002c8  e114              B        |L1.1268|
                  |L1.714|
;;;365    	{
;;;366    		xQueueReceive(xQueueConverter, &msg, portMAX_DELAY);
0002ca  2300              MOVS     r3,#0
0002cc  1e5a              SUBS     r2,r3,#1
0002ce  a903              ADD      r1,sp,#0xc
0002d0  484a              LDR      r0,|L1.1020|
0002d2  6800              LDR      r0,[r0,#0]  ; xQueueConverter
0002d4  f7fffffe          BL       xQueueGenericReceive
;;;367    		
;;;368    
;;;369    		switch (msg.type)
0002d8  9803              LDR      r0,[sp,#0xc]
0002da  2807              CMP      r0,#7
0002dc  d002              BEQ      |L1.740|
0002de  2808              CMP      r0,#8
0002e0  d110              BNE      |L1.772|
0002e2  e007              B        |L1.756|
                  |L1.740|
;;;370    		{
;;;371    			case CONVERTER_SET_VOLTAGE:
;;;372    				regulation_setting_p->set_voltage = CheckSetVoltageRange(msg.data_a, &err_code);
0002e4  a902              ADD      r1,sp,#8
0002e6  9804              LDR      r0,[sp,#0x10]
0002e8  f7fffffe          BL       CheckSetVoltageRange
0002ec  493e              LDR      r1,|L1.1000|
0002ee  6809              LDR      r1,[r1,#0]  ; regulation_setting_p
0002f0  8048              STRH     r0,[r1,#2]
;;;373    				break;
0002f2  e007              B        |L1.772|
                  |L1.756|
;;;374    			case CONVERTER_SET_CURRENT:
;;;375    				regulation_setting_p->set_current = CheckSetCurrentRange(msg.data_a, &err_code);
0002f4  a902              ADD      r1,sp,#8
0002f6  9804              LDR      r0,[sp,#0x10]
0002f8  f7fffffe          BL       CheckSetCurrentRange
0002fc  493a              LDR      r1,|L1.1000|
0002fe  6809              LDR      r1,[r1,#0]  ; regulation_setting_p
000300  8248              STRH     r0,[r1,#0x12]
;;;376    				break;
000302  bf00              NOP      
                  |L1.772|
000304  bf00              NOP                            ;373
;;;377    		}
;;;378    		
;;;379    
;;;380    		
;;;381    		switch(conv_state & CONV_STATE_MASK)
000306  483e              LDR      r0,|L1.1024|
000308  6800              LDR      r0,[r0,#0]  ; conv_state
00030a  f000000f          AND      r0,r0,#0xf
00030e  2801              CMP      r0,#1
000310  d002              BEQ      |L1.792|
000312  2802              CMP      r0,#2
000314  d10e              BNE      |L1.820|
000316  e05f              B        |L1.984|
                  |L1.792|
;;;382    		{
;;;383    			case CONV_OFF:
;;;384    				if (msg.type == CONVERTER_SWITCH_TO_5VCH)
000318  9803              LDR      r0,[sp,#0xc]
00031a  2803              CMP      r0,#3
00031c  d10b              BNE      |L1.822|
;;;385    				{
;;;386    					regulation_setting_p = &channel_5v_setting;
00031e  4833              LDR      r0,|L1.1004|
000320  4931              LDR      r1,|L1.1000|
000322  6008              STR      r0,[r1,#0]  ; regulation_setting_p
;;;387    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
000324  2008              MOVS     r0,#8
000326  4934              LDR      r1,|L1.1016|
000328  7008              STRB     r0,[r1,#0]
;;;388    					while(ctrl_HWProcess);
00032a  bf00              NOP      
                  |L1.812|
00032c  4832              LDR      r0,|L1.1016|
00032e  7800              LDRB     r0,[r0,#0]  ; ctrl_HWProcess
000330  2800              CMP      r0,#0
000332  d1fb              BNE      |L1.812|
                  |L1.820|
;;;389    					break;
000334  e0ad              B        |L1.1170|
                  |L1.822|
;;;390    				}
;;;391    				if (msg.type == CONVERTER_SWITCH_TO_12VCH)
000336  9803              LDR      r0,[sp,#0xc]
000338  2804              CMP      r0,#4
00033a  d10b              BNE      |L1.852|
;;;392    				{
;;;393    					regulation_setting_p = &channel_12v_setting;
00033c  482c              LDR      r0,|L1.1008|
00033e  492a              LDR      r1,|L1.1000|
000340  6008              STR      r0,[r1,#0]  ; regulation_setting_p
;;;394    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
000342  2008              MOVS     r0,#8
000344  492c              LDR      r1,|L1.1016|
000346  7008              STRB     r0,[r1,#0]
;;;395    					while(ctrl_HWProcess);
000348  bf00              NOP      
                  |L1.842|
00034a  482b              LDR      r0,|L1.1016|
00034c  7800              LDRB     r0,[r0,#0]  ; ctrl_HWProcess
00034e  2800              CMP      r0,#0
000350  d1fb              BNE      |L1.842|
;;;396    					break;
000352  e09e              B        |L1.1170|
                  |L1.852|
;;;397    				}
;;;398    				if (msg.type == SET_CURRENT_LIMIT_20A)
000354  9803              LDR      r0,[sp,#0xc]
000356  2805              CMP      r0,#5
000358  d10c              BNE      |L1.884|
;;;399    				{
;;;400    					regulation_setting_p -> current_limit = CURRENT_LIM_LOW;
00035a  2000              MOVS     r0,#0
00035c  4922              LDR      r1,|L1.1000|
00035e  6809              LDR      r1,[r1,#0]  ; regulation_setting_p
000360  7448              STRB     r0,[r1,#0x11]
;;;401    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
000362  2008              MOVS     r0,#8
000364  4924              LDR      r1,|L1.1016|
000366  7008              STRB     r0,[r1,#0]
;;;402    					while(ctrl_HWProcess);
000368  bf00              NOP      
                  |L1.874|
00036a  4823              LDR      r0,|L1.1016|
00036c  7800              LDRB     r0,[r0,#0]  ; ctrl_HWProcess
00036e  2800              CMP      r0,#0
000370  d1fb              BNE      |L1.874|
;;;403    					break;
000372  e08e              B        |L1.1170|
                  |L1.884|
;;;404    				}
;;;405    				if (msg.type == SET_CURRENT_LIMIT_40A)
000374  9803              LDR      r0,[sp,#0xc]
000376  2806              CMP      r0,#6
000378  d10c              BNE      |L1.916|
;;;406    				{
;;;407    					regulation_setting_p -> current_limit = CURRENT_LIM_HIGH;
00037a  2001              MOVS     r0,#1
00037c  491a              LDR      r1,|L1.1000|
00037e  6809              LDR      r1,[r1,#0]  ; regulation_setting_p
000380  7448              STRB     r0,[r1,#0x11]
;;;408    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
000382  2008              MOVS     r0,#8
000384  491c              LDR      r1,|L1.1016|
000386  7008              STRB     r0,[r1,#0]
;;;409    					while(ctrl_HWProcess);
000388  bf00              NOP      
                  |L1.906|
00038a  481b              LDR      r0,|L1.1016|
00038c  7800              LDRB     r0,[r0,#0]  ; ctrl_HWProcess
00038e  2800              CMP      r0,#0
000390  d1fb              BNE      |L1.906|
;;;410    					break;
000392  e07e              B        |L1.1170|
                  |L1.916|
;;;411    				}
;;;412    				if (msg.type == CONVERTER_TURN_OFF)
000394  9803              LDR      r0,[sp,#0xc]
000396  2802              CMP      r0,#2
000398  d103              BNE      |L1.930|
;;;413    				{
;;;414    					conv_state = CONV_OFF;			// Reset overload flag
00039a  2001              MOVS     r0,#1
00039c  4918              LDR      r1,|L1.1024|
00039e  6008              STR      r0,[r1,#0]  ; conv_state
;;;415    					break;
0003a0  e077              B        |L1.1170|
                  |L1.930|
;;;416    				}
;;;417    				if (msg.type == CONVERTER_TURN_ON)
0003a2  9803              LDR      r0,[sp,#0xc]
0003a4  2801              CMP      r0,#1
0003a6  d116              BNE      |L1.982|
;;;418    				{
;;;419    					// Message to turn on converter is received
;;;420    					if ((state_HWProcess & STATE_HW_TIMER_NOT_EXPIRED) || (!(state_HWProcess & STATE_HW_USER_TIMER_EXPIRED)))
0003a8  4812              LDR      r0,|L1.1012|
0003aa  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
0003ac  f0100f10          TST      r0,#0x10
0003b0  d104              BNE      |L1.956|
0003b2  4810              LDR      r0,|L1.1012|
0003b4  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
0003b6  f0100f20          TST      r0,#0x20
0003ba  d100              BNE      |L1.958|
                  |L1.956|
;;;421    					{
;;;422    						// Safe timeout is not expired
;;;423    						break;
0003bc  e069              B        |L1.1170|
                  |L1.958|
;;;424    					}
;;;425    					ctrl_HWProcess = CMD_HW_ON;
0003be  2001              MOVS     r0,#1
0003c0  490d              LDR      r1,|L1.1016|
0003c2  7008              STRB     r0,[r1,#0]
;;;426    					while(ctrl_HWProcess);
0003c4  bf00              NOP      
                  |L1.966|
0003c6  480c              LDR      r0,|L1.1016|
0003c8  7800              LDRB     r0,[r0,#0]  ; ctrl_HWProcess
0003ca  2800              CMP      r0,#0
0003cc  d1fb              BNE      |L1.966|
;;;427    					conv_state = CONV_ON;			// Switch to new state and reset overload flag
0003ce  2002              MOVS     r0,#2
0003d0  490b              LDR      r1,|L1.1024|
0003d2  6008              STR      r0,[r1,#0]  ; conv_state
;;;428    					break;
0003d4  e05d              B        |L1.1170|
                  |L1.982|
;;;429    				}
;;;430    				break;
0003d6  e05c              B        |L1.1170|
                  |L1.984|
;;;431    			case CONV_ON:
;;;432    				if (msg.type == CONVERTER_TURN_OFF)
0003d8  9803              LDR      r0,[sp,#0xc]
0003da  2802              CMP      r0,#2
0003dc  d112              BNE      |L1.1028|
;;;433    				{
;;;434    					conv_state = disableConverterAndCheckHWState();
0003de  f7fffffe          BL       disableConverterAndCheckHWState
0003e2  4907              LDR      r1,|L1.1024|
0003e4  6008              STR      r0,[r1,#0]  ; conv_state
;;;435    					break;
0003e6  e054              B        |L1.1170|
                  |L1.1000|
                          DCD      regulation_setting_p
                  |L1.1004|
                          DCD      channel_5v_setting
                  |L1.1008|
                          DCD      channel_12v_setting
                  |L1.1012|
                          DCD      state_HWProcess
                  |L1.1016|
                          DCD      ctrl_HWProcess
                  |L1.1020|
                          DCD      xQueueConverter
                  |L1.1024|
                          DCD      conv_state
                  |L1.1028|
;;;436    				}
;;;437    				if ( (msg.type == CONVERTER_SWITCH_TO_5VCH) && (regulation_setting_p != &channel_5v_setting) )
000404  9803              LDR      r0,[sp,#0xc]
000406  2803              CMP      r0,#3
000408  d117              BNE      |L1.1082|
00040a  48c4              LDR      r0,|L1.1820|
00040c  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
00040e  49c4              LDR      r1,|L1.1824|
000410  4288              CMP      r0,r1
000412  d012              BEQ      |L1.1082|
;;;438    				{
;;;439    					conv_state = disableConverterAndCheckHWState();
000414  f7fffffe          BL       disableConverterAndCheckHWState
000418  49c2              LDR      r1,|L1.1828|
00041a  6008              STR      r0,[r1,#0]  ; conv_state
;;;440    					vTaskDelay(4);
00041c  2004              MOVS     r0,#4
00041e  f7fffffe          BL       vTaskDelay
;;;441    					regulation_setting_p = &channel_5v_setting;
000422  48bf              LDR      r0,|L1.1824|
000424  49bd              LDR      r1,|L1.1820|
000426  6008              STR      r0,[r1,#0]  ; regulation_setting_p
;;;442    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
000428  2008              MOVS     r0,#8
00042a  49bf              LDR      r1,|L1.1832|
00042c  7008              STRB     r0,[r1,#0]
;;;443    					while(ctrl_HWProcess);
00042e  bf00              NOP      
                  |L1.1072|
000430  48bd              LDR      r0,|L1.1832|
000432  7800              LDRB     r0,[r0,#0]  ; ctrl_HWProcess
000434  2800              CMP      r0,#0
000436  d1fb              BNE      |L1.1072|
;;;444    					break;
000438  e02b              B        |L1.1170|
                  |L1.1082|
;;;445    				}
;;;446    				if ( (msg.type == CONVERTER_SWITCH_TO_12VCH) && (regulation_setting_p != &channel_12v_setting) )
00043a  9803              LDR      r0,[sp,#0xc]
00043c  2804              CMP      r0,#4
00043e  d117              BNE      |L1.1136|
000440  48b6              LDR      r0,|L1.1820|
000442  6800              LDR      r0,[r0,#0]  ; regulation_setting_p
000444  49b9              LDR      r1,|L1.1836|
000446  4288              CMP      r0,r1
000448  d012              BEQ      |L1.1136|
;;;447    				{
;;;448    					conv_state = disableConverterAndCheckHWState();
00044a  f7fffffe          BL       disableConverterAndCheckHWState
00044e  49b5              LDR      r1,|L1.1828|
000450  6008              STR      r0,[r1,#0]  ; conv_state
;;;449    					vTaskDelay(4);
000452  2004              MOVS     r0,#4
000454  f7fffffe          BL       vTaskDelay
;;;450    					regulation_setting_p = &channel_5v_setting;
000458  48b1              LDR      r0,|L1.1824|
00045a  49b0              LDR      r1,|L1.1820|
00045c  6008              STR      r0,[r1,#0]  ; regulation_setting_p
;;;451    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
00045e  2008              MOVS     r0,#8
000460  49b1              LDR      r1,|L1.1832|
000462  7008              STRB     r0,[r1,#0]
;;;452    					while(ctrl_HWProcess);
000464  bf00              NOP      
                  |L1.1126|
000466  48b0              LDR      r0,|L1.1832|
000468  7800              LDRB     r0,[r0,#0]  ; ctrl_HWProcess
00046a  2800              CMP      r0,#0
00046c  d1fb              BNE      |L1.1126|
;;;453    					break;
00046e  e010              B        |L1.1170|
                  |L1.1136|
;;;454    				}
;;;455    				if (state_HWProcess & STATE_HW_OFF)
000470  48af              LDR      r0,|L1.1840|
000472  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
000474  f0100f02          TST      r0,#2
000478  d00a              BEQ      |L1.1168|
;;;456    				{
;;;457    					// Some hardware error has happened and converter had been switched off
;;;458    					conv_state = CONV_OFF;
00047a  2001              MOVS     r0,#1
00047c  49a9              LDR      r1,|L1.1828|
00047e  6008              STR      r0,[r1,#0]  ; conv_state
;;;459    					conv_state |= analyzeAndResetHWErrorState();
000480  f7fffffe          BL       analyzeAndResetHWErrorState
000484  49a7              LDR      r1,|L1.1828|
000486  6809              LDR      r1,[r1,#0]  ; conv_state
000488  4308              ORRS     r0,r0,r1
00048a  49a6              LDR      r1,|L1.1828|
00048c  6008              STR      r0,[r1,#0]  ; conv_state
;;;460    					if (conv_state & CONV_OVERLOAD)
;;;461    					{
;;;462    						// Send message to sound driver - TODO
;;;463    					}
;;;464    					break;
00048e  e000              B        |L1.1170|
                  |L1.1168|
;;;465    				}
;;;466    				break;
000490  bf00              NOP      
                  |L1.1170|
000492  bf00              NOP                            ;389
;;;467    		}
;;;468    		
;;;469    		
;;;470    		// Will be special for charging mode - TODO
;;;471    		if (msg.type == CONVERTER_TICK)
000494  9803              LDR      r0,[sp,#0xc]
000496  28ff              CMP      r0,#0xff
000498  d108              BNE      |L1.1196|
;;;472    		{
;;;473    			// ADC task is responsible for sampling and filtering voltage and current
;;;474    			adc_msg = ADC_GET_ALL_NORMAL;
00049a  2001              MOVS     r0,#1
00049c  9001              STR      r0,[sp,#4]
;;;475    			xQueueSendToBack(xQueueADC, &adc_msg, 0);
00049e  2300              MOVS     r3,#0
0004a0  461a              MOV      r2,r3
0004a2  a901              ADD      r1,sp,#4
0004a4  48a3              LDR      r0,|L1.1844|
0004a6  6800              LDR      r0,[r0,#0]  ; xQueueADC
0004a8  f7fffffe          BL       xQueueGenericSend
                  |L1.1196|
;;;476    		}			
;;;477    		
;;;478    		// Apply controls
;;;479    		__disable_irq();
0004ac  b672              CPSID    i
;;;480    		SetFeedbackChannel(regulation_setting_p->CHANNEL);		// PORTF can be accessed from ISR
0004ae  499b              LDR      r1,|L1.1820|
0004b0  6809              LDR      r1,[r1,#0]  ; regulation_setting_p
0004b2  7808              LDRB     r0,[r1,#0]
0004b4  f7fffffe          BL       SetFeedbackChannel
;;;481    		__enable_irq();
0004b8  b662              CPSIE    i
;;;482    		SetCurrentLimit(regulation_setting_p->current_limit);
0004ba  4998              LDR      r1,|L1.1820|
0004bc  6809              LDR      r1,[r1,#0]  ; regulation_setting_p
0004be  7c48              LDRB     r0,[r1,#0x11]
0004c0  f7fffffe          BL       SetCurrentLimit
;;;483    		SetOutputLoad(channel_12v_setting.load_state);
0004c4  4999              LDR      r1,|L1.1836|
0004c6  7848              LDRB     r0,[r1,#1]  ; channel_12v_setting
0004c8  f7fffffe          BL       SetOutputLoad
;;;484    	
;;;485    		// Always make sure settings are within allowed range
;;;486    		regulation_setting_p->set_current = CheckSetCurrentRange((int32_t)regulation_setting_p->set_current, &err_code);
0004cc  4993              LDR      r1,|L1.1820|
0004ce  6809              LDR      r1,[r1,#0]  ; regulation_setting_p
0004d0  8a48              LDRH     r0,[r1,#0x12]
0004d2  a902              ADD      r1,sp,#8
0004d4  f7fffffe          BL       CheckSetCurrentRange
0004d8  4990              LDR      r1,|L1.1820|
0004da  6809              LDR      r1,[r1,#0]  ; regulation_setting_p
0004dc  8248              STRH     r0,[r1,#0x12]
;;;487    		regulation_setting_p->set_voltage = CheckSetVoltageRange((int32_t)regulation_setting_p->set_voltage, &err_code);
0004de  498f              LDR      r1,|L1.1820|
0004e0  6809              LDR      r1,[r1,#0]  ; regulation_setting_p
0004e2  8848              LDRH     r0,[r1,#2]
0004e4  a902              ADD      r1,sp,#8
0004e6  f7fffffe          BL       CheckSetVoltageRange
0004ea  498c              LDR      r1,|L1.1820|
0004ec  6809              LDR      r1,[r1,#0]  ; regulation_setting_p
0004ee  8048              STRH     r0,[r1,#2]
;;;488    
;;;489    		// Apply voltage and current settings
;;;490    		apply_regulation();		
0004f0  f7fffffe          BL       apply_regulation
                  |L1.1268|
0004f4  e6e9              B        |L1.714|
;;;491    		
;;;492    	
;;;493    		// LED indication
;;;494    
;;;495    	}
;;;496    	
;;;497    }
;;;498    
                          ENDP

                  Converter_HWProcess PROC
;;;518    //---------------------------------------------//
;;;519    void Converter_HWProcess(void) 
0004f6  b570              PUSH     {r4-r6,lr}
;;;520    {
;;;521    	static uint16_t overload_ignore_counter;
;;;522    	static uint16_t overload_counter;
;;;523    	static uint16_t safe_counter = 0;
;;;524    	static uint16_t user_counter = 0;
;;;525    	static uint16_t led_blink_counter = 0;
;;;526    	static uint16_t overload_warning_counter = 0;
;;;527    	uint8_t overload_check_enable;
;;;528    	uint8_t raw_overload_flag;
;;;529    	uint8_t led_state;
;;;530    
;;;531    	//-------------------------------//
;;;532    	// Get converter status and process overload timers
;;;533    	
;;;534    	// Due to hardware specialty overload input is active when converter is powered off
;;;535    	// Overload timeout counter reaches 0 when converter has been enabled for OVERLOAD_IGNORE_TIMEOUT ticks
;;;536    	overload_check_enable = 0;
0004f8  2600              MOVS     r6,#0
;;;537    	if (state_HWProcess & (STATE_HW_OFF | STATE_HW_OFF_BY_ADC))
0004fa  488d              LDR      r0,|L1.1840|
0004fc  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
0004fe  f0100f0a          TST      r0,#0xa
000502  d004              BEQ      |L1.1294|
;;;538    		overload_ignore_counter = OVERLOAD_IGNORE_TIMEOUT;
000504  f44f70fa          MOV      r0,#0x1f4
000508  498b              LDR      r1,|L1.1848|
00050a  8008              STRH     r0,[r1,#0]
00050c  e009              B        |L1.1314|
                  |L1.1294|
;;;539    	else if (overload_ignore_counter != 0)
00050e  488a              LDR      r0,|L1.1848|
000510  8800              LDRH     r0,[r0,#0]  ; overload_ignore_counter
000512  b128              CBZ      r0,|L1.1312|
;;;540    		overload_ignore_counter--;
000514  4888              LDR      r0,|L1.1848|
000516  8800              LDRH     r0,[r0,#0]  ; overload_ignore_counter
000518  1e40              SUBS     r0,r0,#1
00051a  4987              LDR      r1,|L1.1848|
00051c  8008              STRH     r0,[r1,#0]
00051e  e000              B        |L1.1314|
                  |L1.1312|
;;;541    	else
;;;542    		overload_check_enable = 1;
000520  2601              MOVS     r6,#1
                  |L1.1314|
;;;543    	
;;;544    	// Apply top-level overload check control
;;;545    	//if (__overload_functions_disabled__)
;;;546    	//	overload_check_enable = 0;
;;;547    	
;;;548    	if (overload_check_enable)
000522  b11e              CBZ      r6,|L1.1324|
;;;549    		raw_overload_flag = GetOverloadStatus();
000524  f7fffffe          BL       GetOverloadStatus
000528  4604              MOV      r4,r0
00052a  e000              B        |L1.1326|
                  |L1.1324|
;;;550    	else
;;;551    		raw_overload_flag = NORMAL;
00052c  2400              MOVS     r4,#0
                  |L1.1326|
;;;552    	
;;;553    	if (raw_overload_flag == NORMAL)
00052e  b91c              CBNZ     r4,|L1.1336|
;;;554    		overload_counter = OVERLOAD_TIMEOUT;
000530  2005              MOVS     r0,#5
000532  4982              LDR      r1,|L1.1852|
000534  8008              STRH     r0,[r1,#0]
000536  e007              B        |L1.1352|
                  |L1.1336|
;;;555    	else if (overload_counter != 0)
000538  4880              LDR      r0,|L1.1852|
00053a  8800              LDRH     r0,[r0,#0]  ; overload_counter
00053c  b120              CBZ      r0,|L1.1352|
;;;556    		overload_counter--;
00053e  487f              LDR      r0,|L1.1852|
000540  8800              LDRH     r0,[r0,#0]  ; overload_counter
000542  1e40              SUBS     r0,r0,#1
000544  497d              LDR      r1,|L1.1852|
000546  8008              STRH     r0,[r1,#0]
                  |L1.1352|
;;;557    	
;;;558    
;;;559    	//-------------------------------//
;;;560    	// Check overload 	
;;;561    	if (overload_counter == 0)
000548  487c              LDR      r0,|L1.1852|
00054a  8800              LDRH     r0,[r0,#0]  ; overload_counter
00054c  b9a0              CBNZ     r0,|L1.1400|
;;;562    	{
;;;563    		// Converter is overloaded
;;;564    		state_HWProcess &= ~STATE_HW_ON;
00054e  4878              LDR      r0,|L1.1840|
000550  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
000552  f0200001          BIC      r0,r0,#1
000556  4976              LDR      r1,|L1.1840|
000558  7008              STRB     r0,[r1,#0]
;;;565    		state_HWProcess |= STATE_HW_OFF | STATE_HW_OVERLOADED;	// Set status for itself and top-level software
00055a  4608              MOV      r0,r1
00055c  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
00055e  f0400006          ORR      r0,r0,#6
000562  7008              STRB     r0,[r1,#0]
;;;566    		safe_counter = MINIMAL_OFF_TIME;						// Start timer to provide minimal OFF timeout
000564  20c8              MOVS     r0,#0xc8
000566  4976              LDR      r1,|L1.1856|
000568  8008              STRH     r0,[r1,#0]
;;;567    		xQueueSendToFrontFromISR(xQueueConverter, &converter_update_message, 0);	// No need for exact timing
00056a  2301              MOVS     r3,#1
00056c  2200              MOVS     r2,#0
00056e  4975              LDR      r1,|L1.1860|
000570  4875              LDR      r0,|L1.1864|
000572  6800              LDR      r0,[r0,#0]  ; xQueueConverter
000574  f7fffffe          BL       xQueueGenericSendFromISR
                  |L1.1400|
;;;568    	}
;;;569    	
;;;570    	//-------------------------------//
;;;571    	// Process commands from top-level converter controller
;;;572    	if (ctrl_HWProcess & CMD_HW_RESET_OVERLOAD)
000578  486b              LDR      r0,|L1.1832|
00057a  7800              LDRB     r0,[r0,#0]  ; ctrl_HWProcess
00057c  f0100f04          TST      r0,#4
000580  d005              BEQ      |L1.1422|
;;;573    	{
;;;574    		state_HWProcess &= ~STATE_HW_OVERLOADED;
000582  486b              LDR      r0,|L1.1840|
000584  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
000586  f0200004          BIC      r0,r0,#4
00058a  4969              LDR      r1,|L1.1840|
00058c  7008              STRB     r0,[r1,#0]
                  |L1.1422|
;;;575    	}
;;;576    	if ( (ctrl_HWProcess & CMD_HW_OFF) && (!(state_HWProcess & STATE_HW_OFF)) )
00058e  4866              LDR      r0,|L1.1832|
000590  7800              LDRB     r0,[r0,#0]  ; ctrl_HWProcess
000592  f0100f02          TST      r0,#2
000596  d013              BEQ      |L1.1472|
000598  4865              LDR      r0,|L1.1840|
00059a  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
00059c  f0100f02          TST      r0,#2
0005a0  d10e              BNE      |L1.1472|
;;;577    	{
;;;578    		state_HWProcess &= ~STATE_HW_ON;
0005a2  4863              LDR      r0,|L1.1840|
0005a4  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
0005a6  f0200001          BIC      r0,r0,#1
0005aa  4961              LDR      r1,|L1.1840|
0005ac  7008              STRB     r0,[r1,#0]
;;;579    		state_HWProcess |= STATE_HW_OFF;		
0005ae  4608              MOV      r0,r1
0005b0  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
0005b2  f0400002          ORR      r0,r0,#2
0005b6  7008              STRB     r0,[r1,#0]
;;;580    		safe_counter = MINIMAL_OFF_TIME;						// Start timer to provide minimal OFF timeout
0005b8  20c8              MOVS     r0,#0xc8
0005ba  4961              LDR      r1,|L1.1856|
0005bc  8008              STRH     r0,[r1,#0]
0005be  e014              B        |L1.1514|
                  |L1.1472|
;;;581    	}
;;;582    	else if ( (ctrl_HWProcess & CMD_HW_ON) && (!(state_HWProcess & STATE_HW_ON)) )
0005c0  4859              LDR      r0,|L1.1832|
0005c2  7800              LDRB     r0,[r0,#0]  ; ctrl_HWProcess
0005c4  f0100f01          TST      r0,#1
0005c8  d00f              BEQ      |L1.1514|
0005ca  4859              LDR      r0,|L1.1840|
0005cc  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
0005ce  f0100f01          TST      r0,#1
0005d2  d10a              BNE      |L1.1514|
;;;583    	{
;;;584    		state_HWProcess &= ~STATE_HW_OFF;
0005d4  4856              LDR      r0,|L1.1840|
0005d6  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
0005d8  f0200002          BIC      r0,r0,#2
0005dc  4954              LDR      r1,|L1.1840|
0005de  7008              STRB     r0,[r1,#0]
;;;585    		state_HWProcess |= STATE_HW_ON;								
0005e0  4608              MOV      r0,r1
0005e2  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
0005e4  f0400001          ORR      r0,r0,#1
0005e8  7008              STRB     r0,[r1,#0]
                  |L1.1514|
;;;586    	}
;;;587    	if (ctrl_HWProcess & CMD_HW_RESTART_USER_TIMER)
0005ea  484f              LDR      r0,|L1.1832|
0005ec  7800              LDRB     r0,[r0,#0]  ; ctrl_HWProcess
0005ee  f0100f08          TST      r0,#8
0005f2  d002              BEQ      |L1.1530|
;;;588    	{
;;;589    		user_counter = USER_TIMEOUT;
0005f4  2064              MOVS     r0,#0x64
0005f6  4955              LDR      r1,|L1.1868|
0005f8  8008              STRH     r0,[r1,#0]
                  |L1.1530|
;;;590    	}
;;;591    	if (ctrl_HWProcess & CMD_HW_RESTART_LED_BLINK_TIMER)
0005fa  484b              LDR      r0,|L1.1832|
0005fc  7800              LDRB     r0,[r0,#0]  ; ctrl_HWProcess
0005fe  f0100f10          TST      r0,#0x10
000602  d003              BEQ      |L1.1548|
;;;592    	{
;;;593    		user_counter = LED_BLINK_TIMEOUT;
000604  f44f70fa          MOV      r0,#0x1f4
000608  4950              LDR      r1,|L1.1868|
00060a  8008              STRH     r0,[r1,#0]
                  |L1.1548|
;;;594    	}
;;;595    	
;;;596    	//-------------------------------//
;;;597    	// Process commands from top-level ADC controller
;;;598    	if (cmd_ADC_to_HWProcess & CMD_HW_OFF_BY_ADC)
00060c  4850              LDR      r0,|L1.1872|
00060e  7800              LDRB     r0,[r0,#0]  ; cmd_ADC_to_HWProcess
000610  f0100f01          TST      r0,#1
000614  d006              BEQ      |L1.1572|
;;;599    	{
;;;600    		state_HWProcess |= STATE_HW_OFF_BY_ADC;
000616  4846              LDR      r0,|L1.1840|
000618  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
00061a  f0400008          ORR      r0,r0,#8
00061e  4944              LDR      r1,|L1.1840|
000620  7008              STRB     r0,[r1,#0]
000622  e00a              B        |L1.1594|
                  |L1.1572|
;;;601    	}
;;;602    	else if (cmd_ADC_to_HWProcess & CMD_HW_ON_BY_ADC)
000624  484a              LDR      r0,|L1.1872|
000626  7800              LDRB     r0,[r0,#0]  ; cmd_ADC_to_HWProcess
000628  f0100f02          TST      r0,#2
00062c  d005              BEQ      |L1.1594|
;;;603    	{
;;;604    		state_HWProcess &= ~STATE_HW_OFF_BY_ADC;
00062e  4840              LDR      r0,|L1.1840|
000630  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
000632  f0200008          BIC      r0,r0,#8
000636  493e              LDR      r1,|L1.1840|
000638  7008              STRB     r0,[r1,#0]
                  |L1.1594|
;;;605    	}
;;;606    	
;;;607    	// Reset commands
;;;608    	ctrl_HWProcess = 0;
00063a  2000              MOVS     r0,#0
00063c  493a              LDR      r1,|L1.1832|
00063e  7008              STRB     r0,[r1,#0]
;;;609    	cmd_ADC_to_HWProcess = 0;
000640  4943              LDR      r1,|L1.1872|
000642  7008              STRB     r0,[r1,#0]
;;;610    
;;;611    	//-------------------------------//
;;;612    	// Apply converter state
;;;613    	// TODO - check IRQ disable while accessing converter control port (MDR_PORTF) for write
;;;614    	if (state_HWProcess & (STATE_HW_OFF | STATE_HW_OFF_BY_ADC))
000644  483a              LDR      r0,|L1.1840|
000646  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
000648  f0100f0a          TST      r0,#0xa
00064c  d003              BEQ      |L1.1622|
;;;615    		SetConverterState(CONVERTER_OFF);
00064e  2000              MOVS     r0,#0
000650  f7fffffe          BL       SetConverterState
000654  e007              B        |L1.1638|
                  |L1.1622|
;;;616    	else if (state_HWProcess & STATE_HW_ON)
000656  4836              LDR      r0,|L1.1840|
000658  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
00065a  f0100f01          TST      r0,#1
00065e  d002              BEQ      |L1.1638|
;;;617    		SetConverterState(CONVERTER_ON);
000660  2001              MOVS     r0,#1
000662  f7fffffe          BL       SetConverterState
                  |L1.1638|
;;;618    		
;;;619    	//-------------------------------//
;;;620    	// LED indication
;;;621    	// Uses raw converter state and top-level conveter status
;;;622    	// TODO - check IRQ disable while accessing LED port (MDR_PORTB) for write
;;;623    	led_state = 0;
000666  2500              MOVS     r5,#0
;;;624    	if ((state_HWProcess & STATE_HW_ON) && (led_blink_counter == 0))
000668  4831              LDR      r0,|L1.1840|
00066a  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
00066c  f0100f01          TST      r0,#1
000670  d004              BEQ      |L1.1660|
000672  4838              LDR      r0,|L1.1876|
000674  8800              LDRH     r0,[r0,#0]  ; led_blink_counter
000676  b908              CBNZ     r0,|L1.1660|
;;;625    		led_state |= LED_GREEN;
000678  f0450501          ORR      r5,r5,#1
                  |L1.1660|
;;;626    	if ((raw_overload_flag == OVERLOAD) || (conv_state & CONV_OVERLOAD))
00067c  2c01              CMP      r4,#1
00067e  d004              BEQ      |L1.1674|
000680  4828              LDR      r0,|L1.1828|
000682  6800              LDR      r0,[r0,#0]  ; conv_state
000684  f0100f10          TST      r0,#0x10
000688  d001              BEQ      |L1.1678|
                  |L1.1674|
;;;627    		led_state |= LED_RED;
00068a  f0450502          ORR      r5,r5,#2
                  |L1.1678|
;;;628    	UpdateLEDs(led_state);
00068e  4628              MOV      r0,r5
000690  f7fffffe          BL       UpdateLEDs
;;;629    	
;;;630    	//-------------------------------//
;;;631    	// Overload sound warning
;;;632    	if ((raw_overload_flag == OVERLOAD) && (overload_warning_counter == 0))
000694  2c01              CMP      r4,#1
000696  d106              BNE      |L1.1702|
000698  482f              LDR      r0,|L1.1880|
00069a  8800              LDRH     r0,[r0,#0]  ; overload_warning_counter
00069c  b918              CBNZ     r0,|L1.1702|
;;;633    	{
;;;634    		//xQueueSendToFrontFromISR(xQueueSound, &sound_instant_overload_msg, 0);	// No need for exact timing
;;;635    		overload_warning_counter = OVERLOAD_WARNING_TIMEOUT;
00069e  f44f707a          MOV      r0,#0x3e8
0006a2  492d              LDR      r1,|L1.1880|
0006a4  8008              STRH     r0,[r1,#0]
                  |L1.1702|
;;;636    	}
;;;637    	
;;;638    	//-------------------------------//
;;;639    	// Process timers
;;;640    	
;;;641    	// Process safe timer - used by top-level controller to provide a safe minimal OFF timeout
;;;642    	if (safe_counter != 0)
0006a6  4826              LDR      r0,|L1.1856|
0006a8  8800              LDRH     r0,[r0,#0]  ; safe_counter
0006aa  b158              CBZ      r0,|L1.1732|
;;;643    	{
;;;644    		safe_counter--;
0006ac  4824              LDR      r0,|L1.1856|
0006ae  8800              LDRH     r0,[r0,#0]  ; safe_counter
0006b0  1e40              SUBS     r0,r0,#1
0006b2  4923              LDR      r1,|L1.1856|
0006b4  8008              STRH     r0,[r1,#0]
;;;645    		state_HWProcess |= STATE_HW_TIMER_NOT_EXPIRED;
0006b6  481e              LDR      r0,|L1.1840|
0006b8  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
0006ba  f0400010          ORR      r0,r0,#0x10
0006be  491c              LDR      r1,|L1.1840|
0006c0  7008              STRB     r0,[r1,#0]
0006c2  e005              B        |L1.1744|
                  |L1.1732|
;;;646    	}
;;;647    	else
;;;648    	{
;;;649    		state_HWProcess &= ~STATE_HW_TIMER_NOT_EXPIRED;
0006c4  481a              LDR      r0,|L1.1840|
0006c6  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
0006c8  f0200010          BIC      r0,r0,#0x10
0006cc  4918              LDR      r1,|L1.1840|
0006ce  7008              STRB     r0,[r1,#0]
                  |L1.1744|
;;;650    	}
;;;651    	
;;;652    	// Process user timer - used by top-level controller to provide a safe interval after switching channels
;;;653    	if (user_counter != 0)
0006d0  481e              LDR      r0,|L1.1868|
0006d2  8800              LDRH     r0,[r0,#0]  ; user_counter
0006d4  b158              CBZ      r0,|L1.1774|
;;;654    	{
;;;655    		user_counter--;
0006d6  481d              LDR      r0,|L1.1868|
0006d8  8800              LDRH     r0,[r0,#0]  ; user_counter
0006da  1e40              SUBS     r0,r0,#1
0006dc  491b              LDR      r1,|L1.1868|
0006de  8008              STRH     r0,[r1,#0]
;;;656    		state_HWProcess &= ~STATE_HW_USER_TIMER_EXPIRED;
0006e0  4813              LDR      r0,|L1.1840|
0006e2  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
0006e4  f0200020          BIC      r0,r0,#0x20
0006e8  4911              LDR      r1,|L1.1840|
0006ea  7008              STRB     r0,[r1,#0]
0006ec  e005              B        |L1.1786|
                  |L1.1774|
;;;657    	}
;;;658    	else
;;;659    	{
;;;660    		state_HWProcess |= STATE_HW_USER_TIMER_EXPIRED;
0006ee  4810              LDR      r0,|L1.1840|
0006f0  7800              LDRB     r0,[r0,#0]  ; state_HWProcess
0006f2  f0400020          ORR      r0,r0,#0x20
0006f6  490e              LDR      r1,|L1.1840|
0006f8  7008              STRB     r0,[r1,#0]
                  |L1.1786|
;;;661    	}
;;;662    	
;;;663    	// Process LED blink timer
;;;664    	if (led_blink_counter != 0)
0006fa  4816              LDR      r0,|L1.1876|
0006fc  8800              LDRH     r0,[r0,#0]  ; led_blink_counter
0006fe  b120              CBZ      r0,|L1.1802|
;;;665    	{
;;;666    		led_blink_counter--;
000700  4814              LDR      r0,|L1.1876|
000702  8800              LDRH     r0,[r0,#0]  ; led_blink_counter
000704  1e40              SUBS     r0,r0,#1
000706  4913              LDR      r1,|L1.1876|
000708  8008              STRH     r0,[r1,#0]
                  |L1.1802|
;;;667    	}
;;;668    	
;;;669    	// Process overload sound warning timer
;;;670    	if (overload_warning_counter != 0)
00070a  4813              LDR      r0,|L1.1880|
00070c  8800              LDRH     r0,[r0,#0]  ; overload_warning_counter
00070e  b120              CBZ      r0,|L1.1818|
;;;671    	{
;;;672    		overload_warning_counter--;
000710  4811              LDR      r0,|L1.1880|
000712  8800              LDRH     r0,[r0,#0]  ; overload_warning_counter
000714  1e40              SUBS     r0,r0,#1
000716  4910              LDR      r1,|L1.1880|
000718  8008              STRH     r0,[r1,#0]
                  |L1.1818|
;;;673    	}
;;;674    }
00071a  bd70              POP      {r4-r6,pc}
;;;675    
                          ENDP

                  |L1.1820|
                          DCD      regulation_setting_p
                  |L1.1824|
                          DCD      channel_5v_setting
                  |L1.1828|
                          DCD      conv_state
                  |L1.1832|
                          DCD      ctrl_HWProcess
                  |L1.1836|
                          DCD      channel_12v_setting
                  |L1.1840|
                          DCD      state_HWProcess
                  |L1.1844|
                          DCD      xQueueADC
                  |L1.1848|
                          DCD      overload_ignore_counter
                  |L1.1852|
                          DCD      overload_counter
                  |L1.1856|
                          DCD      safe_counter
                  |L1.1860|
                          DCD      converter_update_message
                  |L1.1864|
                          DCD      xQueueConverter
                  |L1.1868|
                          DCD      user_counter
                  |L1.1872|
                          DCD      cmd_ADC_to_HWProcess
                  |L1.1876|
                          DCD      led_blink_counter
                  |L1.1880|
                          DCD      overload_warning_counter

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  channel_5v_setting
                          %        38
                  channel_12v_setting
                          %        38

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  converter_tick_message
                          DCD      0x000000ff
                          DCD      0x00000000
                          DCD      0x00000000
                  converter_update_message
                          DCD      0x000000fe
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=2

                  state_HWProcess
000000  02                DCB      0x02
                  ctrl_HWProcess
000001  00                DCB      0x00
                  cmd_ADC_to_HWProcess
000002  00                DCB      0x00
                  HW_request
000003  00                DCB      0x00
                  conv_state
                          DCD      0x00000001
                  overload_ignore_counter
000008  0000              DCB      0x00,0x00
                  overload_counter
00000a  0000              DCB      0x00,0x00
                  safe_counter
00000c  0000              DCW      0x0000
                  user_counter
00000e  0000              DCW      0x0000
                  led_blink_counter
000010  0000              DCW      0x0000
                  overload_warning_counter
000012  0000              DCW      0x0000
                  regulation_setting_p
                          DCD      0x00000000
                  xQueueConverter
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "src\\converter.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_converter_c_40e17437____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_converter_c_40e17437____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_converter_c_40e17437____REVSH|
#line 130
|__asm___11_converter_c_40e17437____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
