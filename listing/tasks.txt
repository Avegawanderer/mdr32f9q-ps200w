; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\tasks.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\tasks.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\tasks.crf ..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\tasks.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  prvInitialiseTaskLists PROC
;;;2358   
;;;2359   static void prvInitialiseTaskLists( void )
000000  b510              PUSH     {r4,lr}
;;;2360   {
;;;2361   unsigned portBASE_TYPE uxPriority;
;;;2362   
;;;2363   	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
000002  2400              MOVS     r4,#0
000004  e007              B        |L1.22|
                  |L1.6|
;;;2364   	{
;;;2365   		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
000006  eb040184          ADD      r1,r4,r4,LSL #2
00000a  4af7              LDR      r2,|L1.1000|
00000c  eb020081          ADD      r0,r2,r1,LSL #2
000010  f7fffffe          BL       vListInitialise
000014  1c64              ADDS     r4,r4,#1              ;2363
                  |L1.22|
000016  2c05              CMP      r4,#5                 ;2363
000018  d3f5              BCC      |L1.6|
;;;2366   	}
;;;2367   
;;;2368   	vListInitialise( &xDelayedTaskList1 );
00001a  48f4              LDR      r0,|L1.1004|
00001c  f7fffffe          BL       vListInitialise
;;;2369   	vListInitialise( &xDelayedTaskList2 );
000020  48f3              LDR      r0,|L1.1008|
000022  f7fffffe          BL       vListInitialise
;;;2370   	vListInitialise( &xPendingReadyList );
000026  48f3              LDR      r0,|L1.1012|
000028  f7fffffe          BL       vListInitialise
;;;2371   
;;;2372   	#if ( INCLUDE_vTaskDelete == 1 )
;;;2373   	{
;;;2374   		vListInitialise( &xTasksWaitingTermination );
00002c  48f2              LDR      r0,|L1.1016|
00002e  f7fffffe          BL       vListInitialise
;;;2375   	}
;;;2376   	#endif /* INCLUDE_vTaskDelete */
;;;2377   
;;;2378   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2379   	{
;;;2380   		vListInitialise( &xSuspendedTaskList );
000032  48f2              LDR      r0,|L1.1020|
000034  f7fffffe          BL       vListInitialise
;;;2381   	}
;;;2382   	#endif /* INCLUDE_vTaskSuspend */
;;;2383   
;;;2384   	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
;;;2385   	using list2. */
;;;2386   	pxDelayedTaskList = &xDelayedTaskList1;
000038  48ec              LDR      r0,|L1.1004|
00003a  49f1              LDR      r1,|L1.1024|
00003c  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
;;;2387   	pxOverflowDelayedTaskList = &xDelayedTaskList2;
00003e  48ec              LDR      r0,|L1.1008|
000040  49f0              LDR      r1,|L1.1028|
000042  6008              STR      r0,[r1,#0]  ; pxOverflowDelayedTaskList
;;;2388   }
000044  bd10              POP      {r4,pc}
;;;2389   /*-----------------------------------------------------------*/
                          ENDP

                  prvInitialiseTCBVariables PROC
;;;2258   
;;;2259   static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
000046  e92d47f0          PUSH     {r4-r10,lr}
;;;2260   {
00004a  4604              MOV      r4,r0
00004c  460f              MOV      r7,r1
00004e  4616              MOV      r6,r2
000050  4699              MOV      r9,r3
000052  f8dd8020          LDR      r8,[sp,#0x20]
;;;2261   unsigned portBASE_TYPE x;
;;;2262   
;;;2263   	/* Store the task name in the TCB. */
;;;2264   	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
000056  2500              MOVS     r5,#0
000058  e007              B        |L1.106|
                  |L1.90|
;;;2265   	{
;;;2266   		pxTCB->pcTaskName[ x ] = pcName[ x ];
00005a  5d79              LDRB     r1,[r7,r5]
00005c  f1040034          ADD      r0,r4,#0x34
000060  5541              STRB     r1,[r0,r5]
;;;2267   
;;;2268   		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;2269   		configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;2270   		string is not accessible (extremely unlikely). */
;;;2271   		if( pcName[ x ] == 0x00 )
000062  5d78              LDRB     r0,[r7,r5]
000064  b900              CBNZ     r0,|L1.104|
;;;2272   		{
;;;2273   			break;
000066  e002              B        |L1.110|
                  |L1.104|
000068  1c6d              ADDS     r5,r5,#1              ;2264
                  |L1.106|
00006a  2d10              CMP      r5,#0x10              ;2264
00006c  d3f5              BCC      |L1.90|
                  |L1.110|
00006e  bf00              NOP      
;;;2274   		}
;;;2275   	}
;;;2276   
;;;2277   	/* Ensure the name string is terminated in the case that the string length
;;;2278   	was greater or equal to configMAX_TASK_NAME_LEN. */
;;;2279   	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
000070  2100              MOVS     r1,#0
000072  2043              MOVS     r0,#0x43
000074  5501              STRB     r1,[r0,r4]
;;;2280   
;;;2281   	/* This is used as an array index so must ensure it's not too large.  First
;;;2282   	remove the privilege bit if one is present. */
;;;2283   	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
000076  2e05              CMP      r6,#5
000078  d300              BCC      |L1.124|
;;;2284   	{
;;;2285   		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
00007a  2604              MOVS     r6,#4
                  |L1.124|
;;;2286   	}
;;;2287   
;;;2288   	pxTCB->uxPriority = uxPriority;
00007c  62e6              STR      r6,[r4,#0x2c]
;;;2289   	#if ( configUSE_MUTEXES == 1 )
;;;2290   	{
;;;2291   		pxTCB->uxBasePriority = uxPriority;
;;;2292   	}
;;;2293   	#endif /* configUSE_MUTEXES */
;;;2294   
;;;2295   	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
00007e  1d20              ADDS     r0,r4,#4
000080  f7fffffe          BL       vListInitialiseItem
;;;2296   	vListInitialiseItem( &( pxTCB->xEventListItem ) );
000084  f1040018          ADD      r0,r4,#0x18
000088  f7fffffe          BL       vListInitialiseItem
;;;2297   
;;;2298   	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
;;;2299   	back to	the containing TCB from a generic item in a list. */
;;;2300   	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
00008c  6124              STR      r4,[r4,#0x10]
;;;2301   
;;;2302   	/* Event lists are always in priority order. */
;;;2303   	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00008e  f1c60005          RSB      r0,r6,#5
000092  61a0              STR      r0,[r4,#0x18]
;;;2304   	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
000094  6264              STR      r4,[r4,#0x24]
;;;2305   
;;;2306   	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;2307   	{
;;;2308   		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
;;;2309   	}
;;;2310   	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;2311   
;;;2312   	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;2313   	{
;;;2314   		pxTCB->pxTaskTag = NULL;
;;;2315   	}
;;;2316   	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;2317   
;;;2318   	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2319   	{
;;;2320   		pxTCB->ulRunTimeCounter = 0UL;
;;;2321   	}
;;;2322   	#endif /* configGENERATE_RUN_TIME_STATS */
;;;2323   
;;;2324   	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;2325   	{
;;;2326   		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
;;;2327   	}
;;;2328   	#else /* portUSING_MPU_WRAPPERS */
;;;2329   	{
;;;2330   		( void ) xRegions;
;;;2331   		( void ) usStackDepth;
;;;2332   	}
;;;2333   	#endif /* portUSING_MPU_WRAPPERS */
;;;2334   
;;;2335   	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2336   	{
;;;2337   		/* Initialise this task's Newlib reent structure. */
;;;2338   		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
;;;2339   	}
;;;2340   	#endif /* configUSE_NEWLIB_REENTRANT */
;;;2341   }
000096  e8bd87f0          POP      {r4-r10,pc}
;;;2342   /*-----------------------------------------------------------*/
                          ENDP

                  prvAllocateTCBAndStack PROC
;;;2451   
;;;2452   static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
00009a  b570              PUSH     {r4-r6,lr}
;;;2453   {
00009c  4605              MOV      r5,r0
00009e  460e              MOV      r6,r1
;;;2454   tskTCB *pxNewTCB;
;;;2455   
;;;2456   	/* Allocate space for the TCB.  Where the memory comes from depends on
;;;2457   	the implementation of the port malloc function. */
;;;2458   	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
0000a0  2044              MOVS     r0,#0x44
0000a2  f7fffffe          BL       pvPortMalloc
0000a6  4604              MOV      r4,r0
;;;2459   
;;;2460   	if( pxNewTCB != NULL )
0000a8  b194              CBZ      r4,|L1.208|
;;;2461   	{
;;;2462   		/* Allocate space for the stack used by the task being created.
;;;2463   		The base of the stack memory stored in the TCB so the task can
;;;2464   		be deleted later if required. */
;;;2465   		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0000aa  b91e              CBNZ     r6,|L1.180|
0000ac  00a8              LSLS     r0,r5,#2
0000ae  f7fffffe          BL       pvPortMalloc
0000b2  e000              B        |L1.182|
                  |L1.180|
0000b4  4630              MOV      r0,r6
                  |L1.182|
0000b6  6320              STR      r0,[r4,#0x30]
;;;2466   
;;;2467   		if( pxNewTCB->pxStack == NULL )
0000b8  6b20              LDR      r0,[r4,#0x30]
0000ba  b920              CBNZ     r0,|L1.198|
;;;2468   		{
;;;2469   			/* Could not allocate the stack.  Delete the allocated TCB. */
;;;2470   			vPortFree( pxNewTCB );
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       vPortFree
;;;2471   			pxNewTCB = NULL;
0000c2  2400              MOVS     r4,#0
0000c4  e004              B        |L1.208|
                  |L1.198|
;;;2472   		}
;;;2473   		else
;;;2474   		{
;;;2475   			/* Just to help debugging. */
;;;2476   			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
0000c6  00a9              LSLS     r1,r5,#2
0000c8  22a5              MOVS     r2,#0xa5
0000ca  6b20              LDR      r0,[r4,#0x30]
0000cc  f7fffffe          BL       __aeabi_memset
                  |L1.208|
;;;2477   		}
;;;2478   	}
;;;2479   
;;;2480   	return pxNewTCB;
0000d0  4620              MOV      r0,r4
;;;2481   }
0000d2  bd70              POP      {r4-r6,pc}
;;;2482   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGenericCreate PROC
;;;478    
;;;479    signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
0000d4  e92d4fff          PUSH     {r0-r11,lr}
;;;480    {
0000d8  b081              SUB      sp,sp,#4
0000da  4680              MOV      r8,r0
0000dc  4615              MOV      r5,r2
0000de  4699              MOV      r9,r3
0000e0  e9dd7a0e          LDRD     r7,r10,[sp,#0x38]
;;;481    signed portBASE_TYPE xReturn;
;;;482    tskTCB * pxNewTCB;
;;;483    
;;;484    	configASSERT( pxTaskCode );
;;;485    	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
;;;486    
;;;487    	/* Allocate the memory required by the TCB and stack for the new task,
;;;488    	checking that the allocation was successful. */
;;;489    	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
0000e4  4628              MOV      r0,r5
0000e6  9910              LDR      r1,[sp,#0x40]
0000e8  f7fffffe          BL       prvAllocateTCBAndStack
0000ec  4604              MOV      r4,r0
;;;490    
;;;491    	if( pxNewTCB != NULL )
0000ee  2c00              CMP      r4,#0
0000f0  d04e              BEQ      |L1.400|
;;;492    	{
;;;493    		portSTACK_TYPE *pxTopOfStack;
;;;494    
;;;495    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;496    			/* Should the task be created in privileged mode? */
;;;497    			portBASE_TYPE xRunPrivileged;
;;;498    			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;499    			{
;;;500    				xRunPrivileged = pdTRUE;
;;;501    			}
;;;502    			else
;;;503    			{
;;;504    				xRunPrivileged = pdFALSE;
;;;505    			}
;;;506    			uxPriority &= ~portPRIVILEGE_BIT;
;;;507    		#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;508    
;;;509    		/* Calculate the top of stack address.  This depends on whether the
;;;510    		stack grows from high memory to low (as per the 80x86) or visa versa.
;;;511    		portSTACK_GROWTH is used to make the result positive or negative as
;;;512    		required by the port. */
;;;513    		#if( portSTACK_GROWTH < 0 )
;;;514    		{
;;;515    			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
0000f2  1e68              SUBS     r0,r5,#1
0000f4  6b21              LDR      r1,[r4,#0x30]
0000f6  eb010b80          ADD      r11,r1,r0,LSL #2
;;;516    			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
0000fa  f02b0b07          BIC      r11,r11,#7
;;;517    
;;;518    			/* Check the alignment of the calculated top of stack is correct. */
;;;519    			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;520    		}
;;;521    		#else /* portSTACK_GROWTH */
;;;522    		{
;;;523    			pxTopOfStack = pxNewTCB->pxStack;
;;;524    
;;;525    			/* Check the alignment of the stack buffer is correct. */
;;;526    			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;527    
;;;528    			/* If we want to use stack checking on architectures that use
;;;529    			a positive stack growth direction then we also need to store the
;;;530    			other extreme of the stack space. */
;;;531    			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
;;;532    		}
;;;533    		#endif /* portSTACK_GROWTH */
;;;534    
;;;535    		/* Setup the newly allocated TCB with the initial state of the task. */
;;;536    		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
0000fe  9500              STR      r5,[sp,#0]
000100  463a              MOV      r2,r7
000102  4620              MOV      r0,r4
000104  9b11              LDR      r3,[sp,#0x44]
000106  9902              LDR      r1,[sp,#8]
000108  f7fffffe          BL       prvInitialiseTCBVariables
;;;537    
;;;538    		/* Initialize the TCB stack to look as if the task was already running,
;;;539    		but had been interrupted by the scheduler.  The return address is set
;;;540    		to the start of the task function. Once the stack has been initialised
;;;541    		the	top of stack variable is updated. */
;;;542    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;543    		{
;;;544    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;545    		}
;;;546    		#else /* portUSING_MPU_WRAPPERS */
;;;547    		{
;;;548    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
00010c  464a              MOV      r2,r9
00010e  4641              MOV      r1,r8
000110  4658              MOV      r0,r11
000112  f7fffffe          BL       pxPortInitialiseStack
000116  6020              STR      r0,[r4,#0]
;;;549    		}
;;;550    		#endif /* portUSING_MPU_WRAPPERS */
;;;551    
;;;552    		if( ( void * ) pxCreatedTask != NULL )
000118  f1ba0f00          CMP      r10,#0
00011c  d001              BEQ      |L1.290|
;;;553    		{
;;;554    			/* Pass the TCB out - in an anonymous way.  The calling function/
;;;555    			task can use this as a handle to delete the task later if
;;;556    			required.*/
;;;557    			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
00011e  f8ca4000          STR      r4,[r10,#0]
                  |L1.290|
;;;558    		}
;;;559    
;;;560    		/* Ensure interrupts don't access the task lists while they are being
;;;561    		updated. */
;;;562    		taskENTER_CRITICAL();
000122  f7fffffe          BL       vPortEnterCritical
;;;563    		{
;;;564    			uxCurrentNumberOfTasks++;
000126  48b8              LDR      r0,|L1.1032|
000128  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00012a  1c40              ADDS     r0,r0,#1
00012c  49b6              LDR      r1,|L1.1032|
00012e  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;565    			if( pxCurrentTCB == NULL )
000130  48b6              LDR      r0,|L1.1036|
000132  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000134  b940              CBNZ     r0,|L1.328|
;;;566    			{
;;;567    				/* There are no other tasks, or all the other tasks are in
;;;568    				the suspended state - make this the current task. */
;;;569    				pxCurrentTCB =  pxNewTCB;
000136  48b5              LDR      r0,|L1.1036|
000138  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
;;;570    
;;;571    				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
00013a  4608              MOV      r0,r1
00013c  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00013e  2801              CMP      r0,#1
000140  d10c              BNE      |L1.348|
;;;572    				{
;;;573    					/* This is the first task to be created so do the preliminary
;;;574    					initialisation required.  We will not recover if this call
;;;575    					fails, but we will report the failure. */
;;;576    					prvInitialiseTaskLists();
000142  f7fffffe          BL       prvInitialiseTaskLists
000146  e009              B        |L1.348|
                  |L1.328|
;;;577    				}
;;;578    			}
;;;579    			else
;;;580    			{
;;;581    				/* If the scheduler is not already running, make this task the
;;;582    				current task if it is the highest priority task to be created
;;;583    				so far. */
;;;584    				if( xSchedulerRunning == pdFALSE )
000148  48b1              LDR      r0,|L1.1040|
00014a  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00014c  b930              CBNZ     r0,|L1.348|
;;;585    				{
;;;586    					if( pxCurrentTCB->uxPriority <= uxPriority )
00014e  48af              LDR      r0,|L1.1036|
000150  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000152  6ac0              LDR      r0,[r0,#0x2c]
000154  42b8              CMP      r0,r7
000156  d801              BHI      |L1.348|
;;;587    					{
;;;588    						pxCurrentTCB = pxNewTCB;
000158  48ac              LDR      r0,|L1.1036|
00015a  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
                  |L1.348|
;;;589    					}
;;;590    				}
;;;591    			}
;;;592    
;;;593    			uxTaskNumber++;
00015c  48ad              LDR      r0,|L1.1044|
00015e  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
000160  1c40              ADDS     r0,r0,#1
000162  49ac              LDR      r1,|L1.1044|
000164  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;594    
;;;595    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;596    			{
;;;597    				/* Add a counter into the TCB for tracing only. */
;;;598    				pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;599    			}
;;;600    			#endif /* configUSE_TRACE_FACILITY */
;;;601    			traceTASK_CREATE( pxNewTCB );
;;;602    
;;;603    			prvAddTaskToReadyList( pxNewTCB );
000166  49ac              LDR      r1,|L1.1048|
000168  6ae0              LDR      r0,[r4,#0x2c]
00016a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00016c  4288              CMP      r0,r1
00016e  d902              BLS      |L1.374|
000170  49a9              LDR      r1,|L1.1048|
000172  6ae0              LDR      r0,[r4,#0x2c]
000174  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L1.374|
000176  6ae1              LDR      r1,[r4,#0x2c]
000178  eb010181          ADD      r1,r1,r1,LSL #2
00017c  4a9a              LDR      r2,|L1.1000|
00017e  eb020081          ADD      r0,r2,r1,LSL #2
000182  1d21              ADDS     r1,r4,#4
000184  f7fffffe          BL       vListInsertEnd
;;;604    
;;;605    			xReturn = pdPASS;
000188  2601              MOVS     r6,#1
;;;606    			portSETUP_TCB( pxNewTCB );
;;;607    		}
;;;608    		taskEXIT_CRITICAL();
00018a  f7fffffe          BL       vPortExitCritical
;;;609    	}
00018e  e001              B        |L1.404|
                  |L1.400|
;;;610    	else
;;;611    	{
;;;612    		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
000190  f04f36ff          MOV      r6,#0xffffffff
                  |L1.404|
;;;613    		traceTASK_CREATE_FAILED();
;;;614    	}
;;;615    
;;;616    	if( xReturn == pdPASS )
000194  2e01              CMP      r6,#1
000196  d109              BNE      |L1.428|
;;;617    	{
;;;618    		if( xSchedulerRunning != pdFALSE )
000198  489d              LDR      r0,|L1.1040|
00019a  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00019c  b130              CBZ      r0,|L1.428|
;;;619    		{
;;;620    			/* If the created task is of a higher priority than the current task
;;;621    			then it should run now. */
;;;622    			if( pxCurrentTCB->uxPriority < uxPriority )
00019e  489b              LDR      r0,|L1.1036|
0001a0  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0001a2  6ac0              LDR      r0,[r0,#0x2c]
0001a4  42b8              CMP      r0,r7
0001a6  d201              BCS      |L1.428|
;;;623    			{
;;;624    				portYIELD_WITHIN_API();
0001a8  f7fffffe          BL       vPortYield
                  |L1.428|
;;;625    			}
;;;626    		}
;;;627    	}
;;;628    
;;;629    	return xReturn;
0001ac  4630              MOV      r0,r6
;;;630    }
0001ae  b005              ADD      sp,sp,#0x14
0001b0  e8bd8ff0          POP      {r4-r11,pc}
;;;631    /*-----------------------------------------------------------*/
                          ENDP

                  vTaskDelete PROC
;;;634    
;;;635    	void vTaskDelete( xTaskHandle xTaskToDelete )
0001b4  b570              PUSH     {r4-r6,lr}
;;;636    	{
0001b6  4605              MOV      r5,r0
;;;637    	tskTCB *pxTCB;
;;;638    
;;;639    		taskENTER_CRITICAL();
0001b8  f7fffffe          BL       vPortEnterCritical
;;;640    		{
;;;641    			/* If null is passed in here then we are deleting ourselves. */
;;;642    			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
0001bc  b915              CBNZ     r5,|L1.452|
0001be  4893              LDR      r0,|L1.1036|
0001c0  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0001c2  e000              B        |L1.454|
                  |L1.452|
0001c4  4628              MOV      r0,r5
                  |L1.454|
0001c6  4604              MOV      r4,r0
;;;643    
;;;644    			/* Remove task from the ready list and place in the	termination list.
;;;645    			This will stop the task from be scheduled.  The idle task will check
;;;646    			the termination list and free up any memory allocated by the
;;;647    			scheduler for the TCB and stack. */
;;;648    			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
0001c8  1d20              ADDS     r0,r4,#4
0001ca  f7fffffe          BL       uxListRemove
;;;649    			{
;;;650    				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;651    			}
;;;652    
;;;653    			/* Is the task waiting on an event also? */
;;;654    			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0001ce  6aa0              LDR      r0,[r4,#0x28]
0001d0  b118              CBZ      r0,|L1.474|
;;;655    			{
;;;656    				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0001d2  f1040018          ADD      r0,r4,#0x18
0001d6  f7fffffe          BL       uxListRemove
                  |L1.474|
;;;657    			}
;;;658    
;;;659    			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
0001da  1d21              ADDS     r1,r4,#4
0001dc  4886              LDR      r0,|L1.1016|
0001de  f7fffffe          BL       vListInsertEnd
;;;660    
;;;661    			/* Increment the ucTasksDeleted variable so the idle task knows
;;;662    			there is a task that has been deleted and that it should therefore
;;;663    			check the xTasksWaitingTermination list. */
;;;664    			++uxTasksDeleted;
0001e2  488e              LDR      r0,|L1.1052|
0001e4  6800              LDR      r0,[r0,#0]  ; uxTasksDeleted
0001e6  1c40              ADDS     r0,r0,#1
0001e8  498c              LDR      r1,|L1.1052|
0001ea  6008              STR      r0,[r1,#0]  ; uxTasksDeleted
;;;665    
;;;666    			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
;;;667    			can detect that the task lists need re-generating. */
;;;668    			uxTaskNumber++;
0001ec  4889              LDR      r0,|L1.1044|
0001ee  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
0001f0  1c40              ADDS     r0,r0,#1
0001f2  4988              LDR      r1,|L1.1044|
0001f4  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;669    
;;;670    			traceTASK_DELETE( pxTCB );
;;;671    		}
;;;672    		taskEXIT_CRITICAL();
0001f6  f7fffffe          BL       vPortExitCritical
;;;673    
;;;674    		/* Force a reschedule if we have just deleted the current task. */
;;;675    		if( xSchedulerRunning != pdFALSE )
0001fa  4885              LDR      r0,|L1.1040|
0001fc  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
0001fe  b128              CBZ      r0,|L1.524|
;;;676    		{
;;;677    			if( pxTCB == pxCurrentTCB )
000200  4882              LDR      r0,|L1.1036|
000202  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000204  4284              CMP      r4,r0
000206  d101              BNE      |L1.524|
;;;678    			{
;;;679    				portYIELD_WITHIN_API();
000208  f7fffffe          BL       vPortYield
                  |L1.524|
;;;680    			}
;;;681    		}
;;;682    	}
00020c  bd70              POP      {r4-r6,pc}
;;;683    
                          ENDP

                  xTaskIncrementTick PROC
;;;1582   
;;;1583   portBASE_TYPE xTaskIncrementTick( void )
00020e  e92d41f0          PUSH     {r4-r8,lr}
;;;1584   {
;;;1585   tskTCB * pxTCB;
;;;1586   portTickType xItemValue;
;;;1587   portBASE_TYPE xSwitchRequired = pdFALSE;
000212  2700              MOVS     r7,#0
;;;1588   
;;;1589   	/* Called by the portable layer each time a tick interrupt occurs.
;;;1590   	Increments the tick then checks to see if the new tick value will cause any
;;;1591   	tasks to be unblocked. */
;;;1592   	traceTASK_INCREMENT_TICK( xTickCount );
;;;1593   	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
000214  4882              LDR      r0,|L1.1056|
000216  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000218  2800              CMP      r0,#0
00021a  d17a              BNE      |L1.786|
;;;1594   	{
;;;1595   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;1596   		delayed lists if it wraps to 0. */
;;;1597   		++xTickCount;
00021c  4881              LDR      r0,|L1.1060|
00021e  6800              LDR      r0,[r0,#0]  ; xTickCount
000220  1c40              ADDS     r0,r0,#1
000222  4980              LDR      r1,|L1.1060|
000224  6008              STR      r0,[r1,#0]  ; xTickCount
;;;1598   
;;;1599   		{
;;;1600   			/* Minor optimisation.  The tick count cannot change in this
;;;1601   			block. */
;;;1602   			const portTickType xConstTickCount = xTickCount;
000226  4608              MOV      r0,r1
000228  6806              LDR      r6,[r0,#0]  ; xTickCount
;;;1603   
;;;1604   			if( xConstTickCount == ( portTickType ) 0U )
00022a  bb0e              CBNZ     r6,|L1.624|
;;;1605   			{
;;;1606   				taskSWITCH_DELAYED_LISTS();
00022c  4974              LDR      r1,|L1.1024|
00022e  6808              LDR      r0,[r1,#0]  ; pxDelayedTaskList
000230  4974              LDR      r1,|L1.1028|
000232  6809              LDR      r1,[r1,#0]  ; pxOverflowDelayedTaskList
000234  4a72              LDR      r2,|L1.1024|
000236  6011              STR      r1,[r2,#0]  ; pxDelayedTaskList
000238  4972              LDR      r1,|L1.1028|
00023a  6008              STR      r0,[r1,#0]  ; pxOverflowDelayedTaskList
00023c  497a              LDR      r1,|L1.1064|
00023e  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000240  1c49              ADDS     r1,r1,#1
000242  4a79              LDR      r2,|L1.1064|
000244  6011              STR      r1,[r2,#0]  ; xNumOfOverflows
000246  496e              LDR      r1,|L1.1024|
000248  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
00024a  6809              LDR      r1,[r1,#0]
00024c  b909              CBNZ     r1,|L1.594|
00024e  2101              MOVS     r1,#1
000250  e000              B        |L1.596|
                  |L1.594|
000252  2100              MOVS     r1,#0
                  |L1.596|
000254  b121              CBZ      r1,|L1.608|
000256  f04f31ff          MOV      r1,#0xffffffff
00025a  4a74              LDR      r2,|L1.1068|
00025c  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
00025e  e006              B        |L1.622|
                  |L1.608|
000260  4967              LDR      r1,|L1.1024|
000262  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
000264  68c9              LDR      r1,[r1,#0xc]
000266  68cc              LDR      r4,[r1,#0xc]
000268  4a70              LDR      r2,|L1.1068|
00026a  6861              LDR      r1,[r4,#4]
00026c  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
                  |L1.622|
00026e  bf00              NOP      
                  |L1.624|
;;;1607   			}
;;;1608   
;;;1609   			/* See if this tick has made a timeout expire.  Tasks are stored in the
;;;1610   			queue in the order of their wake time - meaning once one tasks has been
;;;1611   			found whose block time has not expired there is no need not look any
;;;1612   			further	down the list. */
;;;1613   			if( xConstTickCount >= xNextTaskUnblockTime )
000270  486e              LDR      r0,|L1.1068|
000272  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000274  4286              CMP      r6,r0
000276  d33a              BCC      |L1.750|
;;;1614   			{
;;;1615   				for( ;; )
000278  bf00              NOP      
                  |L1.634|
;;;1616   				{
;;;1617   					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
00027a  4861              LDR      r0,|L1.1024|
00027c  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
00027e  6800              LDR      r0,[r0,#0]
000280  b908              CBNZ     r0,|L1.646|
000282  2001              MOVS     r0,#1
000284  e000              B        |L1.648|
                  |L1.646|
000286  2000              MOVS     r0,#0
                  |L1.648|
000288  b120              CBZ      r0,|L1.660|
;;;1618   					{
;;;1619   						/* The delayed list is empty.  Set xNextTaskUnblockTime to
;;;1620   						the	maximum possible value so it is extremely unlikely that
;;;1621   						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;1622   						next time through. */
;;;1623   						xNextTaskUnblockTime = portMAX_DELAY;
00028a  f04f30ff          MOV      r0,#0xffffffff
00028e  4967              LDR      r1,|L1.1068|
000290  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;1624   						break;
000292  e02b              B        |L1.748|
                  |L1.660|
;;;1625   					}
;;;1626   					else
;;;1627   					{
;;;1628   						/* The delayed list is not empty, get the value of the item
;;;1629   						at the head of the delayed list.  This is the time at which
;;;1630   						the task at the head of the delayed list must be removed
;;;1631   						from the Blocked state. */
;;;1632   						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
000294  485a              LDR      r0,|L1.1024|
000296  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000298  68c0              LDR      r0,[r0,#0xc]
00029a  68c4              LDR      r4,[r0,#0xc]
;;;1633   						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
00029c  6865              LDR      r5,[r4,#4]
;;;1634   
;;;1635   						if( xConstTickCount < xItemValue )
00029e  42ae              CMP      r6,r5
0002a0  d202              BCS      |L1.680|
;;;1636   						{
;;;1637   							/* It is not time to unblock this item yet, but the item
;;;1638   							value is the time at which the task at the head of the
;;;1639   							blocked list must be removed from the Blocked state -
;;;1640   							so record the item value in xNextTaskUnblockTime. */
;;;1641   							xNextTaskUnblockTime = xItemValue;
0002a2  4862              LDR      r0,|L1.1068|
0002a4  6005              STR      r5,[r0,#0]  ; xNextTaskUnblockTime
;;;1642   							break;
0002a6  e021              B        |L1.748|
                  |L1.680|
;;;1643   						}
;;;1644   
;;;1645   						/* It is time to remove the item from the Blocked state. */
;;;1646   						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
0002a8  1d20              ADDS     r0,r4,#4
0002aa  f7fffffe          BL       uxListRemove
;;;1647   
;;;1648   						/* Is the task waiting on an event also?  If so remove it
;;;1649   						from the event list. */
;;;1650   						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0002ae  6aa0              LDR      r0,[r4,#0x28]
0002b0  b118              CBZ      r0,|L1.698|
;;;1651   						{
;;;1652   							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0002b2  f1040018          ADD      r0,r4,#0x18
0002b6  f7fffffe          BL       uxListRemove
                  |L1.698|
;;;1653   						}
;;;1654   
;;;1655   						/* Place the unblocked task into the appropriate ready
;;;1656   						list. */
;;;1657   						prvAddTaskToReadyList( pxTCB );
0002ba  4957              LDR      r1,|L1.1048|
0002bc  6ae0              LDR      r0,[r4,#0x2c]
0002be  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0002c0  4288              CMP      r0,r1
0002c2  d902              BLS      |L1.714|
0002c4  4954              LDR      r1,|L1.1048|
0002c6  6ae0              LDR      r0,[r4,#0x2c]
0002c8  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L1.714|
0002ca  6ae1              LDR      r1,[r4,#0x2c]
0002cc  eb010181          ADD      r1,r1,r1,LSL #2
0002d0  4a45              LDR      r2,|L1.1000|
0002d2  eb020081          ADD      r0,r2,r1,LSL #2
0002d6  1d21              ADDS     r1,r4,#4
0002d8  f7fffffe          BL       vListInsertEnd
;;;1658   
;;;1659   						/* A task being unblocked cannot cause an immediate context
;;;1660   						switch if preemption is turned off. */
;;;1661   						#if (  configUSE_PREEMPTION == 1 )
;;;1662   						{
;;;1663   							/* Preemption is on, but a context switch should only
;;;1664   							be performed if the unblocked task has a priority that
;;;1665   							is equal to or higher than the currently executing
;;;1666   							task. */
;;;1667   							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0002dc  494b              LDR      r1,|L1.1036|
0002de  6ae0              LDR      r0,[r4,#0x2c]
0002e0  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0002e2  6ac9              LDR      r1,[r1,#0x2c]
0002e4  4288              CMP      r0,r1
0002e6  d3c8              BCC      |L1.634|
;;;1668   							{
;;;1669   								xSwitchRequired = pdTRUE;
0002e8  2701              MOVS     r7,#1
0002ea  e7c6              B        |L1.634|
                  |L1.748|
0002ec  bf00              NOP                            ;1624
                  |L1.750|
;;;1670   							}
;;;1671   						}
;;;1672   						#endif /* configUSE_PREEMPTION */
;;;1673   					}
;;;1674   				}
;;;1675   			}
;;;1676   		}
;;;1677   
;;;1678   		/* Tasks of equal priority to the currently running task will share
;;;1679   		processing time (time slice) if preemption is on, and the application
;;;1680   		writer has not explicitly turned time slicing off. */
;;;1681   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;1682   		{
;;;1683   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
0002ee  4847              LDR      r0,|L1.1036|
0002f0  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0002f2  6ac0              LDR      r0,[r0,#0x2c]
0002f4  eb000080          ADD      r0,r0,r0,LSL #2
0002f8  493b              LDR      r1,|L1.1000|
0002fa  f8510020          LDR      r0,[r1,r0,LSL #2]
0002fe  2801              CMP      r0,#1
000300  d900              BLS      |L1.772|
;;;1684   			{
;;;1685   				xSwitchRequired = pdTRUE;
000302  2701              MOVS     r7,#1
                  |L1.772|
;;;1686   			}
;;;1687   		}
;;;1688   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;1689   		
;;;1690   		#if ( configUSE_TICK_HOOK == 1 )
;;;1691   		{
;;;1692   			/* Guard against the tick hook being called when the pended tick
;;;1693   			count is being unwound (when the scheduler is being unlocked). */
;;;1694   			if( uxPendedTicks == ( unsigned portBASE_TYPE ) 0U )
000304  484a              LDR      r0,|L1.1072|
000306  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
000308  b950              CBNZ     r0,|L1.800|
;;;1695   			{
;;;1696   				vApplicationTickHook();
00030a  f7fffffe          BL       vApplicationTickHook
00030e  e007              B        |L1.800|
000310  e7ff              B        |L1.786|
                  |L1.786|
;;;1697   			}
;;;1698   		}
;;;1699   		#endif /* configUSE_TICK_HOOK */		
;;;1700   	}
;;;1701   	else
;;;1702   	{
;;;1703   		++uxPendedTicks;
000312  4847              LDR      r0,|L1.1072|
000314  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
000316  1c40              ADDS     r0,r0,#1
000318  4945              LDR      r1,|L1.1072|
00031a  6008              STR      r0,[r1,#0]  ; uxPendedTicks
;;;1704   
;;;1705   		/* The tick hook gets called at regular intervals, even if the
;;;1706   		scheduler is locked. */
;;;1707   		#if ( configUSE_TICK_HOOK == 1 )
;;;1708   		{
;;;1709   			vApplicationTickHook();
00031c  f7fffffe          BL       vApplicationTickHook
                  |L1.800|
;;;1710   		}
;;;1711   		#endif
;;;1712   	}
;;;1713   
;;;1714   	#if ( configUSE_PREEMPTION == 1 )
;;;1715   	{
;;;1716   		if( xYieldPending != pdFALSE )
000320  4844              LDR      r0,|L1.1076|
000322  6800              LDR      r0,[r0,#0]  ; xYieldPending
000324  b100              CBZ      r0,|L1.808|
;;;1717   		{
;;;1718   			xSwitchRequired = pdTRUE;
000326  2701              MOVS     r7,#1
                  |L1.808|
;;;1719   		}
;;;1720   	}
;;;1721   	#endif /* configUSE_PREEMPTION */
;;;1722   
;;;1723   	return xSwitchRequired;
000328  4638              MOV      r0,r7
;;;1724   }
00032a  e8bd81f0          POP      {r4-r8,pc}
;;;1725   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskResumeAll PROC
;;;1345   
;;;1346   signed portBASE_TYPE xTaskResumeAll( void )
00032e  b570              PUSH     {r4-r6,lr}
;;;1347   {
;;;1348   tskTCB *pxTCB;
;;;1349   portBASE_TYPE xAlreadyYielded = pdFALSE;
000330  2500              MOVS     r5,#0
;;;1350   
;;;1351   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;1352   	previous call to vTaskSuspendAll(). */
;;;1353   	configASSERT( uxSchedulerSuspended );
;;;1354   
;;;1355   	/* It is possible that an ISR caused a task to be removed from an event
;;;1356   	list while the scheduler was suspended.  If this was the case then the
;;;1357   	removed task will have been added to the xPendingReadyList.  Once the
;;;1358   	scheduler has been resumed it is safe to move all the pending ready
;;;1359   	tasks from this list into their appropriate ready list. */
;;;1360   	taskENTER_CRITICAL();
000332  f7fffffe          BL       vPortEnterCritical
;;;1361   	{
;;;1362   		--uxSchedulerSuspended;
000336  483a              LDR      r0,|L1.1056|
000338  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00033a  1e40              SUBS     r0,r0,#1
00033c  4938              LDR      r1,|L1.1056|
00033e  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;1363   
;;;1364   		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
000340  4608              MOV      r0,r1
000342  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000344  2800              CMP      r0,#0
000346  d14a              BNE      |L1.990|
;;;1365   		{
;;;1366   			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
000348  482f              LDR      r0,|L1.1032|
00034a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00034c  2800              CMP      r0,#0
00034e  d046              BEQ      |L1.990|
;;;1367   			{
;;;1368   				/* Move any readied tasks from the pending list into the
;;;1369   				appropriate ready list. */
;;;1370   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
000350  e023              B        |L1.922|
                  |L1.850|
;;;1371   				{
;;;1372   					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
000352  4828              LDR      r0,|L1.1012|
000354  68c0              LDR      r0,[r0,#0xc]
000356  68c4              LDR      r4,[r0,#0xc]
;;;1373   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000358  f1040018          ADD      r0,r4,#0x18
00035c  f7fffffe          BL       uxListRemove
;;;1374   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
000360  1d20              ADDS     r0,r4,#4
000362  f7fffffe          BL       uxListRemove
;;;1375   					prvAddTaskToReadyList( pxTCB );
000366  492c              LDR      r1,|L1.1048|
000368  6ae0              LDR      r0,[r4,#0x2c]
00036a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00036c  4288              CMP      r0,r1
00036e  d902              BLS      |L1.886|
000370  4929              LDR      r1,|L1.1048|
000372  6ae0              LDR      r0,[r4,#0x2c]
000374  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L1.886|
000376  6ae1              LDR      r1,[r4,#0x2c]
000378  eb010181          ADD      r1,r1,r1,LSL #2
00037c  4a1a              LDR      r2,|L1.1000|
00037e  eb020081          ADD      r0,r2,r1,LSL #2
000382  1d21              ADDS     r1,r4,#4
000384  f7fffffe          BL       vListInsertEnd
;;;1376   
;;;1377   					/* If we have moved a task that has a priority higher than
;;;1378   					the current task then we should yield. */
;;;1379   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000388  4920              LDR      r1,|L1.1036|
00038a  6ae0              LDR      r0,[r4,#0x2c]
00038c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00038e  6ac9              LDR      r1,[r1,#0x2c]
000390  4288              CMP      r0,r1
000392  d302              BCC      |L1.922|
;;;1380   					{
;;;1381   						xYieldPending = pdTRUE;
000394  2001              MOVS     r0,#1
000396  4927              LDR      r1,|L1.1076|
000398  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L1.922|
00039a  4816              LDR      r0,|L1.1012|
00039c  6800              LDR      r0,[r0,#0]            ;1370  ; xPendingReadyList
00039e  b908              CBNZ     r0,|L1.932|
0003a0  2001              MOVS     r0,#1                 ;1370
0003a2  e000              B        |L1.934|
                  |L1.932|
0003a4  2000              MOVS     r0,#0                 ;1370
                  |L1.934|
0003a6  2800              CMP      r0,#0                 ;1370
0003a8  d0d3              BEQ      |L1.850|
;;;1382   					}
;;;1383   				}
;;;1384   
;;;1385   				/* If any ticks occurred while the scheduler was suspended then
;;;1386   				they should be processed now.  This ensures the tick count does not
;;;1387   				slip, and that any delayed tasks are resumed at the correct time. */
;;;1388   				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
0003aa  4821              LDR      r0,|L1.1072|
0003ac  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
0003ae  b178              CBZ      r0,|L1.976|
;;;1389   				{
;;;1390   					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
0003b0  e00a              B        |L1.968|
                  |L1.946|
;;;1391   					{
;;;1392   						if( xTaskIncrementTick() != pdFALSE )
0003b2  f7fffffe          BL       xTaskIncrementTick
0003b6  b110              CBZ      r0,|L1.958|
;;;1393   						{
;;;1394   							xYieldPending = pdTRUE;
0003b8  2001              MOVS     r0,#1
0003ba  491e              LDR      r1,|L1.1076|
0003bc  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L1.958|
;;;1395   						}
;;;1396   						--uxPendedTicks;
0003be  481c              LDR      r0,|L1.1072|
0003c0  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
0003c2  1e40              SUBS     r0,r0,#1
0003c4  491a              LDR      r1,|L1.1072|
0003c6  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L1.968|
0003c8  4819              LDR      r0,|L1.1072|
0003ca  6800              LDR      r0,[r0,#0]            ;1390  ; uxPendedTicks
0003cc  2800              CMP      r0,#0                 ;1390
0003ce  d1f0              BNE      |L1.946|
                  |L1.976|
;;;1397   					}
;;;1398   				}
;;;1399   
;;;1400   				if( xYieldPending == pdTRUE )
0003d0  4818              LDR      r0,|L1.1076|
0003d2  6800              LDR      r0,[r0,#0]  ; xYieldPending
0003d4  2801              CMP      r0,#1
0003d6  d102              BNE      |L1.990|
;;;1401   				{
;;;1402   					xAlreadyYielded = pdTRUE;
0003d8  2501              MOVS     r5,#1
;;;1403   					portYIELD_WITHIN_API();
0003da  f7fffffe          BL       vPortYield
                  |L1.990|
;;;1404   				}
;;;1405   			}
;;;1406   		}
;;;1407   	}
;;;1408   	taskEXIT_CRITICAL();
0003de  f7fffffe          BL       vPortExitCritical
;;;1409   
;;;1410   	return xAlreadyYielded;
0003e2  4628              MOV      r0,r5
;;;1411   }
0003e4  bd70              POP      {r4-r6,pc}
0003e6  0000              DCW      0x0000
                  |L1.1000|
                          DCD      pxReadyTasksLists
                  |L1.1004|
                          DCD      xDelayedTaskList1
                  |L1.1008|
                          DCD      xDelayedTaskList2
                  |L1.1012|
                          DCD      xPendingReadyList
                  |L1.1016|
                          DCD      xTasksWaitingTermination
                  |L1.1020|
                          DCD      xSuspendedTaskList
                  |L1.1024|
                          DCD      pxDelayedTaskList
                  |L1.1028|
                          DCD      pxOverflowDelayedTaskList
                  |L1.1032|
                          DCD      uxCurrentNumberOfTasks
                  |L1.1036|
                          DCD      pxCurrentTCB
                  |L1.1040|
                          DCD      xSchedulerRunning
                  |L1.1044|
                          DCD      uxTaskNumber
                  |L1.1048|
                          DCD      uxTopReadyPriority
                  |L1.1052|
                          DCD      uxTasksDeleted
                  |L1.1056|
                          DCD      uxSchedulerSuspended
                  |L1.1060|
                          DCD      xTickCount
                  |L1.1064|
                          DCD      xNumOfOverflows
                  |L1.1068|
                          DCD      xNextTaskUnblockTime
                  |L1.1072|
                          DCD      uxPendedTicks
                  |L1.1076|
                          DCD      xYieldPending
                          ENDP

                  prvAddCurrentTaskToDelayedList PROC
;;;2425   
;;;2426   static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
000438  b510              PUSH     {r4,lr}
;;;2427   {
00043a  4604              MOV      r4,r0
;;;2428   	/* The list item will be inserted in wake time order. */
;;;2429   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
00043c  48f7              LDR      r0,|L1.2076|
00043e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000440  6044              STR      r4,[r0,#4]
;;;2430   
;;;2431   	if( xTimeToWake < xTickCount )
000442  48f7              LDR      r0,|L1.2080|
000444  6800              LDR      r0,[r0,#0]  ; xTickCount
000446  4284              CMP      r4,r0
000448  d207              BCS      |L1.1114|
;;;2432   	{
;;;2433   		/* Wake time has overflowed.  Place this item in the overflow list. */
;;;2434   		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
00044a  48f4              LDR      r0,|L1.2076|
00044c  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00044e  1d09              ADDS     r1,r1,#4
000450  48f4              LDR      r0,|L1.2084|
000452  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000454  f7fffffe          BL       vListInsert
000458  e00c              B        |L1.1140|
                  |L1.1114|
;;;2435   	}
;;;2436   	else
;;;2437   	{
;;;2438   		/* The wake time has not overflowed, so we can use the current block list. */
;;;2439   		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
00045a  48f0              LDR      r0,|L1.2076|
00045c  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00045e  1d09              ADDS     r1,r1,#4
000460  48f1              LDR      r0,|L1.2088|
000462  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000464  f7fffffe          BL       vListInsert
;;;2440   
;;;2441   		/* If the task entering the blocked state was placed at the head of the
;;;2442   		list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;2443   		too. */
;;;2444   		if( xTimeToWake < xNextTaskUnblockTime )
000468  48f0              LDR      r0,|L1.2092|
00046a  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
00046c  4284              CMP      r4,r0
00046e  d201              BCS      |L1.1140|
;;;2445   		{
;;;2446   			xNextTaskUnblockTime = xTimeToWake;
000470  48ee              LDR      r0,|L1.2092|
000472  6004              STR      r4,[r0,#0]  ; xNextTaskUnblockTime
                  |L1.1140|
;;;2447   		}
;;;2448   	}
;;;2449   }
000474  bd10              POP      {r4,pc}
;;;2450   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSuspendAll PROC
;;;1309   
;;;1310   void vTaskSuspendAll( void )
000476  48ee              LDR      r0,|L1.2096|
;;;1311   {
;;;1312   	/* A critical section is not required as the variable is of type
;;;1313   	portBASE_TYPE. */
;;;1314   	++uxSchedulerSuspended;
000478  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00047a  1c40              ADDS     r0,r0,#1
00047c  49ec              LDR      r1,|L1.2096|
00047e  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;1315   }
000480  4770              BX       lr
;;;1316   /*----------------------------------------------------------*/
                          ENDP

                  vTaskDelayUntil PROC
;;;688    
;;;689    	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
000482  e92d47f0          PUSH     {r4-r10,lr}
;;;690    	{
000486  4604              MOV      r4,r0
000488  4688              MOV      r8,r1
;;;691    	portTickType xTimeToWake;
;;;692    	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
00048a  f04f0900          MOV      r9,#0
;;;693    
;;;694    		configASSERT( pxPreviousWakeTime );
;;;695    		configASSERT( ( xTimeIncrement > 0U ) );
;;;696    
;;;697    		vTaskSuspendAll();
00048e  f7fffffe          BL       vTaskSuspendAll
;;;698    		{
;;;699    			/* Minor optimisation.  The tick count cannot change in this
;;;700    			block. */
;;;701    			const portTickType xConstTickCount = xTickCount;
000492  48e3              LDR      r0,|L1.2080|
000494  6807              LDR      r7,[r0,#0]  ; xTickCount
;;;702    
;;;703    			/* Generate the tick time at which the task wants to wake. */
;;;704    			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
000496  6820              LDR      r0,[r4,#0]
000498  eb000508          ADD      r5,r0,r8
;;;705    
;;;706    			if( xConstTickCount < *pxPreviousWakeTime )
00049c  6820              LDR      r0,[r4,#0]
00049e  42b8              CMP      r0,r7
0004a0  d907              BLS      |L1.1202|
;;;707    			{
;;;708    				/* The tick count has overflowed since this function was
;;;709    				lasted called.  In this case the only time we should ever
;;;710    				actually delay is if the wake time has also	overflowed,
;;;711    				and the wake time is greater than the tick time.  When this
;;;712    				is the case it is as if neither time had overflowed. */
;;;713    				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
0004a2  6820              LDR      r0,[r4,#0]
0004a4  42a8              CMP      r0,r5
0004a6  d90b              BLS      |L1.1216|
0004a8  42bd              CMP      r5,r7
0004aa  d909              BLS      |L1.1216|
;;;714    				{
;;;715    					xShouldDelay = pdTRUE;
0004ac  f04f0901          MOV      r9,#1
0004b0  e006              B        |L1.1216|
                  |L1.1202|
;;;716    				}
;;;717    			}
;;;718    			else
;;;719    			{
;;;720    				/* The tick time has not overflowed.  In this case we will
;;;721    				delay if either the wake time has overflowed, and/or the
;;;722    				tick time is less than the wake time. */
;;;723    				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
0004b2  6820              LDR      r0,[r4,#0]
0004b4  42a8              CMP      r0,r5
0004b6  d801              BHI      |L1.1212|
0004b8  42bd              CMP      r5,r7
0004ba  d901              BLS      |L1.1216|
                  |L1.1212|
;;;724    				{
;;;725    					xShouldDelay = pdTRUE;
0004bc  f04f0901          MOV      r9,#1
                  |L1.1216|
;;;726    				}
;;;727    			}
;;;728    
;;;729    			/* Update the wake time ready for the next call. */
;;;730    			*pxPreviousWakeTime = xTimeToWake;
0004c0  6025              STR      r5,[r4,#0]
;;;731    
;;;732    			if( xShouldDelay != pdFALSE )
0004c2  f1b90f00          CMP      r9,#0
0004c6  d007              BEQ      |L1.1240|
;;;733    			{
;;;734    				traceTASK_DELAY_UNTIL();
;;;735    
;;;736    				/* We must remove ourselves from the ready list before adding
;;;737    				ourselves to the blocked list as the same list item is used for
;;;738    				both lists. */
;;;739    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
0004c8  48d4              LDR      r0,|L1.2076|
0004ca  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0004cc  1d00              ADDS     r0,r0,#4
0004ce  f7fffffe          BL       uxListRemove
;;;740    				{
;;;741    					/* The current task must be in a ready list, so there is
;;;742    					no need to check, and the port reset macro can be called
;;;743    					directly. */
;;;744    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;745    				}
;;;746    
;;;747    				prvAddCurrentTaskToDelayedList( xTimeToWake );
0004d2  4628              MOV      r0,r5
0004d4  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.1240|
;;;748    			}
;;;749    		}
;;;750    		xAlreadyYielded = xTaskResumeAll();
0004d8  f7fffffe          BL       xTaskResumeAll
0004dc  4606              MOV      r6,r0
;;;751    
;;;752    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;753    		have put ourselves to sleep. */
;;;754    		if( xAlreadyYielded == pdFALSE )
0004de  b90e              CBNZ     r6,|L1.1252|
;;;755    		{
;;;756    			portYIELD_WITHIN_API();
0004e0  f7fffffe          BL       vPortYield
                  |L1.1252|
;;;757    		}
;;;758    	}
0004e4  e8bd87f0          POP      {r4-r10,pc}
;;;759    
                          ENDP

                  vTaskDelay PROC
;;;764    
;;;765    	void vTaskDelay( portTickType xTicksToDelay )
0004e8  b570              PUSH     {r4-r6,lr}
;;;766    	{
0004ea  4604              MOV      r4,r0
;;;767    	portTickType xTimeToWake;
;;;768    	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
0004ec  2600              MOVS     r6,#0
;;;769    
;;;770    		/* A delay time of zero just forces a reschedule. */
;;;771    		if( xTicksToDelay > ( portTickType ) 0U )
0004ee  b17c              CBZ      r4,|L1.1296|
;;;772    		{
;;;773    			vTaskSuspendAll();
0004f0  f7fffffe          BL       vTaskSuspendAll
;;;774    			{
;;;775    				traceTASK_DELAY();
;;;776    
;;;777    				/* A task that is removed from the event list while the
;;;778    				scheduler is suspended will not get placed in the ready
;;;779    				list or removed from the blocked list until the scheduler
;;;780    				is resumed.
;;;781    
;;;782    				This task cannot be in an event list as it is the currently
;;;783    				executing task. */
;;;784    
;;;785    				/* Calculate the time to wake - this may overflow but this is
;;;786    				not a problem. */
;;;787    				xTimeToWake = xTickCount + xTicksToDelay;
0004f4  48ca              LDR      r0,|L1.2080|
0004f6  6800              LDR      r0,[r0,#0]  ; xTickCount
0004f8  1905              ADDS     r5,r0,r4
;;;788    
;;;789    				/* We must remove ourselves from the ready list before adding
;;;790    				ourselves to the blocked list as the same list item is used for
;;;791    				both lists. */
;;;792    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
0004fa  48c8              LDR      r0,|L1.2076|
0004fc  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0004fe  1d00              ADDS     r0,r0,#4
000500  f7fffffe          BL       uxListRemove
;;;793    				{
;;;794    					/* The current task must be in a ready list, so there is
;;;795    					no need to check, and the port reset macro can be called
;;;796    					directly. */
;;;797    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;798    				}
;;;799    				prvAddCurrentTaskToDelayedList( xTimeToWake );
000504  4628              MOV      r0,r5
000506  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;800    			}
;;;801    			xAlreadyYielded = xTaskResumeAll();
00050a  f7fffffe          BL       xTaskResumeAll
00050e  4606              MOV      r6,r0
                  |L1.1296|
;;;802    		}
;;;803    
;;;804    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;805    		have put ourselves to sleep. */
;;;806    		if( xAlreadyYielded == pdFALSE )
000510  b90e              CBNZ     r6,|L1.1302|
;;;807    		{
;;;808    			portYIELD_WITHIN_API();
000512  f7fffffe          BL       vPortYield
                  |L1.1302|
;;;809    		}
;;;810    	}
000516  bd70              POP      {r4-r6,pc}
;;;811    
                          ENDP

                  uxTaskPriorityGet PROC
;;;876    
;;;877    	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
000518  b570              PUSH     {r4-r6,lr}
;;;878    	{
00051a  4604              MOV      r4,r0
;;;879    	tskTCB *pxTCB;
;;;880    	unsigned portBASE_TYPE uxReturn;
;;;881    
;;;882    		taskENTER_CRITICAL();
00051c  f7fffffe          BL       vPortEnterCritical
;;;883    		{
;;;884    			/* If null is passed in here then we are changing the
;;;885    			priority of the calling function. */
;;;886    			pxTCB = prvGetTCBFromHandle( xTask );
000520  b914              CBNZ     r4,|L1.1320|
000522  48be              LDR      r0,|L1.2076|
000524  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000526  e000              B        |L1.1322|
                  |L1.1320|
000528  4620              MOV      r0,r4
                  |L1.1322|
00052a  4606              MOV      r6,r0
;;;887    			uxReturn = pxTCB->uxPriority;
00052c  6af5              LDR      r5,[r6,#0x2c]
;;;888    		}
;;;889    		taskEXIT_CRITICAL();
00052e  f7fffffe          BL       vPortExitCritical
;;;890    
;;;891    		return uxReturn;
000532  4628              MOV      r0,r5
;;;892    	}
000534  bd70              POP      {r4-r6,pc}
;;;893    
                          ENDP

                  vTaskPrioritySet PROC
;;;898    
;;;899    	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
000536  e92d47f0          PUSH     {r4-r10,lr}
;;;900    	{
00053a  4607              MOV      r7,r0
00053c  460d              MOV      r5,r1
;;;901    	tskTCB *pxTCB;
;;;902    	unsigned portBASE_TYPE uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;903    	portBASE_TYPE xYieldRequired = pdFALSE;
00053e  f04f0900          MOV      r9,#0
;;;904    
;;;905    		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
;;;906    
;;;907    		/* Ensure the new priority is valid. */
;;;908    		if( uxNewPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
000542  2d05              CMP      r5,#5
000544  d300              BCC      |L1.1352|
;;;909    		{
;;;910    			uxNewPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
000546  2504              MOVS     r5,#4
                  |L1.1352|
;;;911    		}
;;;912    
;;;913    		taskENTER_CRITICAL();
000548  f7fffffe          BL       vPortEnterCritical
;;;914    		{
;;;915    			/* If null is passed in here then it is the priority of the calling
;;;916    			task that is being changed. */
;;;917    			pxTCB = prvGetTCBFromHandle( xTask );
00054c  b917              CBNZ     r7,|L1.1364|
00054e  48b3              LDR      r0,|L1.2076|
000550  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000552  e000              B        |L1.1366|
                  |L1.1364|
000554  4638              MOV      r0,r7
                  |L1.1366|
000556  4604              MOV      r4,r0
;;;918    
;;;919    			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;920    
;;;921    			#if ( configUSE_MUTEXES == 1 )
;;;922    			{
;;;923    				uxCurrentBasePriority = pxTCB->uxBasePriority;
;;;924    			}
;;;925    			#else
;;;926    			{
;;;927    				uxCurrentBasePriority = pxTCB->uxPriority;
000558  6ae6              LDR      r6,[r4,#0x2c]
;;;928    			}
;;;929    			#endif
;;;930    
;;;931    			if( uxCurrentBasePriority != uxNewPriority )
00055a  42ae              CMP      r6,r5
00055c  d03f              BEQ      |L1.1502|
;;;932    			{
;;;933    				/* The priority change may have readied a task of higher
;;;934    				priority than the calling task. */
;;;935    				if( uxNewPriority > uxCurrentBasePriority )
00055e  42b5              CMP      r5,r6
000560  d90b              BLS      |L1.1402|
;;;936    				{
;;;937    					if( pxTCB != pxCurrentTCB )
000562  48ae              LDR      r0,|L1.2076|
000564  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000566  4284              CMP      r4,r0
000568  d00d              BEQ      |L1.1414|
;;;938    					{
;;;939    						/* The priority of a task other than the currently
;;;940    						running task is being raised.  Is the priority being
;;;941    						raised above that of the running task? */
;;;942    						if( uxNewPriority >= pxCurrentTCB->uxPriority )
00056a  48ac              LDR      r0,|L1.2076|
00056c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00056e  6ac0              LDR      r0,[r0,#0x2c]
000570  42a8              CMP      r0,r5
000572  d808              BHI      |L1.1414|
;;;943    						{
;;;944    							xYieldRequired = pdTRUE;
000574  f04f0901          MOV      r9,#1
000578  e005              B        |L1.1414|
                  |L1.1402|
;;;945    						}
;;;946    					}
;;;947    					else
;;;948    					{
;;;949    						/* The priority of the running task is being raised,
;;;950    						but the running task must already be the highest
;;;951    						priority task able to run so no yield is required. */
;;;952    					}
;;;953    				}
;;;954    				else if( pxTCB == pxCurrentTCB )
00057a  48a8              LDR      r0,|L1.2076|
00057c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00057e  4284              CMP      r4,r0
000580  d101              BNE      |L1.1414|
;;;955    				{
;;;956    					/* Setting the priority of the running task down means
;;;957    					there may now be another task of higher priority that
;;;958    					is ready to execute. */
;;;959    					xYieldRequired = pdTRUE;
000582  f04f0901          MOV      r9,#1
                  |L1.1414|
;;;960    				}
;;;961    				else
;;;962    				{
;;;963    					/* Setting the priority of any other task down does not
;;;964    					require a yield as the running task must be above the
;;;965    					new priority of the task being modified. */
;;;966    				}
;;;967    
;;;968    				/* Remember the ready list the task might be referenced from
;;;969    				before its uxPriority member is changed so the
;;;970    				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;971    				uxPriorityUsedOnEntry = pxTCB->uxPriority;
000586  f8d4802c          LDR      r8,[r4,#0x2c]
;;;972    
;;;973    				#if ( configUSE_MUTEXES == 1 )
;;;974    				{
;;;975    					/* Only change the priority being used if the task is not
;;;976    					currently using an inherited priority. */
;;;977    					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
;;;978    					{
;;;979    						pxTCB->uxPriority = uxNewPriority;
;;;980    					}
;;;981    
;;;982    					/* The base priority gets set whatever. */
;;;983    					pxTCB->uxBasePriority = uxNewPriority;
;;;984    				}
;;;985    				#else
;;;986    				{
;;;987    					pxTCB->uxPriority = uxNewPriority;
00058a  62e5              STR      r5,[r4,#0x2c]
;;;988    				}
;;;989    				#endif
;;;990    
;;;991    				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00058c  f1c50005          RSB      r0,r5,#5
000590  61a0              STR      r0,[r4,#0x18]
;;;992    
;;;993    				/* If the task is in the blocked or suspended list we need do
;;;994    				nothing more than change it's priority variable. However, if
;;;995    				the task is in a ready list it needs to be removed and placed
;;;996    				in the list appropriate to its new priority. */
;;;997    				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
000592  eb080188          ADD      r1,r8,r8,LSL #2
000596  4aa7              LDR      r2,|L1.2100|
000598  eb020181          ADD      r1,r2,r1,LSL #2
00059c  6960              LDR      r0,[r4,#0x14]
00059e  4288              CMP      r0,r1
0005a0  d101              BNE      |L1.1446|
0005a2  2001              MOVS     r0,#1
0005a4  e000              B        |L1.1448|
                  |L1.1446|
0005a6  2000              MOVS     r0,#0
                  |L1.1448|
0005a8  b198              CBZ      r0,|L1.1490|
;;;998    				{
;;;999    					/* The task is currently in its ready list - remove before adding
;;;1000   					it to it's new ready list.  As we are in a critical section we
;;;1001   					can do this even if the scheduler is suspended. */
;;;1002   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
0005aa  1d20              ADDS     r0,r4,#4
0005ac  f7fffffe          BL       uxListRemove
;;;1003   					{
;;;1004   						/* It is known that the task is in its ready list so
;;;1005   						there is no need to check again and the port level
;;;1006   						reset macro can be called directly. */
;;;1007   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
;;;1008   					}
;;;1009   					prvAddTaskToReadyList( pxTCB );
0005b0  49a1              LDR      r1,|L1.2104|
0005b2  6ae0              LDR      r0,[r4,#0x2c]
0005b4  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0005b6  4288              CMP      r0,r1
0005b8  d902              BLS      |L1.1472|
0005ba  499f              LDR      r1,|L1.2104|
0005bc  6ae0              LDR      r0,[r4,#0x2c]
0005be  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L1.1472|
0005c0  6ae1              LDR      r1,[r4,#0x2c]
0005c2  eb010181          ADD      r1,r1,r1,LSL #2
0005c6  4a9b              LDR      r2,|L1.2100|
0005c8  eb020081          ADD      r0,r2,r1,LSL #2
0005cc  1d21              ADDS     r1,r4,#4
0005ce  f7fffffe          BL       vListInsertEnd
                  |L1.1490|
;;;1010   				}
;;;1011   
;;;1012   				if( xYieldRequired == pdTRUE )
0005d2  f1b90f01          CMP      r9,#1
0005d6  d101              BNE      |L1.1500|
;;;1013   				{
;;;1014   					portYIELD_WITHIN_API();
0005d8  f7fffffe          BL       vPortYield
                  |L1.1500|
;;;1015   				}
;;;1016   
;;;1017   				/* Remove compiler warning about unused variables when the port
;;;1018   				optimised task selection is not being used. */
;;;1019   				( void ) uxPriorityUsedOnEntry;
0005dc  bf00              NOP      
                  |L1.1502|
;;;1020   			}
;;;1021   		}
;;;1022   		taskEXIT_CRITICAL();
0005de  f7fffffe          BL       vPortExitCritical
;;;1023   	}
0005e2  e8bd87f0          POP      {r4-r10,pc}
;;;1024   
                          ENDP

                  vTaskSwitchContext PROC
;;;1813   
;;;1814   void vTaskSwitchContext( void )
0005e6  4892              LDR      r0,|L1.2096|
;;;1815   {
;;;1816   	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
0005e8  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
0005ea  b118              CBZ      r0,|L1.1524|
;;;1817   	{
;;;1818   		/* The scheduler is currently suspended - do not allow a context
;;;1819   		switch. */
;;;1820   		xYieldPending = pdTRUE;
0005ec  2001              MOVS     r0,#1
0005ee  4993              LDR      r1,|L1.2108|
0005f0  6008              STR      r0,[r1,#0]  ; xYieldPending
0005f2  e02c              B        |L1.1614|
                  |L1.1524|
;;;1821   	}
;;;1822   	else
;;;1823   	{
;;;1824   		xYieldPending = pdFALSE;
0005f4  2000              MOVS     r0,#0
0005f6  4991              LDR      r1,|L1.2108|
0005f8  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;1825   		traceTASK_SWITCHED_OUT();
;;;1826   
;;;1827   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;1828   		{
;;;1829   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;1830   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;1831   				#else
;;;1832   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;1833   				#endif
;;;1834   
;;;1835   				/* Add the amount of time the task has been running to the
;;;1836   				accumulated	time so far.  The time the task started running was
;;;1837   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;1838   				protection here	so count values are only valid until the timer
;;;1839   				overflows.  The guard against negative values is to protect
;;;1840   				against suspect run time stat counter implementations - which
;;;1841   				are provided by the application, not the kernel. */
;;;1842   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;1843   				{
;;;1844   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;1845   				}
;;;1846   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;1847   		}
;;;1848   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;1849   
;;;1850   		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
;;;1851   		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
;;;1852   
;;;1853   		taskSELECT_HIGHEST_PRIORITY_TASK();
0005fa  e004              B        |L1.1542|
                  |L1.1532|
0005fc  488e              LDR      r0,|L1.2104|
0005fe  6800              LDR      r0,[r0,#0]  ; uxTopReadyPriority
000600  1e40              SUBS     r0,r0,#1
000602  498d              LDR      r1,|L1.2104|
000604  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L1.1542|
000606  488c              LDR      r0,|L1.2104|
000608  6800              LDR      r0,[r0,#0]  ; uxTopReadyPriority
00060a  eb000080          ADD      r0,r0,r0,LSL #2
00060e  4989              LDR      r1,|L1.2100|
000610  f8510020          LDR      r0,[r1,r0,LSL #2]
000614  b908              CBNZ     r0,|L1.1562|
000616  2001              MOVS     r0,#1
000618  e000              B        |L1.1564|
                  |L1.1562|
00061a  2000              MOVS     r0,#0
                  |L1.1564|
00061c  2800              CMP      r0,#0
00061e  d1ed              BNE      |L1.1532|
000620  4985              LDR      r1,|L1.2104|
000622  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000624  eb010181          ADD      r1,r1,r1,LSL #2
000628  4a82              LDR      r2,|L1.2100|
00062a  eb020081          ADD      r0,r2,r1,LSL #2
00062e  6841              LDR      r1,[r0,#4]
000630  6849              LDR      r1,[r1,#4]
000632  6041              STR      r1,[r0,#4]
000634  f1000108          ADD      r1,r0,#8
000638  6842              LDR      r2,[r0,#4]
00063a  428a              CMP      r2,r1
00063c  d102              BNE      |L1.1604|
00063e  6841              LDR      r1,[r0,#4]
000640  6849              LDR      r1,[r1,#4]
000642  6041              STR      r1,[r0,#4]
                  |L1.1604|
000644  6841              LDR      r1,[r0,#4]
000646  68c9              LDR      r1,[r1,#0xc]
000648  4a74              LDR      r2,|L1.2076|
00064a  6011              STR      r1,[r2,#0]  ; pxCurrentTCB
00064c  bf00              NOP      
                  |L1.1614|
;;;1854   
;;;1855   		traceTASK_SWITCHED_IN();
;;;1856   
;;;1857   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1858   		{
;;;1859   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1860   			structure specific to this task. */
;;;1861   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1862   		}
;;;1863   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1864   	}
;;;1865   }
00064e  4770              BX       lr
;;;1866   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSuspend PROC
;;;1029   
;;;1030   	void vTaskSuspend( xTaskHandle xTaskToSuspend )
000650  b570              PUSH     {r4-r6,lr}
;;;1031   	{
000652  4605              MOV      r5,r0
;;;1032   	tskTCB *pxTCB;
;;;1033   
;;;1034   		taskENTER_CRITICAL();
000654  f7fffffe          BL       vPortEnterCritical
;;;1035   		{
;;;1036   			/* If null is passed in here then it is the running task that is
;;;1037   			being suspended. */
;;;1038   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000658  b915              CBNZ     r5,|L1.1632|
00065a  4870              LDR      r0,|L1.2076|
00065c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00065e  e000              B        |L1.1634|
                  |L1.1632|
000660  4628              MOV      r0,r5
                  |L1.1634|
000662  4604              MOV      r4,r0
;;;1039   
;;;1040   			traceTASK_SUSPEND( pxTCB );
;;;1041   
;;;1042   			/* Remove task from the ready/delayed list and place in the	suspended list. */
;;;1043   			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
000664  1d20              ADDS     r0,r4,#4
000666  f7fffffe          BL       uxListRemove
;;;1044   			{
;;;1045   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1046   			}
;;;1047   
;;;1048   			/* Is the task waiting on an event also? */
;;;1049   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00066a  6aa0              LDR      r0,[r4,#0x28]
00066c  b118              CBZ      r0,|L1.1654|
;;;1050   			{
;;;1051   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00066e  f1040018          ADD      r0,r4,#0x18
000672  f7fffffe          BL       uxListRemove
                  |L1.1654|
;;;1052   			}
;;;1053   
;;;1054   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
000676  1d21              ADDS     r1,r4,#4
000678  4871              LDR      r0,|L1.2112|
00067a  f7fffffe          BL       vListInsertEnd
;;;1055   		}
;;;1056   		taskEXIT_CRITICAL();
00067e  f7fffffe          BL       vPortExitCritical
;;;1057   
;;;1058   		if( pxTCB == pxCurrentTCB )
000682  4866              LDR      r0,|L1.2076|
000684  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000686  4284              CMP      r4,r0
000688  d111              BNE      |L1.1710|
;;;1059   		{
;;;1060   			if( xSchedulerRunning != pdFALSE )
00068a  486e              LDR      r0,|L1.2116|
00068c  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00068e  b110              CBZ      r0,|L1.1686|
;;;1061   			{
;;;1062   				/* The current task has just been suspended. */
;;;1063   				portYIELD_WITHIN_API();
000690  f7fffffe          BL       vPortYield
000694  e00b              B        |L1.1710|
                  |L1.1686|
;;;1064   			}
;;;1065   			else
;;;1066   			{
;;;1067   				/* The scheduler is not running, but the task that was pointed
;;;1068   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1069   				must be adjusted to point to a different task. */
;;;1070   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
000696  486a              LDR      r0,|L1.2112|
000698  6800              LDR      r0,[r0,#0]  ; xSuspendedTaskList
00069a  496b              LDR      r1,|L1.2120|
00069c  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
00069e  4288              CMP      r0,r1
0006a0  d103              BNE      |L1.1706|
;;;1071   				{
;;;1072   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1073   					NULL so when the next task is created pxCurrentTCB will
;;;1074   					be set to point to it no matter what its relative priority
;;;1075   					is. */
;;;1076   					pxCurrentTCB = NULL;
0006a2  2000              MOVS     r0,#0
0006a4  495d              LDR      r1,|L1.2076|
0006a6  6008              STR      r0,[r1,#0]  ; pxCurrentTCB
0006a8  e001              B        |L1.1710|
                  |L1.1706|
;;;1077   				}
;;;1078   				else
;;;1079   				{
;;;1080   					vTaskSwitchContext();
0006aa  f7fffffe          BL       vTaskSwitchContext
                  |L1.1710|
;;;1081   				}
;;;1082   			}
;;;1083   		}
;;;1084   	}
0006ae  bd70              POP      {r4-r6,pc}
;;;1085   
                          ENDP

                  xTaskIsTaskSuspended PROC
;;;1090   
;;;1091   	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
0006b0  b510              PUSH     {r4,lr}
;;;1092   	{
0006b2  4601              MOV      r1,r0
;;;1093   	portBASE_TYPE xReturn = pdFALSE;
0006b4  2000              MOVS     r0,#0
;;;1094   	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
0006b6  460a              MOV      r2,r1
;;;1095   
;;;1096   		/* It does not make sense to check if the calling task is suspended. */
;;;1097   		configASSERT( xTask );
;;;1098   
;;;1099   		/* Is the task we are attempting to resume actually in the
;;;1100   		suspended list? */
;;;1101   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
0006b8  4c61              LDR      r4,|L1.2112|
0006ba  6953              LDR      r3,[r2,#0x14]
0006bc  42a3              CMP      r3,r4
0006be  d101              BNE      |L1.1732|
0006c0  2301              MOVS     r3,#1
0006c2  e000              B        |L1.1734|
                  |L1.1732|
0006c4  2300              MOVS     r3,#0
                  |L1.1734|
0006c6  b173              CBZ      r3,|L1.1766|
;;;1102   		{
;;;1103   			/* Has the task already been resumed from within an ISR? */
;;;1104   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
0006c8  4c60              LDR      r4,|L1.2124|
0006ca  6a93              LDR      r3,[r2,#0x28]
0006cc  42a3              CMP      r3,r4
0006ce  d101              BNE      |L1.1748|
0006d0  2301              MOVS     r3,#1
0006d2  e000              B        |L1.1750|
                  |L1.1748|
0006d4  2300              MOVS     r3,#0
                  |L1.1750|
0006d6  b933              CBNZ     r3,|L1.1766|
;;;1105   			{
;;;1106   				/* Is it in the suspended list because it is in the
;;;1107   				Suspended state?  It is possible to be in the suspended
;;;1108   				list because it is blocked on a task with no timeout
;;;1109   				specified. */
;;;1110   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
0006d8  6a93              LDR      r3,[r2,#0x28]
0006da  b90b              CBNZ     r3,|L1.1760|
0006dc  2301              MOVS     r3,#1
0006de  e000              B        |L1.1762|
                  |L1.1760|
0006e0  2300              MOVS     r3,#0
                  |L1.1762|
0006e2  b103              CBZ      r3,|L1.1766|
;;;1111   				{
;;;1112   					xReturn = pdTRUE;
0006e4  2001              MOVS     r0,#1
                  |L1.1766|
;;;1113   				}
;;;1114   			}
;;;1115   		}
;;;1116   
;;;1117   		return xReturn;
;;;1118   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
0006e6  bd10              POP      {r4,pc}
;;;1119   
                          ENDP

                  vTaskResume PROC
;;;1124   
;;;1125   	void vTaskResume( xTaskHandle xTaskToResume )
0006e8  b570              PUSH     {r4-r6,lr}
;;;1126   	{
0006ea  4605              MOV      r5,r0
;;;1127   	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
0006ec  462c              MOV      r4,r5
;;;1128   
;;;1129   		/* It does not make sense to resume the calling task. */
;;;1130   		configASSERT( xTaskToResume );
;;;1131   
;;;1132   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1133   		currently executing task. */
;;;1134   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
0006ee  b344              CBZ      r4,|L1.1858|
0006f0  484a              LDR      r0,|L1.2076|
0006f2  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0006f4  4284              CMP      r4,r0
0006f6  d024              BEQ      |L1.1858|
;;;1135   		{
;;;1136   			taskENTER_CRITICAL();
0006f8  f7fffffe          BL       vPortEnterCritical
;;;1137   			{
;;;1138   				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
0006fc  4620              MOV      r0,r4
0006fe  f7fffffe          BL       xTaskIsTaskSuspended
000702  2801              CMP      r0,#1
000704  d11b              BNE      |L1.1854|
;;;1139   				{
;;;1140   					traceTASK_RESUME( pxTCB );
;;;1141   
;;;1142   					/* As we are in a critical section we can access the ready
;;;1143   					lists even if the scheduler is suspended. */
;;;1144   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
000706  1d20              ADDS     r0,r4,#4
000708  f7fffffe          BL       uxListRemove
;;;1145   					prvAddTaskToReadyList( pxTCB );
00070c  494a              LDR      r1,|L1.2104|
00070e  6ae0              LDR      r0,[r4,#0x2c]
000710  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000712  4288              CMP      r0,r1
000714  d902              BLS      |L1.1820|
000716  4948              LDR      r1,|L1.2104|
000718  6ae0              LDR      r0,[r4,#0x2c]
00071a  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L1.1820|
00071c  6ae1              LDR      r1,[r4,#0x2c]
00071e  eb010181          ADD      r1,r1,r1,LSL #2
000722  4a44              LDR      r2,|L1.2100|
000724  eb020081          ADD      r0,r2,r1,LSL #2
000728  1d21              ADDS     r1,r4,#4
00072a  f7fffffe          BL       vListInsertEnd
;;;1146   
;;;1147   					/* We may have just resumed a higher priority task. */
;;;1148   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00072e  493b              LDR      r1,|L1.2076|
000730  6ae0              LDR      r0,[r4,#0x2c]
000732  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000734  6ac9              LDR      r1,[r1,#0x2c]
000736  4288              CMP      r0,r1
000738  d301              BCC      |L1.1854|
;;;1149   					{
;;;1150   						/* This yield may not cause the task just resumed to run, but
;;;1151   						will leave the lists in the correct state for the next yield. */
;;;1152   						portYIELD_WITHIN_API();
00073a  f7fffffe          BL       vPortYield
                  |L1.1854|
;;;1153   					}
;;;1154   				}
;;;1155   			}
;;;1156   			taskEXIT_CRITICAL();
00073e  f7fffffe          BL       vPortExitCritical
                  |L1.1858|
;;;1157   		}
;;;1158   	}
000742  bd70              POP      {r4-r6,pc}
;;;1159   
                          ENDP

                  xTaskResumeFromISR PROC
;;;1165   
;;;1166   	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
000744  e92d41f0          PUSH     {r4-r8,lr}
;;;1167   	{
000748  4605              MOV      r5,r0
;;;1168   	portBASE_TYPE xYieldRequired = pdFALSE;
00074a  2600              MOVS     r6,#0
;;;1169   	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
00074c  462c              MOV      r4,r5
;;;1170   	unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1171   
;;;1172   		configASSERT( xTaskToResume );
;;;1173   
;;;1174   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1175   		maximum	system call (or maximum API call) interrupt priority.
;;;1176   		Interrupts that are	above the maximum system call priority are keep
;;;1177   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1178   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1179   		is defined in FreeRTOSConfig.h then
;;;1180   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1181   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1182   		been assigned a priority above the configured maximum system call
;;;1183   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1184   		from interrupts	that have been assigned a priority at or (logically)
;;;1185   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1186   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1187   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1188   		provided on the following link:
;;;1189   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1190   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1191   
;;;1192   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00074e  f7fffffe          BL       ulPortSetInterruptMask
000752  4607              MOV      r7,r0
;;;1193   		{
;;;1194   			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
000754  4620              MOV      r0,r4
000756  f7fffffe          BL       xTaskIsTaskSuspended
00075a  2801              CMP      r0,#1
00075c  d123              BNE      |L1.1958|
;;;1195   			{
;;;1196   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1197   
;;;1198   				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
00075e  4834              LDR      r0,|L1.2096|
000760  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000762  b9d8              CBNZ     r0,|L1.1948|
;;;1199   				{
;;;1200   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000764  492d              LDR      r1,|L1.2076|
000766  6ae0              LDR      r0,[r4,#0x2c]
000768  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00076a  6ac9              LDR      r1,[r1,#0x2c]
00076c  4288              CMP      r0,r1
00076e  d300              BCC      |L1.1906|
;;;1201   					{
;;;1202   						xYieldRequired = pdTRUE;
000770  2601              MOVS     r6,#1
                  |L1.1906|
;;;1203   					}
;;;1204   
;;;1205   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
000772  1d20              ADDS     r0,r4,#4
000774  f7fffffe          BL       uxListRemove
;;;1206   					prvAddTaskToReadyList( pxTCB );
000778  492f              LDR      r1,|L1.2104|
00077a  6ae0              LDR      r0,[r4,#0x2c]
00077c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00077e  4288              CMP      r0,r1
000780  d902              BLS      |L1.1928|
000782  492d              LDR      r1,|L1.2104|
000784  6ae0              LDR      r0,[r4,#0x2c]
000786  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L1.1928|
000788  6ae1              LDR      r1,[r4,#0x2c]
00078a  eb010181          ADD      r1,r1,r1,LSL #2
00078e  4a29              LDR      r2,|L1.2100|
000790  eb020081          ADD      r0,r2,r1,LSL #2
000794  1d21              ADDS     r1,r4,#4
000796  f7fffffe          BL       vListInsertEnd
00079a  e004              B        |L1.1958|
                  |L1.1948|
;;;1207   				}
;;;1208   				else
;;;1209   				{
;;;1210   					/* We cannot access the delayed or ready lists, so will hold this
;;;1211   					task pending until the scheduler is resumed, at which point a
;;;1212   					yield will be performed if necessary. */
;;;1213   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00079c  f1040118          ADD      r1,r4,#0x18
0007a0  482a              LDR      r0,|L1.2124|
0007a2  f7fffffe          BL       vListInsertEnd
                  |L1.1958|
;;;1214   				}
;;;1215   			}
;;;1216   		}
;;;1217   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0007a6  4638              MOV      r0,r7
0007a8  f7fffffe          BL       vPortClearInterruptMask
;;;1218   
;;;1219   		return xYieldRequired;
0007ac  4630              MOV      r0,r6
;;;1220   	}
0007ae  e8bd81f0          POP      {r4-r8,pc}
;;;1221   
                          ENDP

                  prvDeleteTCB PROC
;;;2599   
;;;2600   	static void prvDeleteTCB( tskTCB *pxTCB )
0007b2  b510              PUSH     {r4,lr}
;;;2601   	{
0007b4  4604              MOV      r4,r0
;;;2602   		/* This call is required specifically for the TriCore port.  It must be
;;;2603   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;2604   		want to allocate and clean RAM statically. */
;;;2605   		portCLEAN_UP_TCB( pxTCB );
;;;2606   
;;;2607   		/* Free up the memory allocated by the scheduler for the task.  It is up to
;;;2608   		the task to free any memory allocated at the application level. */
;;;2609   		vPortFreeAligned( pxTCB->pxStack );
0007b6  6b20              LDR      r0,[r4,#0x30]
0007b8  f7fffffe          BL       vPortFree
;;;2610   		vPortFree( pxTCB );
0007bc  4620              MOV      r0,r4
0007be  f7fffffe          BL       vPortFree
;;;2611   	}
0007c2  bd10              POP      {r4,pc}
;;;2612   
                          ENDP

                  prvCheckTasksWaitingTermination PROC
;;;2390   
;;;2391   static void prvCheckTasksWaitingTermination( void )
0007c4  b570              PUSH     {r4-r6,lr}
;;;2392   {
;;;2393   	#if ( INCLUDE_vTaskDelete == 1 )
;;;2394   	{
;;;2395   		portBASE_TYPE xListIsEmpty;
;;;2396   
;;;2397   		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
;;;2398   		too often in the idle task. */
;;;2399   		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
0007c6  e023              B        |L1.2064|
                  |L1.1992|
;;;2400   		{
;;;2401   			vTaskSuspendAll();
0007c8  f7fffffe          BL       vTaskSuspendAll
;;;2402   				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
0007cc  4820              LDR      r0,|L1.2128|
0007ce  6800              LDR      r0,[r0,#0]  ; xTasksWaitingTermination
0007d0  b908              CBNZ     r0,|L1.2006|
0007d2  2001              MOVS     r0,#1
0007d4  e000              B        |L1.2008|
                  |L1.2006|
0007d6  2000              MOVS     r0,#0
                  |L1.2008|
0007d8  4605              MOV      r5,r0
;;;2403   			( void ) xTaskResumeAll();
0007da  f7fffffe          BL       xTaskResumeAll
;;;2404   
;;;2405   			if( xListIsEmpty == pdFALSE )
0007de  b9bd              CBNZ     r5,|L1.2064|
;;;2406   			{
;;;2407   				tskTCB *pxTCB;
;;;2408   
;;;2409   				taskENTER_CRITICAL();
0007e0  f7fffffe          BL       vPortEnterCritical
;;;2410   				{
;;;2411   					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
0007e4  481a              LDR      r0,|L1.2128|
0007e6  68c0              LDR      r0,[r0,#0xc]
0007e8  68c4              LDR      r4,[r0,#0xc]
;;;2412   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
0007ea  1d20              ADDS     r0,r4,#4
0007ec  f7fffffe          BL       uxListRemove
;;;2413   					--uxCurrentNumberOfTasks;
0007f0  4815              LDR      r0,|L1.2120|
0007f2  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
0007f4  1e40              SUBS     r0,r0,#1
0007f6  4914              LDR      r1,|L1.2120|
0007f8  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;2414   					--uxTasksDeleted;
0007fa  4816              LDR      r0,|L1.2132|
0007fc  6800              LDR      r0,[r0,#0]  ; uxTasksDeleted
0007fe  1e40              SUBS     r0,r0,#1
000800  4914              LDR      r1,|L1.2132|
000802  6008              STR      r0,[r1,#0]  ; uxTasksDeleted
;;;2415   				}
;;;2416   				taskEXIT_CRITICAL();
000804  f7fffffe          BL       vPortExitCritical
;;;2417   
;;;2418   				prvDeleteTCB( pxTCB );
000808  4620              MOV      r0,r4
00080a  f7fffffe          BL       prvDeleteTCB
;;;2419   			}
00080e  bf00              NOP      
                  |L1.2064|
000810  4810              LDR      r0,|L1.2132|
000812  6800              LDR      r0,[r0,#0]            ;2399  ; uxTasksDeleted
000814  2800              CMP      r0,#0                 ;2399
000816  d1d7              BNE      |L1.1992|
;;;2420   		}
;;;2421   	}
;;;2422   	#endif /* vTaskDelete */
;;;2423   }
000818  bd70              POP      {r4-r6,pc}
00081a  0000              DCW      0x0000
                  |L1.2076|
                          DCD      pxCurrentTCB
                  |L1.2080|
                          DCD      xTickCount
                  |L1.2084|
                          DCD      pxOverflowDelayedTaskList
                  |L1.2088|
                          DCD      pxDelayedTaskList
                  |L1.2092|
                          DCD      xNextTaskUnblockTime
                  |L1.2096|
                          DCD      uxSchedulerSuspended
                  |L1.2100|
                          DCD      pxReadyTasksLists
                  |L1.2104|
                          DCD      uxTopReadyPriority
                  |L1.2108|
                          DCD      xYieldPending
                  |L1.2112|
                          DCD      xSuspendedTaskList
                  |L1.2116|
                          DCD      xSchedulerRunning
                  |L1.2120|
                          DCD      uxCurrentNumberOfTasks
                  |L1.2124|
                          DCD      xPendingReadyList
                  |L1.2128|
                          DCD      xTasksWaitingTermination
                  |L1.2132|
                          DCD      uxTasksDeleted
                          ENDP

                  prvIdleTask PROC
;;;2127    */
;;;2128   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000858  bf00              NOP      
                  |L1.2138|
;;;2129   {
;;;2130   	/* Stop warnings. */
;;;2131   	( void ) pvParameters;
;;;2132   
;;;2133   	for( ;; )
;;;2134   	{
;;;2135   		/* See if any tasks have been deleted. */
;;;2136   		prvCheckTasksWaitingTermination();
00085a  f7fffffe          BL       prvCheckTasksWaitingTermination
;;;2137   
;;;2138   		#if ( configUSE_PREEMPTION == 0 )
;;;2139   		{
;;;2140   			/* If we are not using preemption we keep forcing a task switch to
;;;2141   			see if any other task has become available.  If we are using
;;;2142   			preemption we don't need to do this as any task becoming available
;;;2143   			will automatically get the processor anyway. */
;;;2144   			taskYIELD();
;;;2145   		}
;;;2146   		#endif /* configUSE_PREEMPTION */
;;;2147   
;;;2148   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;2149   		{
;;;2150   			/* When using preemption tasks of equal priority will be
;;;2151   			timesliced.  If a task that is sharing the idle priority is ready
;;;2152   			to run then the idle task should yield before the end of the
;;;2153   			timeslice.
;;;2154   
;;;2155   			A critical region is not required here as we are just reading from
;;;2156   			the list, and an occasional incorrect value will not matter.  If
;;;2157   			the ready list at the idle priority contains more than one task
;;;2158   			then a task other than the idle task is ready to execute. */
;;;2159   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
00085e  4863              LDR      r0,|L1.2540|
000860  6800              LDR      r0,[r0,#0]  ; pxReadyTasksLists
000862  2801              CMP      r0,#1
000864  d9f9              BLS      |L1.2138|
;;;2160   			{
;;;2161   				taskYIELD();
000866  f7fffffe          BL       vPortYield
00086a  e7f6              B        |L1.2138|
;;;2162   			}
;;;2163   		}
;;;2164   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;2165   
;;;2166   		#if ( configUSE_IDLE_HOOK == 1 )
;;;2167   		{
;;;2168   			extern void vApplicationIdleHook( void );
;;;2169   
;;;2170   			/* Call the user defined function from within the idle task.  This
;;;2171   			allows the application designer to add background functionality
;;;2172   			without the overhead of a separate task.
;;;2173   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;2174   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;2175   			vApplicationIdleHook();
;;;2176   		}
;;;2177   		#endif /* configUSE_IDLE_HOOK */
;;;2178   
;;;2179   		/* This conditional compilation should use inequality to 0, not equality
;;;2180   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;2181   		user defined low power mode	implementations require
;;;2182   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;2183   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;2184   		{
;;;2185   		portTickType xExpectedIdleTime;
;;;2186   
;;;2187   			/* It is not desirable to suspend then resume the scheduler on
;;;2188   			each iteration of the idle task.  Therefore, a preliminary
;;;2189   			test of the expected idle time is performed without the
;;;2190   			scheduler suspended.  The result here is not necessarily
;;;2191   			valid. */
;;;2192   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2193   
;;;2194   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2195   			{
;;;2196   				vTaskSuspendAll();
;;;2197   				{
;;;2198   					/* Now the scheduler is suspended, the expected idle
;;;2199   					time can be sampled again, and this time its value can
;;;2200   					be used. */
;;;2201   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;2202   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2203   
;;;2204   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2205   					{
;;;2206   						traceLOW_POWER_IDLE_BEGIN();
;;;2207   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;2208   						traceLOW_POWER_IDLE_END();
;;;2209   					}
;;;2210   				}
;;;2211   				( void ) xTaskResumeAll();
;;;2212   			}
;;;2213   		}
;;;2214   		#endif /* configUSE_TICKLESS_IDLE */
;;;2215   	}
;;;2216   }
;;;2217   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskStartScheduler PROC
;;;1224   
;;;1225   void vTaskStartScheduler( void )
00086c  b51f              PUSH     {r0-r4,lr}
;;;1226   {
;;;1227   portBASE_TYPE xReturn;
;;;1228   
;;;1229   	/* Add the idle task at the lowest priority. */
;;;1230   	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
;;;1231   	{
;;;1232   		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
;;;1233   		be returned by the xTaskGetIdleTaskHandle() function. */
;;;1234   		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1235   	}
;;;1236   	#else
;;;1237   	{
;;;1238   		/* Create the idle task without storing its handle. */
;;;1239   		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
00086e  2000              MOVS     r0,#0
000870  9000              STR      r0,[sp,#0]
000872  9001              STR      r0,[sp,#4]
000874  9002              STR      r0,[sp,#8]
000876  4603              MOV      r3,r0
000878  2280              MOVS     r2,#0x80
00087a  a15d              ADR      r1,|L1.2544|
00087c  9003              STR      r0,[sp,#0xc]
00087e  485e              LDR      r0,|L1.2552|
000880  f7fffffe          BL       xTaskGenericCreate
000884  4604              MOV      r4,r0
;;;1240   	}
;;;1241   	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
;;;1242   
;;;1243   	#if ( configUSE_TIMERS == 1 )
;;;1244   	{
;;;1245   		if( xReturn == pdPASS )
;;;1246   		{
;;;1247   			xReturn = xTimerCreateTimerTask();
;;;1248   		}
;;;1249   	}
;;;1250   	#endif /* configUSE_TIMERS */
;;;1251   
;;;1252   	if( xReturn == pdPASS )
000886  2c01              CMP      r4,#1
000888  d109              BNE      |L1.2206|
;;;1253   	{
;;;1254   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1255   		before or during the call to xPortStartScheduler().  The stacks of
;;;1256   		the created tasks contain a status word with interrupts switched on
;;;1257   		so interrupts will automatically get re-enabled when the first task
;;;1258   		starts to run. */
;;;1259   		portDISABLE_INTERRUPTS();
00088a  f7fffffe          BL       ulPortSetInterruptMask
;;;1260   
;;;1261   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1262   		{
;;;1263   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1264   			structure specific to the task that will run first. */
;;;1265   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1266   		}
;;;1267   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1268   
;;;1269   		xSchedulerRunning = pdTRUE;
00088e  2001              MOVS     r0,#1
000890  495a              LDR      r1,|L1.2556|
000892  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1270   		xTickCount = ( portTickType ) 0U;
000894  2000              MOVS     r0,#0
000896  495a              LDR      r1,|L1.2560|
000898  6008              STR      r0,[r1,#0]  ; xTickCount
;;;1271   
;;;1272   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1273   		macro must be defined to configure the timer/counter used to generate
;;;1274   		the run time counter time base. */
;;;1275   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1276   
;;;1277   		/* Setting up the timer tick is hardware specific and thus in the
;;;1278   		portable interface. */
;;;1279   		if( xPortStartScheduler() != pdFALSE )
00089a  f7fffffe          BL       xPortStartScheduler
                  |L1.2206|
;;;1280   		{
;;;1281   			/* Should not reach here as if the scheduler is running the
;;;1282   			function will not return. */
;;;1283   		}
;;;1284   		else
;;;1285   		{
;;;1286   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1287   		}
;;;1288   	}
;;;1289   	else
;;;1290   	{
;;;1291   		/* This line will only be reached if the kernel could not be started,
;;;1292   		because there was not enough FreeRTOS heap to create the idle task
;;;1293   		or the timer task. */
;;;1294   		configASSERT( xReturn );
;;;1295   	}
;;;1296   }
00089e  bd1f              POP      {r0-r4,pc}
;;;1297   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskEndScheduler PROC
;;;1298   
;;;1299   void vTaskEndScheduler( void )
0008a0  b510              PUSH     {r4,lr}
;;;1300   {
;;;1301   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1302   	routine so the original ISRs can be restored if necessary.  The port
;;;1303   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1304   	portDISABLE_INTERRUPTS();
0008a2  f7fffffe          BL       ulPortSetInterruptMask
;;;1305   	xSchedulerRunning = pdFALSE;
0008a6  2000              MOVS     r0,#0
0008a8  4954              LDR      r1,|L1.2556|
0008aa  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1306   	vPortEndScheduler();
0008ac  f7fffffe          BL       vPortEndScheduler
;;;1307   }
0008b0  bd10              POP      {r4,pc}
;;;1308   /*----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCount PROC
;;;1413   
;;;1414   portTickType xTaskGetTickCount( void )
0008b2  b510              PUSH     {r4,lr}
;;;1415   {
;;;1416   portTickType xTicks;
;;;1417   
;;;1418   	/* Critical section required if running on a 16 bit processor. */
;;;1419   	taskENTER_CRITICAL();
0008b4  f7fffffe          BL       vPortEnterCritical
;;;1420   	{
;;;1421   		xTicks = xTickCount;
0008b8  4851              LDR      r0,|L1.2560|
0008ba  6804              LDR      r4,[r0,#0]  ; xTickCount
;;;1422   	}
;;;1423   	taskEXIT_CRITICAL();
0008bc  f7fffffe          BL       vPortExitCritical
;;;1424   
;;;1425   	return xTicks;
0008c0  4620              MOV      r0,r4
;;;1426   }
0008c2  bd10              POP      {r4,pc}
;;;1427   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCountFromISR PROC
;;;1428   
;;;1429   portTickType xTaskGetTickCountFromISR( void )
0008c4  b570              PUSH     {r4-r6,lr}
;;;1430   {
;;;1431   portTickType xReturn;
;;;1432   unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1433   
;;;1434   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1435   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1436   	above the maximum system call priority are keep permanently enabled, even
;;;1437   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1438   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1439   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1440   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1441   	assigned a priority above the configured maximum system call priority.
;;;1442   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1443   	that have been assigned a priority at or (logically) below the maximum
;;;1444   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1445   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1446   	More information (albeit Cortex-M specific) is provided on the following
;;;1447   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1448   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1449   
;;;1450   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0008c6  f7fffffe          BL       ulPortSetInterruptMask
0008ca  4605              MOV      r5,r0
;;;1451   	xReturn = xTickCount;
0008cc  484c              LDR      r0,|L1.2560|
0008ce  6804              LDR      r4,[r0,#0]  ; xTickCount
;;;1452   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0008d0  4628              MOV      r0,r5
0008d2  f7fffffe          BL       vPortClearInterruptMask
;;;1453   
;;;1454   	return xReturn;
0008d6  4620              MOV      r0,r4
;;;1455   }
0008d8  bd70              POP      {r4-r6,pc}
;;;1456   /*-----------------------------------------------------------*/
                          ENDP

                  uxTaskGetNumberOfTasks PROC
;;;1457   
;;;1458   unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
0008da  484a              LDR      r0,|L1.2564|
;;;1459   {
;;;1460   	/* A critical section is not required because the variables are of type
;;;1461   	portBASE_TYPE. */
;;;1462   	return uxCurrentNumberOfTasks;
0008dc  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
;;;1463   }
0008de  4770              BX       lr
;;;1464   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskPlaceOnEventList PROC
;;;1867   
;;;1868   void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
0008e0  b570              PUSH     {r4-r6,lr}
;;;1869   {
0008e2  4606              MOV      r6,r0
0008e4  460c              MOV      r4,r1
;;;1870   portTickType xTimeToWake;
;;;1871   
;;;1872   	configASSERT( pxEventList );
;;;1873   
;;;1874   	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
;;;1875   	SCHEDULER SUSPENDED. */
;;;1876   
;;;1877   	/* Place the event list item of the TCB in the appropriate event list.
;;;1878   	This is placed in the list in priority order so the highest priority task
;;;1879   	is the first to be woken by the event. */
;;;1880   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
0008e6  4848              LDR      r0,|L1.2568|
0008e8  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
0008ea  3118              ADDS     r1,r1,#0x18
0008ec  4630              MOV      r0,r6
0008ee  f7fffffe          BL       vListInsert
;;;1881   
;;;1882   	/* We must remove ourselves from the ready list before adding ourselves
;;;1883   	to the blocked list as the same list item is used for both lists.  We have
;;;1884   	exclusive access to the ready lists as the scheduler is locked. */
;;;1885   	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
0008f2  4845              LDR      r0,|L1.2568|
0008f4  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0008f6  1d00              ADDS     r0,r0,#4
0008f8  f7fffffe          BL       uxListRemove
;;;1886   	{
;;;1887   		/* The current task must be in a ready list, so there is no need to
;;;1888   		check, and the port reset macro can be called directly. */
;;;1889   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;1890   	}
;;;1891   
;;;1892   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;1893   	{
;;;1894   		if( xTicksToWait == portMAX_DELAY )
0008fc  1c60              ADDS     r0,r4,#1
0008fe  d106              BNE      |L1.2318|
;;;1895   		{
;;;1896   			/* Add ourselves to the suspended task list instead of a delayed task
;;;1897   			list to ensure we are not woken by a timing event.  We will block
;;;1898   			indefinitely. */
;;;1899   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000900  4841              LDR      r0,|L1.2568|
000902  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000904  1d09              ADDS     r1,r1,#4
000906  4841              LDR      r0,|L1.2572|
000908  f7fffffe          BL       vListInsertEnd
00090c  e005              B        |L1.2330|
                  |L1.2318|
;;;1900   		}
;;;1901   		else
;;;1902   		{
;;;1903   			/* Calculate the time at which the task should be woken if the event does
;;;1904   			not occur.  This may overflow but this doesn't matter. */
;;;1905   			xTimeToWake = xTickCount + xTicksToWait;
00090e  483c              LDR      r0,|L1.2560|
000910  6800              LDR      r0,[r0,#0]  ; xTickCount
000912  1905              ADDS     r5,r0,r4
;;;1906   			prvAddCurrentTaskToDelayedList( xTimeToWake );
000914  4628              MOV      r0,r5
000916  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.2330|
;;;1907   		}
;;;1908   	}
;;;1909   	#else /* INCLUDE_vTaskSuspend */
;;;1910   	{
;;;1911   			/* Calculate the time at which the task should be woken if the event does
;;;1912   			not occur.  This may overflow but this doesn't matter. */
;;;1913   			xTimeToWake = xTickCount + xTicksToWait;
;;;1914   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;1915   	}
;;;1916   	#endif /* INCLUDE_vTaskSuspend */
;;;1917   }
00091a  bd70              POP      {r4-r6,pc}
;;;1918   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskRemoveFromEventList PROC
;;;1960   
;;;1961   signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
00091c  b570              PUSH     {r4-r6,lr}
;;;1962   {
00091e  4606              MOV      r6,r0
;;;1963   tskTCB *pxUnblockedTCB;
;;;1964   portBASE_TYPE xReturn;
;;;1965   
;;;1966   	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
;;;1967   	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
;;;1968   
;;;1969   	/* The event list is sorted in priority order, so we can remove the
;;;1970   	first in the list, remove the TCB from the delayed list, and add
;;;1971   	it to the ready list.
;;;1972   
;;;1973   	If an event is for a queue that is locked then this function will never
;;;1974   	get called - the lock count on the queue will get modified instead.  This
;;;1975   	means we can always expect exclusive access to the event list here.
;;;1976   
;;;1977   	This function assumes that a check has already been made to ensure that
;;;1978   	pxEventList is not empty. */
;;;1979   	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000920  68f0              LDR      r0,[r6,#0xc]
000922  68c4              LDR      r4,[r0,#0xc]
;;;1980   	configASSERT( pxUnblockedTCB );
;;;1981   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000924  f1040018          ADD      r0,r4,#0x18
000928  f7fffffe          BL       uxListRemove
;;;1982   
;;;1983   	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
00092c  4838              LDR      r0,|L1.2576|
00092e  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000930  b9a0              CBNZ     r0,|L1.2396|
;;;1984   	{
;;;1985   		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
000932  1d20              ADDS     r0,r4,#4
000934  f7fffffe          BL       uxListRemove
;;;1986   		prvAddTaskToReadyList( pxUnblockedTCB );
000938  4936              LDR      r1,|L1.2580|
00093a  6ae0              LDR      r0,[r4,#0x2c]
00093c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00093e  4288              CMP      r0,r1
000940  d902              BLS      |L1.2376|
000942  4934              LDR      r1,|L1.2580|
000944  6ae0              LDR      r0,[r4,#0x2c]
000946  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L1.2376|
000948  6ae1              LDR      r1,[r4,#0x2c]
00094a  eb010181          ADD      r1,r1,r1,LSL #2
00094e  4a27              LDR      r2,|L1.2540|
000950  eb020081          ADD      r0,r2,r1,LSL #2
000954  1d21              ADDS     r1,r4,#4
000956  f7fffffe          BL       vListInsertEnd
00095a  e004              B        |L1.2406|
                  |L1.2396|
;;;1987   	}
;;;1988   	else
;;;1989   	{
;;;1990   		/* We cannot access the delayed or ready lists, so will hold this
;;;1991   		task pending until the scheduler is resumed. */
;;;1992   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
00095c  f1040118          ADD      r1,r4,#0x18
000960  482d              LDR      r0,|L1.2584|
000962  f7fffffe          BL       vListInsertEnd
                  |L1.2406|
;;;1993   	}
;;;1994   
;;;1995   	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
000966  4928              LDR      r1,|L1.2568|
000968  6ae0              LDR      r0,[r4,#0x2c]
00096a  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00096c  6ac9              LDR      r1,[r1,#0x2c]
00096e  4288              CMP      r0,r1
000970  d304              BCC      |L1.2428|
;;;1996   	{
;;;1997   		/* Return true if the task removed from the event list has
;;;1998   		a higher priority than the calling task.  This allows
;;;1999   		the calling task to know if it should force a context
;;;2000   		switch now. */
;;;2001   		xReturn = pdTRUE;
000972  2501              MOVS     r5,#1
;;;2002   
;;;2003   		/* Mark that a yield is pending in case the user is not using the
;;;2004   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2005   		xYieldPending = pdTRUE;
000974  2001              MOVS     r0,#1
000976  4929              LDR      r1,|L1.2588|
000978  6008              STR      r0,[r1,#0]  ; xYieldPending
00097a  e000              B        |L1.2430|
                  |L1.2428|
;;;2006   	}
;;;2007   	else
;;;2008   	{
;;;2009   		xReturn = pdFALSE;
00097c  2500              MOVS     r5,#0
                  |L1.2430|
;;;2010   	}
;;;2011   
;;;2012   	return xReturn;
00097e  4628              MOV      r0,r5
;;;2013   }
000980  bd70              POP      {r4-r6,pc}
;;;2014   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSetTimeOutState PROC
;;;2015   
;;;2016   void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
000982  4927              LDR      r1,|L1.2592|
;;;2017   {
;;;2018   	configASSERT( pxTimeOut );
;;;2019   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000984  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000986  6001              STR      r1,[r0,#0]
;;;2020   	pxTimeOut->xTimeOnEntering = xTickCount;
000988  491d              LDR      r1,|L1.2560|
00098a  6809              LDR      r1,[r1,#0]  ; xTickCount
00098c  6041              STR      r1,[r0,#4]
;;;2021   }
00098e  4770              BX       lr
;;;2022   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskCheckForTimeOut PROC
;;;2023   
;;;2024   portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
000990  b570              PUSH     {r4-r6,lr}
;;;2025   {
000992  4604              MOV      r4,r0
000994  460d              MOV      r5,r1
;;;2026   portBASE_TYPE xReturn;
;;;2027   
;;;2028   	configASSERT( pxTimeOut );
;;;2029   	configASSERT( pxTicksToWait );
;;;2030   
;;;2031   	taskENTER_CRITICAL();
000996  f7fffffe          BL       vPortEnterCritical
;;;2032   	{
;;;2033   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;2034   		const portTickType xConstTickCount = xTickCount;
00099a  4819              LDR      r0,|L1.2560|
00099c  6802              LDR      r2,[r0,#0]  ; xTickCount
;;;2035   
;;;2036   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;2037   			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
;;;2038   			the maximum block time then the task should block indefinitely, and
;;;2039   			therefore never time out. */
;;;2040   			if( *pxTicksToWait == portMAX_DELAY )
00099e  6828              LDR      r0,[r5,#0]
0009a0  1c40              ADDS     r0,r0,#1
0009a2  d101              BNE      |L1.2472|
;;;2041   			{
;;;2042   				xReturn = pdFALSE;
0009a4  2600              MOVS     r6,#0
0009a6  e019              B        |L1.2524|
                  |L1.2472|
;;;2043   			}
;;;2044   			else /* We are not blocking indefinitely, perform the checks below. */
;;;2045   		#endif
;;;2046   
;;;2047   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
0009a8  491d              LDR      r1,|L1.2592|
0009aa  6820              LDR      r0,[r4,#0]
0009ac  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
0009ae  4288              CMP      r0,r1
0009b0  d004              BEQ      |L1.2492|
0009b2  6860              LDR      r0,[r4,#4]
0009b4  4290              CMP      r0,r2
0009b6  d801              BHI      |L1.2492|
;;;2048   		{
;;;2049   			/* The tick count is greater than the time at which vTaskSetTimeout()
;;;2050   			was called, but has also overflowed since vTaskSetTimeOut() was called.
;;;2051   			It must have wrapped all the way around and gone past us again. This
;;;2052   			passed since vTaskSetTimeout() was called. */
;;;2053   			xReturn = pdTRUE;
0009b8  2601              MOVS     r6,#1
0009ba  e00f              B        |L1.2524|
                  |L1.2492|
;;;2054   		}
;;;2055   		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
0009bc  6860              LDR      r0,[r4,#4]
0009be  1a10              SUBS     r0,r2,r0
0009c0  6829              LDR      r1,[r5,#0]
0009c2  4288              CMP      r0,r1
0009c4  d209              BCS      |L1.2522|
;;;2056   		{
;;;2057   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;2058   			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
0009c6  6828              LDR      r0,[r5,#0]
0009c8  6861              LDR      r1,[r4,#4]
0009ca  1a51              SUBS     r1,r2,r1
0009cc  1a40              SUBS     r0,r0,r1
0009ce  6028              STR      r0,[r5,#0]
;;;2059   			vTaskSetTimeOutState( pxTimeOut );
0009d0  4620              MOV      r0,r4
0009d2  f7fffffe          BL       vTaskSetTimeOutState
;;;2060   			xReturn = pdFALSE;
0009d6  2600              MOVS     r6,#0
0009d8  e000              B        |L1.2524|
                  |L1.2522|
;;;2061   		}
;;;2062   		else
;;;2063   		{
;;;2064   			xReturn = pdTRUE;
0009da  2601              MOVS     r6,#1
                  |L1.2524|
;;;2065   		}
;;;2066   	}
;;;2067   	taskEXIT_CRITICAL();
0009dc  f7fffffe          BL       vPortExitCritical
;;;2068   
;;;2069   	return xReturn;
0009e0  4630              MOV      r0,r6
;;;2070   }
0009e2  bd70              POP      {r4-r6,pc}
;;;2071   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskMissedYield PROC
;;;2072   
;;;2073   void vTaskMissedYield( void )
0009e4  2001              MOVS     r0,#1
;;;2074   {
;;;2075   	xYieldPending = pdTRUE;
0009e6  490d              LDR      r1,|L1.2588|
0009e8  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;2076   }
0009ea  4770              BX       lr
;;;2077   /*-----------------------------------------------------------*/
                          ENDP

                  |L1.2540|
                          DCD      pxReadyTasksLists
                  |L1.2544|
0009f0  49444c45          DCB      "IDLE",0
0009f4  00      
0009f5  00                DCB      0
0009f6  00                DCB      0
0009f7  00                DCB      0
                  |L1.2552|
                          DCD      prvIdleTask
                  |L1.2556|
                          DCD      xSchedulerRunning
                  |L1.2560|
                          DCD      xTickCount
                  |L1.2564|
                          DCD      uxCurrentNumberOfTasks
                  |L1.2568|
                          DCD      pxCurrentTCB
                  |L1.2572|
                          DCD      xSuspendedTaskList
                  |L1.2576|
                          DCD      uxSchedulerSuspended
                  |L1.2580|
                          DCD      uxTopReadyPriority
                  |L1.2584|
                          DCD      xPendingReadyList
                  |L1.2588|
                          DCD      xYieldPending
                  |L1.2592|
                          DCD      xNumOfOverflows

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        100
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  uxTasksDeleted
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0xffffffff
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
