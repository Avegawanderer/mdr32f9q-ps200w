; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\tasks.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\tasks.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\tasks.crf ..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\tasks.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  prvInitialiseTaskLists PROC
;;;2358   
;;;2359   static void prvInitialiseTaskLists( void )
000000  b570              PUSH     {r4-r6,lr}
;;;2360   {
;;;2361   unsigned portBASE_TYPE uxPriority;
;;;2362   
;;;2363   	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
000002  2400              MOVS     r4,#0
;;;2364   	{
;;;2365   		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
000004  4dfe              LDR      r5,|L1.1024|
                  |L1.6|
000006  eb040084          ADD      r0,r4,r4,LSL #2
00000a  eb050080          ADD      r0,r5,r0,LSL #2
00000e  f7fffffe          BL       vListInitialise
000012  1c64              ADDS     r4,r4,#1              ;2363
000014  2c05              CMP      r4,#5                 ;2363
000016  d3f6              BCC      |L1.6|
;;;2366   	}
;;;2367   
;;;2368   	vListInitialise( &xDelayedTaskList1 );
000018  48f9              LDR      r0,|L1.1024|
00001a  3064              ADDS     r0,r0,#0x64
00001c  f7fffffe          BL       vListInitialise
;;;2369   	vListInitialise( &xDelayedTaskList2 );
000020  48f7              LDR      r0,|L1.1024|
000022  3078              ADDS     r0,r0,#0x78
000024  f7fffffe          BL       vListInitialise
;;;2370   	vListInitialise( &xPendingReadyList );
000028  48f5              LDR      r0,|L1.1024|
00002a  308c              ADDS     r0,r0,#0x8c
00002c  f7fffffe          BL       vListInitialise
;;;2371   
;;;2372   	#if ( INCLUDE_vTaskDelete == 1 )
;;;2373   	{
;;;2374   		vListInitialise( &xTasksWaitingTermination );
000030  48f3              LDR      r0,|L1.1024|
000032  30a0              ADDS     r0,r0,#0xa0
000034  f7fffffe          BL       vListInitialise
;;;2375   	}
;;;2376   	#endif /* INCLUDE_vTaskDelete */
;;;2377   
;;;2378   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;2379   	{
;;;2380   		vListInitialise( &xSuspendedTaskList );
000038  48f1              LDR      r0,|L1.1024|
00003a  30b4              ADDS     r0,r0,#0xb4
00003c  f7fffffe          BL       vListInitialise
;;;2381   	}
;;;2382   	#endif /* INCLUDE_vTaskSuspend */
;;;2383   
;;;2384   	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
;;;2385   	using list2. */
;;;2386   	pxDelayedTaskList = &xDelayedTaskList1;
000040  49ef              LDR      r1,|L1.1024|
000042  48f0              LDR      r0,|L1.1028|
000044  3164              ADDS     r1,r1,#0x64
000046  6301              STR      r1,[r0,#0x30]  ; pxDelayedTaskList
;;;2387   	pxOverflowDelayedTaskList = &xDelayedTaskList2;
000048  3114              ADDS     r1,r1,#0x14
00004a  6341              STR      r1,[r0,#0x34]  ; pxOverflowDelayedTaskList
;;;2388   }
00004c  bd70              POP      {r4-r6,pc}
;;;2389   /*-----------------------------------------------------------*/
                          ENDP

                  prvInitialiseTCBVariables PROC
;;;2258   
;;;2259   static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
00004e  b570              PUSH     {r4-r6,lr}
;;;2260   {
000050  4604              MOV      r4,r0
000052  4615              MOV      r5,r2
;;;2261   unsigned portBASE_TYPE x;
;;;2262   
;;;2263   	/* Store the task name in the TCB. */
;;;2264   	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
000054  2300              MOVS     r3,#0
                  |L1.86|
;;;2265   	{
;;;2266   		pxTCB->pcTaskName[ x ] = pcName[ x ];
000056  18e2              ADDS     r2,r4,r3
000058  5cc8              LDRB     r0,[r1,r3]
00005a  f8820034          STRB     r0,[r2,#0x34]
;;;2267   
;;;2268   		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;2269   		configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;2270   		string is not accessible (extremely unlikely). */
;;;2271   		if( pcName[ x ] == 0x00 )
00005e  5cc8              LDRB     r0,[r1,r3]
000060  b110              CBZ      r0,|L1.104|
000062  1c5b              ADDS     r3,r3,#1              ;2264
000064  2b10              CMP      r3,#0x10              ;2264
000066  d3f6              BCC      |L1.86|
                  |L1.104|
;;;2272   		{
;;;2273   			break;
;;;2274   		}
;;;2275   	}
;;;2276   
;;;2277   	/* Ensure the name string is terminated in the case that the string length
;;;2278   	was greater or equal to configMAX_TASK_NAME_LEN. */
;;;2279   	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
000068  2000              MOVS     r0,#0
00006a  f8840043          STRB     r0,[r4,#0x43]
;;;2280   
;;;2281   	/* This is used as an array index so must ensure it's not too large.  First
;;;2282   	remove the privilege bit if one is present. */
;;;2283   	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
00006e  2d05              CMP      r5,#5
000070  d300              BCC      |L1.116|
;;;2284   	{
;;;2285   		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
000072  2504              MOVS     r5,#4
                  |L1.116|
;;;2286   	}
;;;2287   
;;;2288   	pxTCB->uxPriority = uxPriority;
000074  62e5              STR      r5,[r4,#0x2c]
;;;2289   	#if ( configUSE_MUTEXES == 1 )
;;;2290   	{
;;;2291   		pxTCB->uxBasePriority = uxPriority;
;;;2292   	}
;;;2293   	#endif /* configUSE_MUTEXES */
;;;2294   
;;;2295   	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
000076  1d20              ADDS     r0,r4,#4
000078  f7fffffe          BL       vListInitialiseItem
;;;2296   	vListInitialiseItem( &( pxTCB->xEventListItem ) );
00007c  f1040018          ADD      r0,r4,#0x18
000080  f7fffffe          BL       vListInitialiseItem
;;;2297   
;;;2298   	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
;;;2299   	back to	the containing TCB from a generic item in a list. */
;;;2300   	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
000084  6124              STR      r4,[r4,#0x10]
;;;2301   
;;;2302   	/* Event lists are always in priority order. */
;;;2303   	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000086  f1c50005          RSB      r0,r5,#5
00008a  61a0              STR      r0,[r4,#0x18]
;;;2304   	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
00008c  6264              STR      r4,[r4,#0x24]
;;;2305   
;;;2306   	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;2307   	{
;;;2308   		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
;;;2309   	}
;;;2310   	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;2311   
;;;2312   	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;2313   	{
;;;2314   		pxTCB->pxTaskTag = NULL;
;;;2315   	}
;;;2316   	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;2317   
;;;2318   	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2319   	{
;;;2320   		pxTCB->ulRunTimeCounter = 0UL;
;;;2321   	}
;;;2322   	#endif /* configGENERATE_RUN_TIME_STATS */
;;;2323   
;;;2324   	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;2325   	{
;;;2326   		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
;;;2327   	}
;;;2328   	#else /* portUSING_MPU_WRAPPERS */
;;;2329   	{
;;;2330   		( void ) xRegions;
;;;2331   		( void ) usStackDepth;
;;;2332   	}
;;;2333   	#endif /* portUSING_MPU_WRAPPERS */
;;;2334   
;;;2335   	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2336   	{
;;;2337   		/* Initialise this task's Newlib reent structure. */
;;;2338   		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
;;;2339   	}
;;;2340   	#endif /* configUSE_NEWLIB_REENTRANT */
;;;2341   }
00008e  bd70              POP      {r4-r6,pc}
;;;2342   /*-----------------------------------------------------------*/
                          ENDP

                  prvAllocateTCBAndStack PROC
;;;2451   
;;;2452   static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
000090  b570              PUSH     {r4-r6,lr}
;;;2453   {
000092  4606              MOV      r6,r0
000094  460d              MOV      r5,r1
;;;2454   tskTCB *pxNewTCB;
;;;2455   
;;;2456   	/* Allocate space for the TCB.  Where the memory comes from depends on
;;;2457   	the implementation of the port malloc function. */
;;;2458   	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
000096  2044              MOVS     r0,#0x44
000098  f7fffffe          BL       pvPortMalloc
00009c  4604              MOV      r4,r0
;;;2459   
;;;2460   	if( pxNewTCB != NULL )
00009e  b144              CBZ      r4,|L1.178|
;;;2461   	{
;;;2462   		/* Allocate space for the stack used by the task being created.
;;;2463   		The base of the stack memory stored in the TCB so the task can
;;;2464   		be deleted later if required. */
;;;2465   		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0000a0  00b6              LSLS     r6,r6,#2
0000a2  b145              CBZ      r5,|L1.182|
0000a4  4628              MOV      r0,r5
                  |L1.166|
0000a6  6320              STR      r0,[r4,#0x30]
;;;2466   
;;;2467   		if( pxNewTCB->pxStack == NULL )
0000a8  b148              CBZ      r0,|L1.190|
;;;2468   		{
;;;2469   			/* Could not allocate the stack.  Delete the allocated TCB. */
;;;2470   			vPortFree( pxNewTCB );
;;;2471   			pxNewTCB = NULL;
;;;2472   		}
;;;2473   		else
;;;2474   		{
;;;2475   			/* Just to help debugging. */
;;;2476   			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
0000aa  22a5              MOVS     r2,#0xa5
0000ac  4631              MOV      r1,r6
0000ae  f7fffffe          BL       __aeabi_memset
                  |L1.178|
;;;2477   		}
;;;2478   	}
;;;2479   
;;;2480   	return pxNewTCB;
0000b2  4620              MOV      r0,r4
;;;2481   }
0000b4  bd70              POP      {r4-r6,pc}
                  |L1.182|
0000b6  4630              MOV      r0,r6                 ;2465
0000b8  f7fffffe          BL       pvPortMalloc
0000bc  e7f3              B        |L1.166|
                  |L1.190|
0000be  4620              MOV      r0,r4                 ;2470
0000c0  f7fffffe          BL       vPortFree
0000c4  2400              MOVS     r4,#0                 ;2471
0000c6  e7f4              B        |L1.178|
;;;2482   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGenericCreate PROC
;;;478    
;;;479    signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
0000c8  e92d4fff          PUSH     {r0-r11,lr}
;;;480    {
0000cc  b081              SUB      sp,sp,#4
0000ce  4682              MOV      r10,r0
0000d0  e9dd680e          LDRD     r6,r8,[sp,#0x38]
0000d4  9910              LDR      r1,[sp,#0x40]
0000d6  4617              MOV      r7,r2
0000d8  469b              MOV      r11,r3
;;;481    signed portBASE_TYPE xReturn;
;;;482    tskTCB * pxNewTCB;
;;;483    
;;;484    	configASSERT( pxTaskCode );
;;;485    	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
;;;486    
;;;487    	/* Allocate the memory required by the TCB and stack for the new task,
;;;488    	checking that the allocation was successful. */
;;;489    	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
0000da  4638              MOV      r0,r7
0000dc  f7fffffe          BL       prvAllocateTCBAndStack
0000e0  4604              MOV      r4,r0
;;;490    
;;;491    	if( pxNewTCB != NULL )
;;;492    	{
;;;493    		portSTACK_TYPE *pxTopOfStack;
;;;494    
;;;495    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;496    			/* Should the task be created in privileged mode? */
;;;497    			portBASE_TYPE xRunPrivileged;
;;;498    			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;499    			{
;;;500    				xRunPrivileged = pdTRUE;
;;;501    			}
;;;502    			else
;;;503    			{
;;;504    				xRunPrivileged = pdFALSE;
;;;505    			}
;;;506    			uxPriority &= ~portPRIVILEGE_BIT;
;;;507    		#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;508    
;;;509    		/* Calculate the top of stack address.  This depends on whether the
;;;510    		stack grows from high memory to low (as per the 80x86) or visa versa.
;;;511    		portSTACK_GROWTH is used to make the result positive or negative as
;;;512    		required by the port. */
;;;513    		#if( portSTACK_GROWTH < 0 )
;;;514    		{
;;;515    			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
;;;516    			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
;;;517    
;;;518    			/* Check the alignment of the calculated top of stack is correct. */
;;;519    			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;520    		}
;;;521    		#else /* portSTACK_GROWTH */
;;;522    		{
;;;523    			pxTopOfStack = pxNewTCB->pxStack;
;;;524    
;;;525    			/* Check the alignment of the stack buffer is correct. */
;;;526    			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;527    
;;;528    			/* If we want to use stack checking on architectures that use
;;;529    			a positive stack growth direction then we also need to store the
;;;530    			other extreme of the stack space. */
;;;531    			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
;;;532    		}
;;;533    		#endif /* portSTACK_GROWTH */
;;;534    
;;;535    		/* Setup the newly allocated TCB with the initial state of the task. */
;;;536    		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
;;;537    
;;;538    		/* Initialize the TCB stack to look as if the task was already running,
;;;539    		but had been interrupted by the scheduler.  The return address is set
;;;540    		to the start of the task function. Once the stack has been initialised
;;;541    		the	top of stack variable is updated. */
;;;542    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;543    		{
;;;544    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;545    		}
;;;546    		#else /* portUSING_MPU_WRAPPERS */
;;;547    		{
;;;548    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
;;;549    		}
;;;550    		#endif /* portUSING_MPU_WRAPPERS */
;;;551    
;;;552    		if( ( void * ) pxCreatedTask != NULL )
;;;553    		{
;;;554    			/* Pass the TCB out - in an anonymous way.  The calling function/
;;;555    			task can use this as a handle to delete the task later if
;;;556    			required.*/
;;;557    			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
;;;558    		}
;;;559    
;;;560    		/* Ensure interrupts don't access the task lists while they are being
;;;561    		updated. */
;;;562    		taskENTER_CRITICAL();
;;;563    		{
;;;564    			uxCurrentNumberOfTasks++;
0000e2  4dc8              LDR      r5,|L1.1028|
0000e4  b3f4              CBZ      r4,|L1.356|
0000e6  6b21              LDR      r1,[r4,#0x30]         ;515
0000e8  1e78              SUBS     r0,r7,#1              ;515
0000ea  eb010080          ADD      r0,r1,r0,LSL #2       ;515
0000ee  f0200907          BIC      r9,r0,#7              ;516
0000f2  9700              STR      r7,[sp,#0]            ;536
0000f4  4632              MOV      r2,r6                 ;536
0000f6  4620              MOV      r0,r4                 ;536
0000f8  9b11              LDR      r3,[sp,#0x44]         ;536
0000fa  9902              LDR      r1,[sp,#8]            ;536
0000fc  f7fffffe          BL       prvInitialiseTCBVariables
000100  465a              MOV      r2,r11                ;548
000102  4651              MOV      r1,r10                ;548
000104  4648              MOV      r0,r9                 ;548
000106  f7fffffe          BL       pxPortInitialiseStack
00010a  6020              STR      r0,[r4,#0]            ;548
00010c  f1b80f00          CMP      r8,#0                 ;552
000110  d001              BEQ      |L1.278|
000112  f8c84000          STR      r4,[r8,#0]            ;557
                  |L1.278|
000116  f7fffffe          BL       vPortEnterCritical
00011a  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
00011c  1c40              ADDS     r0,r0,#1
00011e  60a8              STR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;565    			if( pxCurrentTCB == NULL )
000120  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000122  b110              CBZ      r0,|L1.298|
;;;566    			{
;;;567    				/* There are no other tasks, or all the other tasks are in
;;;568    				the suspended state - make this the current task. */
;;;569    				pxCurrentTCB =  pxNewTCB;
;;;570    
;;;571    				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
;;;572    				{
;;;573    					/* This is the first task to be created so do the preliminary
;;;574    					initialisation required.  We will not recover if this call
;;;575    					fails, but we will report the failure. */
;;;576    					prvInitialiseTaskLists();
;;;577    				}
;;;578    			}
;;;579    			else
;;;580    			{
;;;581    				/* If the scheduler is not already running, make this task the
;;;582    				current task if it is the highest priority task to be created
;;;583    				so far. */
;;;584    				if( xSchedulerRunning == pdFALSE )
000124  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000126  b138              CBZ      r0,|L1.312|
000128  e00b              B        |L1.322|
                  |L1.298|
00012a  602c              STR      r4,[r5,#0]            ;569  ; pxCurrentTCB
00012c  68a8              LDR      r0,[r5,#8]            ;571  ; uxCurrentNumberOfTasks
00012e  2801              CMP      r0,#1                 ;571
000130  d107              BNE      |L1.322|
000132  f7fffffe          BL       prvInitialiseTaskLists
000136  e004              B        |L1.322|
                  |L1.312|
;;;585    				{
;;;586    					if( pxCurrentTCB->uxPriority <= uxPriority )
000138  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00013a  6ac0              LDR      r0,[r0,#0x2c]
00013c  42b0              CMP      r0,r6
00013e  d800              BHI      |L1.322|
;;;587    					{
;;;588    						pxCurrentTCB = pxNewTCB;
000140  602c              STR      r4,[r5,#0]  ; pxCurrentTCB
                  |L1.322|
;;;589    					}
;;;590    				}
;;;591    			}
;;;592    
;;;593    			uxTaskNumber++;
000142  6aa8              LDR      r0,[r5,#0x28]  ; uxTaskNumber
000144  1c40              ADDS     r0,r0,#1
000146  62a8              STR      r0,[r5,#0x28]  ; uxTaskNumber
;;;594    
;;;595    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;596    			{
;;;597    				/* Add a counter into the TCB for tracing only. */
;;;598    				pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;599    			}
;;;600    			#endif /* configUSE_TRACE_FACILITY */
;;;601    			traceTASK_CREATE( pxNewTCB );
;;;602    
;;;603    			prvAddTaskToReadyList( pxNewTCB );
000148  6ae0              LDR      r0,[r4,#0x2c]
00014a  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
00014c  4288              CMP      r0,r1
00014e  d900              BLS      |L1.338|
000150  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L1.338|
000152  49ab              LDR      r1,|L1.1024|
000154  eb000080          ADD      r0,r0,r0,LSL #2
000158  eb010080          ADD      r0,r1,r0,LSL #2
00015c  1d21              ADDS     r1,r4,#4
00015e  f7fffffe          BL       vListInsertEnd
;;;604    
;;;605    			xReturn = pdPASS;
000162  e000              B        |L1.358|
                  |L1.356|
000164  e003              B        |L1.366|
                  |L1.358|
000166  2401              MOVS     r4,#1
;;;606    			portSETUP_TCB( pxNewTCB );
;;;607    		}
;;;608    		taskEXIT_CRITICAL();
000168  f7fffffe          BL       vPortExitCritical
;;;609    	}
00016c  e001              B        |L1.370|
                  |L1.366|
;;;610    	else
;;;611    	{
;;;612    		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
00016e  f04f34ff          MOV      r4,#0xffffffff
                  |L1.370|
;;;613    		traceTASK_CREATE_FAILED();
;;;614    	}
;;;615    
;;;616    	if( xReturn == pdPASS )
000172  2c01              CMP      r4,#1
000174  d107              BNE      |L1.390|
;;;617    	{
;;;618    		if( xSchedulerRunning != pdFALSE )
000176  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000178  b128              CBZ      r0,|L1.390|
;;;619    		{
;;;620    			/* If the created task is of a higher priority than the current task
;;;621    			then it should run now. */
;;;622    			if( pxCurrentTCB->uxPriority < uxPriority )
00017a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00017c  6ac0              LDR      r0,[r0,#0x2c]
00017e  42b0              CMP      r0,r6
000180  d201              BCS      |L1.390|
;;;623    			{
;;;624    				portYIELD_WITHIN_API();
000182  f7fffffe          BL       vPortYield
                  |L1.390|
;;;625    			}
;;;626    		}
;;;627    	}
;;;628    
;;;629    	return xReturn;
;;;630    }
000186  b005              ADD      sp,sp,#0x14
000188  4620              MOV      r0,r4                 ;629
00018a  e8bd8ff0          POP      {r4-r11,pc}
;;;631    /*-----------------------------------------------------------*/
                          ENDP

                  vTaskDelete PROC
;;;634    
;;;635    	void vTaskDelete( xTaskHandle xTaskToDelete )
00018e  b570              PUSH     {r4-r6,lr}
;;;636    	{
000190  4604              MOV      r4,r0
;;;637    	tskTCB *pxTCB;
;;;638    
;;;639    		taskENTER_CRITICAL();
000192  f7fffffe          BL       vPortEnterCritical
;;;640    		{
;;;641    			/* If null is passed in here then we are deleting ourselves. */
;;;642    			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000196  4d9b              LDR      r5,|L1.1028|
000198  b904              CBNZ     r4,|L1.412|
00019a  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L1.412|
;;;643    
;;;644    			/* Remove task from the ready list and place in the	termination list.
;;;645    			This will stop the task from be scheduled.  The idle task will check
;;;646    			the termination list and free up any memory allocated by the
;;;647    			scheduler for the TCB and stack. */
;;;648    			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
00019c  1d20              ADDS     r0,r4,#4
00019e  f7fffffe          BL       uxListRemove
;;;649    			{
;;;650    				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;651    			}
;;;652    
;;;653    			/* Is the task waiting on an event also? */
;;;654    			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
0001a2  6aa0              LDR      r0,[r4,#0x28]
0001a4  b118              CBZ      r0,|L1.430|
;;;655    			{
;;;656    				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
0001a6  f1040018          ADD      r0,r4,#0x18
0001aa  f7fffffe          BL       uxListRemove
                  |L1.430|
;;;657    			}
;;;658    
;;;659    			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
0001ae  4894              LDR      r0,|L1.1024|
0001b0  1d21              ADDS     r1,r4,#4
0001b2  30a0              ADDS     r0,r0,#0xa0
0001b4  f7fffffe          BL       vListInsertEnd
;;;660    
;;;661    			/* Increment the ucTasksDeleted variable so the idle task knows
;;;662    			there is a task that has been deleted and that it should therefore
;;;663    			check the xTasksWaitingTermination list. */
;;;664    			++uxTasksDeleted;
0001b8  6868              LDR      r0,[r5,#4]  ; uxTasksDeleted
0001ba  1c40              ADDS     r0,r0,#1
0001bc  6068              STR      r0,[r5,#4]  ; uxTasksDeleted
;;;665    
;;;666    			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
;;;667    			can detect that the task lists need re-generating. */
;;;668    			uxTaskNumber++;
0001be  6aa8              LDR      r0,[r5,#0x28]  ; uxTaskNumber
0001c0  1c40              ADDS     r0,r0,#1
0001c2  62a8              STR      r0,[r5,#0x28]  ; uxTaskNumber
;;;669    
;;;670    			traceTASK_DELETE( pxTCB );
;;;671    		}
;;;672    		taskEXIT_CRITICAL();
0001c4  f7fffffe          BL       vPortExitCritical
;;;673    
;;;674    		/* Force a reschedule if we have just deleted the current task. */
;;;675    		if( xSchedulerRunning != pdFALSE )
0001c8  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
0001ca  2800              CMP      r0,#0
0001cc  d006              BEQ      |L1.476|
;;;676    		{
;;;677    			if( pxTCB == pxCurrentTCB )
0001ce  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
0001d0  4284              CMP      r4,r0
0001d2  d103              BNE      |L1.476|
;;;678    			{
;;;679    				portYIELD_WITHIN_API();
0001d4  e8bd4070          POP      {r4-r6,lr}
0001d8  f7ffbffe          B.W      vPortYield
                  |L1.476|
;;;680    			}
;;;681    		}
;;;682    	}
0001dc  bd70              POP      {r4-r6,pc}
;;;683    
                          ENDP

                  xTaskIncrementTick PROC
;;;1582   
;;;1583   portBASE_TYPE xTaskIncrementTick( void )
0001de  e92d47f0          PUSH     {r4-r10,lr}
;;;1584   {
;;;1585   tskTCB * pxTCB;
;;;1586   portTickType xItemValue;
;;;1587   portBASE_TYPE xSwitchRequired = pdFALSE;
0001e2  2500              MOVS     r5,#0
;;;1588   
;;;1589   	/* Called by the portable layer each time a tick interrupt occurs.
;;;1590   	Increments the tick then checks to see if the new tick value will cause any
;;;1591   	tasks to be unblocked. */
;;;1592   	traceTASK_INCREMENT_TICK( xTickCount );
;;;1593   	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
0001e4  4f87              LDR      r7,|L1.1028|
0001e6  69b8              LDR      r0,[r7,#0x18]  ; uxSchedulerSuspended
0001e8  b150              CBZ      r0,|L1.512|
;;;1594   	{
;;;1595   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;1596   		delayed lists if it wraps to 0. */
;;;1597   		++xTickCount;
;;;1598   
;;;1599   		{
;;;1600   			/* Minor optimisation.  The tick count cannot change in this
;;;1601   			block. */
;;;1602   			const portTickType xConstTickCount = xTickCount;
;;;1603   
;;;1604   			if( xConstTickCount == ( portTickType ) 0U )
;;;1605   			{
;;;1606   				taskSWITCH_DELAYED_LISTS();
;;;1607   			}
;;;1608   
;;;1609   			/* See if this tick has made a timeout expire.  Tasks are stored in the
;;;1610   			queue in the order of their wake time - meaning once one tasks has been
;;;1611   			found whose block time has not expired there is no need not look any
;;;1612   			further	down the list. */
;;;1613   			if( xConstTickCount >= xNextTaskUnblockTime )
;;;1614   			{
;;;1615   				for( ;; )
;;;1616   				{
;;;1617   					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
;;;1618   					{
;;;1619   						/* The delayed list is empty.  Set xNextTaskUnblockTime to
;;;1620   						the	maximum possible value so it is extremely unlikely that
;;;1621   						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;1622   						next time through. */
;;;1623   						xNextTaskUnblockTime = portMAX_DELAY;
;;;1624   						break;
;;;1625   					}
;;;1626   					else
;;;1627   					{
;;;1628   						/* The delayed list is not empty, get the value of the item
;;;1629   						at the head of the delayed list.  This is the time at which
;;;1630   						the task at the head of the delayed list must be removed
;;;1631   						from the Blocked state. */
;;;1632   						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
;;;1633   						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
;;;1634   
;;;1635   						if( xConstTickCount < xItemValue )
;;;1636   						{
;;;1637   							/* It is not time to unblock this item yet, but the item
;;;1638   							value is the time at which the task at the head of the
;;;1639   							blocked list must be removed from the Blocked state -
;;;1640   							so record the item value in xNextTaskUnblockTime. */
;;;1641   							xNextTaskUnblockTime = xItemValue;
;;;1642   							break;
;;;1643   						}
;;;1644   
;;;1645   						/* It is time to remove the item from the Blocked state. */
;;;1646   						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;1647   
;;;1648   						/* Is the task waiting on an event also?  If so remove it
;;;1649   						from the event list. */
;;;1650   						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
;;;1651   						{
;;;1652   							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;1653   						}
;;;1654   
;;;1655   						/* Place the unblocked task into the appropriate ready
;;;1656   						list. */
;;;1657   						prvAddTaskToReadyList( pxTCB );
;;;1658   
;;;1659   						/* A task being unblocked cannot cause an immediate context
;;;1660   						switch if preemption is turned off. */
;;;1661   						#if (  configUSE_PREEMPTION == 1 )
;;;1662   						{
;;;1663   							/* Preemption is on, but a context switch should only
;;;1664   							be performed if the unblocked task has a priority that
;;;1665   							is equal to or higher than the currently executing
;;;1666   							task. */
;;;1667   							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;1668   							{
;;;1669   								xSwitchRequired = pdTRUE;
;;;1670   							}
;;;1671   						}
;;;1672   						#endif /* configUSE_PREEMPTION */
;;;1673   					}
;;;1674   				}
;;;1675   			}
;;;1676   		}
;;;1677   
;;;1678   		/* Tasks of equal priority to the currently running task will share
;;;1679   		processing time (time slice) if preemption is on, and the application
;;;1680   		writer has not explicitly turned time slicing off. */
;;;1681   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;1682   		{
;;;1683   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
;;;1684   			{
;;;1685   				xSwitchRequired = pdTRUE;
;;;1686   			}
;;;1687   		}
;;;1688   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;1689   		
;;;1690   		#if ( configUSE_TICK_HOOK == 1 )
;;;1691   		{
;;;1692   			/* Guard against the tick hook being called when the pended tick
;;;1693   			count is being unwound (when the scheduler is being unlocked). */
;;;1694   			if( uxPendedTicks == ( unsigned portBASE_TYPE ) 0U )
;;;1695   			{
;;;1696   				vApplicationTickHook();
;;;1697   			}
;;;1698   		}
;;;1699   		#endif /* configUSE_TICK_HOOK */		
;;;1700   	}
;;;1701   	else
;;;1702   	{
;;;1703   		++uxPendedTicks;
0001ea  69f8              LDR      r0,[r7,#0x1c]  ; uxPendedTicks
0001ec  1c40              ADDS     r0,r0,#1
0001ee  61f8              STR      r0,[r7,#0x1c]  ; uxPendedTicks
;;;1704   
;;;1705   		/* The tick hook gets called at regular intervals, even if the
;;;1706   		scheduler is locked. */
;;;1707   		#if ( configUSE_TICK_HOOK == 1 )
;;;1708   		{
;;;1709   			vApplicationTickHook();
0001f0  f7fffffe          BL       vApplicationTickHook
                  |L1.500|
;;;1710   		}
;;;1711   		#endif
;;;1712   	}
;;;1713   
;;;1714   	#if ( configUSE_PREEMPTION == 1 )
;;;1715   	{
;;;1716   		if( xYieldPending != pdFALSE )
0001f4  6a38              LDR      r0,[r7,#0x20]  ; xYieldPending
0001f6  b100              CBZ      r0,|L1.506|
;;;1717   		{
;;;1718   			xSwitchRequired = pdTRUE;
0001f8  2501              MOVS     r5,#1
                  |L1.506|
;;;1719   		}
;;;1720   	}
;;;1721   	#endif /* configUSE_PREEMPTION */
;;;1722   
;;;1723   	return xSwitchRequired;
0001fa  4628              MOV      r0,r5
;;;1724   }
0001fc  e8bd87f0          POP      {r4-r10,pc}
                  |L1.512|
000200  68f8              LDR      r0,[r7,#0xc]          ;1597  ; xTickCount
000202  1c40              ADDS     r0,r0,#1              ;1597
000204  60f8              STR      r0,[r7,#0xc]          ;1597  ; xTickCount
000206  68fe              LDR      r6,[r7,#0xc]          ;1602  ; xTickCount
000208  f04f39ff          MOV      r9,#0xffffffff        ;1606
00020c  b976              CBNZ     r6,|L1.556|
00020e  6b38              LDR      r0,[r7,#0x30]         ;1606  ; pxDelayedTaskList
000210  6b79              LDR      r1,[r7,#0x34]         ;1606  ; pxOverflowDelayedTaskList
000212  6339              STR      r1,[r7,#0x30]         ;1606  ; pxDelayedTaskList
000214  6378              STR      r0,[r7,#0x34]         ;1606  ; pxOverflowDelayedTaskList
000216  6a78              LDR      r0,[r7,#0x24]         ;1606  ; xNumOfOverflows
000218  1c40              ADDS     r0,r0,#1              ;1606
00021a  6278              STR      r0,[r7,#0x24]         ;1606  ; xNumOfOverflows
00021c  6b38              LDR      r0,[r7,#0x30]         ;1606  ; pxDelayedTaskList
00021e  6800              LDR      r0,[r0,#0]            ;1606
000220  b1a0              CBZ      r0,|L1.588|
000222  6b38              LDR      r0,[r7,#0x30]         ;1606  ; pxDelayedTaskList
000224  68c0              LDR      r0,[r0,#0xc]          ;1606
000226  68c0              LDR      r0,[r0,#0xc]          ;1606
000228  6840              LDR      r0,[r0,#4]            ;1606
00022a  62f8              STR      r0,[r7,#0x2c]         ;1606  ; xNextTaskUnblockTime
                  |L1.556|
00022c  6af8              LDR      r0,[r7,#0x2c]         ;1613  ; xNextTaskUnblockTime
00022e  f8df81d0          LDR      r8,|L1.1024|
000232  4286              CMP      r6,r0                 ;1613
000234  d30f              BCC      |L1.598|
                  |L1.566|
000236  6b38              LDR      r0,[r7,#0x30]         ;1617  ; pxDelayedTaskList
000238  6800              LDR      r0,[r0,#0]            ;1617
00023a  b150              CBZ      r0,|L1.594|
00023c  6b38              LDR      r0,[r7,#0x30]         ;1632  ; pxDelayedTaskList
00023e  68c0              LDR      r0,[r0,#0xc]          ;1632
000240  68c4              LDR      r4,[r0,#0xc]          ;1632
000242  6860              LDR      r0,[r4,#4]            ;1633
000244  4286              CMP      r6,r0                 ;1635
000246  d215              BCS      |L1.628|
000248  62f8              STR      r0,[r7,#0x2c]         ;1641  ; xNextTaskUnblockTime
00024a  e004              B        |L1.598|
                  |L1.588|
00024c  f8c7902c          STR      r9,[r7,#0x2c]         ;1606  ; xNextTaskUnblockTime
000250  e7ec              B        |L1.556|
                  |L1.594|
000252  f8c7902c          STR      r9,[r7,#0x2c]         ;1623  ; xNextTaskUnblockTime
                  |L1.598|
000256  6838              LDR      r0,[r7,#0]            ;1683  ; pxCurrentTCB
000258  6ac0              LDR      r0,[r0,#0x2c]         ;1683
00025a  eb000080          ADD      r0,r0,r0,LSL #2       ;1683
00025e  f8580020          LDR      r0,[r8,r0,LSL #2]     ;1683
000262  2801              CMP      r0,#1                 ;1683
000264  d900              BLS      |L1.616|
000266  2501              MOVS     r5,#1                 ;1685
                  |L1.616|
000268  69f8              LDR      r0,[r7,#0x1c]         ;1694  ; uxPendedTicks
00026a  2800              CMP      r0,#0                 ;1694
00026c  d1c2              BNE      |L1.500|
00026e  f7fffffe          BL       vApplicationTickHook
000272  e7bf              B        |L1.500|
                  |L1.628|
000274  1d20              ADDS     r0,r4,#4              ;1646
000276  f7fffffe          BL       uxListRemove
00027a  6aa0              LDR      r0,[r4,#0x28]         ;1650
00027c  b118              CBZ      r0,|L1.646|
00027e  f1040018          ADD      r0,r4,#0x18           ;1652
000282  f7fffffe          BL       uxListRemove
                  |L1.646|
000286  6ae0              LDR      r0,[r4,#0x2c]         ;1657
000288  6939              LDR      r1,[r7,#0x10]         ;1657  ; uxTopReadyPriority
00028a  4288              CMP      r0,r1                 ;1657
00028c  d900              BLS      |L1.656|
00028e  6138              STR      r0,[r7,#0x10]         ;1657  ; uxTopReadyPriority
                  |L1.656|
000290  eb000080          ADD      r0,r0,r0,LSL #2       ;1657
000294  eb080080          ADD      r0,r8,r0,LSL #2       ;1657
000298  1d21              ADDS     r1,r4,#4              ;1657
00029a  f7fffffe          BL       vListInsertEnd
00029e  6ae0              LDR      r0,[r4,#0x2c]         ;1667
0002a0  6839              LDR      r1,[r7,#0]            ;1667  ; pxCurrentTCB
0002a2  6ac9              LDR      r1,[r1,#0x2c]         ;1667
0002a4  4288              CMP      r0,r1                 ;1667
0002a6  d3c6              BCC      |L1.566|
0002a8  2501              MOVS     r5,#1                 ;1669
0002aa  e7c4              B        |L1.566|
;;;1725   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskResumeAll PROC
;;;1345   
;;;1346   signed portBASE_TYPE xTaskResumeAll( void )
0002ac  e92d41f0          PUSH     {r4-r8,lr}
;;;1347   {
;;;1348   tskTCB *pxTCB;
;;;1349   portBASE_TYPE xAlreadyYielded = pdFALSE;
0002b0  2700              MOVS     r7,#0
;;;1350   
;;;1351   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;1352   	previous call to vTaskSuspendAll(). */
;;;1353   	configASSERT( uxSchedulerSuspended );
;;;1354   
;;;1355   	/* It is possible that an ISR caused a task to be removed from an event
;;;1356   	list while the scheduler was suspended.  If this was the case then the
;;;1357   	removed task will have been added to the xPendingReadyList.  Once the
;;;1358   	scheduler has been resumed it is safe to move all the pending ready
;;;1359   	tasks from this list into their appropriate ready list. */
;;;1360   	taskENTER_CRITICAL();
0002b2  f7fffffe          BL       vPortEnterCritical
;;;1361   	{
;;;1362   		--uxSchedulerSuspended;
0002b6  4d53              LDR      r5,|L1.1028|
0002b8  69a8              LDR      r0,[r5,#0x18]  ; uxSchedulerSuspended
0002ba  1e40              SUBS     r0,r0,#1
0002bc  61a8              STR      r0,[r5,#0x18]  ; uxSchedulerSuspended
;;;1363   
;;;1364   		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
0002be  69a8              LDR      r0,[r5,#0x18]  ; uxSchedulerSuspended
0002c0  bbd8              CBNZ     r0,|L1.826|
;;;1365   		{
;;;1366   			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
0002c2  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
0002c4  b3c8              CBZ      r0,|L1.826|
;;;1367   			{
;;;1368   				/* Move any readied tasks from the pending list into the
;;;1369   				appropriate ready list. */
;;;1370   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
;;;1371   				{
;;;1372   					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
0002c6  f8df8138          LDR      r8,|L1.1024|
;;;1373   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;1374   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;1375   					prvAddTaskToReadyList( pxTCB );
;;;1376   
;;;1377   					/* If we have moved a task that has a priority higher than
;;;1378   					the current task then we should yield. */
;;;1379   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;1380   					{
;;;1381   						xYieldPending = pdTRUE;
0002ca  2601              MOVS     r6,#1
0002cc  f108088c          ADD      r8,r8,#0x8c           ;1372
0002d0  e01c              B        |L1.780|
                  |L1.722|
0002d2  f8d8000c          LDR      r0,[r8,#0xc]          ;1372  ; xPendingReadyList
0002d6  68c4              LDR      r4,[r0,#0xc]          ;1372
0002d8  f1040018          ADD      r0,r4,#0x18           ;1373
0002dc  f7fffffe          BL       uxListRemove
0002e0  1d20              ADDS     r0,r4,#4              ;1374
0002e2  f7fffffe          BL       uxListRemove
0002e6  6ae0              LDR      r0,[r4,#0x2c]         ;1375
0002e8  6929              LDR      r1,[r5,#0x10]         ;1375  ; uxTopReadyPriority
0002ea  4288              CMP      r0,r1                 ;1375
0002ec  d900              BLS      |L1.752|
0002ee  6128              STR      r0,[r5,#0x10]         ;1375  ; uxTopReadyPriority
                  |L1.752|
0002f0  4943              LDR      r1,|L1.1024|
0002f2  eb000080          ADD      r0,r0,r0,LSL #2       ;1375
0002f6  eb010080          ADD      r0,r1,r0,LSL #2       ;1375
0002fa  1d21              ADDS     r1,r4,#4              ;1375
0002fc  f7fffffe          BL       vListInsertEnd
000300  6ae0              LDR      r0,[r4,#0x2c]         ;1379
000302  6829              LDR      r1,[r5,#0]            ;1379  ; pxCurrentTCB
000304  6ac9              LDR      r1,[r1,#0x2c]         ;1379
000306  4288              CMP      r0,r1                 ;1379
000308  d300              BCC      |L1.780|
00030a  622e              STR      r6,[r5,#0x20]  ; xYieldPending
                  |L1.780|
00030c  f8d80000          LDR      r0,[r8,#0]            ;1370  ; xPendingReadyList
000310  2800              CMP      r0,#0                 ;1370
000312  d1de              BNE      |L1.722|
;;;1382   					}
;;;1383   				}
;;;1384   
;;;1385   				/* If any ticks occurred while the scheduler was suspended then
;;;1386   				they should be processed now.  This ensures the tick count does not
;;;1387   				slip, and that any delayed tasks are resumed at the correct time. */
;;;1388   				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
000314  69e8              LDR      r0,[r5,#0x1c]  ; uxPendedTicks
000316  b938              CBNZ     r0,|L1.808|
000318  e009              B        |L1.814|
                  |L1.794|
;;;1389   				{
;;;1390   					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
;;;1391   					{
;;;1392   						if( xTaskIncrementTick() != pdFALSE )
00031a  f7fffffe          BL       xTaskIncrementTick
00031e  b100              CBZ      r0,|L1.802|
;;;1393   						{
;;;1394   							xYieldPending = pdTRUE;
000320  622e              STR      r6,[r5,#0x20]  ; xYieldPending
                  |L1.802|
;;;1395   						}
;;;1396   						--uxPendedTicks;
000322  69e8              LDR      r0,[r5,#0x1c]  ; uxPendedTicks
000324  1e40              SUBS     r0,r0,#1
000326  61e8              STR      r0,[r5,#0x1c]  ; uxPendedTicks
                  |L1.808|
000328  69e8              LDR      r0,[r5,#0x1c]         ;1390  ; uxPendedTicks
00032a  2800              CMP      r0,#0                 ;1390
00032c  d1f5              BNE      |L1.794|
                  |L1.814|
;;;1397   					}
;;;1398   				}
;;;1399   
;;;1400   				if( xYieldPending == pdTRUE )
00032e  6a28              LDR      r0,[r5,#0x20]  ; xYieldPending
000330  2801              CMP      r0,#1
000332  d102              BNE      |L1.826|
;;;1401   				{
;;;1402   					xAlreadyYielded = pdTRUE;
000334  2701              MOVS     r7,#1
;;;1403   					portYIELD_WITHIN_API();
000336  f7fffffe          BL       vPortYield
                  |L1.826|
;;;1404   				}
;;;1405   			}
;;;1406   		}
;;;1407   	}
;;;1408   	taskEXIT_CRITICAL();
00033a  f7fffffe          BL       vPortExitCritical
;;;1409   
;;;1410   	return xAlreadyYielded;
00033e  4638              MOV      r0,r7
                  |L1.832|
;;;1411   }
000340  e8bd81f0          POP      {r4-r8,pc}
;;;1412   /*-----------------------------------------------------------*/
                          ENDP

                  prvAddCurrentTaskToDelayedList PROC
;;;2425   
;;;2426   static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
000344  b570              PUSH     {r4-r6,lr}
;;;2427   {
000346  4604              MOV      r4,r0
;;;2428   	/* The list item will be inserted in wake time order. */
;;;2429   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
000348  4d2e              LDR      r5,|L1.1028|
00034a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00034c  6044              STR      r4,[r0,#4]
;;;2430   
;;;2431   	if( xTimeToWake < xTickCount )
00034e  68e8              LDR      r0,[r5,#0xc]  ; xTickCount
000350  4284              CMP      r4,r0
000352  d206              BCS      |L1.866|
;;;2432   	{
;;;2433   		/* Wake time has overflowed.  Place this item in the overflow list. */
;;;2434   		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000354  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000356  6b68              LDR      r0,[r5,#0x34]  ; pxOverflowDelayedTaskList
000358  1d09              ADDS     r1,r1,#4
00035a  e8bd4070          POP      {r4-r6,lr}
00035e  f7ffbffe          B.W      vListInsert
                  |L1.866|
;;;2435   	}
;;;2436   	else
;;;2437   	{
;;;2438   		/* The wake time has not overflowed, so we can use the current block list. */
;;;2439   		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
000362  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000364  6b28              LDR      r0,[r5,#0x30]  ; pxDelayedTaskList
000366  1d09              ADDS     r1,r1,#4
000368  f7fffffe          BL       vListInsert
;;;2440   
;;;2441   		/* If the task entering the blocked state was placed at the head of the
;;;2442   		list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;2443   		too. */
;;;2444   		if( xTimeToWake < xNextTaskUnblockTime )
00036c  6ae8              LDR      r0,[r5,#0x2c]  ; xNextTaskUnblockTime
00036e  4284              CMP      r4,r0
000370  d200              BCS      |L1.884|
;;;2445   		{
;;;2446   			xNextTaskUnblockTime = xTimeToWake;
000372  62ec              STR      r4,[r5,#0x2c]  ; xNextTaskUnblockTime
                  |L1.884|
;;;2447   		}
;;;2448   	}
;;;2449   }
000374  bd70              POP      {r4-r6,pc}
;;;2450   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSuspendAll PROC
;;;1309   
;;;1310   void vTaskSuspendAll( void )
000376  4823              LDR      r0,|L1.1028|
;;;1311   {
;;;1312   	/* A critical section is not required as the variable is of type
;;;1313   	portBASE_TYPE. */
;;;1314   	++uxSchedulerSuspended;
000378  6981              LDR      r1,[r0,#0x18]  ; uxSchedulerSuspended
00037a  1c49              ADDS     r1,r1,#1
00037c  6181              STR      r1,[r0,#0x18]  ; uxSchedulerSuspended
;;;1315   }
00037e  4770              BX       lr
;;;1316   /*----------------------------------------------------------*/
                          ENDP

                  vTaskDelayUntil PROC
;;;688    
;;;689    	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
000380  b570              PUSH     {r4-r6,lr}
;;;690    	{
000382  4605              MOV      r5,r0
000384  460c              MOV      r4,r1
;;;691    	portTickType xTimeToWake;
;;;692    	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
000386  2200              MOVS     r2,#0
;;;693    
;;;694    		configASSERT( pxPreviousWakeTime );
;;;695    		configASSERT( ( xTimeIncrement > 0U ) );
;;;696    
;;;697    		vTaskSuspendAll();
000388  f7fffffe          BL       vTaskSuspendAll
;;;698    		{
;;;699    			/* Minor optimisation.  The tick count cannot change in this
;;;700    			block. */
;;;701    			const portTickType xConstTickCount = xTickCount;
00038c  4e1d              LDR      r6,|L1.1028|
00038e  68f0              LDR      r0,[r6,#0xc]  ; xTickCount
;;;702    
;;;703    			/* Generate the tick time at which the task wants to wake. */
;;;704    			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
000390  682b              LDR      r3,[r5,#0]
000392  441c              ADD      r4,r4,r3
;;;705    
;;;706    			if( xConstTickCount < *pxPreviousWakeTime )
000394  4283              CMP      r3,r0
000396  d905              BLS      |L1.932|
;;;707    			{
;;;708    				/* The tick count has overflowed since this function was
;;;709    				lasted called.  In this case the only time we should ever
;;;710    				actually delay is if the wake time has also	overflowed,
;;;711    				and the wake time is greater than the tick time.  When this
;;;712    				is the case it is as if neither time had overflowed. */
;;;713    				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
000398  42a3              CMP      r3,r4
00039a  d908              BLS      |L1.942|
00039c  4284              CMP      r4,r0
00039e  d906              BLS      |L1.942|
;;;714    				{
;;;715    					xShouldDelay = pdTRUE;
0003a0  2201              MOVS     r2,#1
0003a2  e004              B        |L1.942|
                  |L1.932|
;;;716    				}
;;;717    			}
;;;718    			else
;;;719    			{
;;;720    				/* The tick time has not overflowed.  In this case we will
;;;721    				delay if either the wake time has overflowed, and/or the
;;;722    				tick time is less than the wake time. */
;;;723    				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
0003a4  42a3              CMP      r3,r4
0003a6  d801              BHI      |L1.940|
0003a8  4284              CMP      r4,r0
0003aa  d900              BLS      |L1.942|
                  |L1.940|
;;;724    				{
;;;725    					xShouldDelay = pdTRUE;
0003ac  2201              MOVS     r2,#1
                  |L1.942|
;;;726    				}
;;;727    			}
;;;728    
;;;729    			/* Update the wake time ready for the next call. */
;;;730    			*pxPreviousWakeTime = xTimeToWake;
0003ae  602c              STR      r4,[r5,#0]
;;;731    
;;;732    			if( xShouldDelay != pdFALSE )
0003b0  b132              CBZ      r2,|L1.960|
;;;733    			{
;;;734    				traceTASK_DELAY_UNTIL();
;;;735    
;;;736    				/* We must remove ourselves from the ready list before adding
;;;737    				ourselves to the blocked list as the same list item is used for
;;;738    				both lists. */
;;;739    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
0003b2  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
0003b4  1d00              ADDS     r0,r0,#4
0003b6  f7fffffe          BL       uxListRemove
;;;740    				{
;;;741    					/* The current task must be in a ready list, so there is
;;;742    					no need to check, and the port reset macro can be called
;;;743    					directly. */
;;;744    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;745    				}
;;;746    
;;;747    				prvAddCurrentTaskToDelayedList( xTimeToWake );
0003ba  4620              MOV      r0,r4
0003bc  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.960|
;;;748    			}
;;;749    		}
;;;750    		xAlreadyYielded = xTaskResumeAll();
0003c0  f7fffffe          BL       xTaskResumeAll
;;;751    
;;;752    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;753    		have put ourselves to sleep. */
;;;754    		if( xAlreadyYielded == pdFALSE )
0003c4  2800              CMP      r0,#0
0003c6  d103              BNE      |L1.976|
;;;755    		{
;;;756    			portYIELD_WITHIN_API();
0003c8  e8bd4070          POP      {r4-r6,lr}
0003cc  f7ffbffe          B.W      vPortYield
                  |L1.976|
;;;757    		}
;;;758    	}
0003d0  bd70              POP      {r4-r6,pc}
;;;759    
                          ENDP

                  vTaskDelay PROC
;;;764    
;;;765    	void vTaskDelay( portTickType xTicksToDelay )
0003d2  b510              PUSH     {r4,lr}
;;;766    	{
0003d4  4602              MOV      r2,r0
;;;767    	portTickType xTimeToWake;
;;;768    	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
0003d6  2000              MOVS     r0,#0
;;;769    
;;;770    		/* A delay time of zero just forces a reschedule. */
;;;771    		if( xTicksToDelay > ( portTickType ) 0U )
0003d8  b16a              CBZ      r2,|L1.1014|
;;;772    		{
;;;773    			vTaskSuspendAll();
0003da  f7fffffe          BL       vTaskSuspendAll
;;;774    			{
;;;775    				traceTASK_DELAY();
;;;776    
;;;777    				/* A task that is removed from the event list while the
;;;778    				scheduler is suspended will not get placed in the ready
;;;779    				list or removed from the blocked list until the scheduler
;;;780    				is resumed.
;;;781    
;;;782    				This task cannot be in an event list as it is the currently
;;;783    				executing task. */
;;;784    
;;;785    				/* Calculate the time to wake - this may overflow but this is
;;;786    				not a problem. */
;;;787    				xTimeToWake = xTickCount + xTicksToDelay;
0003de  4809              LDR      r0,|L1.1028|
0003e0  68c1              LDR      r1,[r0,#0xc]  ; xTickCount
0003e2  188c              ADDS     r4,r1,r2
;;;788    
;;;789    				/* We must remove ourselves from the ready list before adding
;;;790    				ourselves to the blocked list as the same list item is used for
;;;791    				both lists. */
;;;792    				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
0003e4  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0003e6  1d00              ADDS     r0,r0,#4
0003e8  f7fffffe          BL       uxListRemove
;;;793    				{
;;;794    					/* The current task must be in a ready list, so there is
;;;795    					no need to check, and the port reset macro can be called
;;;796    					directly. */
;;;797    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;798    				}
;;;799    				prvAddCurrentTaskToDelayedList( xTimeToWake );
0003ec  4620              MOV      r0,r4
0003ee  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;800    			}
;;;801    			xAlreadyYielded = xTaskResumeAll();
0003f2  f7fffffe          BL       xTaskResumeAll
                  |L1.1014|
;;;802    		}
;;;803    
;;;804    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;805    		have put ourselves to sleep. */
;;;806    		if( xAlreadyYielded == pdFALSE )
0003f6  2800              CMP      r0,#0
0003f8  d108              BNE      |L1.1036|
;;;807    		{
;;;808    			portYIELD_WITHIN_API();
0003fa  e8bd4010          POP      {r4,lr}
0003fe  e003              B        |L1.1032|
                  |L1.1024|
                          DCD      ||.bss||
                  |L1.1028|
                          DCD      ||.data||
                  |L1.1032|
000408  f7ffbffe          B.W      vPortYield
                  |L1.1036|
;;;809    		}
;;;810    	}
00040c  bd10              POP      {r4,pc}
;;;811    
                          ENDP

                  uxTaskPriorityGet PROC
;;;876    
;;;877    	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
00040e  b510              PUSH     {r4,lr}
;;;878    	{
000410  4604              MOV      r4,r0
;;;879    	tskTCB *pxTCB;
;;;880    	unsigned portBASE_TYPE uxReturn;
;;;881    
;;;882    		taskENTER_CRITICAL();
000412  f7fffffe          BL       vPortEnterCritical
;;;883    		{
;;;884    			/* If null is passed in here then we are changing the
;;;885    			priority of the calling function. */
;;;886    			pxTCB = prvGetTCBFromHandle( xTask );
000416  b90c              CBNZ     r4,|L1.1052|
000418  48f5              LDR      r0,|L1.2032|
00041a  6804              LDR      r4,[r0,#0]  ; pxCurrentTCB
                  |L1.1052|
;;;887    			uxReturn = pxTCB->uxPriority;
00041c  6ae4              LDR      r4,[r4,#0x2c]
;;;888    		}
;;;889    		taskEXIT_CRITICAL();
00041e  f7fffffe          BL       vPortExitCritical
;;;890    
;;;891    		return uxReturn;
000422  4620              MOV      r0,r4
;;;892    	}
000424  bd10              POP      {r4,pc}
;;;893    
                          ENDP

                  vTaskPrioritySet PROC
;;;898    
;;;899    	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
000426  e92d41f0          PUSH     {r4-r8,lr}
;;;900    	{
00042a  4604              MOV      r4,r0
00042c  460d              MOV      r5,r1
;;;901    	tskTCB *pxTCB;
;;;902    	unsigned portBASE_TYPE uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;903    	portBASE_TYPE xYieldRequired = pdFALSE;
00042e  2600              MOVS     r6,#0
;;;904    
;;;905    		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
;;;906    
;;;907    		/* Ensure the new priority is valid. */
;;;908    		if( uxNewPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
000430  2d05              CMP      r5,#5
000432  d300              BCC      |L1.1078|
;;;909    		{
;;;910    			uxNewPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
000434  2504              MOVS     r5,#4
                  |L1.1078|
;;;911    		}
;;;912    
;;;913    		taskENTER_CRITICAL();
000436  f7fffffe          BL       vPortEnterCritical
;;;914    		{
;;;915    			/* If null is passed in here then it is the priority of the calling
;;;916    			task that is being changed. */
;;;917    			pxTCB = prvGetTCBFromHandle( xTask );
00043a  4fed              LDR      r7,|L1.2032|
00043c  b904              CBNZ     r4,|L1.1088|
00043e  683c              LDR      r4,[r7,#0]  ; pxCurrentTCB
                  |L1.1088|
;;;918    
;;;919    			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;920    
;;;921    			#if ( configUSE_MUTEXES == 1 )
;;;922    			{
;;;923    				uxCurrentBasePriority = pxTCB->uxBasePriority;
;;;924    			}
;;;925    			#else
;;;926    			{
;;;927    				uxCurrentBasePriority = pxTCB->uxPriority;
000440  6ae0              LDR      r0,[r4,#0x2c]
;;;928    			}
;;;929    			#endif
;;;930    
;;;931    			if( uxCurrentBasePriority != uxNewPriority )
000442  42a8              CMP      r0,r5
000444  d02d              BEQ      |L1.1186|
;;;932    			{
;;;933    				/* The priority change may have readied a task of higher
;;;934    				priority than the calling task. */
;;;935    				if( uxNewPriority > uxCurrentBasePriority )
000446  4285              CMP      r5,r0
000448  d908              BLS      |L1.1116|
;;;936    				{
;;;937    					if( pxTCB != pxCurrentTCB )
00044a  6839              LDR      r1,[r7,#0]  ; pxCurrentTCB
00044c  428c              CMP      r4,r1
00044e  d009              BEQ      |L1.1124|
;;;938    					{
;;;939    						/* The priority of a task other than the currently
;;;940    						running task is being raised.  Is the priority being
;;;941    						raised above that of the running task? */
;;;942    						if( uxNewPriority >= pxCurrentTCB->uxPriority )
000450  6839              LDR      r1,[r7,#0]  ; pxCurrentTCB
000452  6ac9              LDR      r1,[r1,#0x2c]
000454  42a9              CMP      r1,r5
000456  d805              BHI      |L1.1124|
;;;943    						{
;;;944    							xYieldRequired = pdTRUE;
000458  2601              MOVS     r6,#1
00045a  e003              B        |L1.1124|
                  |L1.1116|
;;;945    						}
;;;946    					}
;;;947    					else
;;;948    					{
;;;949    						/* The priority of the running task is being raised,
;;;950    						but the running task must already be the highest
;;;951    						priority task able to run so no yield is required. */
;;;952    					}
;;;953    				}
;;;954    				else if( pxTCB == pxCurrentTCB )
00045c  6839              LDR      r1,[r7,#0]  ; pxCurrentTCB
00045e  428c              CMP      r4,r1
000460  d100              BNE      |L1.1124|
;;;955    				{
;;;956    					/* Setting the priority of the running task down means
;;;957    					there may now be another task of higher priority that
;;;958    					is ready to execute. */
;;;959    					xYieldRequired = pdTRUE;
000462  2601              MOVS     r6,#1
                  |L1.1124|
;;;960    				}
;;;961    				else
;;;962    				{
;;;963    					/* Setting the priority of any other task down does not
;;;964    					require a yield as the running task must be above the
;;;965    					new priority of the task being modified. */
;;;966    				}
;;;967    
;;;968    				/* Remember the ready list the task might be referenced from
;;;969    				before its uxPriority member is changed so the
;;;970    				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;971    				uxPriorityUsedOnEntry = pxTCB->uxPriority;
;;;972    
;;;973    				#if ( configUSE_MUTEXES == 1 )
;;;974    				{
;;;975    					/* Only change the priority being used if the task is not
;;;976    					currently using an inherited priority. */
;;;977    					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
;;;978    					{
;;;979    						pxTCB->uxPriority = uxNewPriority;
;;;980    					}
;;;981    
;;;982    					/* The base priority gets set whatever. */
;;;983    					pxTCB->uxBasePriority = uxNewPriority;
;;;984    				}
;;;985    				#else
;;;986    				{
;;;987    					pxTCB->uxPriority = uxNewPriority;
000464  62e5              STR      r5,[r4,#0x2c]
;;;988    				}
;;;989    				#endif
;;;990    
;;;991    				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000466  f1c50105          RSB      r1,r5,#5
00046a  61a1              STR      r1,[r4,#0x18]
;;;992    
;;;993    				/* If the task is in the blocked or suspended list we need do
;;;994    				nothing more than change it's priority variable. However, if
;;;995    				the task is in a ready list it needs to be removed and placed
;;;996    				in the list appropriate to its new priority. */
;;;997    				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
00046c  4de1              LDR      r5,|L1.2036|
00046e  eb000080          ADD      r0,r0,r0,LSL #2
000472  6961              LDR      r1,[r4,#0x14]
000474  eb050080          ADD      r0,r5,r0,LSL #2
000478  4281              CMP      r1,r0
00047a  d10e              BNE      |L1.1178|
;;;998    				{
;;;999    					/* The task is currently in its ready list - remove before adding
;;;1000   					it to it's new ready list.  As we are in a critical section we
;;;1001   					can do this even if the scheduler is suspended. */
;;;1002   					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
00047c  1d20              ADDS     r0,r4,#4
00047e  f7fffffe          BL       uxListRemove
;;;1003   					{
;;;1004   						/* It is known that the task is in its ready list so
;;;1005   						there is no need to check again and the port level
;;;1006   						reset macro can be called directly. */
;;;1007   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
;;;1008   					}
;;;1009   					prvAddTaskToReadyList( pxTCB );
000482  6ae0              LDR      r0,[r4,#0x2c]
000484  6939              LDR      r1,[r7,#0x10]  ; uxTopReadyPriority
000486  4288              CMP      r0,r1
000488  d900              BLS      |L1.1164|
00048a  6138              STR      r0,[r7,#0x10]  ; uxTopReadyPriority
                  |L1.1164|
00048c  eb000080          ADD      r0,r0,r0,LSL #2
000490  eb050080          ADD      r0,r5,r0,LSL #2
000494  1d21              ADDS     r1,r4,#4
000496  f7fffffe          BL       vListInsertEnd
                  |L1.1178|
;;;1010   				}
;;;1011   
;;;1012   				if( xYieldRequired == pdTRUE )
00049a  2e01              CMP      r6,#1
00049c  d101              BNE      |L1.1186|
;;;1013   				{
;;;1014   					portYIELD_WITHIN_API();
00049e  f7fffffe          BL       vPortYield
                  |L1.1186|
;;;1015   				}
;;;1016   
;;;1017   				/* Remove compiler warning about unused variables when the port
;;;1018   				optimised task selection is not being used. */
;;;1019   				( void ) uxPriorityUsedOnEntry;
;;;1020   			}
;;;1021   		}
;;;1022   		taskEXIT_CRITICAL();
0004a2  e8bd41f0          POP      {r4-r8,lr}
0004a6  f7ffbffe          B.W      vPortExitCritical
;;;1023   	}
;;;1024   
                          ENDP

                  vTaskSwitchContext PROC
;;;1813   
;;;1814   void vTaskSwitchContext( void )
0004aa  49d1              LDR      r1,|L1.2032|
;;;1815   {
;;;1816   	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
0004ac  6988              LDR      r0,[r1,#0x18]  ; uxSchedulerSuspended
0004ae  b110              CBZ      r0,|L1.1206|
;;;1817   	{
;;;1818   		/* The scheduler is currently suspended - do not allow a context
;;;1819   		switch. */
;;;1820   		xYieldPending = pdTRUE;
0004b0  2001              MOVS     r0,#1
0004b2  6208              STR      r0,[r1,#0x20]  ; xYieldPending
;;;1821   	}
;;;1822   	else
;;;1823   	{
;;;1824   		xYieldPending = pdFALSE;
;;;1825   		traceTASK_SWITCHED_OUT();
;;;1826   
;;;1827   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;1828   		{
;;;1829   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;1830   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;1831   				#else
;;;1832   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;1833   				#endif
;;;1834   
;;;1835   				/* Add the amount of time the task has been running to the
;;;1836   				accumulated	time so far.  The time the task started running was
;;;1837   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;1838   				protection here	so count values are only valid until the timer
;;;1839   				overflows.  The guard against negative values is to protect
;;;1840   				against suspect run time stat counter implementations - which
;;;1841   				are provided by the application, not the kernel. */
;;;1842   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;1843   				{
;;;1844   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;1845   				}
;;;1846   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;1847   		}
;;;1848   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;1849   
;;;1850   		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
;;;1851   		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
;;;1852   
;;;1853   		taskSELECT_HIGHEST_PRIORITY_TASK();
;;;1854   
;;;1855   		traceTASK_SWITCHED_IN();
;;;1856   
;;;1857   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1858   		{
;;;1859   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1860   			structure specific to this task. */
;;;1861   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1862   		}
;;;1863   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1864   	}
;;;1865   }
0004b4  4770              BX       lr
                  |L1.1206|
0004b6  2000              MOVS     r0,#0                 ;1824
0004b8  6208              STR      r0,[r1,#0x20]         ;1824  ; xYieldPending
0004ba  4ace              LDR      r2,|L1.2036|
0004bc  e002              B        |L1.1220|
                  |L1.1214|
0004be  6908              LDR      r0,[r1,#0x10]         ;1853  ; uxTopReadyPriority
0004c0  1e40              SUBS     r0,r0,#1              ;1853
0004c2  6108              STR      r0,[r1,#0x10]         ;1853  ; uxTopReadyPriority
                  |L1.1220|
0004c4  6908              LDR      r0,[r1,#0x10]         ;1853  ; uxTopReadyPriority
0004c6  eb000080          ADD      r0,r0,r0,LSL #2       ;1853
0004ca  f8520020          LDR      r0,[r2,r0,LSL #2]     ;1853
0004ce  2800              CMP      r0,#0                 ;1853
0004d0  d0f5              BEQ      |L1.1214|
0004d2  6908              LDR      r0,[r1,#0x10]         ;1853  ; uxTopReadyPriority
0004d4  eb000080          ADD      r0,r0,r0,LSL #2       ;1853
0004d8  eb020080          ADD      r0,r2,r0,LSL #2       ;1853
0004dc  6842              LDR      r2,[r0,#4]            ;1853
0004de  6852              LDR      r2,[r2,#4]            ;1853
0004e0  6042              STR      r2,[r0,#4]            ;1853
0004e2  f1000308          ADD      r3,r0,#8              ;1853
0004e6  429a              CMP      r2,r3                 ;1853
0004e8  d101              BNE      |L1.1262|
0004ea  6852              LDR      r2,[r2,#4]            ;1853
0004ec  6042              STR      r2,[r0,#4]            ;1853
                  |L1.1262|
0004ee  6840              LDR      r0,[r0,#4]            ;1853
0004f0  68c0              LDR      r0,[r0,#0xc]          ;1853
0004f2  6008              STR      r0,[r1,#0]            ;1853  ; pxCurrentTCB
0004f4  4770              BX       lr
;;;1866   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSuspend PROC
;;;1029   
;;;1030   	void vTaskSuspend( xTaskHandle xTaskToSuspend )
0004f6  b570              PUSH     {r4-r6,lr}
;;;1031   	{
0004f8  4604              MOV      r4,r0
;;;1032   	tskTCB *pxTCB;
;;;1033   
;;;1034   		taskENTER_CRITICAL();
0004fa  f7fffffe          BL       vPortEnterCritical
;;;1035   		{
;;;1036   			/* If null is passed in here then it is the running task that is
;;;1037   			being suspended. */
;;;1038   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
0004fe  4dbc              LDR      r5,|L1.2032|
000500  b904              CBNZ     r4,|L1.1284|
000502  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L1.1284|
;;;1039   
;;;1040   			traceTASK_SUSPEND( pxTCB );
;;;1041   
;;;1042   			/* Remove task from the ready/delayed list and place in the	suspended list. */
;;;1043   			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
000504  1d20              ADDS     r0,r4,#4
000506  f7fffffe          BL       uxListRemove
;;;1044   			{
;;;1045   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1046   			}
;;;1047   
;;;1048   			/* Is the task waiting on an event also? */
;;;1049   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00050a  6aa0              LDR      r0,[r4,#0x28]
00050c  b118              CBZ      r0,|L1.1302|
;;;1050   			{
;;;1051   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00050e  f1040018          ADD      r0,r4,#0x18
000512  f7fffffe          BL       uxListRemove
                  |L1.1302|
;;;1052   			}
;;;1053   
;;;1054   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
000516  48b7              LDR      r0,|L1.2036|
000518  1d21              ADDS     r1,r4,#4
00051a  30b4              ADDS     r0,r0,#0xb4
00051c  f7fffffe          BL       vListInsertEnd
;;;1055   		}
;;;1056   		taskEXIT_CRITICAL();
000520  f7fffffe          BL       vPortExitCritical
;;;1057   
;;;1058   		if( pxTCB == pxCurrentTCB )
000524  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000526  4284              CMP      r4,r0
000528  d10d              BNE      |L1.1350|
;;;1059   		{
;;;1060   			if( xSchedulerRunning != pdFALSE )
00052a  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
00052c  b118              CBZ      r0,|L1.1334|
;;;1061   			{
;;;1062   				/* The current task has just been suspended. */
;;;1063   				portYIELD_WITHIN_API();
00052e  e8bd4070          POP      {r4-r6,lr}
000532  f7ffbffe          B.W      vPortYield
                  |L1.1334|
;;;1064   			}
;;;1065   			else
;;;1066   			{
;;;1067   				/* The scheduler is not running, but the task that was pointed
;;;1068   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1069   				must be adjusted to point to a different task. */
;;;1070   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
000536  48af              LDR      r0,|L1.2036|
000538  68a9              LDR      r1,[r5,#8]  ; uxCurrentNumberOfTasks
00053a  30b4              ADDS     r0,r0,#0xb4
00053c  6800              LDR      r0,[r0,#0]  ; xSuspendedTaskList
00053e  4288              CMP      r0,r1
000540  d102              BNE      |L1.1352|
;;;1071   				{
;;;1072   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1073   					NULL so when the next task is created pxCurrentTCB will
;;;1074   					be set to point to it no matter what its relative priority
;;;1075   					is. */
;;;1076   					pxCurrentTCB = NULL;
000542  2000              MOVS     r0,#0
000544  6028              STR      r0,[r5,#0]  ; pxCurrentTCB
                  |L1.1350|
;;;1077   				}
;;;1078   				else
;;;1079   				{
;;;1080   					vTaskSwitchContext();
;;;1081   				}
;;;1082   			}
;;;1083   		}
;;;1084   	}
000546  bd70              POP      {r4-r6,pc}
                  |L1.1352|
000548  e8bd4070          POP      {r4-r6,lr}            ;1080
00054c  e7fe              B        vTaskSwitchContext
;;;1085   
                          ENDP

                  xTaskIsTaskSuspended PROC
;;;1090   
;;;1091   	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
00054e  2100              MOVS     r1,#0
;;;1092   	{
;;;1093   	portBASE_TYPE xReturn = pdFALSE;
;;;1094   	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
;;;1095   
;;;1096   		/* It does not make sense to check if the calling task is suspended. */
;;;1097   		configASSERT( xTask );
;;;1098   
;;;1099   		/* Is the task we are attempting to resume actually in the
;;;1100   		suspended list? */
;;;1101   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
000550  4ba8              LDR      r3,|L1.2036|
000552  6942              LDR      r2,[r0,#0x14]
000554  33b4              ADDS     r3,r3,#0xb4
000556  429a              CMP      r2,r3
000558  d106              BNE      |L1.1384|
;;;1102   		{
;;;1103   			/* Has the task already been resumed from within an ISR? */
;;;1104   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
00055a  6a80              LDR      r0,[r0,#0x28]
00055c  f1a30228          SUB      r2,r3,#0x28
000560  4290              CMP      r0,r2
000562  d001              BEQ      |L1.1384|
;;;1105   			{
;;;1106   				/* Is it in the suspended list because it is in the
;;;1107   				Suspended state?  It is possible to be in the suspended
;;;1108   				list because it is blocked on a task with no timeout
;;;1109   				specified. */
;;;1110   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
000564  b900              CBNZ     r0,|L1.1384|
;;;1111   				{
;;;1112   					xReturn = pdTRUE;
000566  2101              MOVS     r1,#1
                  |L1.1384|
;;;1113   				}
;;;1114   			}
;;;1115   		}
;;;1116   
;;;1117   		return xReturn;
000568  4608              MOV      r0,r1
;;;1118   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
00056a  4770              BX       lr
;;;1119   
                          ENDP

                  vTaskResume PROC
;;;1124   
;;;1125   	void vTaskResume( xTaskHandle xTaskToResume )
00056c  b570              PUSH     {r4-r6,lr}
;;;1126   	{
00056e  4604              MOV      r4,r0
;;;1127   	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
;;;1128   
;;;1129   		/* It does not make sense to resume the calling task. */
;;;1130   		configASSERT( xTaskToResume );
;;;1131   
;;;1132   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1133   		currently executing task. */
;;;1134   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
000570  2c00              CMP      r4,#0
000572  d025              BEQ      |L1.1472|
000574  4d9e              LDR      r5,|L1.2032|
000576  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000578  4284              CMP      r4,r0
00057a  d021              BEQ      |L1.1472|
;;;1135   		{
;;;1136   			taskENTER_CRITICAL();
00057c  f7fffffe          BL       vPortEnterCritical
;;;1137   			{
;;;1138   				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
000580  4620              MOV      r0,r4
000582  f7fffffe          BL       xTaskIsTaskSuspended
000586  2801              CMP      r0,#1
000588  d116              BNE      |L1.1464|
;;;1139   				{
;;;1140   					traceTASK_RESUME( pxTCB );
;;;1141   
;;;1142   					/* As we are in a critical section we can access the ready
;;;1143   					lists even if the scheduler is suspended. */
;;;1144   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
00058a  1d20              ADDS     r0,r4,#4
00058c  f7fffffe          BL       uxListRemove
;;;1145   					prvAddTaskToReadyList( pxTCB );
000590  6ae0              LDR      r0,[r4,#0x2c]
000592  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
000594  4288              CMP      r0,r1
000596  d900              BLS      |L1.1434|
000598  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L1.1434|
00059a  4996              LDR      r1,|L1.2036|
00059c  eb000080          ADD      r0,r0,r0,LSL #2
0005a0  eb010080          ADD      r0,r1,r0,LSL #2
0005a4  1d21              ADDS     r1,r4,#4
0005a6  f7fffffe          BL       vListInsertEnd
;;;1146   
;;;1147   					/* We may have just resumed a higher priority task. */
;;;1148   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0005aa  6ae0              LDR      r0,[r4,#0x2c]
0005ac  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
0005ae  6ac9              LDR      r1,[r1,#0x2c]
0005b0  4288              CMP      r0,r1
0005b2  d301              BCC      |L1.1464|
;;;1149   					{
;;;1150   						/* This yield may not cause the task just resumed to run, but
;;;1151   						will leave the lists in the correct state for the next yield. */
;;;1152   						portYIELD_WITHIN_API();
0005b4  f7fffffe          BL       vPortYield
                  |L1.1464|
;;;1153   					}
;;;1154   				}
;;;1155   			}
;;;1156   			taskEXIT_CRITICAL();
0005b8  e8bd4070          POP      {r4-r6,lr}
0005bc  f7ffbffe          B.W      vPortExitCritical
                  |L1.1472|
;;;1157   		}
;;;1158   	}
0005c0  bd70              POP      {r4-r6,pc}
;;;1159   
                          ENDP

                  xTaskResumeFromISR PROC
;;;1165   
;;;1166   	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
0005c2  e92d41f0          PUSH     {r4-r8,lr}
;;;1167   	{
0005c6  4604              MOV      r4,r0
;;;1168   	portBASE_TYPE xYieldRequired = pdFALSE;
0005c8  2500              MOVS     r5,#0
;;;1169   	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
;;;1170   	unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1171   
;;;1172   		configASSERT( xTaskToResume );
;;;1173   
;;;1174   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1175   		maximum	system call (or maximum API call) interrupt priority.
;;;1176   		Interrupts that are	above the maximum system call priority are keep
;;;1177   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1178   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1179   		is defined in FreeRTOSConfig.h then
;;;1180   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1181   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1182   		been assigned a priority above the configured maximum system call
;;;1183   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1184   		from interrupts	that have been assigned a priority at or (logically)
;;;1185   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1186   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1187   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1188   		provided on the following link:
;;;1189   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1190   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1191   
;;;1192   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0005ca  f7fffffe          BL       ulPortSetInterruptMask
0005ce  4607              MOV      r7,r0
;;;1193   		{
;;;1194   			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
0005d0  4620              MOV      r0,r4
0005d2  f7fffffe          BL       xTaskIsTaskSuspended
0005d6  2801              CMP      r0,#1
0005d8  d108              BNE      |L1.1516|
;;;1195   			{
;;;1196   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1197   
;;;1198   				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
0005da  4e85              LDR      r6,|L1.2032|
0005dc  69b0              LDR      r0,[r6,#0x18]  ; uxSchedulerSuspended
0005de  b150              CBZ      r0,|L1.1526|
;;;1199   				{
;;;1200   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;1201   					{
;;;1202   						xYieldRequired = pdTRUE;
;;;1203   					}
;;;1204   
;;;1205   					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
;;;1206   					prvAddTaskToReadyList( pxTCB );
;;;1207   				}
;;;1208   				else
;;;1209   				{
;;;1210   					/* We cannot access the delayed or ready lists, so will hold this
;;;1211   					task pending until the scheduler is resumed, at which point a
;;;1212   					yield will be performed if necessary. */
;;;1213   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0005e0  4884              LDR      r0,|L1.2036|
0005e2  f1040118          ADD      r1,r4,#0x18
0005e6  308c              ADDS     r0,r0,#0x8c
0005e8  f7fffffe          BL       vListInsertEnd
                  |L1.1516|
;;;1214   				}
;;;1215   			}
;;;1216   		}
;;;1217   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0005ec  4638              MOV      r0,r7
0005ee  f7fffffe          BL       vPortClearInterruptMask
;;;1218   
;;;1219   		return xYieldRequired;
0005f2  4628              MOV      r0,r5
;;;1220   	}
0005f4  e6a4              B        |L1.832|
                  |L1.1526|
0005f6  6ae0              LDR      r0,[r4,#0x2c]         ;1200
0005f8  6831              LDR      r1,[r6,#0]            ;1200  ; pxCurrentTCB
0005fa  6ac9              LDR      r1,[r1,#0x2c]         ;1200
0005fc  4288              CMP      r0,r1                 ;1200
0005fe  d300              BCC      |L1.1538|
000600  2501              MOVS     r5,#1                 ;1202
                  |L1.1538|
000602  1d20              ADDS     r0,r4,#4              ;1205
000604  f7fffffe          BL       uxListRemove
000608  6ae0              LDR      r0,[r4,#0x2c]         ;1206
00060a  6931              LDR      r1,[r6,#0x10]         ;1206  ; uxTopReadyPriority
00060c  4288              CMP      r0,r1                 ;1206
00060e  d900              BLS      |L1.1554|
000610  6130              STR      r0,[r6,#0x10]         ;1206  ; uxTopReadyPriority
                  |L1.1554|
000612  4978              LDR      r1,|L1.2036|
000614  eb000080          ADD      r0,r0,r0,LSL #2       ;1206
000618  eb010080          ADD      r0,r1,r0,LSL #2       ;1206
00061c  1d21              ADDS     r1,r4,#4              ;1206
00061e  f7fffffe          BL       vListInsertEnd
000622  e7e3              B        |L1.1516|
;;;1221   
                          ENDP

                  prvDeleteTCB PROC
;;;2599   
;;;2600   	static void prvDeleteTCB( tskTCB *pxTCB )
000624  b510              PUSH     {r4,lr}
;;;2601   	{
000626  4604              MOV      r4,r0
;;;2602   		/* This call is required specifically for the TriCore port.  It must be
;;;2603   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;2604   		want to allocate and clean RAM statically. */
;;;2605   		portCLEAN_UP_TCB( pxTCB );
;;;2606   
;;;2607   		/* Free up the memory allocated by the scheduler for the task.  It is up to
;;;2608   		the task to free any memory allocated at the application level. */
;;;2609   		vPortFreeAligned( pxTCB->pxStack );
000628  6b20              LDR      r0,[r4,#0x30]
00062a  f7fffffe          BL       vPortFree
;;;2610   		vPortFree( pxTCB );
00062e  4620              MOV      r0,r4
000630  e8bd4010          POP      {r4,lr}
000634  f7ffbffe          B.W      vPortFree
;;;2611   	}
;;;2612   
                          ENDP

                  prvCheckTasksWaitingTermination PROC
;;;2390   
;;;2391   static void prvCheckTasksWaitingTermination( void )
000638  b570              PUSH     {r4-r6,lr}
;;;2392   {
;;;2393   	#if ( INCLUDE_vTaskDelete == 1 )
;;;2394   	{
;;;2395   		portBASE_TYPE xListIsEmpty;
;;;2396   
;;;2397   		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
;;;2398   		too often in the idle task. */
;;;2399   		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
;;;2400   		{
;;;2401   			vTaskSuspendAll();
;;;2402   				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
00063a  4e6e              LDR      r6,|L1.2036|
;;;2403   			( void ) xTaskResumeAll();
;;;2404   
;;;2405   			if( xListIsEmpty == pdFALSE )
;;;2406   			{
;;;2407   				tskTCB *pxTCB;
;;;2408   
;;;2409   				taskENTER_CRITICAL();
;;;2410   				{
;;;2411   					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
;;;2412   					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
;;;2413   					--uxCurrentNumberOfTasks;
00063c  4d6c              LDR      r5,|L1.2032|
00063e  36a0              ADDS     r6,r6,#0xa0           ;2402
000640  e01c              B        |L1.1660|
                  |L1.1602|
000642  f7fffffe          BL       vTaskSuspendAll
000646  6830              LDR      r0,[r6,#0]            ;2402  ; xTasksWaitingTermination
000648  b120              CBZ      r0,|L1.1620|
00064a  2400              MOVS     r4,#0                 ;2402
                  |L1.1612|
00064c  f7fffffe          BL       xTaskResumeAll
000650  b9a4              CBNZ     r4,|L1.1660|
000652  e001              B        |L1.1624|
                  |L1.1620|
000654  2401              MOVS     r4,#1                 ;2402
000656  e7f9              B        |L1.1612|
                  |L1.1624|
000658  f7fffffe          BL       vPortEnterCritical
00065c  68f0              LDR      r0,[r6,#0xc]          ;2411  ; xTasksWaitingTermination
00065e  68c4              LDR      r4,[r0,#0xc]          ;2411
000660  1d20              ADDS     r0,r4,#4              ;2412
000662  f7fffffe          BL       uxListRemove
000666  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
000668  1e40              SUBS     r0,r0,#1
00066a  60a8              STR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;2414   					--uxTasksDeleted;
00066c  6868              LDR      r0,[r5,#4]  ; uxTasksDeleted
00066e  1e40              SUBS     r0,r0,#1
000670  6068              STR      r0,[r5,#4]  ; uxTasksDeleted
;;;2415   				}
;;;2416   				taskEXIT_CRITICAL();
000672  f7fffffe          BL       vPortExitCritical
;;;2417   
;;;2418   				prvDeleteTCB( pxTCB );
000676  4620              MOV      r0,r4
000678  f7fffffe          BL       prvDeleteTCB
                  |L1.1660|
00067c  6868              LDR      r0,[r5,#4]            ;2399  ; uxTasksDeleted
00067e  2800              CMP      r0,#0                 ;2399
000680  d1df              BNE      |L1.1602|
;;;2419   			}
;;;2420   		}
;;;2421   	}
;;;2422   	#endif /* vTaskDelete */
;;;2423   }
000682  bd70              POP      {r4-r6,pc}
;;;2424   /*-----------------------------------------------------------*/
                          ENDP

                  prvIdleTask PROC
;;;2127    */
;;;2128   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000684  4c5b              LDR      r4,|L1.2036|
                  |L1.1670|
;;;2129   {
;;;2130   	/* Stop warnings. */
;;;2131   	( void ) pvParameters;
;;;2132   
;;;2133   	for( ;; )
;;;2134   	{
;;;2135   		/* See if any tasks have been deleted. */
;;;2136   		prvCheckTasksWaitingTermination();
000686  f7fffffe          BL       prvCheckTasksWaitingTermination
;;;2137   
;;;2138   		#if ( configUSE_PREEMPTION == 0 )
;;;2139   		{
;;;2140   			/* If we are not using preemption we keep forcing a task switch to
;;;2141   			see if any other task has become available.  If we are using
;;;2142   			preemption we don't need to do this as any task becoming available
;;;2143   			will automatically get the processor anyway. */
;;;2144   			taskYIELD();
;;;2145   		}
;;;2146   		#endif /* configUSE_PREEMPTION */
;;;2147   
;;;2148   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;2149   		{
;;;2150   			/* When using preemption tasks of equal priority will be
;;;2151   			timesliced.  If a task that is sharing the idle priority is ready
;;;2152   			to run then the idle task should yield before the end of the
;;;2153   			timeslice.
;;;2154   
;;;2155   			A critical region is not required here as we are just reading from
;;;2156   			the list, and an occasional incorrect value will not matter.  If
;;;2157   			the ready list at the idle priority contains more than one task
;;;2158   			then a task other than the idle task is ready to execute. */
;;;2159   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
00068a  6820              LDR      r0,[r4,#0]  ; pxReadyTasksLists
00068c  2801              CMP      r0,#1
00068e  d9fa              BLS      |L1.1670|
;;;2160   			{
;;;2161   				taskYIELD();
000690  f7fffffe          BL       vPortYield
000694  e7f7              B        |L1.1670|
;;;2162   			}
;;;2163   		}
;;;2164   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;2165   
;;;2166   		#if ( configUSE_IDLE_HOOK == 1 )
;;;2167   		{
;;;2168   			extern void vApplicationIdleHook( void );
;;;2169   
;;;2170   			/* Call the user defined function from within the idle task.  This
;;;2171   			allows the application designer to add background functionality
;;;2172   			without the overhead of a separate task.
;;;2173   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;2174   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;2175   			vApplicationIdleHook();
;;;2176   		}
;;;2177   		#endif /* configUSE_IDLE_HOOK */
;;;2178   
;;;2179   		/* This conditional compilation should use inequality to 0, not equality
;;;2180   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;2181   		user defined low power mode	implementations require
;;;2182   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;2183   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;2184   		{
;;;2185   		portTickType xExpectedIdleTime;
;;;2186   
;;;2187   			/* It is not desirable to suspend then resume the scheduler on
;;;2188   			each iteration of the idle task.  Therefore, a preliminary
;;;2189   			test of the expected idle time is performed without the
;;;2190   			scheduler suspended.  The result here is not necessarily
;;;2191   			valid. */
;;;2192   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2193   
;;;2194   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2195   			{
;;;2196   				vTaskSuspendAll();
;;;2197   				{
;;;2198   					/* Now the scheduler is suspended, the expected idle
;;;2199   					time can be sampled again, and this time its value can
;;;2200   					be used. */
;;;2201   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;2202   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2203   
;;;2204   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2205   					{
;;;2206   						traceLOW_POWER_IDLE_BEGIN();
;;;2207   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;2208   						traceLOW_POWER_IDLE_END();
;;;2209   					}
;;;2210   				}
;;;2211   				( void ) xTaskResumeAll();
;;;2212   			}
;;;2213   		}
;;;2214   		#endif /* configUSE_TICKLESS_IDLE */
;;;2215   	}
;;;2216   }
;;;2217   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskStartScheduler PROC
;;;1224   
;;;1225   void vTaskStartScheduler( void )
000696  b51f              PUSH     {r0-r4,lr}
;;;1226   {
;;;1227   portBASE_TYPE xReturn;
;;;1228   
;;;1229   	/* Add the idle task at the lowest priority. */
;;;1230   	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
;;;1231   	{
;;;1232   		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
;;;1233   		be returned by the xTaskGetIdleTaskHandle() function. */
;;;1234   		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1235   	}
;;;1236   	#else
;;;1237   	{
;;;1238   		/* Create the idle task without storing its handle. */
;;;1239   		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
000698  2400              MOVS     r4,#0
00069a  9400              STR      r4,[sp,#0]
00069c  9401              STR      r4,[sp,#4]
00069e  9402              STR      r4,[sp,#8]
0006a0  4623              MOV      r3,r4
0006a2  2280              MOVS     r2,#0x80
0006a4  a154              ADR      r1,|L1.2040|
0006a6  4856              LDR      r0,|L1.2048|
0006a8  9403              STR      r4,[sp,#0xc]
0006aa  f7fffffe          BL       xTaskGenericCreate
;;;1240   	}
;;;1241   	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
;;;1242   
;;;1243   	#if ( configUSE_TIMERS == 1 )
;;;1244   	{
;;;1245   		if( xReturn == pdPASS )
;;;1246   		{
;;;1247   			xReturn = xTimerCreateTimerTask();
;;;1248   		}
;;;1249   	}
;;;1250   	#endif /* configUSE_TIMERS */
;;;1251   
;;;1252   	if( xReturn == pdPASS )
0006ae  2801              CMP      r0,#1
0006b0  d109              BNE      |L1.1734|
;;;1253   	{
;;;1254   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1255   		before or during the call to xPortStartScheduler().  The stacks of
;;;1256   		the created tasks contain a status word with interrupts switched on
;;;1257   		so interrupts will automatically get re-enabled when the first task
;;;1258   		starts to run. */
;;;1259   		portDISABLE_INTERRUPTS();
0006b2  f7fffffe          BL       ulPortSetInterruptMask
;;;1260   
;;;1261   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1262   		{
;;;1263   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1264   			structure specific to the task that will run first. */
;;;1265   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1266   		}
;;;1267   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1268   
;;;1269   		xSchedulerRunning = pdTRUE;
0006b6  484e              LDR      r0,|L1.2032|
0006b8  2101              MOVS     r1,#1
0006ba  6141              STR      r1,[r0,#0x14]  ; xSchedulerRunning
;;;1270   		xTickCount = ( portTickType ) 0U;
0006bc  60c4              STR      r4,[r0,#0xc]  ; xTickCount
;;;1271   
;;;1272   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1273   		macro must be defined to configure the timer/counter used to generate
;;;1274   		the run time counter time base. */
;;;1275   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1276   
;;;1277   		/* Setting up the timer tick is hardware specific and thus in the
;;;1278   		portable interface. */
;;;1279   		if( xPortStartScheduler() != pdFALSE )
0006be  e8bd401f          POP      {r0-r4,lr}
0006c2  f7ffbffe          B.W      xPortStartScheduler
                  |L1.1734|
;;;1280   		{
;;;1281   			/* Should not reach here as if the scheduler is running the
;;;1282   			function will not return. */
;;;1283   		}
;;;1284   		else
;;;1285   		{
;;;1286   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1287   		}
;;;1288   	}
;;;1289   	else
;;;1290   	{
;;;1291   		/* This line will only be reached if the kernel could not be started,
;;;1292   		because there was not enough FreeRTOS heap to create the idle task
;;;1293   		or the timer task. */
;;;1294   		configASSERT( xReturn );
;;;1295   	}
;;;1296   }
0006c6  bd1f              POP      {r0-r4,pc}
;;;1297   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskEndScheduler PROC
;;;1298   
;;;1299   void vTaskEndScheduler( void )
0006c8  b510              PUSH     {r4,lr}
;;;1300   {
;;;1301   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1302   	routine so the original ISRs can be restored if necessary.  The port
;;;1303   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1304   	portDISABLE_INTERRUPTS();
0006ca  f7fffffe          BL       ulPortSetInterruptMask
;;;1305   	xSchedulerRunning = pdFALSE;
0006ce  4948              LDR      r1,|L1.2032|
0006d0  2000              MOVS     r0,#0
0006d2  6148              STR      r0,[r1,#0x14]  ; xSchedulerRunning
;;;1306   	vPortEndScheduler();
0006d4  e8bd4010          POP      {r4,lr}
0006d8  f7ffbffe          B.W      vPortEndScheduler
;;;1307   }
;;;1308   /*----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCount PROC
;;;1413   
;;;1414   portTickType xTaskGetTickCount( void )
0006dc  b510              PUSH     {r4,lr}
;;;1415   {
;;;1416   portTickType xTicks;
;;;1417   
;;;1418   	/* Critical section required if running on a 16 bit processor. */
;;;1419   	taskENTER_CRITICAL();
0006de  f7fffffe          BL       vPortEnterCritical
;;;1420   	{
;;;1421   		xTicks = xTickCount;
0006e2  4843              LDR      r0,|L1.2032|
0006e4  68c4              LDR      r4,[r0,#0xc]  ; xTickCount
;;;1422   	}
;;;1423   	taskEXIT_CRITICAL();
0006e6  f7fffffe          BL       vPortExitCritical
;;;1424   
;;;1425   	return xTicks;
0006ea  4620              MOV      r0,r4
;;;1426   }
0006ec  bd10              POP      {r4,pc}
;;;1427   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCountFromISR PROC
;;;1428   
;;;1429   portTickType xTaskGetTickCountFromISR( void )
0006ee  b510              PUSH     {r4,lr}
;;;1430   {
;;;1431   portTickType xReturn;
;;;1432   unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1433   
;;;1434   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1435   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1436   	above the maximum system call priority are keep permanently enabled, even
;;;1437   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1438   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1439   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1440   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1441   	assigned a priority above the configured maximum system call priority.
;;;1442   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1443   	that have been assigned a priority at or (logically) below the maximum
;;;1444   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1445   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1446   	More information (albeit Cortex-M specific) is provided on the following
;;;1447   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1448   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1449   
;;;1450   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0006f0  f7fffffe          BL       ulPortSetInterruptMask
;;;1451   	xReturn = xTickCount;
0006f4  493e              LDR      r1,|L1.2032|
0006f6  68cc              LDR      r4,[r1,#0xc]  ; xTickCount
;;;1452   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0006f8  f7fffffe          BL       vPortClearInterruptMask
;;;1453   
;;;1454   	return xReturn;
0006fc  4620              MOV      r0,r4
;;;1455   }
0006fe  bd10              POP      {r4,pc}
;;;1456   /*-----------------------------------------------------------*/
                          ENDP

                  uxTaskGetNumberOfTasks PROC
;;;1457   
;;;1458   unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
000700  483b              LDR      r0,|L1.2032|
;;;1459   {
;;;1460   	/* A critical section is not required because the variables are of type
;;;1461   	portBASE_TYPE. */
;;;1462   	return uxCurrentNumberOfTasks;
000702  6880              LDR      r0,[r0,#8]  ; uxCurrentNumberOfTasks
;;;1463   }
000704  4770              BX       lr
;;;1464   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskPlaceOnEventList PROC
;;;1867   
;;;1868   void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
000706  b570              PUSH     {r4-r6,lr}
;;;1869   {
000708  460d              MOV      r5,r1
;;;1870   portTickType xTimeToWake;
;;;1871   
;;;1872   	configASSERT( pxEventList );
;;;1873   
;;;1874   	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
;;;1875   	SCHEDULER SUSPENDED. */
;;;1876   
;;;1877   	/* Place the event list item of the TCB in the appropriate event list.
;;;1878   	This is placed in the list in priority order so the highest priority task
;;;1879   	is the first to be woken by the event. */
;;;1880   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
00070a  4c39              LDR      r4,|L1.2032|
00070c  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
00070e  3118              ADDS     r1,r1,#0x18
000710  f7fffffe          BL       vListInsert
;;;1881   
;;;1882   	/* We must remove ourselves from the ready list before adding ourselves
;;;1883   	to the blocked list as the same list item is used for both lists.  We have
;;;1884   	exclusive access to the ready lists as the scheduler is locked. */
;;;1885   	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
000714  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000716  1d00              ADDS     r0,r0,#4
000718  f7fffffe          BL       uxListRemove
;;;1886   	{
;;;1887   		/* The current task must be in a ready list, so there is no need to
;;;1888   		check, and the port reset macro can be called directly. */
;;;1889   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;1890   	}
;;;1891   
;;;1892   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;1893   	{
;;;1894   		if( xTicksToWait == portMAX_DELAY )
00071c  1c68              ADDS     r0,r5,#1
00071e  d004              BEQ      |L1.1834|
;;;1895   		{
;;;1896   			/* Add ourselves to the suspended task list instead of a delayed task
;;;1897   			list to ensure we are not woken by a timing event.  We will block
;;;1898   			indefinitely. */
;;;1899   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
;;;1900   		}
;;;1901   		else
;;;1902   		{
;;;1903   			/* Calculate the time at which the task should be woken if the event does
;;;1904   			not occur.  This may overflow but this doesn't matter. */
;;;1905   			xTimeToWake = xTickCount + xTicksToWait;
000720  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
000722  4428              ADD      r0,r0,r5
;;;1906   			prvAddCurrentTaskToDelayedList( xTimeToWake );
000724  e8bd4070          POP      {r4-r6,lr}
000728  e7fe              B        prvAddCurrentTaskToDelayedList
                  |L1.1834|
00072a  6821              LDR      r1,[r4,#0]            ;1899  ; pxCurrentTCB
00072c  e8bd4070          POP      {r4-r6,lr}            ;1899
000730  4830              LDR      r0,|L1.2036|
000732  1d09              ADDS     r1,r1,#4              ;1899
000734  30b4              ADDS     r0,r0,#0xb4           ;1899
000736  f7ffbffe          B.W      vListInsertEnd
;;;1907   		}
;;;1908   	}
;;;1909   	#else /* INCLUDE_vTaskSuspend */
;;;1910   	{
;;;1911   			/* Calculate the time at which the task should be woken if the event does
;;;1912   			not occur.  This may overflow but this doesn't matter. */
;;;1913   			xTimeToWake = xTickCount + xTicksToWait;
;;;1914   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;1915   	}
;;;1916   	#endif /* INCLUDE_vTaskSuspend */
;;;1917   }
;;;1918   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskRemoveFromEventList PROC
;;;1960   
;;;1961   signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
00073a  b570              PUSH     {r4-r6,lr}
;;;1962   {
;;;1963   tskTCB *pxUnblockedTCB;
;;;1964   portBASE_TYPE xReturn;
;;;1965   
;;;1966   	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
;;;1967   	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
;;;1968   
;;;1969   	/* The event list is sorted in priority order, so we can remove the
;;;1970   	first in the list, remove the TCB from the delayed list, and add
;;;1971   	it to the ready list.
;;;1972   
;;;1973   	If an event is for a queue that is locked then this function will never
;;;1974   	get called - the lock count on the queue will get modified instead.  This
;;;1975   	means we can always expect exclusive access to the event list here.
;;;1976   
;;;1977   	This function assumes that a check has already been made to ensure that
;;;1978   	pxEventList is not empty. */
;;;1979   	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
00073c  68c0              LDR      r0,[r0,#0xc]
00073e  68c4              LDR      r4,[r0,#0xc]
;;;1980   	configASSERT( pxUnblockedTCB );
;;;1981   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000740  f1040018          ADD      r0,r4,#0x18
000744  4606              MOV      r6,r0
000746  f7fffffe          BL       uxListRemove
;;;1982   
;;;1983   	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
00074a  4d29              LDR      r5,|L1.2032|
00074c  69aa              LDR      r2,[r5,#0x18]  ; uxSchedulerSuspended
00074e  b16a              CBZ      r2,|L1.1900|
;;;1984   	{
;;;1985   		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
;;;1986   		prvAddTaskToReadyList( pxUnblockedTCB );
;;;1987   	}
;;;1988   	else
;;;1989   	{
;;;1990   		/* We cannot access the delayed or ready lists, so will hold this
;;;1991   		task pending until the scheduler is resumed. */
;;;1992   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
000750  4828              LDR      r0,|L1.2036|
000752  4631              MOV      r1,r6
000754  308c              ADDS     r0,r0,#0x8c
000756  f7fffffe          BL       vListInsertEnd
                  |L1.1882|
;;;1993   	}
;;;1994   
;;;1995   	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
00075a  6ae0              LDR      r0,[r4,#0x2c]
00075c  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00075e  6ac9              LDR      r1,[r1,#0x2c]
000760  4288              CMP      r0,r1
000762  d314              BCC      |L1.1934|
;;;1996   	{
;;;1997   		/* Return true if the task removed from the event list has
;;;1998   		a higher priority than the calling task.  This allows
;;;1999   		the calling task to know if it should force a context
;;;2000   		switch now. */
;;;2001   		xReturn = pdTRUE;
000764  2001              MOVS     r0,#1
;;;2002   
;;;2003   		/* Mark that a yield is pending in case the user is not using the
;;;2004   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2005   		xYieldPending = pdTRUE;
000766  2101              MOVS     r1,#1
000768  6229              STR      r1,[r5,#0x20]  ; xYieldPending
;;;2006   	}
;;;2007   	else
;;;2008   	{
;;;2009   		xReturn = pdFALSE;
;;;2010   	}
;;;2011   
;;;2012   	return xReturn;
;;;2013   }
00076a  bd70              POP      {r4-r6,pc}
                  |L1.1900|
00076c  1d20              ADDS     r0,r4,#4              ;1985
00076e  f7fffffe          BL       uxListRemove
000772  6ae0              LDR      r0,[r4,#0x2c]         ;1986
000774  6929              LDR      r1,[r5,#0x10]         ;1986  ; uxTopReadyPriority
000776  4288              CMP      r0,r1                 ;1986
000778  d900              BLS      |L1.1916|
00077a  6128              STR      r0,[r5,#0x10]         ;1986  ; uxTopReadyPriority
                  |L1.1916|
00077c  491d              LDR      r1,|L1.2036|
00077e  eb000080          ADD      r0,r0,r0,LSL #2       ;1986
000782  eb010080          ADD      r0,r1,r0,LSL #2       ;1986
000786  1d21              ADDS     r1,r4,#4              ;1986
000788  f7fffffe          BL       vListInsertEnd
00078c  e7e5              B        |L1.1882|
                  |L1.1934|
00078e  2000              MOVS     r0,#0                 ;2009
000790  bd70              POP      {r4-r6,pc}
;;;2014   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSetTimeOutState PROC
;;;2015   
;;;2016   void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
000792  4917              LDR      r1,|L1.2032|
;;;2017   {
;;;2018   	configASSERT( pxTimeOut );
;;;2019   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000794  6a4a              LDR      r2,[r1,#0x24]  ; xNumOfOverflows
000796  6002              STR      r2,[r0,#0]
;;;2020   	pxTimeOut->xTimeOnEntering = xTickCount;
000798  68c9              LDR      r1,[r1,#0xc]  ; xTickCount
00079a  6041              STR      r1,[r0,#4]
;;;2021   }
00079c  4770              BX       lr
;;;2022   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskCheckForTimeOut PROC
;;;2023   
;;;2024   portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
00079e  b570              PUSH     {r4-r6,lr}
;;;2025   {
0007a0  4604              MOV      r4,r0
0007a2  460d              MOV      r5,r1
;;;2026   portBASE_TYPE xReturn;
;;;2027   
;;;2028   	configASSERT( pxTimeOut );
;;;2029   	configASSERT( pxTicksToWait );
;;;2030   
;;;2031   	taskENTER_CRITICAL();
0007a4  f7fffffe          BL       vPortEnterCritical
;;;2032   	{
;;;2033   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;2034   		const portTickType xConstTickCount = xTickCount;
0007a8  4911              LDR      r1,|L1.2032|
0007aa  68c8              LDR      r0,[r1,#0xc]  ; xTickCount
;;;2035   
;;;2036   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;2037   			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
;;;2038   			the maximum block time then the task should block indefinitely, and
;;;2039   			therefore never time out. */
;;;2040   			if( *pxTicksToWait == portMAX_DELAY )
0007ac  682a              LDR      r2,[r5,#0]
0007ae  1c53              ADDS     r3,r2,#1
0007b0  d008              BEQ      |L1.1988|
;;;2041   			{
;;;2042   				xReturn = pdFALSE;
;;;2043   			}
;;;2044   			else /* We are not blocking indefinitely, perform the checks below. */
;;;2045   		#endif
;;;2046   
;;;2047   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
0007b2  6823              LDR      r3,[r4,#0]
0007b4  6a49              LDR      r1,[r1,#0x24]  ; xNumOfOverflows
0007b6  428b              CMP      r3,r1
0007b8  d006              BEQ      |L1.1992|
0007ba  6861              LDR      r1,[r4,#4]
0007bc  4281              CMP      r1,r0
0007be  d803              BHI      |L1.1992|
;;;2048   		{
;;;2049   			/* The tick count is greater than the time at which vTaskSetTimeout()
;;;2050   			was called, but has also overflowed since vTaskSetTimeOut() was called.
;;;2051   			It must have wrapped all the way around and gone past us again. This
;;;2052   			passed since vTaskSetTimeout() was called. */
;;;2053   			xReturn = pdTRUE;
0007c0  2401              MOVS     r4,#1
0007c2  e00d              B        |L1.2016|
                  |L1.1988|
0007c4  2400              MOVS     r4,#0                 ;2042
0007c6  e00b              B        |L1.2016|
                  |L1.1992|
;;;2054   		}
;;;2055   		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
0007c8  6861              LDR      r1,[r4,#4]
0007ca  1a40              SUBS     r0,r0,r1
0007cc  4290              CMP      r0,r2
0007ce  d206              BCS      |L1.2014|
;;;2056   		{
;;;2057   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;2058   			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
0007d0  1a10              SUBS     r0,r2,r0
0007d2  6028              STR      r0,[r5,#0]
;;;2059   			vTaskSetTimeOutState( pxTimeOut );
0007d4  4620              MOV      r0,r4
0007d6  f7fffffe          BL       vTaskSetTimeOutState
;;;2060   			xReturn = pdFALSE;
0007da  2400              MOVS     r4,#0
0007dc  e000              B        |L1.2016|
                  |L1.2014|
;;;2061   		}
;;;2062   		else
;;;2063   		{
;;;2064   			xReturn = pdTRUE;
0007de  2401              MOVS     r4,#1
                  |L1.2016|
;;;2065   		}
;;;2066   	}
;;;2067   	taskEXIT_CRITICAL();
0007e0  f7fffffe          BL       vPortExitCritical
;;;2068   
;;;2069   	return xReturn;
0007e4  4620              MOV      r0,r4
;;;2070   }
0007e6  bd70              POP      {r4-r6,pc}
;;;2071   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskMissedYield PROC
;;;2072   
;;;2073   void vTaskMissedYield( void )
0007e8  4901              LDR      r1,|L1.2032|
;;;2074   {
;;;2075   	xYieldPending = pdTRUE;
0007ea  2001              MOVS     r0,#1
0007ec  6208              STR      r0,[r1,#0x20]  ; xYieldPending
;;;2076   }
0007ee  4770              BX       lr
;;;2077   /*-----------------------------------------------------------*/
                          ENDP

                  |L1.2032|
                          DCD      ||.data||
                  |L1.2036|
                          DCD      ||.bss||
                  |L1.2040|
0007f8  49444c45          DCB      "IDLE",0
0007fc  00      
0007fd  00                DCB      0
0007fe  00                DCB      0
0007ff  00                DCB      0
                  |L1.2048|
                          DCD      prvIdleTask

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        100
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  uxTasksDeleted
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0xffffffff
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
