; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\buttons.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\buttons.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\buttons.crf src\buttons.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UpdateRawButtonState PROC
;;;23     //---------------------------------------------//
;;;24     static void UpdateRawButtonState(void)
000000  b570              PUSH     {r4-r6,lr}
;;;25     {
;;;26     	uint16_t raw_buttons = 0;
000002  2400              MOVS     r4,#0
;;;27     	uint32_t temp;
;;;28     	uint32_t time_delay;
;;;29     	// SB_ON and SB_OFF are combined with the green and red leds
;;;30     	// disable output for leds
;;;31     	MDR_PORTB->OE &= ~(1<<LGREEN | 1<<LRED);
000004  4849              LDR      r0,|L1.300|
000006  6840              LDR      r0,[r0,#4]
000008  f02000c0          BIC      r0,r0,#0xc0
00000c  4947              LDR      r1,|L1.300|
00000e  6048              STR      r0,[r1,#4]
;;;32     	// Start delay
;;;33     	time_delay = DWT_StartDelayUs(10);
000010  200a              MOVS     r0,#0xa
000012  f7fffffe          BL       DWT_StartDelayUs
000016  4606              MOV      r6,r0
;;;34     	// get other buttons by delay time
;;;35     	temp = MDR_PORTA->RXTX;
000018  4845              LDR      r0,|L1.304|
00001a  6805              LDR      r5,[r0,#0]
;;;36     	if (! (temp & (1<<ENC_BTN)) )
00001c  f0150f20          TST      r5,#0x20
000020  d101              BNE      |L1.38|
;;;37     		raw_buttons |= BTN_ENCODER;
000022  f0440410          ORR      r4,r4,#0x10
                  |L1.38|
;;;38     	if (temp & (1<<EEN))
000026  f0150f04          TST      r5,#4
00002a  d001              BEQ      |L1.48|
;;;39     		raw_buttons |= SW_EXTERNAL;
00002c  f4447480          ORR      r4,r4,#0x100
                  |L1.48|
;;;40     	temp = MDR_PORTB->RXTX;
000030  483e              LDR      r0,|L1.300|
000032  6805              LDR      r5,[r0,#0]
;;;41     	if (! (temp & (1<<SB_ESC)) )
000034  f0150f01          TST      r5,#1
000038  d101              BNE      |L1.62|
;;;42     		raw_buttons |= BTN_ESC;
00003a  f0440401          ORR      r4,r4,#1
                  |L1.62|
;;;43     	if (! (temp & (1<<SB_LEFT)) )
00003e  f0150f02          TST      r5,#2
000042  d101              BNE      |L1.72|
;;;44     		raw_buttons |= BTN_LEFT;
000044  f0440402          ORR      r4,r4,#2
                  |L1.72|
;;;45     	if (! (temp & (1<<SB_RIGHT)) )
000048  f0150f04          TST      r5,#4
00004c  d101              BNE      |L1.82|
;;;46     		raw_buttons |= BTN_RIGHT;
00004e  f0440404          ORR      r4,r4,#4
                  |L1.82|
;;;47     	if (! (temp & (1<<SB_OK)) )
000052  f0150f10          TST      r5,#0x10
000056  d101              BNE      |L1.92|
;;;48     		raw_buttons |= BTN_OK;
000058  f0440408          ORR      r4,r4,#8
                  |L1.92|
;;;49     	if (! (temp & (1<<SB_MODE)) )
00005c  f0150f20          TST      r5,#0x20
000060  d101              BNE      |L1.102|
;;;50     		raw_buttons |= SW_CHANNEL;
000062  f0440420          ORR      r4,r4,#0x20
                  |L1.102|
;;;51     	// wait until delay is done
;;;52     	while(DWT_DelayInProgress(time_delay));
000066  bf00              NOP      
                  |L1.104|
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       DWT_DelayInProgress
00006e  2800              CMP      r0,#0
000070  d1fa              BNE      |L1.104|
;;;53     	// read once more
;;;54     	temp = MDR_PORTB->RXTX;
000072  482e              LDR      r0,|L1.300|
000074  6805              LDR      r5,[r0,#0]
;;;55     	// enable outputs for leds again
;;;56     	MDR_PORTB->OE |= (1<<LGREEN | 1<<LRED);
000076  6840              LDR      r0,[r0,#4]
000078  f04000c0          ORR      r0,r0,#0xc0
00007c  492b              LDR      r1,|L1.300|
00007e  6048              STR      r0,[r1,#4]
;;;57     	// add remaining buttons	
;;;58     	if (! (temp & (1<<LGREEN)) )
000080  f0150f80          TST      r5,#0x80
000084  d101              BNE      |L1.138|
;;;59     		raw_buttons |= BTN_ON;
000086  f0440440          ORR      r4,r4,#0x40
                  |L1.138|
;;;60     	if (! (temp & (1<<LRED)) )
00008a  f0150f40          TST      r5,#0x40
00008e  d101              BNE      |L1.148|
;;;61     		raw_buttons |= BTN_OFF;
000090  f0440480          ORR      r4,r4,#0x80
                  |L1.148|
;;;62     
;;;63     	
;;;64     	// Update global variable
;;;65     	raw_button_state = raw_buttons;
000094  4827              LDR      r0,|L1.308|
000096  8004              STRH     r4,[r0,#0]
;;;66     }
000098  bd70              POP      {r4-r6,pc}
;;;67     
                          ENDP

                  ResetButtonEvents PROC
;;;71     //---------------------------------------------//
;;;72     static void ResetButtonEvents(void)
00009a  2000              MOVS     r0,#0
;;;73     {
;;;74     	buttons.action_down = 0;
00009c  4926              LDR      r1,|L1.312|
00009e  8048              STRH     r0,[r1,#2]
;;;75     	#ifdef USE_ACTION_REP
;;;76     	buttons.action_rep = 0;
;;;77     	#endif
;;;78     	#ifdef USE_ACTION_UP
;;;79     	buttons.action_up = 0;
0000a0  8088              STRH     r0,[r1,#4]
;;;80     	#endif
;;;81     	#ifdef USE_ACTION_UP_SHORT
;;;82     	buttons.action_up_short = 0;
;;;83     	#endif
;;;84     	#ifdef USE_ACTION_UP_LONG
;;;85     	buttons.action_up_long = 0;
;;;86     	#endif
;;;87     	#ifdef USE_ACTION_HOLD
;;;88     	buttons.action_hold = 0;
;;;89     	#endif
;;;90     }
0000a2  4770              BX       lr
;;;91     
                          ENDP

                  InitButtons PROC
;;;95     //---------------------------------------------//
;;;96     void InitButtons(void)
0000a4  b510              PUSH     {r4,lr}
;;;97     {
;;;98     	uint8_t i;
;;;99     	for (i=0; i<TOTAL_BUTTONS; i++)
0000a6  2400              MOVS     r4,#0
0000a8  e005              B        |L1.182|
                  |L1.170|
;;;100    	{
;;;101    		bit_fifo[i] = 0;
0000aa  2000              MOVS     r0,#0
0000ac  4923              LDR      r1,|L1.316|
0000ae  f8210014          STRH     r0,[r1,r4,LSL #1]
0000b2  1c60              ADDS     r0,r4,#1              ;99
0000b4  b2c4              UXTB     r4,r0                 ;99
                  |L1.182|
0000b6  2c09              CMP      r4,#9                 ;99
0000b8  dbf7              BLT      |L1.170|
;;;102    	}
;;;103    	ResetButtonEvents();
0000ba  f7fffffe          BL       ResetButtonEvents
;;;104    	#ifdef USE_ACTION_TOGGLE
;;;105    	buttons.action_toggle = 0;
;;;106    	#endif
;;;107    }
0000be  bd10              POP      {r4,pc}
;;;108    
                          ENDP

                  ProcessButtons PROC
;;;112    //---------------------------------------------//
;;;113    void ProcessButtons(void)
0000c0  e92d41f0          PUSH     {r4-r8,lr}
;;;114    {
;;;115    	bfifo_type_t temp;	
;;;116    	btn_type_t raw_current;
;;;117    	btn_type_t current_bit;
;;;118    	uint8_t i;
;;;119    	
;;;120    	UpdateRawButtonState();
0000c4  f7fffffe          BL       UpdateRawButtonState
;;;121    	raw_current = raw_button_state ^ RAW_BUTTON_INVERSE_MASK;
0000c8  481a              LDR      r0,|L1.308|
0000ca  8807              LDRH     r7,[r0,#0]  ; raw_button_state
;;;122    	ResetButtonEvents();
0000cc  f7fffffe          BL       ResetButtonEvents
;;;123    	
;;;124    	// Loop through all buttons
;;;125    	for (i=0; i<TOTAL_BUTTONS; i++)
0000d0  2400              MOVS     r4,#0
0000d2  e024              B        |L1.286|
                  |L1.212|
;;;126    	{
;;;127    		current_bit = (1<<i);
0000d4  2001              MOVS     r0,#1
0000d6  40a0              LSLS     r0,r0,r4
0000d8  b286              UXTH     r6,r0
;;;128    		temp = bit_fifo[i];
0000da  4818              LDR      r0,|L1.316|
0000dc  f8305014          LDRH     r5,[r0,r4,LSL #1]
;;;129    		// Shift in current button state bit
;;;130    		temp <<= 1;
0000e0  0468              LSLS     r0,r5,#17
0000e2  0c05              LSRS     r5,r0,#16
;;;131    		if (raw_current & current_bit)
0000e4  4237              TST      r7,r6
0000e6  d001              BEQ      |L1.236|
;;;132    			temp |= 0x01;
0000e8  f0450501          ORR      r5,r5,#1
                  |L1.236|
;;;133    		// Analyse FIFO and produce events
;;;134    		switch(temp & BFIFO_BUTTON_MASK)
0000ec  f0050003          AND      r0,r5,#3
0000f0  2801              CMP      r0,#1
0000f2  d002              BEQ      |L1.250|
0000f4  2802              CMP      r0,#2
0000f6  d10c              BNE      |L1.274|
0000f8  e005              B        |L1.262|
                  |L1.250|
;;;135    		{
;;;136    			case BFIFO_BUTTON_DOWN:
;;;137    				buttons.action_down |= current_bit;
0000fa  480f              LDR      r0,|L1.312|
0000fc  8840              LDRH     r0,[r0,#2]  ; buttons
0000fe  4330              ORRS     r0,r0,r6
000100  490d              LDR      r1,|L1.312|
000102  8048              STRH     r0,[r1,#2]
;;;138    				#ifdef USE_ACTION_REP
;;;139    				buttons.action_rep |= current_bit;
;;;140    				#endif
;;;141    				#ifdef USE_ACTION_TOGGLE
;;;142    				buttons.action_toggle ^= current_bit;
;;;143    				#endif
;;;144    				break;
000104  e005              B        |L1.274|
                  |L1.262|
;;;145    			#ifdef ANALYSE_ACTION_UP
;;;146    			case BFIFO_BUTTON_UP:
;;;147    				#ifdef USE_ACTION_UP
;;;148    				buttons.action_up |= current_bit;
000106  480c              LDR      r0,|L1.312|
000108  8880              LDRH     r0,[r0,#4]  ; buttons
00010a  4330              ORRS     r0,r0,r6
00010c  490a              LDR      r1,|L1.312|
00010e  8088              STRH     r0,[r1,#4]
000110  bf00              NOP                            ;134
                  |L1.274|
000112  bf00              NOP                            ;144
;;;149    				#endif
;;;150    				#ifdef ANALYZE_TIMED_ACTION_UP
;;;151    				if ((temp & BFIFO_LONG_MASK) == BFIFO_LONG_MASK)
;;;152    				{
;;;153    					#ifdef USE_ACTION_UP_LONG
;;;154    					buttons.action_up_long |= current_bit;
;;;155    					#endif
;;;156    				}
;;;157    				else
;;;158    				{
;;;159    					#ifdef USE_ACTION_UP_SHORT
;;;160    					buttons.action_up_short |= current_bit;
;;;161    					#endif
;;;162    				}
;;;163    				break;
;;;164    				#endif
;;;165    			#endif
;;;166    			#ifdef ANALYSE_HOLD
;;;167    			case BFIFO_BUTTON_HOLD:
;;;168    				#ifdef USE_ACTION_REP
;;;169    				if ((temp & BFIFO_REPEAT_MASK) == BFIFO_REPEAT_MASK)
;;;170    				{
;;;171    					buttons.action_rep |= current_bit;
;;;172    				}
;;;173    				#endif
;;;174    				#ifdef USE_ACTION_HOLD
;;;175    				if ((temp & BFIFO_LONG_MASK) == BFIFO_HOLD)
;;;176    				{
;;;177    					buttons.action_hold |= current_bit;
;;;178    				}
;;;179    				break;
;;;180    				#endif
;;;181    			#endif
;;;182    		}
;;;183    		bit_fifo[i] = temp;
000114  4809              LDR      r0,|L1.316|
000116  f8205014          STRH     r5,[r0,r4,LSL #1]
00011a  1c60              ADDS     r0,r4,#1              ;125
00011c  b2c4              UXTB     r4,r0                 ;125
                  |L1.286|
00011e  2c09              CMP      r4,#9                 ;125
000120  dbd8              BLT      |L1.212|
;;;184    	}
;;;185    	buttons.raw_state = raw_current;
000122  4805              LDR      r0,|L1.312|
000124  8007              STRH     r7,[r0,#0]
;;;186    }
000126  e8bd81f0          POP      {r4-r8,pc}
;;;187    
                          ENDP

00012a  0000              DCW      0x0000
                  |L1.300|
                          DCD      0x400b0000
                  |L1.304|
                          DCD      0x400a8000
                  |L1.308|
                          DCD      raw_button_state
                  |L1.312|
                          DCD      buttons
                  |L1.316|
                          DCD      bit_fifo

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  bit_fifo
                          %        18

                          AREA ||.data||, DATA, ALIGN=1

                  raw_button_state
000000  0000              DCW      0x0000
                  buttons
000002  0000              DCB      0x00,0x00
                          DCDU     0x00000000

;*** Start embedded assembler ***

#line 1 "src\\buttons.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_buttons_c_c0fb6984____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_buttons_c_c0fb6984____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_buttons_c_c0fb6984____REVSH|
#line 130
|__asm___9_buttons_c_c0fb6984____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
