; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list -c --asm --interleave -o.\FLASH\buttons.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\buttons.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -I.\src\gui -I.\src\gui\guiCore -I.\src\gui\guiWidgets -I.\src\gui\guiGraphics -I.\src\gui\utils -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\buttons.crf src\buttons.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UpdateRawButtonState PROC
;;;23     //---------------------------------------------//
;;;24     static void UpdateRawButtonState(void)
000000  b570              PUSH     {r4-r6,lr}
;;;25     {
;;;26     	uint16_t raw_buttons = 0;
000002  2400              MOVS     r4,#0
;;;27     	uint32_t temp;
;;;28     	uint32_t time_delay;
;;;29     	// SB_ON and SB_OFF are combined with the green and red leds
;;;30     	// disable output for leds
;;;31     	MDR_PORTB->OE &= ~(1<<LGREEN | 1<<LRED);
000004  4d3e              LDR      r5,|L1.256|
000006  6868              LDR      r0,[r5,#4]
000008  f02000c0          BIC      r0,r0,#0xc0
00000c  6068              STR      r0,[r5,#4]
;;;32     	// Start delay
;;;33     	time_delay = DWT_StartDelayUs(10);
00000e  200a              MOVS     r0,#0xa
000010  f7fffffe          BL       DWT_StartDelayUs
000014  4606              MOV      r6,r0
;;;34     	// get other buttons by delay time
;;;35     	temp = MDR_PORTA->RXTX;
000016  483b              LDR      r0,|L1.260|
000018  6800              LDR      r0,[r0,#0]
;;;36     	if (! (temp & (1<<ENC_BTN)) )
00001a  0681              LSLS     r1,r0,#26
00001c  d400              BMI      |L1.32|
;;;37     		raw_buttons |= BTN_ENCODER;
00001e  2410              MOVS     r4,#0x10
                  |L1.32|
;;;38     	if (! (temp & (1<<EEN)) )
000020  0740              LSLS     r0,r0,#29
000022  d401              BMI      |L1.40|
;;;39     		raw_buttons |= SW_EXTERNAL;
000024  f4447480          ORR      r4,r4,#0x100
                  |L1.40|
;;;40     	temp = MDR_PORTB->RXTX;
000028  6828              LDR      r0,[r5,#0]
;;;41     	if (! (temp & (1<<SB_ESC)) )
00002a  07c1              LSLS     r1,r0,#31
00002c  d101              BNE      |L1.50|
;;;42     		raw_buttons |= BTN_ESC;
00002e  f0440401          ORR      r4,r4,#1
                  |L1.50|
;;;43     	if (! (temp & (1<<SB_LEFT)) )
000032  0781              LSLS     r1,r0,#30
000034  d401              BMI      |L1.58|
;;;44     		raw_buttons |= BTN_LEFT;
000036  f0440402          ORR      r4,r4,#2
                  |L1.58|
;;;45     	if (! (temp & (1<<SB_RIGHT)) )
00003a  0741              LSLS     r1,r0,#29
00003c  d401              BMI      |L1.66|
;;;46     		raw_buttons |= BTN_RIGHT;
00003e  f0440404          ORR      r4,r4,#4
                  |L1.66|
;;;47     	if (! (temp & (1<<SB_OK)) )
000042  06c1              LSLS     r1,r0,#27
000044  d401              BMI      |L1.74|
;;;48     		raw_buttons |= BTN_OK;
000046  f0440408          ORR      r4,r4,#8
                  |L1.74|
;;;49     	if (! (temp & (1<<SB_MODE)) )
00004a  0680              LSLS     r0,r0,#26
00004c  d401              BMI      |L1.82|
;;;50     		raw_buttons |= SW_CHANNEL;
00004e  f0440420          ORR      r4,r4,#0x20
                  |L1.82|
;;;51     	// wait until delay is done
;;;52     	while(DWT_DelayInProgress(time_delay));
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       DWT_DelayInProgress
000058  2800              CMP      r0,#0
00005a  d1fa              BNE      |L1.82|
;;;53     	// read once more
;;;54     	temp = MDR_PORTB->RXTX;
00005c  6828              LDR      r0,[r5,#0]
;;;55     	// enable outputs for leds again
;;;56     	MDR_PORTB->OE |= (1<<LGREEN | 1<<LRED);
00005e  6869              LDR      r1,[r5,#4]
000060  f04101c0          ORR      r1,r1,#0xc0
000064  6069              STR      r1,[r5,#4]
;;;57     	// add remaining buttons	
;;;58     	if (! (temp & (1<<LGREEN)) )
000066  0601              LSLS     r1,r0,#24
000068  d401              BMI      |L1.110|
;;;59     		raw_buttons |= BTN_ON;
00006a  f0440440          ORR      r4,r4,#0x40
                  |L1.110|
;;;60     	if (! (temp & (1<<LRED)) )
00006e  0640              LSLS     r0,r0,#25
000070  d401              BMI      |L1.118|
;;;61     		raw_buttons |= BTN_OFF;
000072  f0440480          ORR      r4,r4,#0x80
                  |L1.118|
;;;62     
;;;63     	
;;;64     	// Update global variable
;;;65     	raw_button_state = raw_buttons;
000076  4824              LDR      r0,|L1.264|
000078  8004              STRH     r4,[r0,#0]
;;;66     }
00007a  bd70              POP      {r4-r6,pc}
;;;67     
                          ENDP

                  ResetButtonEvents PROC
;;;71     //---------------------------------------------//
;;;72     static void ResetButtonEvents(void)
00007c  4822              LDR      r0,|L1.264|
;;;73     {
;;;74     	buttons.action_down = 0;
00007e  2100              MOVS     r1,#0
000080  1c80              ADDS     r0,r0,#2
000082  8041              STRH     r1,[r0,#2]
;;;75     	#ifdef USE_ACTION_REP
;;;76     	buttons.action_rep = 0;
;;;77     	#endif
;;;78     	#ifdef USE_ACTION_UP
;;;79     	buttons.action_up = 0;
000084  8081              STRH     r1,[r0,#4]
;;;80     	#endif
;;;81     	#ifdef USE_ACTION_UP_SHORT
;;;82     	buttons.action_up_short = 0;
;;;83     	#endif
;;;84     	#ifdef USE_ACTION_UP_LONG
;;;85     	buttons.action_up_long = 0;
;;;86     	#endif
;;;87     	#ifdef USE_ACTION_HOLD
;;;88     	buttons.action_hold = 0;
;;;89     	#endif
;;;90     }
000086  4770              BX       lr
;;;91     
                          ENDP

                  InitButtons PROC
;;;95     //---------------------------------------------//
;;;96     void InitButtons(void)
000088  2000              MOVS     r0,#0
;;;97     {
;;;98     	uint8_t i;
;;;99     	for (i=0; i<TOTAL_BUTTONS; i++)
;;;100    	{
;;;101    		bit_fifo[i] = 0;
00008a  4a20              LDR      r2,|L1.268|
00008c  2100              MOVS     r1,#0                 ;99
                  |L1.142|
00008e  f8221010          STRH     r1,[r2,r0,LSL #1]
000092  1c40              ADDS     r0,r0,#1              ;99
000094  b2c0              UXTB     r0,r0                 ;99
000096  2809              CMP      r0,#9                 ;99
000098  d3f9              BCC      |L1.142|
;;;102    	}
;;;103    	ResetButtonEvents();
00009a  e7fe              B        ResetButtonEvents
;;;104    	#ifdef USE_ACTION_TOGGLE
;;;105    	buttons.action_toggle = 0;
;;;106    	#endif
;;;107    }
;;;108    
                          ENDP

                  ProcessButtons PROC
;;;112    //---------------------------------------------//
;;;113    void ProcessButtons(void)
00009c  e92d41f0          PUSH     {r4-r8,lr}
;;;114    {
;;;115    	bfifo_type_t temp;	
;;;116    	btn_type_t raw_current;
;;;117    	btn_type_t current_bit;
;;;118    	uint8_t i;
;;;119    	
;;;120    	UpdateRawButtonState();
0000a0  f7fffffe          BL       UpdateRawButtonState
;;;121    	raw_current = raw_button_state ^ RAW_BUTTON_INVERSE_MASK;
0000a4  4818              LDR      r0,|L1.264|
0000a6  8800              LDRH     r0,[r0,#0]  ; raw_button_state
;;;122    	#ifdef NOT_USE_JTAG_BUTTONS
;;;123    	raw_current &= ~BTN_JTAG_MASK;
0000a8  f020040f          BIC      r4,r0,#0xf
;;;124    	#endif
;;;125    	ResetButtonEvents();
0000ac  f7fffffe          BL       ResetButtonEvents
;;;126    	
;;;127    	// Loop through all buttons
;;;128    	for (i=0; i<TOTAL_BUTTONS; i++)
0000b0  2000              MOVS     r0,#0
;;;129    	{
;;;130    		current_bit = (1<<i);
;;;131    		temp = bit_fifo[i];
;;;132    		// Shift in current button state bit
;;;133    		temp <<= 1;
;;;134    		if (raw_current & current_bit)
;;;135    			temp |= 0x01;
;;;136    		// Analyse FIFO and produce events
;;;137    		switch(temp & BFIFO_BUTTON_MASK)
;;;138    		{
;;;139    			case BFIFO_BUTTON_DOWN:
;;;140    				buttons.action_down |= current_bit;
0000b2  4d15              LDR      r5,|L1.264|
0000b4  2701              MOVS     r7,#1                 ;130
0000b6  4e15              LDR      r6,|L1.268|
0000b8  1cad              ADDS     r5,r5,#2
                  |L1.186|
0000ba  fa07f100          LSL      r1,r7,r0              ;130
0000be  b28a              UXTH     r2,r1                 ;130
0000c0  f8361010          LDRH     r1,[r6,r0,LSL #1]     ;131
0000c4  0449              LSLS     r1,r1,#17             ;133
0000c6  0c09              LSRS     r1,r1,#16             ;133
0000c8  4214              TST      r4,r2                 ;134
0000ca  d001              BEQ      |L1.208|
0000cc  f0410101          ORR      r1,r1,#1              ;135
                  |L1.208|
0000d0  f0010303          AND      r3,r1,#3              ;137
0000d4  2b01              CMP      r3,#1                 ;137
0000d6  d002              BEQ      |L1.222|
0000d8  2b02              CMP      r3,#2                 ;137
0000da  d107              BNE      |L1.236|
0000dc  e003              B        |L1.230|
                  |L1.222|
0000de  886b              LDRH     r3,[r5,#2]  ; buttons
0000e0  4313              ORRS     r3,r3,r2
0000e2  806b              STRH     r3,[r5,#2]
;;;141    				#ifdef USE_ACTION_REP
;;;142    				buttons.action_rep |= current_bit;
;;;143    				#endif
;;;144    				#ifdef USE_ACTION_TOGGLE
;;;145    				buttons.action_toggle ^= current_bit;
;;;146    				#endif
;;;147    				break;
0000e4  e002              B        |L1.236|
                  |L1.230|
;;;148    			#ifdef ANALYSE_ACTION_UP
;;;149    			case BFIFO_BUTTON_UP:
;;;150    				#ifdef USE_ACTION_UP
;;;151    				buttons.action_up |= current_bit;
0000e6  88ab              LDRH     r3,[r5,#4]  ; buttons
0000e8  4313              ORRS     r3,r3,r2
0000ea  80ab              STRH     r3,[r5,#4]
                  |L1.236|
;;;152    				#endif
;;;153    				#ifdef ANALYZE_TIMED_ACTION_UP
;;;154    				if ((temp & BFIFO_LONG_MASK) == BFIFO_LONG_MASK)
;;;155    				{
;;;156    					#ifdef USE_ACTION_UP_LONG
;;;157    					buttons.action_up_long |= current_bit;
;;;158    					#endif
;;;159    				}
;;;160    				else
;;;161    				{
;;;162    					#ifdef USE_ACTION_UP_SHORT
;;;163    					buttons.action_up_short |= current_bit;
;;;164    					#endif
;;;165    				}
;;;166    				break;
;;;167    				#endif
;;;168    			#endif
;;;169    			#ifdef ANALYSE_HOLD
;;;170    			case BFIFO_BUTTON_HOLD:
;;;171    				#ifdef USE_ACTION_REP
;;;172    				if ((temp & BFIFO_REPEAT_MASK) == BFIFO_REPEAT_MASK)
;;;173    				{
;;;174    					buttons.action_rep |= current_bit;
;;;175    				}
;;;176    				#endif
;;;177    				#ifdef USE_ACTION_HOLD
;;;178    				if ((temp & BFIFO_LONG_MASK) == BFIFO_HOLD)
;;;179    				{
;;;180    					buttons.action_hold |= current_bit;
;;;181    				}
;;;182    				break;
;;;183    				#endif
;;;184    			#endif
;;;185    		}
;;;186    		bit_fifo[i] = temp;
0000ec  f8261010          STRH     r1,[r6,r0,LSL #1]
0000f0  1c40              ADDS     r0,r0,#1              ;128
0000f2  b2c0              UXTB     r0,r0                 ;128
0000f4  2809              CMP      r0,#9                 ;128
0000f6  d3e0              BCC      |L1.186|
;;;187    	}
;;;188    	buttons.raw_state = raw_current;
0000f8  802c              STRH     r4,[r5,#0]
;;;189    }
0000fa  e8bd81f0          POP      {r4-r8,pc}
;;;190    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L1.256|
                          DCD      0x400b0000
                  |L1.260|
                          DCD      0x400a8000
                  |L1.264|
                          DCD      ||.data||
                  |L1.268|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  bit_fifo
                          %        18

                          AREA ||.data||, DATA, ALIGN=1

                  raw_button_state
000000  0000              DCW      0x0000
                  buttons
000002  0000              DCB      0x00,0x00
                          DCDU     0x00000000

;*** Start embedded assembler ***

#line 1 "src\\buttons.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_buttons_c_c0fb6984____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_buttons_c_c0fb6984____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_buttons_c_c0fb6984____REVSH|
#line 130
|__asm___9_buttons_c_c0fb6984____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
