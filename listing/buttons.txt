; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\buttons.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\buttons.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\buttons.crf src\buttons.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UpdateRawButtonState PROC
;;;23     //---------------------------------------------//
;;;24     static void UpdateRawButtonState(void)
000000  b570              PUSH     {r4-r6,lr}
;;;25     {
;;;26     	uint16_t raw_buttons = 0;
000002  2400              MOVS     r4,#0
;;;27     	uint32_t temp;
;;;28     	uint32_t time_delay;
;;;29     	// SB_ON and SB_OFF are combined with the green and red leds
;;;30     	// disable output for leds
;;;31     	MDR_PORTB->OE &= ~(1<<LGREEN | 1<<LRED);
000004  4d3d              LDR      r5,|L1.252|
000006  6868              LDR      r0,[r5,#4]
000008  f02000c0          BIC      r0,r0,#0xc0
00000c  6068              STR      r0,[r5,#4]
;;;32     	// Start delay
;;;33     	time_delay = DWT_StartDelayUs(10);
00000e  200a              MOVS     r0,#0xa
000010  f7fffffe          BL       DWT_StartDelayUs
000014  4606              MOV      r6,r0
;;;34     	// get other buttons by delay time
;;;35     	temp = MDR_PORTA->RXTX;
000016  483a              LDR      r0,|L1.256|
000018  6800              LDR      r0,[r0,#0]
;;;36     	if (! (temp & (1<<ENC_BTN)) )
00001a  0681              LSLS     r1,r0,#26
00001c  d400              BMI      |L1.32|
;;;37     		raw_buttons |= BTN_ENCODER;
00001e  2410              MOVS     r4,#0x10
                  |L1.32|
;;;38     	if (! (temp & (1<<EEN)) )
000020  0740              LSLS     r0,r0,#29
000022  d401              BMI      |L1.40|
;;;39     		raw_buttons |= SW_EXTERNAL;
000024  f4447480          ORR      r4,r4,#0x100
                  |L1.40|
;;;40     	temp = MDR_PORTB->RXTX;
000028  6828              LDR      r0,[r5,#0]
;;;41     	if (! (temp & (1<<SB_ESC)) )
00002a  07c1              LSLS     r1,r0,#31
00002c  d101              BNE      |L1.50|
;;;42     		raw_buttons |= BTN_ESC;
00002e  f0440401          ORR      r4,r4,#1
                  |L1.50|
;;;43     	if (! (temp & (1<<SB_LEFT)) )
000032  0781              LSLS     r1,r0,#30
000034  d401              BMI      |L1.58|
;;;44     		raw_buttons |= BTN_LEFT;
000036  f0440402          ORR      r4,r4,#2
                  |L1.58|
;;;45     	if (! (temp & (1<<SB_RIGHT)) )
00003a  0741              LSLS     r1,r0,#29
00003c  d401              BMI      |L1.66|
;;;46     		raw_buttons |= BTN_RIGHT;
00003e  f0440404          ORR      r4,r4,#4
                  |L1.66|
;;;47     	if (! (temp & (1<<SB_OK)) )
000042  06c1              LSLS     r1,r0,#27
000044  d401              BMI      |L1.74|
;;;48     		raw_buttons |= BTN_OK;
000046  f0440408          ORR      r4,r4,#8
                  |L1.74|
;;;49     	if (! (temp & (1<<SB_MODE)) )
00004a  0680              LSLS     r0,r0,#26
00004c  d401              BMI      |L1.82|
;;;50     		raw_buttons |= SW_CHANNEL;
00004e  f0440420          ORR      r4,r4,#0x20
                  |L1.82|
;;;51     	// wait until delay is done
;;;52     	while(DWT_DelayInProgress(time_delay));
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       DWT_DelayInProgress
000058  2800              CMP      r0,#0
00005a  d1fa              BNE      |L1.82|
;;;53     	// read once more
;;;54     	temp = MDR_PORTB->RXTX;
00005c  6828              LDR      r0,[r5,#0]
;;;55     	// enable outputs for leds again
;;;56     	MDR_PORTB->OE |= (1<<LGREEN | 1<<LRED);
00005e  6869              LDR      r1,[r5,#4]
000060  f04101c0          ORR      r1,r1,#0xc0
000064  6069              STR      r1,[r5,#4]
;;;57     	// add remaining buttons	
;;;58     	if (! (temp & (1<<LGREEN)) )
000066  0601              LSLS     r1,r0,#24
000068  d401              BMI      |L1.110|
;;;59     		raw_buttons |= BTN_ON;
00006a  f0440440          ORR      r4,r4,#0x40
                  |L1.110|
;;;60     	if (! (temp & (1<<LRED)) )
00006e  0640              LSLS     r0,r0,#25
000070  d401              BMI      |L1.118|
;;;61     		raw_buttons |= BTN_OFF;
000072  f0440480          ORR      r4,r4,#0x80
                  |L1.118|
;;;62     
;;;63     	
;;;64     	// Update global variable
;;;65     	raw_button_state = raw_buttons;
000076  4823              LDR      r0,|L1.260|
000078  8004              STRH     r4,[r0,#0]
;;;66     }
00007a  bd70              POP      {r4-r6,pc}
;;;67     
                          ENDP

                  ResetButtonEvents PROC
;;;71     //---------------------------------------------//
;;;72     static void ResetButtonEvents(void)
00007c  4821              LDR      r0,|L1.260|
;;;73     {
;;;74     	buttons.action_down = 0;
00007e  2100              MOVS     r1,#0
000080  1c80              ADDS     r0,r0,#2
000082  8041              STRH     r1,[r0,#2]
;;;75     	#ifdef USE_ACTION_REP
;;;76     	buttons.action_rep = 0;
;;;77     	#endif
;;;78     	#ifdef USE_ACTION_UP
;;;79     	buttons.action_up = 0;
000084  8081              STRH     r1,[r0,#4]
;;;80     	#endif
;;;81     	#ifdef USE_ACTION_UP_SHORT
;;;82     	buttons.action_up_short = 0;
;;;83     	#endif
;;;84     	#ifdef USE_ACTION_UP_LONG
;;;85     	buttons.action_up_long = 0;
;;;86     	#endif
;;;87     	#ifdef USE_ACTION_HOLD
;;;88     	buttons.action_hold = 0;
;;;89     	#endif
;;;90     }
000086  4770              BX       lr
;;;91     
                          ENDP

                  InitButtons PROC
;;;95     //---------------------------------------------//
;;;96     void InitButtons(void)
000088  2000              MOVS     r0,#0
;;;97     {
;;;98     	uint8_t i;
;;;99     	for (i=0; i<TOTAL_BUTTONS; i++)
;;;100    	{
;;;101    		bit_fifo[i] = 0;
00008a  4a1f              LDR      r2,|L1.264|
00008c  2100              MOVS     r1,#0                 ;99
                  |L1.142|
00008e  f8221010          STRH     r1,[r2,r0,LSL #1]
000092  1c40              ADDS     r0,r0,#1              ;99
000094  b2c0              UXTB     r0,r0                 ;99
000096  2809              CMP      r0,#9                 ;99
000098  d3f9              BCC      |L1.142|
;;;102    	}
;;;103    	ResetButtonEvents();
00009a  e7fe              B        ResetButtonEvents
;;;104    	#ifdef USE_ACTION_TOGGLE
;;;105    	buttons.action_toggle = 0;
;;;106    	#endif
;;;107    }
;;;108    
                          ENDP

                  ProcessButtons PROC
;;;112    //---------------------------------------------//
;;;113    void ProcessButtons(void)
00009c  e92d41f0          PUSH     {r4-r8,lr}
;;;114    {
;;;115    	bfifo_type_t temp;	
;;;116    	btn_type_t raw_current;
;;;117    	btn_type_t current_bit;
;;;118    	uint8_t i;
;;;119    	
;;;120    	UpdateRawButtonState();
0000a0  f7fffffe          BL       UpdateRawButtonState
;;;121    	raw_current = raw_button_state ^ RAW_BUTTON_INVERSE_MASK;
0000a4  4817              LDR      r0,|L1.260|
0000a6  8804              LDRH     r4,[r0,#0]  ; raw_button_state
;;;122    	ResetButtonEvents();
0000a8  f7fffffe          BL       ResetButtonEvents
;;;123    	
;;;124    	// Loop through all buttons
;;;125    	for (i=0; i<TOTAL_BUTTONS; i++)
0000ac  2000              MOVS     r0,#0
;;;126    	{
;;;127    		current_bit = (1<<i);
;;;128    		temp = bit_fifo[i];
;;;129    		// Shift in current button state bit
;;;130    		temp <<= 1;
;;;131    		if (raw_current & current_bit)
;;;132    			temp |= 0x01;
;;;133    		// Analyse FIFO and produce events
;;;134    		switch(temp & BFIFO_BUTTON_MASK)
;;;135    		{
;;;136    			case BFIFO_BUTTON_DOWN:
;;;137    				buttons.action_down |= current_bit;
0000ae  4d15              LDR      r5,|L1.260|
0000b0  2601              MOVS     r6,#1                 ;127
0000b2  4f15              LDR      r7,|L1.264|
0000b4  1cad              ADDS     r5,r5,#2
                  |L1.182|
0000b6  fa06f100          LSL      r1,r6,r0              ;127
0000ba  b28a              UXTH     r2,r1                 ;127
0000bc  f8371010          LDRH     r1,[r7,r0,LSL #1]     ;128
0000c0  0449              LSLS     r1,r1,#17             ;130
0000c2  0c09              LSRS     r1,r1,#16             ;130
0000c4  4214              TST      r4,r2                 ;131
0000c6  d001              BEQ      |L1.204|
0000c8  f0410101          ORR      r1,r1,#1              ;132
                  |L1.204|
0000cc  f0010303          AND      r3,r1,#3              ;134
0000d0  2b01              CMP      r3,#1                 ;134
0000d2  d002              BEQ      |L1.218|
0000d4  2b02              CMP      r3,#2                 ;134
0000d6  d107              BNE      |L1.232|
0000d8  e003              B        |L1.226|
                  |L1.218|
0000da  886b              LDRH     r3,[r5,#2]  ; buttons
0000dc  4313              ORRS     r3,r3,r2
0000de  806b              STRH     r3,[r5,#2]
;;;138    				#ifdef USE_ACTION_REP
;;;139    				buttons.action_rep |= current_bit;
;;;140    				#endif
;;;141    				#ifdef USE_ACTION_TOGGLE
;;;142    				buttons.action_toggle ^= current_bit;
;;;143    				#endif
;;;144    				break;
0000e0  e002              B        |L1.232|
                  |L1.226|
;;;145    			#ifdef ANALYSE_ACTION_UP
;;;146    			case BFIFO_BUTTON_UP:
;;;147    				#ifdef USE_ACTION_UP
;;;148    				buttons.action_up |= current_bit;
0000e2  88ab              LDRH     r3,[r5,#4]  ; buttons
0000e4  4313              ORRS     r3,r3,r2
0000e6  80ab              STRH     r3,[r5,#4]
                  |L1.232|
;;;149    				#endif
;;;150    				#ifdef ANALYZE_TIMED_ACTION_UP
;;;151    				if ((temp & BFIFO_LONG_MASK) == BFIFO_LONG_MASK)
;;;152    				{
;;;153    					#ifdef USE_ACTION_UP_LONG
;;;154    					buttons.action_up_long |= current_bit;
;;;155    					#endif
;;;156    				}
;;;157    				else
;;;158    				{
;;;159    					#ifdef USE_ACTION_UP_SHORT
;;;160    					buttons.action_up_short |= current_bit;
;;;161    					#endif
;;;162    				}
;;;163    				break;
;;;164    				#endif
;;;165    			#endif
;;;166    			#ifdef ANALYSE_HOLD
;;;167    			case BFIFO_BUTTON_HOLD:
;;;168    				#ifdef USE_ACTION_REP
;;;169    				if ((temp & BFIFO_REPEAT_MASK) == BFIFO_REPEAT_MASK)
;;;170    				{
;;;171    					buttons.action_rep |= current_bit;
;;;172    				}
;;;173    				#endif
;;;174    				#ifdef USE_ACTION_HOLD
;;;175    				if ((temp & BFIFO_LONG_MASK) == BFIFO_HOLD)
;;;176    				{
;;;177    					buttons.action_hold |= current_bit;
;;;178    				}
;;;179    				break;
;;;180    				#endif
;;;181    			#endif
;;;182    		}
;;;183    		bit_fifo[i] = temp;
0000e8  f8271010          STRH     r1,[r7,r0,LSL #1]
0000ec  1c40              ADDS     r0,r0,#1              ;125
0000ee  b2c0              UXTB     r0,r0                 ;125
0000f0  2809              CMP      r0,#9                 ;125
0000f2  d3e0              BCC      |L1.182|
;;;184    	}
;;;185    	buttons.raw_state = raw_current;
0000f4  802c              STRH     r4,[r5,#0]
;;;186    }
0000f6  e8bd81f0          POP      {r4-r8,pc}
;;;187    
                          ENDP

0000fa  0000              DCW      0x0000
                  |L1.252|
                          DCD      0x400b0000
                  |L1.256|
                          DCD      0x400a8000
                  |L1.260|
                          DCD      ||.data||
                  |L1.264|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  bit_fifo
                          %        18

                          AREA ||.data||, DATA, ALIGN=1

                  raw_button_state
000000  0000              DCW      0x0000
                  buttons
000002  0000              DCB      0x00,0x00
                          DCDU     0x00000000

;*** Start embedded assembler ***

#line 1 "src\\buttons.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_buttons_c_c0fb6984____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_buttons_c_c0fb6984____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_buttons_c_c0fb6984____REVSH|
#line 130
|__asm___9_buttons_c_c0fb6984____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
