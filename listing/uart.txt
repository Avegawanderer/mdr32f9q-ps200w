; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list -c --asm --interleave -o.\FLASH\uart.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\uart.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -I.\src\gui -I.\src\gui\guiCore -I.\src\gui\guiWidgets -I.\src\gui\guiGraphics -I.\src\gui\utils -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\uart.crf src\uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART_Init_RX_buffer PROC
;;;63     
;;;64     static void UART_Init_RX_buffer(uart_dma_rx_buffer_t *rx_buffer, uint16_t *data, uint32_t size)
000000  6041              STR      r1,[r0,#4]
;;;65     {
;;;66     	rx_buffer->data = data;
;;;67     	rx_buffer->size = size;
000002  8042              STRH     r2,[r0,#2]
;;;68     	rx_buffer->read_index = 0;
000004  2300              MOVS     r3,#0
000006  8003              STRH     r3,[r0,#0]
;;;69     	
;;;70     	// Fill buffer with invalid data
;;;71     	while(size)
;;;72     	{
;;;73     		data[--size] = EMPTY_DATA;
000008  f64f70ff          MOV      r0,#0xffff
00000c  e002              B        |L1.20|
                  |L1.14|
00000e  1e52              SUBS     r2,r2,#1
000010  f8210012          STRH     r0,[r1,r2,LSL #1]
                  |L1.20|
000014  2a00              CMP      r2,#0                 ;71
000016  d1fa              BNE      |L1.14|
;;;74     	}
;;;75     }
000018  4770              BX       lr
;;;76     
                          ENDP

                  UART_Get_from_RX_buffer PROC
;;;77     uint8_t UART_Get_from_RX_buffer(uart_dma_rx_buffer_t *rx_buffer, uint16_t *rx_word)
00001a  8803              LDRH     r3,[r0,#0]
;;;78     {
;;;79     	*rx_word = rx_buffer->data[rx_buffer->read_index];
00001c  6842              LDR      r2,[r0,#4]
00001e  f8322013          LDRH     r2,[r2,r3,LSL #1]
000022  800a              STRH     r2,[r1,#0]
;;;80     	if (*rx_word != EMPTY_DATA)
000024  f64f71ff          MOV      r1,#0xffff
000028  428a              CMP      r2,r1
00002a  d00e              BEQ      |L1.74|
;;;81     	{
;;;82     		// Valid data had been put into buffer by DMA
;;;83     		rx_buffer->data[rx_buffer->read_index] = EMPTY_DATA;	
00002c  8803              LDRH     r3,[r0,#0]
00002e  6842              LDR      r2,[r0,#4]
000030  f8221013          STRH     r1,[r2,r3,LSL #1]
;;;84     		rx_buffer->read_index = (rx_buffer->read_index < (rx_buffer->size - 1)) ? rx_buffer->read_index + 1 : 0;
000034  8842              LDRH     r2,[r0,#2]
000036  8801              LDRH     r1,[r0,#0]
000038  1e52              SUBS     r2,r2,#1
00003a  4291              CMP      r1,r2
00003c  da01              BGE      |L1.66|
00003e  1c49              ADDS     r1,r1,#1
000040  e000              B        |L1.68|
                  |L1.66|
000042  2100              MOVS     r1,#0
                  |L1.68|
000044  8001              STRH     r1,[r0,#0]
;;;85     		return 1;
000046  2001              MOVS     r0,#1
;;;86     	}
;;;87     	return 0;
;;;88     }
000048  4770              BX       lr
                  |L1.74|
00004a  2000              MOVS     r0,#0                 ;87
00004c  4770              BX       lr
;;;89     
                          ENDP

                  UART_init_RX_DMA PROC
;;;91     // DMA channel UARTx RX configuration 
;;;92     static void UART_init_RX_DMA(MDR_UART_TypeDef *MDR_UARTx, uart_dma_rx_buffer_t *rx_buffer, uint32_t *saved_tcb)
00004e  b530              PUSH     {r4,r5,lr}
;;;93     {
000050  b08f              SUB      sp,sp,#0x3c
000052  4614              MOV      r4,r2
;;;94     	DMA_ChannelInitTypeDef DMA_InitStr;
;;;95     	DMA_CtrlDataInitTypeDef DMA_PriCtrlStr;
;;;96     	uint32_t *tcb_ptr;
;;;97     	uint32_t DMA_Channel_UARTn_RX = (MDR_UARTx == MDR_UART1) ? DMA_Channel_UART1_RX : DMA_Channel_UART2_RX;
000054  4afe              LDR      r2,|L1.1104|
000056  4290              CMP      r0,r2
000058  d101              BNE      |L1.94|
00005a  2501              MOVS     r5,#1
00005c  e000              B        |L1.96|
                  |L1.94|
00005e  2503              MOVS     r5,#3
                  |L1.96|
;;;98     	
;;;99     	// Setup Primary Control Data 
;;;100    	DMA_PriCtrlStr.DMA_SourceBaseAddr = (uint32_t)(&(MDR_UARTx->DR));
000060  9001              STR      r0,[sp,#4]
;;;101    	DMA_PriCtrlStr.DMA_DestBaseAddr = (uint32_t)rx_buffer->data;			// dest (buffer of 16-bit shorts)
000062  6848              LDR      r0,[r1,#4]
000064  9002              STR      r0,[sp,#8]
;;;102    	DMA_PriCtrlStr.DMA_SourceIncSize = DMA_SourceIncNo;
000066  f04f6040          MOV      r0,#0xc000000
00006a  9003              STR      r0,[sp,#0xc]
;;;103    	DMA_PriCtrlStr.DMA_DestIncSize = DMA_DestIncHalfword ;
00006c  f04f4080          MOV      r0,#0x40000000
000070  9004              STR      r0,[sp,#0x10]
;;;104    	DMA_PriCtrlStr.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
000072  f04f5088          MOV      r0,#0x11000000
000076  9005              STR      r0,[sp,#0x14]
;;;105    	DMA_PriCtrlStr.DMA_Mode = DMA_Mode_Basic;								// 
000078  2201              MOVS     r2,#1
00007a  9206              STR      r2,[sp,#0x18]
;;;106    	DMA_PriCtrlStr.DMA_CycleSize = rx_buffer->size;							// count of 16-bit shorts
00007c  8848              LDRH     r0,[r1,#2]
00007e  9007              STR      r0,[sp,#0x1c]
;;;107    	DMA_PriCtrlStr.DMA_NumContinuous = DMA_Transfers_1;
000080  2000              MOVS     r0,#0
000082  9008              STR      r0,[sp,#0x20]
;;;108    	DMA_PriCtrlStr.DMA_SourceProtCtrl = DMA_SourcePrivileged;				// ?
000084  0491              LSLS     r1,r2,#18
000086  9109              STR      r1,[sp,#0x24]
;;;109    	DMA_PriCtrlStr.DMA_DestProtCtrl = DMA_DestPrivileged;					// ?
000088  00c9              LSLS     r1,r1,#3
00008a  910a              STR      r1,[sp,#0x28]
;;;110    	
;;;111    	// Setup Channel Structure
;;;112    	DMA_InitStr.DMA_PriCtrlData = &DMA_PriCtrlStr;
00008c  a901              ADD      r1,sp,#4
00008e  910b              STR      r1,[sp,#0x2c]
;;;113    	DMA_InitStr.DMA_AltCtrlData = 0;										// Not used
000090  900c              STR      r0,[sp,#0x30]
;;;114    	DMA_InitStr.DMA_ProtCtrl = 0;											// Not used
000092  900d              STR      r0,[sp,#0x34]
;;;115    	DMA_InitStr.DMA_Priority = DMA_Priority_High ;
000094  f88d2038          STRB     r2,[sp,#0x38]
;;;116    	DMA_InitStr.DMA_UseBurst = DMA_BurstClear;								// Enable single words trasfer
000098  f88d0039          STRB     r0,[sp,#0x39]
;;;117    	DMA_InitStr.DMA_SelectDataStructure = DMA_CTRL_DATA_PRIMARY;
00009c  f88d003a          STRB     r0,[sp,#0x3a]
;;;118    	
;;;119    	// Init DMA channel
;;;120    	my_DMA_ChannelInit(DMA_Channel_UARTn_RX, &DMA_InitStr);
0000a0  a90b              ADD      r1,sp,#0x2c
0000a2  b2e8              UXTB     r0,r5
0000a4  f7fffffe          BL       my_DMA_ChannelInit
;;;121    	
;;;122    	// Save created RX UART DMA control block for reinit in DMA ISR
;;;123    	tcb_ptr = (uint32_t*)&DMA_ControlTable[DMA_Channel_UARTn_RX];
0000a8  48ea              LDR      r0,|L1.1108|
0000aa  eb001005          ADD      r0,r0,r5,LSL #4
;;;124    	saved_tcb[0] = *tcb_ptr++;
0000ae  6801              LDR      r1,[r0,#0]
0000b0  6021              STR      r1,[r4,#0]
;;;125    	saved_tcb[1] = *tcb_ptr++;
0000b2  6841              LDR      r1,[r0,#4]
0000b4  6061              STR      r1,[r4,#4]
;;;126    	saved_tcb[2] = *tcb_ptr;
0000b6  6880              LDR      r0,[r0,#8]
0000b8  60a0              STR      r0,[r4,#8]
;;;127    }
0000ba  b00f              ADD      sp,sp,#0x3c
0000bc  bd30              POP      {r4,r5,pc}
;;;128    
                          ENDP

                  UART_init_TX_DMA PROC
;;;131    // DMA channel UARTx TX configuration 
;;;132    static void UART_init_TX_DMA(MDR_UART_TypeDef *MDR_UARTx, DMA_CtrlDataInitTypeDef *DMA_PriCtrlStr_p)
0000be  b51f              PUSH     {r0-r4,lr}
;;;133    {
;;;134    	uint32_t DMA_Channel_UARTn_TX = (MDR_UARTx == MDR_UART1) ? DMA_Channel_UART1_TX : DMA_Channel_UART2_TX;
0000c0  4ae3              LDR      r2,|L1.1104|
0000c2  4290              CMP      r0,r2
0000c4  d101              BNE      |L1.202|
0000c6  2300              MOVS     r3,#0
0000c8  e000              B        |L1.204|
                  |L1.202|
0000ca  2302              MOVS     r3,#2
                  |L1.204|
;;;135    	DMA_ChannelInitTypeDef DMA_InitStr;
;;;136    	
;;;137    	// Setup Primary Control Data 
;;;138    	DMA_PriCtrlStr_p->DMA_SourceBaseAddr = 0;									// Will be set before channel start
0000cc  2200              MOVS     r2,#0
0000ce  600a              STR      r2,[r1,#0]
;;;139    	DMA_PriCtrlStr_p->DMA_DestBaseAddr = (uint32_t)(&(MDR_UARTx->DR));			
0000d0  6048              STR      r0,[r1,#4]
;;;140    	DMA_PriCtrlStr_p->DMA_SourceIncSize = DMA_SourceIncByte;
0000d2  608a              STR      r2,[r1,#8]
;;;141    	DMA_PriCtrlStr_p->DMA_DestIncSize = DMA_DestIncNo;
0000d4  f04f4040          MOV      r0,#0xc0000000
0000d8  60c8              STR      r0,[r1,#0xc]
;;;142    	DMA_PriCtrlStr_p->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
0000da  610a              STR      r2,[r1,#0x10]
;;;143    	DMA_PriCtrlStr_p->DMA_Mode = DMA_Mode_Basic; 
0000dc  2001              MOVS     r0,#1
0000de  6148              STR      r0,[r1,#0x14]
;;;144    	DMA_PriCtrlStr_p->DMA_CycleSize = 0;										// Will be set before channel start
0000e0  618a              STR      r2,[r1,#0x18]
;;;145    	DMA_PriCtrlStr_p->DMA_NumContinuous = DMA_Transfers_1;
0000e2  61ca              STR      r2,[r1,#0x1c]
;;;146    	DMA_PriCtrlStr_p->DMA_SourceProtCtrl = DMA_SourcePrivileged;				// ?
0000e4  0484              LSLS     r4,r0,#18
0000e6  620c              STR      r4,[r1,#0x20]
;;;147    	DMA_PriCtrlStr_p->DMA_DestProtCtrl = DMA_DestPrivileged;					// ?
0000e8  0544              LSLS     r4,r0,#21
0000ea  624c              STR      r4,[r1,#0x24]
;;;148    	
;;;149    	// Setup Channel Structure
;;;150    	DMA_InitStr.DMA_PriCtrlData = 0;										// Will be set before channel start
0000ec  9200              STR      r2,[sp,#0]
;;;151    	DMA_InitStr.DMA_AltCtrlData = 0;										// Not used
0000ee  9201              STR      r2,[sp,#4]
;;;152    	DMA_InitStr.DMA_ProtCtrl = 0;											// Not used
0000f0  9202              STR      r2,[sp,#8]
;;;153    	DMA_InitStr.DMA_Priority = DMA_Priority_High;
0000f2  f88d000c          STRB     r0,[sp,#0xc]
;;;154    	DMA_InitStr.DMA_UseBurst = DMA_BurstClear;								// Enable single words trasfer
0000f6  f88d200d          STRB     r2,[sp,#0xd]
;;;155    	DMA_InitStr.DMA_SelectDataStructure = DMA_CTRL_DATA_PRIMARY;
0000fa  f88d200e          STRB     r2,[sp,#0xe]
;;;156    	
;;;157    	// Init DMA channel
;;;158    	my_DMA_ChannelInit(DMA_Channel_UARTn_TX, &DMA_InitStr);
0000fe  4669              MOV      r1,sp
000100  b2d8              UXTB     r0,r3
000102  f7fffffe          BL       my_DMA_ChannelInit
;;;159    }
000106  bd1f              POP      {r0-r4,pc}
;;;160    
                          ENDP

                  UART_sendStrAlloc PROC
;;;407    
;;;408    static void UART_sendStrAlloc(char *str)
000108  b51c              PUSH     {r2-r4,lr}
;;;409    {
00010a  4604              MOV      r4,r0
;;;410    	uart_transmiter_msg_t msg;
;;;411    	uint32_t str_length = strlen(str);
00010c  4620              MOV      r0,r4
00010e  f7fffffe          BL       strlen
;;;412    	msg.pdata = pvPortMalloc(str_length);		// heap_3 or heap_4 should be used
000112  f7fffffe          BL       pvPortMalloc
000116  9001              STR      r0,[sp,#4]
;;;413    	if (msg.pdata == 0)
000118  9801              LDR      r0,[sp,#4]
00011a  2800              CMP      r0,#0
00011c  d012              BEQ      |L1.324|
;;;414    		return;
;;;415    	strcpy(msg.pdata, str);
00011e  4621              MOV      r1,r4
000120  9801              LDR      r0,[sp,#4]
000122  f7fffffe          BL       strcpy
;;;416    	msg.type = SEND_ALLOCATED_STRING;
000126  2002              MOVS     r0,#2
000128  f8ad0000          STRH     r0,[sp,#0]
;;;417    	if (xQueueSendToBack(xQueueUART1TX, &msg, 0) == errQUEUE_FULL)
00012c  48ca              LDR      r0,|L1.1112|
00012e  2300              MOVS     r3,#0
000130  461a              MOV      r2,r3
000132  4669              MOV      r1,sp
000134  6800              LDR      r0,[r0,#0]  ; xQueueUART1TX
000136  f7fffffe          BL       xQueueGenericSend
00013a  2800              CMP      r0,#0
00013c  d102              BNE      |L1.324|
;;;418    		vPortFree(msg.pdata);
00013e  9801              LDR      r0,[sp,#4]
000140  f7fffffe          BL       vPortFree
                  |L1.324|
;;;419    }
000144  bd1c              POP      {r2-r4,pc}
;;;420    
                          ENDP

                  vTaskUARTReceiver PROC
;;;162    
;;;163    void vTaskUARTReceiver(void *pvParameters) 
000146  b0bc              SUB      sp,sp,#0xf0
;;;164    {
;;;165    	char received_msg[RX_MESSAGE_MAX_LENGTH];
;;;166    	uint16_t msg_length = 0;
000148  2400              MOVS     r4,#0
;;;167    	char *argv[MAX_WORDS_IN_MESSAGE];		// Array of pointers to separate words
;;;168    	uint16_t argc = 0;						// Count of words in message
00014a  2500              MOVS     r5,#0
;;;169    	char temp_char;
;;;170    	uint16_t uart_rx_word;
;;;171    	uint16_t search_for_word = 1;
00014c  2601              MOVS     r6,#1
;;;172    	
;;;173    	
;;;174    	// Debug
;;;175    	uint16_t i;
;;;176    	uint32_t temp32u;
;;;177    	
;;;178    	char temp_str[50];
;;;179    	
;;;180    	portTickType lastExecutionTime = xTaskGetTickCount();
00014e  f7fffffe          BL       xTaskGetTickCount
000152  9005              STR      r0,[sp,#0x14]
;;;181    	dispatch_incoming_msg_t dispatcher_msg;
;;;182    	uart_transmiter_msg_t transmitter_msg;
;;;183    	
;;;184    	// Setup and init receiver buffer
;;;185    	UART_Init_RX_buffer(&uart1_rx_dma_buffer, uart1_rx_data_buff, RX_BUFFER_SIZE);
000154  48c0              LDR      r0,|L1.1112|
000156  22c8              MOVS     r2,#0xc8
000158  49c0              LDR      r1,|L1.1116|
00015a  3008              ADDS     r0,r0,#8
00015c  f7fffffe          BL       UART_Init_RX_buffer
;;;186    	
;;;187    	// Setup DMA channel
;;;188    	UART_init_RX_DMA(MDR_UART1, &uart1_rx_dma_buffer, UART1_RX_saved_TCB);
000160  49bd              LDR      r1,|L1.1112|
000162  4fbb              LDR      r7,|L1.1104|
000164  4abe              LDR      r2,|L1.1120|
000166  3108              ADDS     r1,r1,#8
000168  4638              MOV      r0,r7
00016a  f7fffffe          BL       UART_init_RX_DMA
;;;189    	// Enable DMA channel
;;;190    	DMA_Cmd(DMA_Channel_UART1_RX, ENABLE);
00016e  2101              MOVS     r1,#1
000170  4608              MOV      r0,r1
000172  f7fffffe          BL       DMA_Cmd
;;;191    	// Enable UARTn DMA Rx request
;;;192    	UART_DMACmd(MDR_UART1,UART_DMA_RXE, ENABLE);
000176  2201              MOVS     r2,#1
000178  4611              MOV      r1,r2
00017a  4638              MOV      r0,r7
00017c  f7fffffe          BL       UART_DMACmd
000180  f10d09a0          ADD      r9,sp,#0xa0           ;165
000184  46a2              MOV      r10,r4                ;166
;;;193    	
;;;194    	
;;;195    	//HW_NVIC_check();		// FIXME - debug
;;;196    	
;;;197    	
;;;198    	while(1)
;;;199    	{
;;;200    		/////////////////////////
;;;201    	/*	while(1)
;;;202    		{
;;;203    			vTaskDelayUntil(&lastExecutionTime, 5);
;;;204    			
;;;205    			transmitter_msg.type = UNKNOWN_CMD;
;;;206    			xQueueSendToBack(xQueueUART1TX, &transmitter_msg, 0); 
;;;207    			xQueueSendToBack(xQueueUART1TX, &transmitter_msg, 0); 
;;;208    			xQueueSendToBack(xQueueUART1TX, &transmitter_msg, 0); 
;;;209    			xQueueSendToBack(xQueueUART1TX, &transmitter_msg, 0); 
;;;210    			xQueueSendToBack(xQueueUART1TX, &transmitter_msg, 0); 
;;;211    		}
;;;212    		*/
;;;213    		/////////////////////////
;;;214    		vTaskDelayUntil(&lastExecutionTime, 5);		// 10ms period
;;;215    
;;;216    		// Read full message from buffer
;;;217    		while(UART_Get_from_RX_buffer(&uart1_rx_dma_buffer, &uart_rx_word))
;;;218    		{
;;;219    			if ((uart_rx_word & ( (1<<UART_Data_BE) | (1<<UART_Data_PE) | (1<<UART_Data_FE) )) != 0)
;;;220    				continue;
;;;221    				
;;;222    			temp_char = (char)(uart_rx_word);
;;;223    			
;;;224    			if (temp_char == SPACING_SYMBOL)
;;;225    			{
;;;226    				received_msg[msg_length++] = '\0';
;;;227    				search_for_word = 1;
;;;228    			}
;;;229    			else if ((temp_char == MESSAGE_END_SYMBOL) || (temp_char == MESSAGE_NEW_LINE))
;;;230    			{
;;;231    				received_msg[msg_length++] = '\0';
;;;232    			}
;;;233    			else
;;;234    			{
;;;235    				// Normal char
;;;236    				if (search_for_word == 1)
;;;237    				{
;;;238    					argv[argc++] = &received_msg[msg_length];		// Found start position of a word
;;;239    					search_for_word = 0;
;;;240    				}
;;;241    				received_msg[msg_length++] = temp_char;
;;;242    			}
;;;243    			
;;;244    			
;;;245    			if ((temp_char == MESSAGE_END_SYMBOL) || (temp_char == MESSAGE_NEW_LINE) || (msg_length == RX_MESSAGE_MAX_LENGTH))
;;;246    			{
;;;247    				// Received full message OR maximum allowed message length is reached
;;;248    				// Parse message
;;;249    				if (argc != 0)
;;;250    				{
;;;251    					dispatcher_msg.type = 0;
;;;252    					transmitter_msg.type = RESPONSE_OK;
;;;253    					
;;;254    					//---------- Converter control -----------//
;;;255    					if (strcmp(argv[0], "on") == 0)							// Turn converter ON	
;;;256    					{
;;;257    						dispatcher_msg.type = DP_CONVERTER_TURN_ON;
;;;258    					}
;;;259    					else if (strcmp(argv[0], "off") == 0)					// Turn converter OFF
;;;260    					{
;;;261    						dispatcher_msg.type = DP_CONVERTER_TURN_OFF;
;;;262    					}
;;;263    					else if (strcmp(argv[0], "set_voltage") == 0)			// Setting converter voltage
;;;264    					{
;;;265    						if (argc < 2)
;;;266    						{
;;;267    							transmitter_msg.type = SEND_STRING;
;;;268    							transmitter_msg.pdata = "ERR: missing argument [mV]\r";
;;;269    						}
;;;270    						else
;;;271    						{
;;;272    							// Second argument is voltage value [mV]
;;;273    							dispatcher_msg.type = DP_CONVERTER_SET_VOLTAGE;
;;;274    							dispatcher_msg.data = strtoul(argv[1], 0, 0);
;;;275    						}
;;;276    					}
;;;277    					else if (strcmp(argv[0], "set_current") == 0)			// Setting converter current
;;;278    					{
;;;279    						if (argc < 2)
;;;280    						{
;;;281    							transmitter_msg.type = SEND_STRING;
;;;282    							transmitter_msg.pdata = "ERR: missing argument [mA]\r";
;;;283    						}
;;;284    						else
;;;285    						{
;;;286    							// Second argument is current value [mA]
;;;287    							dispatcher_msg.type = DP_CONVERTER_SET_CURRENT;
;;;288    							dispatcher_msg.data = strtoul(argv[1], 0, 0);
;;;289    						}
;;;290    					}
;;;291    					else if (strcmp(argv[0], "set_current_limit") == 0)			// Setting converter current limit
;;;292    					{
;;;293    						if (argc < 2)
;;;294    						{
;;;295    							transmitter_msg.type = SEND_STRING;
;;;296    							transmitter_msg.pdata = "ERR: missing argument (20/40)[A]\r";
;;;297    						}
;;;298    						else
;;;299    						{
;;;300    							// Second argument is current limit value [A]
;;;301    							dispatcher_msg.type = DP_CONVERTER_SET_CURRENT_LIMIT;
;;;302    							dispatcher_msg.data = strtoul(argv[1], 0, 0);
;;;303    						}
;;;304    					}
;;;305    					//----- button and encoder emulation -----//
;;;306    					else if (strcmp(argv[0], "btn_esc") == 0)				// ESC button
;;;307    					{
;;;308    						dispatcher_msg.type = DP_EMU_BTN_DOWN;
000186  02b7              LSLS     r7,r6,#10
000188  f04f0801          MOV      r8,#1                 ;171
                  |L1.396|
00018c  2105              MOVS     r1,#5                 ;214
00018e  a805              ADD      r0,sp,#0x14           ;214
000190  f7fffffe          BL       vTaskDelayUntil
                  |L1.404|
000194  e0a2              B        |L1.732|
                  |L1.406|
000196  f8bd004c          LDRH     r0,[sp,#0x4c]         ;219
00019a  f4106fe0          TST      r0,#0x700             ;219
00019e  d1f9              BNE      |L1.404|
0001a0  b2c0              UXTB     r0,r0                 ;222
0001a2  2820              CMP      r0,#0x20              ;224
0001a4  d006              BEQ      |L1.436|
0001a6  280d              CMP      r0,#0xd               ;229
0001a8  d00b              BEQ      |L1.450|
0001aa  280a              CMP      r0,#0xa               ;229
0001ac  d009              BEQ      |L1.450|
0001ae  2e01              CMP      r6,#1                 ;236
0001b0  d00d              BEQ      |L1.462|
0001b2  e015              B        |L1.480|
                  |L1.436|
0001b4  4621              MOV      r1,r4                 ;226
0001b6  1c64              ADDS     r4,r4,#1              ;226
0001b8  b2a4              UXTH     r4,r4                 ;226
0001ba  f809a001          STRB     r10,[r9,r1]           ;226
0001be  2601              MOVS     r6,#1                 ;227
0001c0  e013              B        |L1.490|
                  |L1.450|
0001c2  4621              MOV      r1,r4                 ;231
0001c4  1c64              ADDS     r4,r4,#1              ;231
0001c6  b2a4              UXTH     r4,r4                 ;231
0001c8  f809a001          STRB     r10,[r9,r1]           ;231
0001cc  e00d              B        |L1.490|
                  |L1.462|
0001ce  4629              MOV      r1,r5                 ;238
0001d0  ab14              ADD      r3,sp,#0x50           ;238
0001d2  eb090204          ADD      r2,r9,r4              ;238
0001d6  1c6d              ADDS     r5,r5,#1              ;238
0001d8  b2ad              UXTH     r5,r5                 ;238
0001da  f8432021          STR      r2,[r3,r1,LSL #2]     ;238
0001de  2600              MOVS     r6,#0                 ;239
                  |L1.480|
0001e0  4621              MOV      r1,r4                 ;241
0001e2  1c64              ADDS     r4,r4,#1              ;241
0001e4  b2a4              UXTH     r4,r4                 ;241
0001e6  f8090001          STRB     r0,[r9,r1]            ;241
                  |L1.490|
0001ea  280d              CMP      r0,#0xd               ;245
0001ec  d003              BEQ      |L1.502|
0001ee  280a              CMP      r0,#0xa               ;245
0001f0  d001              BEQ      |L1.502|
0001f2  2c50              CMP      r4,#0x50              ;245
0001f4  d172              BNE      |L1.732|
                  |L1.502|
0001f6  2d00              CMP      r5,#0                 ;249
0001f8  d06d              BEQ      |L1.726|
0001fa  f8cda00c          STR      r10,[sp,#0xc]         ;251
0001fe  f44f7080          MOV      r0,#0x100             ;252
000202  f8ad0004          STRH     r0,[sp,#4]            ;252
000206  a197              ADR      r1,|L1.1124|
000208  9814              LDR      r0,[sp,#0x50]         ;255
00020a  f7fffffe          BL       strcmp
00020e  2800              CMP      r0,#0                 ;255
000210  d06d              BEQ      |L1.750|
000212  a195              ADR      r1,|L1.1128|
000214  9814              LDR      r0,[sp,#0x50]         ;259
000216  f7fffffe          BL       strcmp
00021a  2800              CMP      r0,#0                 ;259
00021c  d06b              BEQ      |L1.758|
00021e  a193              ADR      r1,|L1.1132|
000220  9814              LDR      r0,[sp,#0x50]         ;263
000222  f7fffffe          BL       strcmp
000226  2800              CMP      r0,#0                 ;263
000228  d069              BEQ      |L1.766|
00022a  a193              ADR      r1,|L1.1144|
00022c  9814              LDR      r0,[sp,#0x50]         ;277
00022e  f7fffffe          BL       strcmp
000232  2800              CMP      r0,#0                 ;277
000234  d077              BEQ      |L1.806|
000236  a193              ADR      r1,|L1.1156|
000238  9814              LDR      r0,[sp,#0x50]         ;291
00023a  f7fffffe          BL       strcmp
00023e  2800              CMP      r0,#0                 ;291
000240  d06f              BEQ      |L1.802|
000242  a195              ADR      r1,|L1.1176|
000244  9814              LDR      r0,[sp,#0x50]         ;306
000246  f7fffffe          BL       strcmp
00024a  2800              CMP      r0,#0                 ;306
00024c  d06a              BEQ      |L1.804|
;;;309    						dispatcher_msg.data = BTN_ESC;
;;;310    					}
;;;311    					else if (strcmp(argv[0], "btn_ok") == 0)				// OK button
00024e  a194              ADR      r1,|L1.1184|
000250  9814              LDR      r0,[sp,#0x50]
000252  f7fffffe          BL       strcmp
000256  2800              CMP      r0,#0
000258  d076              BEQ      |L1.840|
;;;312    					{
;;;313    						dispatcher_msg.type = DP_EMU_BTN_DOWN;
;;;314    						dispatcher_msg.data = BTN_OK;
;;;315    					}
;;;316    					else if (strcmp(argv[0], "btn_left") == 0)				// LEFT button
00025a  a193              ADR      r1,|L1.1192|
00025c  9814              LDR      r0,[sp,#0x50]
00025e  f7fffffe          BL       strcmp
000262  2800              CMP      r0,#0
000264  d071              BEQ      |L1.842|
;;;317    					{
;;;318    						dispatcher_msg.type = DP_EMU_BTN_DOWN;
;;;319    						dispatcher_msg.data = BTN_LEFT;
;;;320    					}
;;;321    					else if (strcmp(argv[0], "btn_right") == 0)				// RIGHT button
000266  a193              ADR      r1,|L1.1204|
000268  9814              LDR      r0,[sp,#0x50]
00026a  f7fffffe          BL       strcmp
00026e  2800              CMP      r0,#0
000270  d06c              BEQ      |L1.844|
;;;322    					{
;;;323    						dispatcher_msg.type = DP_EMU_BTN_DOWN;
;;;324    						dispatcher_msg.data = BTN_RIGHT;
;;;325    					}
;;;326    					else if (strcmp(argv[0], "btn_on") == 0)				// ON button
000272  a193              ADR      r1,|L1.1216|
000274  9814              LDR      r0,[sp,#0x50]
000276  f7fffffe          BL       strcmp
00027a  2800              CMP      r0,#0
00027c  d067              BEQ      |L1.846|
;;;327    					{
;;;328    						dispatcher_msg.type = DP_EMU_BTN_DOWN;
;;;329    						dispatcher_msg.data = BTN_ON;
;;;330    					}
;;;331    					else if (strcmp(argv[0], "btn_off") == 0)				// OFF button
00027e  a192              ADR      r1,|L1.1224|
000280  9814              LDR      r0,[sp,#0x50]
000282  f7fffffe          BL       strcmp
000286  2800              CMP      r0,#0
000288  d073              BEQ      |L1.882|
;;;332    					{
;;;333    						dispatcher_msg.type = DP_EMU_BTN_DOWN;
;;;334    						dispatcher_msg.data = BTN_OFF;
;;;335    					}
;;;336    					else if (strcmp(argv[0], "push_encoder") == 0)			// Encoder push
00028a  a191              ADR      r1,|L1.1232|
00028c  9814              LDR      r0,[sp,#0x50]
00028e  f7fffffe          BL       strcmp
000292  2800              CMP      r0,#0
000294  d06e              BEQ      |L1.884|
;;;337    					{
;;;338    						dispatcher_msg.type = DP_EMU_BTN_DOWN;
;;;339    						dispatcher_msg.data = BTN_ENCODER;
;;;340    					}
;;;341    					else if (strcmp(argv[0], "encoder_delta") == 0)			// Encoder delta
000296  a192              ADR      r1,|L1.1248|
000298  9814              LDR      r0,[sp,#0x50]
00029a  f7fffffe          BL       strcmp
00029e  2800              CMP      r0,#0
0002a0  d069              BEQ      |L1.886|
;;;342    					{
;;;343    						if (argc < 2)
;;;344    						{
;;;345    							transmitter_msg.type = SEND_STRING;
;;;346    							transmitter_msg.pdata = "ERR: missing argument [ticks]\r";
;;;347    						}
;;;348    						else
;;;349    						{
;;;350    							// Second argument is encoder ticks (signed)
;;;351    							dispatcher_msg.type = DP_EMU_ENC_DELTA;
;;;352    							dispatcher_msg.data = (uint32_t)strtol(argv[1], 0, 0);
;;;353    						}
;;;354    					}
;;;355    					//----------------- misc -----------------//
;;;356    					else if (strcmp(argv[0], "get_time_profiling") == 0)			// Time profiling
0002a2  a193              ADR      r1,|L1.1264|
0002a4  9814              LDR      r0,[sp,#0x50]
0002a6  f7fffffe          BL       strcmp
0002aa  2800              CMP      r0,#0
0002ac  d070              BEQ      |L1.912|
;;;357    					{
;;;358    						// FIXME
;;;359    						sprintf(temp_str,"Systick hook max ticks: %d\r",time_profile.max_ticks_in_Systick_hook);
;;;360    						UART_sendStrAlloc(temp_str);
;;;361    						sprintf(temp_str,"Timer2 ISR max ticks: %d\r",time_profile.max_ticks_in_Timer2_ISR);
;;;362    						UART_sendStrAlloc(temp_str);
;;;363    					}
;;;364    					//------------ unknown command -----------//
;;;365    					else
;;;366    					{
;;;367    						transmitter_msg.type = UNKNOWN_CMD;
0002ae  f2401001          MOV      r0,#0x101
0002b2  f8ad0004          STRH     r0,[sp,#4]
                  |L1.694|
;;;368    					}
;;;369    					
;;;370    					//----------------------------------------//
;;;371    					
;;;372    					// Send result to dispatcher
;;;373    					if (dispatcher_msg.type)
0002b6  9803              LDR      r0,[sp,#0xc]
0002b8  b130              CBZ      r0,|L1.712|
;;;374    						xQueueSendToBack(xQueueDispatcher, &dispatcher_msg, 0);
0002ba  4892              LDR      r0,|L1.1284|
0002bc  2300              MOVS     r3,#0
0002be  461a              MOV      r2,r3
0002c0  a903              ADD      r1,sp,#0xc
0002c2  6800              LDR      r0,[r0,#0]  ; xQueueDispatcher
0002c4  f7fffffe          BL       xQueueGenericSend
                  |L1.712|
;;;375    					
;;;376    					// Send response over UART
;;;377    					xQueueSendToBack(xQueueUART1TX, &transmitter_msg, 0); 
0002c8  4863              LDR      r0,|L1.1112|
0002ca  2300              MOVS     r3,#0
0002cc  461a              MOV      r2,r3
0002ce  a901              ADD      r1,sp,#4
0002d0  6800              LDR      r0,[r0,#0]  ; xQueueUART1TX
0002d2  f7fffffe          BL       xQueueGenericSend
                  |L1.726|
;;;378    			
;;;379    				}			
;;;380    				msg_length = 0;
0002d6  2400              MOVS     r4,#0
;;;381    				argc = 0;
0002d8  2500              MOVS     r5,#0
;;;382    				search_for_word = 1;
0002da  2601              MOVS     r6,#1
                  |L1.732|
0002dc  485e              LDR      r0,|L1.1112|
0002de  a913              ADD      r1,sp,#0x4c           ;217
0002e0  3008              ADDS     r0,r0,#8              ;217
0002e2  f7fffffe          BL       UART_Get_from_RX_buffer
0002e6  2800              CMP      r0,#0                 ;217
0002e8  f43faf50          BEQ      |L1.396|
0002ec  e753              B        |L1.406|
                  |L1.750|
0002ee  f44f7000          MOV      r0,#0x200             ;257
0002f2  9003              STR      r0,[sp,#0xc]          ;257
0002f4  e7df              B        |L1.694|
                  |L1.758|
0002f6  f2402001          MOV      r0,#0x201             ;261
0002fa  9003              STR      r0,[sp,#0xc]          ;261
0002fc  e7db              B        |L1.694|
                  |L1.766|
0002fe  2d02              CMP      r5,#2                 ;265
000300  d204              BCS      |L1.780|
000302  f8ad8004          STRH     r8,[sp,#4]            ;267
000306  a080              ADR      r0,|L1.1288|
000308  9002              STR      r0,[sp,#8]            ;268
00030a  e7d4              B        |L1.694|
                  |L1.780|
00030c  f44f7004          MOV      r0,#0x210             ;273
000310  9003              STR      r0,[sp,#0xc]          ;273
000312  2200              MOVS     r2,#0                 ;274
000314  4611              MOV      r1,r2                 ;274
000316  9815              LDR      r0,[sp,#0x54]         ;274
000318  f7fffffe          BL       strtoul
00031c  9004              STR      r0,[sp,#0x10]         ;274
00031e  e7ca              B        |L1.694|
000320  e001              B        |L1.806|
                  |L1.802|
000322  e015              B        |L1.848|
                  |L1.804|
000324  e028              B        |L1.888|
                  |L1.806|
000326  2d02              CMP      r5,#2                 ;279
000328  d204              BCS      |L1.820|
00032a  f8ad8004          STRH     r8,[sp,#4]            ;281
00032e  a07d              ADR      r0,|L1.1316|
000330  9002              STR      r0,[sp,#8]            ;282
000332  e7c0              B        |L1.694|
                  |L1.820|
000334  f2402011          MOV      r0,#0x211             ;287
000338  9003              STR      r0,[sp,#0xc]          ;287
00033a  2200              MOVS     r2,#0                 ;288
00033c  4611              MOV      r1,r2                 ;288
00033e  9815              LDR      r0,[sp,#0x54]         ;288
000340  f7fffffe          BL       strtoul
000344  9004              STR      r0,[sp,#0x10]         ;288
000346  e7b6              B        |L1.694|
                  |L1.840|
000348  e01a              B        |L1.896|
                  |L1.842|
00034a  e01d              B        |L1.904|
                  |L1.844|
00034c  e021              B        |L1.914|
                  |L1.846|
00034e  e024              B        |L1.922|
                  |L1.848|
000350  2d02              CMP      r5,#2                 ;293
000352  d204              BCS      |L1.862|
000354  f8ad8004          STRH     r8,[sp,#4]            ;295
000358  a079              ADR      r0,|L1.1344|
00035a  9002              STR      r0,[sp,#8]            ;296
00035c  e7ab              B        |L1.694|
                  |L1.862|
00035e  f2402012          MOV      r0,#0x212             ;301
000362  9003              STR      r0,[sp,#0xc]          ;301
000364  2200              MOVS     r2,#0                 ;302
000366  4611              MOV      r1,r2                 ;302
000368  9815              LDR      r0,[sp,#0x54]         ;302
00036a  f7fffffe          BL       strtoul
00036e  9004              STR      r0,[sp,#0x10]         ;302
000370  e7a1              B        |L1.694|
                  |L1.882|
000372  e016              B        |L1.930|
                  |L1.884|
000374  e019              B        |L1.938|
                  |L1.886|
000376  e01c              B        |L1.946|
                  |L1.888|
000378  9703              STR      r7,[sp,#0xc]          ;308
00037a  f8cd8010          STR      r8,[sp,#0x10]         ;309
00037e  e79a              B        |L1.694|
                  |L1.896|
000380  9703              STR      r7,[sp,#0xc]          ;313
000382  2008              MOVS     r0,#8                 ;314
000384  9004              STR      r0,[sp,#0x10]         ;314
000386  e796              B        |L1.694|
                  |L1.904|
000388  9703              STR      r7,[sp,#0xc]          ;318
00038a  2002              MOVS     r0,#2                 ;319
00038c  9004              STR      r0,[sp,#0x10]         ;319
00038e  e792              B        |L1.694|
                  |L1.912|
000390  e020              B        |L1.980|
                  |L1.914|
000392  9703              STR      r7,[sp,#0xc]          ;323
000394  2004              MOVS     r0,#4                 ;324
000396  9004              STR      r0,[sp,#0x10]         ;324
000398  e78d              B        |L1.694|
                  |L1.922|
00039a  9703              STR      r7,[sp,#0xc]          ;328
00039c  2040              MOVS     r0,#0x40              ;329
00039e  9004              STR      r0,[sp,#0x10]         ;329
0003a0  e789              B        |L1.694|
                  |L1.930|
0003a2  9703              STR      r7,[sp,#0xc]          ;333
0003a4  2080              MOVS     r0,#0x80              ;334
0003a6  9004              STR      r0,[sp,#0x10]         ;334
0003a8  e785              B        |L1.694|
                  |L1.938|
0003aa  9703              STR      r7,[sp,#0xc]          ;338
0003ac  2010              MOVS     r0,#0x10              ;339
0003ae  9004              STR      r0,[sp,#0x10]         ;339
0003b0  e781              B        |L1.694|
                  |L1.946|
0003b2  2d02              CMP      r5,#2                 ;343
0003b4  d204              BCS      |L1.960|
0003b6  f8ad8004          STRH     r8,[sp,#4]            ;345
0003ba  a06a              ADR      r0,|L1.1380|
0003bc  9002              STR      r0,[sp,#8]            ;346
0003be  e77a              B        |L1.694|
                  |L1.960|
0003c0  f44f6082          MOV      r0,#0x410             ;351
0003c4  9003              STR      r0,[sp,#0xc]          ;351
0003c6  2200              MOVS     r2,#0                 ;352
0003c8  4611              MOV      r1,r2                 ;352
0003ca  9815              LDR      r0,[sp,#0x54]         ;352
0003cc  f7fffffe          BL       strtol
0003d0  9004              STR      r0,[sp,#0x10]         ;352
0003d2  e770              B        |L1.694|
                  |L1.980|
0003d4  4c6b              LDR      r4,|L1.1412|
0003d6  a16c              ADR      r1,|L1.1416|
0003d8  a806              ADD      r0,sp,#0x18           ;359
0003da  6822              LDR      r2,[r4,#0]            ;359  ; time_profile
0003dc  f7fffffe          BL       __2sprintf
0003e0  a806              ADD      r0,sp,#0x18           ;360
0003e2  f7fffffe          BL       UART_sendStrAlloc
0003e6  a16f              ADR      r1,|L1.1444|
0003e8  a806              ADD      r0,sp,#0x18           ;361
0003ea  6862              LDR      r2,[r4,#4]            ;361  ; time_profile
0003ec  f7fffffe          BL       __2sprintf
0003f0  a806              ADD      r0,sp,#0x18           ;362
0003f2  f7fffffe          BL       UART_sendStrAlloc
0003f6  e75e              B        |L1.694|
;;;383    			}
;;;384    		}  // \UART_Get_from_RX_buffer()
;;;385    		
;;;386    	}
;;;387    }
;;;388    
                          ENDP

                  vTaskUARTTransmitter PROC
;;;423    
;;;424    void vTaskUARTTransmitter(void *pvParameters) 
0003f8  b08c              SUB      sp,sp,#0x30
;;;425    {
;;;426    	uart_transmiter_msg_t income_msg;
;;;427    	//uint32_t src_address;
;;;428    	char *string_to_send;
;;;429    	uint32_t n;
;;;430    	
;;;431    	DMA_CtrlDataInitTypeDef DMA_PriCtrlStr;
;;;432    	
;;;433    	// Setup DMA channel
;;;434    	UART_init_TX_DMA(MDR_UART1, &DMA_PriCtrlStr);
0003fa  f8df9054          LDR      r9,|L1.1104|
0003fe  4669              MOV      r1,sp
000400  4648              MOV      r0,r9
000402  f7fffffe          BL       UART_init_TX_DMA
;;;435    	
;;;436    	// Initialize OS items
;;;437    	xQueueUART1TX = xQueueCreate( 10, sizeof( uart_transmiter_msg_t ) );
000406  2200              MOVS     r2,#0
000408  2108              MOVS     r1,#8
00040a  200a              MOVS     r0,#0xa
00040c  f7fffffe          BL       xQueueGenericCreate
000410  4e11              LDR      r6,|L1.1112|
000412  6030              STR      r0,[r6,#0]  ; xQueueUART1TX
;;;438    	if( xQueueUART1TX == 0 )
000414  b1d0              CBZ      r0,|L1.1100|
;;;439    	{
;;;440    		// Queue was not created and must not be used.
;;;441    		while(1);
;;;442    	}
;;;443    	
;;;444    	vSemaphoreCreateBinary( xSemaphoreUART1TX );
000416  2203              MOVS     r2,#3
000418  2100              MOVS     r1,#0
00041a  2001              MOVS     r0,#1
00041c  f7fffffe          BL       xQueueGenericCreate
000420  6070              STR      r0,[r6,#4]  ; xSemaphoreUART1TX
000422  b120              CBZ      r0,|L1.1070|
000424  2300              MOVS     r3,#0
000426  461a              MOV      r2,r3
000428  4619              MOV      r1,r3
00042a  f7fffffe          BL       xQueueGenericSend
                  |L1.1070|
;;;445    	if( xSemaphoreUART1TX == 0 )
00042e  6870              LDR      r0,[r6,#4]  ; xSemaphoreUART1TX
000430  b168              CBZ      r0,|L1.1102|
;;;446        {
;;;447            while(1);
;;;448        }
;;;449    	
;;;450    	xSemaphoreTake(xSemaphoreUART1TX, 0);	
000432  2300              MOVS     r3,#0
000434  461a              MOV      r2,r3
000436  4619              MOV      r1,r3
000438  f7fffffe          BL       xQueueGenericReceive
;;;451    	
;;;452    	while(1)
;;;453    	{
;;;454    		xQueueReceive(xQueueUART1TX, &income_msg, portMAX_DELAY);
;;;455    		if ( (income_msg.type == SEND_STRING) || (income_msg.type == SEND_ALLOCATED_STRING) )
;;;456    		{
;;;457    			string_to_send = income_msg.pdata;
;;;458    		}
;;;459    		else if (income_msg.type == RESPONSE_OK)
;;;460    		{
;;;461    			string_to_send = (char *)_resp_OK;
;;;462    		}
;;;463    		else //if (income_msg.type == UNKNOWN_CMD)
;;;464    		{
;;;465    			string_to_send = (char *)_resp_UNKN_CMD;
;;;466    		}
;;;467    		
;;;468    		// Get number of chars to transmit
;;;469    		n = strlen(string_to_send);
;;;470    		// DMA cannot read from program memory, copy data to temporary buffer
;;;471    		if ((uint32_t)string_to_send < 0x20000000UL)
00043c  f04f5800          MOV      r8,#0x20000000
000440  f04f37ff          MOV      r7,#0xffffffff        ;454
                  |L1.1092|
000444  2300              MOVS     r3,#0                 ;454
000446  463a              MOV      r2,r7                 ;454
000448  a90a              ADD      r1,sp,#0x28           ;454
00044a  e0b9              B        |L1.1472|
                  |L1.1100|
00044c  e0d6              B        |L1.1532|
                  |L1.1102|
00044e  e0d6              B        |L1.1534|
                  |L1.1104|
                          DCD      0x40030000
                  |L1.1108|
                          DCD      DMA_ControlTable
                  |L1.1112|
                          DCD      ||area_number.7||
                  |L1.1116|
                          DCD      ||.bss||+0x64
                  |L1.1120|
                          DCD      ||.bss||+0x1f4
                  |L1.1124|
000464  6f6e00            DCB      "on",0
000467  00                DCB      0
                  |L1.1128|
000468  6f666600          DCB      "off",0
                  |L1.1132|
00046c  7365745f          DCB      "set_voltage",0
000470  766f6c74
000474  61676500
                  |L1.1144|
000478  7365745f          DCB      "set_current",0
00047c  63757272
000480  656e7400
                  |L1.1156|
000484  7365745f          DCB      "set_current_limit",0
000488  63757272
00048c  656e745f
000490  6c696d69
000494  7400    
000496  00                DCB      0
000497  00                DCB      0
                  |L1.1176|
000498  62746e5f          DCB      "btn_esc",0
00049c  65736300
                  |L1.1184|
0004a0  62746e5f          DCB      "btn_ok",0
0004a4  6f6b00  
0004a7  00                DCB      0
                  |L1.1192|
0004a8  62746e5f          DCB      "btn_left",0
0004ac  6c656674
0004b0  00      
0004b1  00                DCB      0
0004b2  00                DCB      0
0004b3  00                DCB      0
                  |L1.1204|
0004b4  62746e5f          DCB      "btn_right",0
0004b8  72696768
0004bc  7400    
0004be  00                DCB      0
0004bf  00                DCB      0
                  |L1.1216|
0004c0  62746e5f          DCB      "btn_on",0
0004c4  6f6e00  
0004c7  00                DCB      0
                  |L1.1224|
0004c8  62746e5f          DCB      "btn_off",0
0004cc  6f666600
                  |L1.1232|
0004d0  70757368          DCB      "push_encoder",0
0004d4  5f656e63
0004d8  6f646572
0004dc  00      
0004dd  00                DCB      0
0004de  00                DCB      0
0004df  00                DCB      0
                  |L1.1248|
0004e0  656e636f          DCB      "encoder_delta",0
0004e4  6465725f
0004e8  64656c74
0004ec  6100    
0004ee  00                DCB      0
0004ef  00                DCB      0
                  |L1.1264|
0004f0  6765745f          DCB      "get_time_profiling",0
0004f4  74696d65
0004f8  5f70726f
0004fc  66696c69
000500  6e6700  
000503  00                DCB      0
                  |L1.1284|
                          DCD      xQueueDispatcher
                  |L1.1288|
000508  4552523a          DCB      "ERR: missing argument [mV]\r",0
00050c  206d6973
000510  73696e67
000514  20617267
000518  756d656e
00051c  74205b6d
000520  565d0d00
                  |L1.1316|
000524  4552523a          DCB      "ERR: missing argument [mA]\r",0
000528  206d6973
00052c  73696e67
000530  20617267
000534  756d656e
000538  74205b6d
00053c  415d0d00
                  |L1.1344|
000540  4552523a          DCB      "ERR: missing argument (20/40)[A]\r",0
000544  206d6973
000548  73696e67
00054c  20617267
000550  756d656e
000554  74202832
000558  302f3430
00055c  295b415d
000560  0d00    
000562  00                DCB      0
000563  00                DCB      0
                  |L1.1380|
000564  4552523a          DCB      "ERR: missing argument [ticks]\r",0
000568  206d6973
00056c  73696e67
000570  20617267
000574  756d656e
000578  74205b74
00057c  69636b73
000580  5d0d00  
000583  00                DCB      0
                  |L1.1412|
                          DCD      time_profile
                  |L1.1416|
000588  53797374          DCB      "Systick hook max ticks: %d\r",0
00058c  69636b20
000590  686f6f6b
000594  206d6178
000598  20746963
00059c  6b733a20
0005a0  25640d00
                  |L1.1444|
0005a4  54696d65          DCB      "Timer2 ISR max ticks: %d\r",0
0005a8  72322049
0005ac  5352206d
0005b0  61782074
0005b4  69636b73
0005b8  3a202564
0005bc  0d00    
0005be  00                DCB      0
0005bf  00                DCB      0
                  |L1.1472|
0005c0  6830              LDR      r0,[r6,#0]            ;454  ; xQueueUART1TX
0005c2  f7fffffe          BL       xQueueGenericReceive
0005c6  f8bd0028          LDRH     r0,[sp,#0x28]         ;455
0005ca  2801              CMP      r0,#1                 ;455
0005cc  d018              BEQ      |L1.1536|
0005ce  2802              CMP      r0,#2                 ;455
0005d0  d016              BEQ      |L1.1536|
0005d2  f5b07f80          CMP      r0,#0x100             ;459
0005d6  d015              BEQ      |L1.1540|
0005d8  4c31              LDR      r4,|L1.1696|
                  |L1.1498|
0005da  4620              MOV      r0,r4                 ;469
0005dc  f7fffffe          BL       strlen
0005e0  4605              MOV      r5,r0                 ;469
0005e2  4544              CMP      r4,r8
0005e4  d211              BCS      |L1.1546|
;;;472    		{
;;;473    			if (n > TX_BUFFER_SIZE)
0005e6  2d64              CMP      r5,#0x64
0005e8  d900              BLS      |L1.1516|
;;;474    				n = TX_BUFFER_SIZE;
0005ea  2564              MOVS     r5,#0x64
                  |L1.1516|
;;;475    			strncpy(uart1_tx_data_buff, string_to_send, n);
0005ec  462a              MOV      r2,r5
0005ee  4621              MOV      r1,r4
0005f0  482c              LDR      r0,|L1.1700|
0005f2  f7fffffe          BL       strncpy
;;;476    			DMA_PriCtrlStr.DMA_SourceBaseAddr = (uint32_t)&uart1_tx_data_buff;
0005f6  482b              LDR      r0,|L1.1700|
0005f8  9000              STR      r0,[sp,#0]
0005fa  e007              B        |L1.1548|
                  |L1.1532|
0005fc  e7fe              B        |L1.1532|
                  |L1.1534|
0005fe  e7fe              B        |L1.1534|
                  |L1.1536|
000600  9c0b              LDR      r4,[sp,#0x2c]         ;457
000602  e7ea              B        |L1.1498|
                  |L1.1540|
000604  4c26              LDR      r4,|L1.1696|
000606  1f24              SUBS     r4,r4,#4              ;461
000608  e7e7              B        |L1.1498|
                  |L1.1546|
;;;477    		}
;;;478    		else
;;;479    		{
;;;480    			DMA_PriCtrlStr.DMA_SourceBaseAddr = (uint32_t)string_to_send;
00060a  9400              STR      r4,[sp,#0]
                  |L1.1548|
;;;481    		}
;;;482    		// Setup DMA control block
;;;483    		DMA_PriCtrlStr.DMA_CycleSize = n;
00060c  9506              STR      r5,[sp,#0x18]
;;;484    		// Start DMA
;;;485    		DMA_CtrlInit (DMA_Channel_UART1_TX, DMA_CTRL_DATA_PRIMARY, &DMA_PriCtrlStr);
00060e  2100              MOVS     r1,#0
000610  466a              MOV      r2,sp
000612  4608              MOV      r0,r1
000614  f7fffffe          BL       DMA_CtrlInit
;;;486    		DMA_Cmd(DMA_Channel_UART1_TX, ENABLE);
000618  2101              MOVS     r1,#1
00061a  2000              MOVS     r0,#0
00061c  f7fffffe          BL       DMA_Cmd
;;;487    		// Enable UART1 DMA Tx request
;;;488    		UART_DMACmd(MDR_UART1,UART_DMA_TXE, ENABLE);
000620  2201              MOVS     r2,#1
000622  2102              MOVS     r1,#2
000624  4648              MOV      r0,r9
000626  f7fffffe          BL       UART_DMACmd
;;;489    			
;;;490    		// Wait for DMA
;;;491    		xSemaphoreTake(xSemaphoreUART1TX, portMAX_DELAY);
00062a  2300              MOVS     r3,#0
00062c  463a              MOV      r2,r7
00062e  4619              MOV      r1,r3
000630  6870              LDR      r0,[r6,#4]  ; xSemaphoreUART1TX
000632  f7fffffe          BL       xQueueGenericReceive
;;;492    	
;;;493    		// Free memory if required
;;;494    		if (income_msg.type == SEND_ALLOCATED_STRING)
000636  f8bd0028          LDRH     r0,[sp,#0x28]
00063a  2802              CMP      r0,#2
00063c  f47faf02          BNE      |L1.1092|
;;;495    		{
;;;496    			vPortFree(income_msg.pdata);		// heap_3 or heap_4 should be used
000640  980b              LDR      r0,[sp,#0x2c]
000642  f7fffffe          BL       vPortFree
000646  e6fd              B        |L1.1092|
;;;497    		}
;;;498    	}
;;;499    }
;;;500    
                          ENDP

                  DMA_IRQHandler PROC
;;;505    
;;;506    void DMA_IRQHandler(void)
000648  b538              PUSH     {r3-r5,lr}
;;;507    {
;;;508    	uint32_t *tcb_ptr;
;;;509    	portBASE_TYPE xHigherPriorityTaskWokenByPost = pdFALSE;
00064a  2000              MOVS     r0,#0
00064c  9000              STR      r0,[sp,#0]
;;;510    	
;;;511    	if ((MDR_DMA->CHNL_ENABLE_SET & (1<<DMA_Channel_UART1_TX)) == 0)	
00064e  4c16              LDR      r4,|L1.1704|
000650  6aa0              LDR      r0,[r4,#0x28]
000652  07c0              LSLS     r0,r0,#31
000654  d10e              BNE      |L1.1652|
;;;512    	{
;;;513    		// UART 1 DMA transfer complete
;;;514    		if (MDR_UART1->DMACR & UART_DMACR_TXDMAE)
000656  4815              LDR      r0,|L1.1708|
000658  6c81              LDR      r1,[r0,#0x48]
00065a  0789              LSLS     r1,r1,#30
00065c  d50a              BPL      |L1.1652|
;;;515    		{
;;;516    			// Disable UART1 DMA Tx request
;;;517    			MDR_UART1->DMACR &= ~UART_DMACR_TXDMAE;
00065e  6c81              LDR      r1,[r0,#0x48]
000660  f0210102          BIC      r1,r1,#2
000664  6481              STR      r1,[r0,#0x48]
;;;518    			xSemaphoreGiveFromISR( xSemaphoreUART1TX, &xHigherPriorityTaskWokenByPost );
000666  4812              LDR      r0,|L1.1712|
000668  2300              MOVS     r3,#0
00066a  466a              MOV      r2,sp
00066c  4619              MOV      r1,r3
00066e  6840              LDR      r0,[r0,#4]  ; xSemaphoreUART1TX
000670  f7fffffe          BL       xQueueGenericSendFromISR
                  |L1.1652|
;;;519    		}
;;;520    	}
;;;521    	/*
;;;522    	if (MDR_DMA->CHNL_ENABLE_SET & (1<<DMA_Channel_UART2_TX) == 0)	
;;;523    	{
;;;524    		// UART 2 DMA transfer complete
;;;525    		// Disable UART2 DMA Tx request
;;;526    		UART_DMACmd(MDR_UART2,UART_DMA_TXE, DISABLE);
;;;527    		// postSemaphoreFromISR(__complete__);
;;;528    	}	
;;;529    	*/
;;;530    	
;;;531    	if ((MDR_DMA->CHNL_ENABLE_SET & (1<<DMA_Channel_UART1_RX)) == 0)	
000674  6aa0              LDR      r0,[r4,#0x28]
000676  0780              LSLS     r0,r0,#30
000678  d409              BMI      |L1.1678|
;;;532    	{
;;;533    		// Reload TCB
;;;534    		tcb_ptr = (uint32_t*)&DMA_ControlTable[DMA_Channel_UART1_RX];
00067a  480e              LDR      r0,|L1.1716|
;;;535    		*tcb_ptr++ = UART1_RX_saved_TCB[0];
00067c  490e              LDR      r1,|L1.1720|
00067e  680a              LDR      r2,[r1,#0]  ; UART1_RX_saved_TCB
000680  6102              STR      r2,[r0,#0x10]
;;;536    		*tcb_ptr++ = UART1_RX_saved_TCB[1];
000682  684a              LDR      r2,[r1,#4]  ; UART1_RX_saved_TCB
000684  6142              STR      r2,[r0,#0x14]
;;;537    		*tcb_ptr = UART1_RX_saved_TCB[2];
000686  6889              LDR      r1,[r1,#8]  ; UART1_RX_saved_TCB
000688  6181              STR      r1,[r0,#0x18]
;;;538    		MDR_DMA->CHNL_ENABLE_SET = (1 << DMA_Channel_UART1_RX);
00068a  2002              MOVS     r0,#2
00068c  62a0              STR      r0,[r4,#0x28]
                  |L1.1678|
;;;539    	}
;;;540    		
;;;541    	
;;;542    	// Error handling
;;;543    	if (DMA_GetFlagStatus(0, DMA_FLAG_DMA_ERR) == SET)
00068e  2102              MOVS     r1,#2
000690  2000              MOVS     r0,#0
000692  f7fffffe          BL       DMA_GetFlagStatus
000696  2801              CMP      r0,#1
000698  d101              BNE      |L1.1694|
;;;544    	{
;;;545    		DMA_ClearError();	// normally this should not happen
00069a  f7fffffe          BL       DMA_ClearError
                  |L1.1694|
;;;546    	}
;;;547    	
;;;548    	// Force context switching if required
;;;549    	//portEND_SWITCHING_ISR(xHigherPriorityTaskWokenByPost);
;;;550    }
00069e  bd38              POP      {r3-r5,pc}
;;;551    
                          ENDP

                  |L1.1696|
                          DCD      ||.constdata||+0x4
                  |L1.1700|
                          DCD      ||.bss||
                  |L1.1704|
                          DCD      0x40028000
                  |L1.1708|
                          DCD      0x40030000
                  |L1.1712|
                          DCD      ||area_number.7||
                  |L1.1716|
                          DCD      DMA_ControlTable
                  |L1.1720|
                          DCD      ||.bss||+0x1f4

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uart1_tx_data_buff
                          %        100
                  uart1_rx_data_buff
                          %        400
                  UART1_RX_saved_TCB
                          %        12

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  _resp_OK
000000  4f4b0d00          DCB      0x4f,0x4b,0x0d,0x00
                  _resp_UNKN_CMD
000004  556e6b6e          DCB      0x55,0x6e,0x6b,0x6e
000008  6f776e20          DCB      0x6f,0x77,0x6e,0x20
00000c  636d640d          DCB      0x63,0x6d,0x64,0x0d
000010  00                DCB      0x00

                          AREA ||.data||, DATA, ALIGN=0

                  test_mode
000000  00                DCB      0x00

                          AREA ||area_number.7||, DATA, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.data||
                  xQueueUART1TX
                          DCD      0x00000000
                  xSemaphoreUART1TX
                          DCD      0x00000000
                  uart1_rx_dma_buffer
                          %        8

;*** Start embedded assembler ***

#line 1 "src\\uart.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_uart_c__resp_OK____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_uart_c__resp_OK____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_uart_c__resp_OK____REVSH|
#line 130
|__asm___6_uart_c__resp_OK____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
