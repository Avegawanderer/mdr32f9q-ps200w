; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\mdr32f9qx_adc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\mdr32f9qx_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\mdr32f9qx_adc.crf ..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;45       */
;;;46     void ADC_DeInit(void)
000000  2000              MOVS     r0,#0
;;;47     {
;;;48       MDR_ADC->ADC1_CFG = 0;
000002  49e3              LDR      r1,|L1.912|
000004  6008              STR      r0,[r1,#0]
;;;49       MDR_ADC->ADC2_CFG = 0;
000006  6048              STR      r0,[r1,#4]
;;;50       MDR_ADC->ADC1_H_LEVEL = 0;
000008  6088              STR      r0,[r1,#8]
;;;51       MDR_ADC->ADC2_H_LEVEL = 0;
00000a  60c8              STR      r0,[r1,#0xc]
;;;52       MDR_ADC->ADC1_L_LEVEL = 0;
00000c  6108              STR      r0,[r1,#0x10]
;;;53       MDR_ADC->ADC2_L_LEVEL = 0;
00000e  6148              STR      r0,[r1,#0x14]
;;;54       MDR_ADC->ADC1_RESULT;
000010  4608              MOV      r0,r1
000012  6980              LDR      r0,[r0,#0x18]
;;;55       MDR_ADC->ADC2_RESULT;
000014  4608              MOV      r0,r1
000016  69c0              LDR      r0,[r0,#0x1c]
;;;56       MDR_ADC->ADC1_STATUS = 0;
000018  2000              MOVS     r0,#0
00001a  6208              STR      r0,[r1,#0x20]
;;;57       MDR_ADC->ADC2_STATUS = 0;
00001c  6248              STR      r0,[r1,#0x24]
;;;58       MDR_ADC->ADC1_CHSEL = 0;
00001e  6288              STR      r0,[r1,#0x28]
;;;59       MDR_ADC->ADC2_CHSEL = 0;
000020  62c8              STR      r0,[r1,#0x2c]
;;;60     }
000022  4770              BX       lr
;;;61     
                          ENDP

                  ADC_Init PROC
;;;69       */
;;;70     void ADC_Init(const ADC_InitTypeDef* ADC_InitStruct)
000024  b510              PUSH     {r4,lr}
;;;71     {
;;;72       uint32_t tmpreg_CFG;
;;;73       uint32_t tmpreg_MSK;
;;;74     
;;;75       /* Check the parameters */
;;;76       assert_param(IS_ADC_SYNC_MODE(ADC_InitStruct->ADC_SynchronousMode));
;;;77       assert_param(IS_ADC_START_DELAY_VALUE(ADC_InitStruct->ADC_StartDelay));
;;;78       assert_param(IS_ADC_TEMP_SENSOR_CONFIG(ADC_InitStruct->ADC_TempSensor));
;;;79       assert_param(IS_ADC_TEMP_SENSOR_AMP_CONFIG(ADC_InitStruct->ADC_TempSensorAmplifier));
;;;80       assert_param(IS_ADC_TEMP_SENSOR_CONVERSION_CONFIG(ADC_InitStruct->ADC_TempSensorConversion));
;;;81       assert_param(IS_ADC_VREF_CONVERSION_CONFIG(ADC_InitStruct->ADC_IntVRefConversion));
;;;82       assert_param(IS_ADC_VREF_TRIMMING_VALUE(ADC_InitStruct->ADC_IntVRefTrimming));
;;;83     
;;;84       tmpreg_CFG = ADC_InitStruct->ADC_SynchronousMode
000026  e9d03400          LDRD     r3,r4,[r0,#0]
00002a  eb037304          ADD      r3,r3,r4,LSL #28
00002e  6884              LDR      r4,[r0,#8]
000030  4423              ADD      r3,r3,r4
000032  68c4              LDR      r4,[r0,#0xc]
000034  4423              ADD      r3,r3,r4
000036  6904              LDR      r4,[r0,#0x10]
000038  4423              ADD      r3,r3,r4
00003a  6944              LDR      r4,[r0,#0x14]
00003c  4423              ADD      r3,r3,r4
00003e  6984              LDR      r4,[r0,#0x18]
000040  eb035144          ADD      r1,r3,r4,LSL #21
;;;85                  + (ADC_InitStruct->ADC_StartDelay << ADC1_CFG_DELAY_ADC_Pos)
;;;86                  + ADC_InitStruct->ADC_TempSensor
;;;87                  + ADC_InitStruct->ADC_TempSensorAmplifier
;;;88                  + ADC_InitStruct->ADC_TempSensorConversion
;;;89                  + ADC_InitStruct->ADC_IntVRefConversion
;;;90                  + (ADC_InitStruct->ADC_IntVRefTrimming << ADC1_CFG_TR_Pos);
;;;91     
;;;92       tmpreg_MSK = ADC1_CFG_SYNC_CONVER
000044  4ad3              LDR      r2,|L1.916|
;;;93                  | ADC1_CFG_DELAY_ADC_Msk
;;;94                  | ADC1_CFG_TS_EN
;;;95                  | ADC1_CFG_TS_BUF_EN
;;;96                  | ADC1_CFG_SEL_TS
;;;97                  | ADC1_CFG_SEL_VREF
;;;98                  | ADC1_CFG_TR_Msk;
;;;99     
;;;100      MDR_ADC->ADC1_CFG = (MDR_ADC->ADC1_CFG & ~tmpreg_MSK) + tmpreg_CFG;
000046  4bd2              LDR      r3,|L1.912|
000048  681b              LDR      r3,[r3,#0]
00004a  4393              BICS     r3,r3,r2
00004c  440b              ADD      r3,r3,r1
00004e  4cd0              LDR      r4,|L1.912|
000050  6023              STR      r3,[r4,#0]
;;;101    }
000052  bd10              POP      {r4,pc}
;;;102    
                          ENDP

                  ADC_StructInit PROC
;;;108      */
;;;109    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000054  2100              MOVS     r1,#0
;;;110    {
;;;111      ADC_InitStruct->ADC_SynchronousMode      = ADC_SyncMode_Independent;
000056  6001              STR      r1,[r0,#0]
;;;112      ADC_InitStruct->ADC_StartDelay           = 0;
000058  6041              STR      r1,[r0,#4]
;;;113      ADC_InitStruct->ADC_TempSensor           = ADC_TEMP_SENSOR_Disable;
00005a  6081              STR      r1,[r0,#8]
;;;114      ADC_InitStruct->ADC_TempSensorAmplifier  = ADC_TEMP_SENSOR_AMPLIFIER_Disable;
00005c  60c1              STR      r1,[r0,#0xc]
;;;115      ADC_InitStruct->ADC_TempSensorConversion = ADC_TEMP_SENSOR_CONVERSION_Disable;
00005e  6101              STR      r1,[r0,#0x10]
;;;116      ADC_InitStruct->ADC_IntVRefConversion    = ADC_VREF_CONVERSION_Disable;
000060  6141              STR      r1,[r0,#0x14]
;;;117      ADC_InitStruct->ADC_IntVRefTrimming      = 0;
000062  6181              STR      r1,[r0,#0x18]
;;;118    }
000064  4770              BX       lr
;;;119    
                          ENDP

                  ADC_SetTrim PROC
;;;124      */
;;;125    void ADC_SetTrim(uint32_t Trim)
000066  4aca              LDR      r2,|L1.912|
;;;126    {
;;;127      uint32_t tmpreg_CFG;
;;;128    
;;;129      /* Check the parameters */
;;;130      assert_param(IS_ADC_VREF_TRIMMING_VALUE(Trim));
;;;131    
;;;132      tmpreg_CFG = MDR_ADC->ADC1_CFG & ~ADC1_CFG_TR_Msk;
000068  6812              LDR      r2,[r2,#0]
00006a  f02271f0          BIC      r1,r2,#0x1e00000
;;;133      MDR_ADC->ADC1_CFG = tmpreg_CFG + (Trim << ADC1_CFG_TR_Pos);
00006e  eb015240          ADD      r2,r1,r0,LSL #21
000072  4bc7              LDR      r3,|L1.912|
000074  601a              STR      r2,[r3,#0]
;;;134    }
000076  4770              BX       lr
;;;135    
                          ENDP

                  ADC1_Init PROC
;;;143      */
;;;144    void ADC1_Init(const ADCx_InitTypeDef* ADCx_InitStruct)
000078  b510              PUSH     {r4,lr}
;;;145    {
;;;146      uint32_t tmpreg_CFG1;
;;;147      uint32_t tmpreg_CFG2;
;;;148    
;;;149      /* Check the parameters */
;;;150      assert_param(IS_ADC_CLOCK_SOURCE_CONFIG(ADCx_InitStruct->ADC_ClockSource));
;;;151      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(ADCx_InitStruct->ADC_SamplingMode));
;;;152      assert_param(IS_ADC_CH_SWITCHING_CONFIG(ADCx_InitStruct->ADC_ChannelSwitching));
;;;153      assert_param(IS_ADC1_CH_NUM(ADCx_InitStruct->ADC_ChannelNumber));
;;;154      assert_param(IS_ADC1_CH_MASK(ADCx_InitStruct->ADC_Channels));
;;;155      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(ADCx_InitStruct->ADC_LevelControl));
;;;156      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_LowLevel));
;;;157      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_HighLevel));
;;;158      assert_param(IS_ADC_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_VRefSource));
;;;159      assert_param(IS_ADC_INT_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_IntVRefSource));
;;;160      assert_param(IS_ADC_CLK_div_VALUE(ADCx_InitStruct->ADC_Prescaler));
;;;161      assert_param(IS_ADC_DELAY_GO_VALUE(ADCx_InitStruct->ADC_DelayGo));
;;;162    
;;;163      tmpreg_CFG1 = MDR_ADC->ADC1_CFG;
00007a  4bc5              LDR      r3,|L1.912|
00007c  681a              LDR      r2,[r3,#0]
;;;164    
;;;165      tmpreg_CFG1 &= ~(ADC1_CFG_REG_CLKS
00007e  4bc5              LDR      r3,|L1.916|
000080  1cdb              ADDS     r3,r3,#3
000082  401a              ANDS     r2,r2,r3
;;;166                     | ADC1_CFG_REG_SAMPLE
;;;167                     | ADC1_CFG_REG_CHCH
;;;168                     | ADC1_CFG_REG_CHS_Msk
;;;169                     | ADC1_CFG_REG_RNGC
;;;170                     | ADC1_CFG_M_REF
;;;171                     | ADC1_CFG_REG_DIVCLK_Msk
;;;172                     | ADC1_CFG_DELAY_GO_Msk);
;;;173    
;;;174      tmpreg_CFG1 += ADCx_InitStruct->ADC_ClockSource
000084  e9d03400          LDRD     r3,r4,[r0,#0]
000088  4423              ADD      r3,r3,r4
00008a  6884              LDR      r4,[r0,#8]
00008c  4423              ADD      r3,r3,r4
00008e  68c4              LDR      r4,[r0,#0xc]
000090  eb031304          ADD      r3,r3,r4,LSL #4
000094  6944              LDR      r4,[r0,#0x14]
000096  4423              ADD      r3,r3,r4
000098  69c4              LDR      r4,[r0,#0x1c]
00009a  4423              ADD      r3,r3,r4
00009c  6a44              LDR      r4,[r0,#0x24]
00009e  4423              ADD      r3,r3,r4
0000a0  6a84              LDR      r4,[r0,#0x28]
0000a2  eb036344          ADD      r3,r3,r4,LSL #25
0000a6  441a              ADD      r2,r2,r3
;;;175                   + ADCx_InitStruct->ADC_SamplingMode
;;;176                   + ADCx_InitStruct->ADC_ChannelSwitching
;;;177                   + (ADCx_InitStruct->ADC_ChannelNumber << ADC1_CFG_REG_CHS_Pos)
;;;178                   + ADCx_InitStruct->ADC_LevelControl
;;;179                   + ADCx_InitStruct->ADC_VRefSource
;;;180                   + ADCx_InitStruct->ADC_Prescaler
;;;181                   + (ADCx_InitStruct->ADC_DelayGo << ADC1_CFG_DELAY_GO_Pos);
;;;182    
;;;183      tmpreg_CFG2 = MDR_ADC->ADC2_CFG;
0000a8  4bb9              LDR      r3,|L1.912|
0000aa  6859              LDR      r1,[r3,#4]
;;;184      tmpreg_CFG2 &= ~ADC2_CFG_ADC1_OP;
0000ac  f4213100          BIC      r1,r1,#0x20000
;;;185      tmpreg_CFG2 += ADCx_InitStruct->ADC_IntVRefSource << ADC2_CFG_ADC1_OP_Pos;
0000b0  6a03              LDR      r3,[r0,#0x20]
0000b2  eb014143          ADD      r1,r1,r3,LSL #17
;;;186    
;;;187      MDR_ADC->ADC1_CFG = tmpreg_CFG1;
0000b6  4bb6              LDR      r3,|L1.912|
0000b8  601a              STR      r2,[r3,#0]
;;;188      MDR_ADC->ADC2_CFG = tmpreg_CFG2;
0000ba  6059              STR      r1,[r3,#4]
;;;189    
;;;190      MDR_ADC->ADC1_L_LEVEL = ADCx_InitStruct->ADC_LowLevel;
0000bc  8b03              LDRH     r3,[r0,#0x18]
0000be  4cb4              LDR      r4,|L1.912|
0000c0  6123              STR      r3,[r4,#0x10]
;;;191      MDR_ADC->ADC1_H_LEVEL = ADCx_InitStruct->ADC_HighLevel;
0000c2  8b43              LDRH     r3,[r0,#0x1a]
0000c4  60a3              STR      r3,[r4,#8]
;;;192      MDR_ADC->ADC1_CHSEL   = ADCx_InitStruct->ADC_Channels;
0000c6  6903              LDR      r3,[r0,#0x10]
0000c8  62a3              STR      r3,[r4,#0x28]
;;;193    }
0000ca  bd10              POP      {r4,pc}
;;;194    
                          ENDP

                  ADC2_Init PROC
;;;202      */
;;;203    void ADC2_Init(const ADCx_InitTypeDef* ADCx_InitStruct)
0000cc  4ab0              LDR      r2,|L1.912|
;;;204    {
;;;205      uint32_t tmpreg_CFG2;
;;;206    
;;;207      /* Check the parameters */
;;;208      assert_param(IS_ADC_CLOCK_SOURCE_CONFIG(ADCx_InitStruct->ADC_ClockSource));
;;;209      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(ADCx_InitStruct->ADC_SamplingMode));
;;;210      assert_param(IS_ADC_CH_SWITCHING_CONFIG(ADCx_InitStruct->ADC_ChannelSwitching));
;;;211      assert_param(IS_ADC2_CH_NUM(ADCx_InitStruct->ADC_ChannelNumber));
;;;212      assert_param(IS_ADC2_CH_MASK(ADCx_InitStruct->ADC_Channels));
;;;213      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(ADCx_InitStruct->ADC_LevelControl));
;;;214      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_LowLevel));
;;;215      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_HighLevel));
;;;216      assert_param(IS_ADC_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_VRefSource));
;;;217      assert_param(IS_ADC_INT_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_IntVRefSource));
;;;218      assert_param(IS_ADC_CLK_div_VALUE(ADCx_InitStruct->ADC_Prescaler));
;;;219      assert_param(IS_ADC_DELAY_GO_VALUE(ADCx_InitStruct->ADC_DelayGo));
;;;220    
;;;221      tmpreg_CFG2 = MDR_ADC->ADC2_CFG;
0000ce  6851              LDR      r1,[r2,#4]
;;;222    
;;;223      tmpreg_CFG2 &= ~(ADC2_CFG_REG_CLKS
0000d0  4ab1              LDR      r2,|L1.920|
0000d2  4011              ANDS     r1,r1,r2
;;;224                     | ADC2_CFG_REG_SAMPLE
;;;225                     | ADC2_CFG_REG_CHCH
;;;226                     | ADC2_CFG_REG_CHS_Msk
;;;227                     | ADC2_CFG_REG_RNGC
;;;228                     | ADC2_CFG_M_REF
;;;229                     | ADC2_CFG_ADC2_OP
;;;230                     | ADC2_CFG_REG_DIVCLK_Msk
;;;231                     | ADC2_CFG_DELAY_GO_Msk);
;;;232    
;;;233      tmpreg_CFG2 += ADCx_InitStruct->ADC_ClockSource
0000d4  e9d02300          LDRD     r2,r3,[r0,#0]
0000d8  441a              ADD      r2,r2,r3
0000da  6883              LDR      r3,[r0,#8]
0000dc  441a              ADD      r2,r2,r3
0000de  68c3              LDR      r3,[r0,#0xc]
0000e0  eb021203          ADD      r2,r2,r3,LSL #4
0000e4  6943              LDR      r3,[r0,#0x14]
0000e6  441a              ADD      r2,r2,r3
0000e8  69c3              LDR      r3,[r0,#0x1c]
0000ea  441a              ADD      r2,r2,r3
0000ec  6a03              LDR      r3,[r0,#0x20]
0000ee  eb024283          ADD      r2,r2,r3,LSL #18
0000f2  6a43              LDR      r3,[r0,#0x24]
0000f4  441a              ADD      r2,r2,r3
0000f6  6a83              LDR      r3,[r0,#0x28]
0000f8  eb026243          ADD      r2,r2,r3,LSL #25
0000fc  4411              ADD      r1,r1,r2
;;;234                   + ADCx_InitStruct->ADC_SamplingMode
;;;235                   + ADCx_InitStruct->ADC_ChannelSwitching
;;;236                   + (ADCx_InitStruct->ADC_ChannelNumber << ADC2_CFG_REG_CHS_Pos)
;;;237                   + ADCx_InitStruct->ADC_LevelControl
;;;238                   + ADCx_InitStruct->ADC_VRefSource
;;;239                   + (ADCx_InitStruct->ADC_IntVRefSource << ADC2_CFG_ADC2_OP_Pos)
;;;240                   + ADCx_InitStruct->ADC_Prescaler
;;;241                   + (ADCx_InitStruct->ADC_DelayGo << ADC2_CFG_DELAY_GO_Pos);
;;;242    
;;;243      MDR_ADC->ADC2_CFG = tmpreg_CFG2;
0000fe  4aa4              LDR      r2,|L1.912|
000100  6051              STR      r1,[r2,#4]
;;;244      MDR_ADC->ADC2_L_LEVEL = ADCx_InitStruct->ADC_LowLevel;
000102  8b02              LDRH     r2,[r0,#0x18]
000104  4ba2              LDR      r3,|L1.912|
000106  615a              STR      r2,[r3,#0x14]
;;;245      MDR_ADC->ADC2_H_LEVEL = ADCx_InitStruct->ADC_HighLevel;
000108  8b42              LDRH     r2,[r0,#0x1a]
00010a  60da              STR      r2,[r3,#0xc]
;;;246      MDR_ADC->ADC2_CHSEL   = ADCx_InitStruct->ADC_Channels;
00010c  6902              LDR      r2,[r0,#0x10]
00010e  62da              STR      r2,[r3,#0x2c]
;;;247    }
000110  4770              BX       lr
;;;248    
                          ENDP

                  ADCx_StructInit PROC
;;;254      */
;;;255    void ADCx_StructInit(ADCx_InitTypeDef* ADCx_InitStruct)
000112  2100              MOVS     r1,#0
;;;256    {
;;;257      ADCx_InitStruct->ADC_ClockSource      = ADC_CLOCK_SOURCE_CPU;
000114  6001              STR      r1,[r0,#0]
;;;258      ADCx_InitStruct->ADC_SamplingMode     = ADC_SAMPLING_MODE_SINGLE_CONV;
000116  6041              STR      r1,[r0,#4]
;;;259      ADCx_InitStruct->ADC_ChannelSwitching = ADC_CH_SWITCHING_Disable;
000118  6081              STR      r1,[r0,#8]
;;;260      ADCx_InitStruct->ADC_ChannelNumber    = ADC_CH_ADC0;
00011a  60c1              STR      r1,[r0,#0xc]
;;;261      ADCx_InitStruct->ADC_Channels         = 0;
00011c  6101              STR      r1,[r0,#0x10]
;;;262      ADCx_InitStruct->ADC_LevelControl     = ADC_LEVEL_CONTROL_Disable;
00011e  6141              STR      r1,[r0,#0x14]
;;;263      ADCx_InitStruct->ADC_LowLevel         = 0;
000120  8301              STRH     r1,[r0,#0x18]
;;;264      ADCx_InitStruct->ADC_HighLevel        = 0;
000122  8341              STRH     r1,[r0,#0x1a]
;;;265      ADCx_InitStruct->ADC_VRefSource       = ADC_VREF_SOURCE_INTERNAL;
000124  61c1              STR      r1,[r0,#0x1c]
;;;266      ADCx_InitStruct->ADC_IntVRefSource    = ADC_INT_VREF_SOURCE_INEXACT;
000126  6201              STR      r1,[r0,#0x20]
;;;267      ADCx_InitStruct->ADC_Prescaler        = ADC_CLK_div_None;
000128  6241              STR      r1,[r0,#0x24]
;;;268      ADCx_InitStruct->ADC_DelayGo          = 0;
00012a  6281              STR      r1,[r0,#0x28]
;;;269    }
00012c  4770              BX       lr
;;;270    
                          ENDP

                  ADC1_Cmd PROC
;;;276      */
;;;277    void ADC1_Cmd(FunctionalState NewState)
00012e  4601              MOV      r1,r0
;;;278    {
;;;279      uint32_t tmpreg_CFG;
;;;280    
;;;281      /* Check the parameters */
;;;282      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;283    
;;;284      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000130  4a97              LDR      r2,|L1.912|
000132  6810              LDR      r0,[r2,#0]
;;;285    
;;;286      /* Form new value */
;;;287      if (NewState != DISABLE)
000134  b111              CBZ      r1,|L1.316|
;;;288      {
;;;289        /* Enable ADC1 by setting the Cfg_REG_ADON bit in the ADC1_CFG register */
;;;290        tmpreg_CFG |= ADC1_CFG_REG_ADON;
000136  f0400001          ORR      r0,r0,#1
00013a  e001              B        |L1.320|
                  |L1.316|
;;;291      }
;;;292      else
;;;293      {
;;;294        /* Disable ADC1 by resetting the Cfg_REG_ADON bit in the ADC1_CFG register */
;;;295        tmpreg_CFG &= ~ADC1_CFG_REG_ADON;
00013c  f0200001          BIC      r0,r0,#1
                  |L1.320|
;;;296      }
;;;297    
;;;298      /* Configure ADC1_CFG register with new value */
;;;299      MDR_ADC->ADC1_CFG = tmpreg_CFG;
000140  4a93              LDR      r2,|L1.912|
000142  6010              STR      r0,[r2,#0]
;;;300    }
000144  4770              BX       lr
;;;301    
                          ENDP

                  ADC2_Cmd PROC
;;;307      */
;;;308    void ADC2_Cmd(FunctionalState NewState)
000146  4601              MOV      r1,r0
;;;309    {
;;;310      uint32_t tmpreg_CFG;
;;;311    
;;;312      /* Check the parameters */
;;;313      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;314    
;;;315      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000148  4a91              LDR      r2,|L1.912|
00014a  6850              LDR      r0,[r2,#4]
;;;316    
;;;317      /* Form new value */
;;;318      if (NewState != DISABLE)
00014c  b111              CBZ      r1,|L1.340|
;;;319      {
;;;320        /* Enable ADC2 by setting the Cfg_REG_ADON bit in the ADC2_CFG register */
;;;321        tmpreg_CFG |= ADC2_CFG_REG_ADON;
00014e  f0400001          ORR      r0,r0,#1
000152  e001              B        |L1.344|
                  |L1.340|
;;;322      }
;;;323      else
;;;324      {
;;;325        /* Disable ADC2 by resetting the Cfg_REG_ADON bit in the ADC2_CFG register */
;;;326        tmpreg_CFG &= ~ADC2_CFG_REG_ADON;
000154  f0200001          BIC      r0,r0,#1
                  |L1.344|
;;;327      }
;;;328    
;;;329      /* Configure ADC2_CFG register with new value */
;;;330      MDR_ADC->ADC2_CFG = tmpreg_CFG;
000158  4a8d              LDR      r2,|L1.912|
00015a  6050              STR      r0,[r2,#4]
;;;331    }
00015c  4770              BX       lr
;;;332    
                          ENDP

                  ADC1_SetChannel PROC
;;;337      */
;;;338    void ADC1_SetChannel(uint32_t Channel)
00015e  4601              MOV      r1,r0
;;;339    {
;;;340      uint32_t tmpreg_CFG;
;;;341    
;;;342      /* Check the parameters */
;;;343      assert_param(IS_ADC1_CH_NUM(Channel));
;;;344    
;;;345      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000160  4a8b              LDR      r2,|L1.912|
000162  6810              LDR      r0,[r2,#0]
;;;346      tmpreg_CFG &= ~ADC1_CFG_REG_CHS_Msk;
000164  f42070f8          BIC      r0,r0,#0x1f0
;;;347      tmpreg_CFG += Channel << ADC1_CFG_REG_CHS_Pos;
000168  eb001001          ADD      r0,r0,r1,LSL #4
;;;348      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00016c  6010              STR      r0,[r2,#0]
;;;349    }
00016e  4770              BX       lr
;;;350    
                          ENDP

                  ADC2_SetChannel PROC
;;;355      */
;;;356    void ADC2_SetChannel(uint32_t Channel)
000170  4601              MOV      r1,r0
;;;357    {
;;;358      uint32_t tmpreg_CFG;
;;;359    
;;;360      /* Check the parameters */
;;;361      assert_param(IS_ADC2_CH_NUM(Channel));
;;;362    
;;;363      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000172  4a87              LDR      r2,|L1.912|
000174  6850              LDR      r0,[r2,#4]
;;;364      tmpreg_CFG &= ~ADC2_CFG_REG_CHS_Msk;
000176  f42070f8          BIC      r0,r0,#0x1f0
;;;365      tmpreg_CFG += Channel << ADC2_CFG_REG_CHS_Pos;
00017a  eb001001          ADD      r0,r0,r1,LSL #4
;;;366      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00017e  6050              STR      r0,[r2,#4]
;;;367    }
000180  4770              BX       lr
;;;368    
                          ENDP

                  ADC1_SetChannels PROC
;;;373      */
;;;374    void ADC1_SetChannels(uint32_t ChannelMask)
000182  4983              LDR      r1,|L1.912|
;;;375    {
;;;376      /* Check the parameters */
;;;377      assert_param(IS_ADC1_CH_MASK(ChannelMask));
;;;378    
;;;379      MDR_ADC->ADC1_CHSEL = ChannelMask;
000184  6288              STR      r0,[r1,#0x28]
;;;380    }
000186  4770              BX       lr
;;;381    
                          ENDP

                  ADC2_SetChannels PROC
;;;386      */
;;;387    void ADC2_SetChannels(uint32_t ChannelMask)
000188  4981              LDR      r1,|L1.912|
;;;388    {
;;;389      /* Check the parameters */
;;;390      assert_param(IS_ADC2_CH_MASK(ChannelMask));
;;;391    
;;;392      MDR_ADC->ADC2_CHSEL = ChannelMask;
00018a  62c8              STR      r0,[r1,#0x2c]
;;;393    }
00018c  4770              BX       lr
;;;394    
                          ENDP

                  ADC1_OperationModeConfig PROC
;;;400      */
;;;401    void ADC1_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode)
00018e  4602              MOV      r2,r0
;;;402    {
;;;403      uint32_t tmpreg_CFG;
;;;404    
;;;405      /* Check the parameters */
;;;406      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;407      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;408    
;;;409      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000190  4b7f              LDR      r3,|L1.912|
000192  6818              LDR      r0,[r3,#0]
;;;410      tmpreg_CFG &= ~(ADC1_CFG_REG_SAMPLE | ADC1_CFG_REG_CHCH);
000194  f4207002          BIC      r0,r0,#0x208
;;;411      tmpreg_CFG += SamplingMode + SwitchingMode;
000198  1853              ADDS     r3,r2,r1
00019a  4418              ADD      r0,r0,r3
;;;412      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00019c  4b7c              LDR      r3,|L1.912|
00019e  6018              STR      r0,[r3,#0]
;;;413    }
0001a0  4770              BX       lr
;;;414    
                          ENDP

                  ADC2_OperationModeConfig PROC
;;;420      */
;;;421    void ADC2_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode)
0001a2  4602              MOV      r2,r0
;;;422    {
;;;423      uint32_t tmpreg_CFG;
;;;424    
;;;425      /* Check the parameters */
;;;426      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;427      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;428    
;;;429      tmpreg_CFG = MDR_ADC->ADC2_CFG;
0001a4  4b7a              LDR      r3,|L1.912|
0001a6  6858              LDR      r0,[r3,#4]
;;;430      tmpreg_CFG &= ~(ADC2_CFG_REG_SAMPLE | ADC2_CFG_REG_CHCH);
0001a8  f4207002          BIC      r0,r0,#0x208
;;;431      tmpreg_CFG += SamplingMode + SwitchingMode;
0001ac  1853              ADDS     r3,r2,r1
0001ae  4418              ADD      r0,r0,r3
;;;432      MDR_ADC->ADC2_CFG = tmpreg_CFG;
0001b0  4b77              LDR      r3,|L1.912|
0001b2  6058              STR      r0,[r3,#4]
;;;433    }
0001b4  4770              BX       lr
;;;434    
                          ENDP

                  ADC1_SamplingModeConfig PROC
;;;439      */
;;;440    void ADC1_SamplingModeConfig(uint32_t SamplingMode)
0001b6  4601              MOV      r1,r0
;;;441    {
;;;442      uint32_t tmpreg_CFG;
;;;443    
;;;444      /* Check the parameters */
;;;445      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;446    
;;;447      tmpreg_CFG = MDR_ADC->ADC1_CFG;
0001b8  4a75              LDR      r2,|L1.912|
0001ba  6810              LDR      r0,[r2,#0]
;;;448      tmpreg_CFG &= ~ADC1_CFG_REG_SAMPLE;
0001bc  f0200008          BIC      r0,r0,#8
;;;449      tmpreg_CFG += SamplingMode;
0001c0  4408              ADD      r0,r0,r1
;;;450      MDR_ADC->ADC1_CFG = tmpreg_CFG;
0001c2  6010              STR      r0,[r2,#0]
;;;451    }
0001c4  4770              BX       lr
;;;452    
                          ENDP

                  ADC2_SamplingModeConfig PROC
;;;457      */
;;;458    void ADC2_SamplingModeConfig(uint32_t SamplingMode)
0001c6  4601              MOV      r1,r0
;;;459    {
;;;460      uint32_t tmpreg_CFG;
;;;461    
;;;462      /* Check the parameters */
;;;463      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;464    
;;;465      tmpreg_CFG = MDR_ADC->ADC2_CFG;
0001c8  4a71              LDR      r2,|L1.912|
0001ca  6850              LDR      r0,[r2,#4]
;;;466      tmpreg_CFG &= ~ADC2_CFG_REG_SAMPLE;
0001cc  f0200008          BIC      r0,r0,#8
;;;467      tmpreg_CFG += SamplingMode;
0001d0  4408              ADD      r0,r0,r1
;;;468      MDR_ADC->ADC2_CFG = tmpreg_CFG;
0001d2  6050              STR      r0,[r2,#4]
;;;469    }
0001d4  4770              BX       lr
;;;470    
                          ENDP

                  ADC1_ChannelSwithingConfig PROC
;;;475      */
;;;476    void ADC1_ChannelSwithingConfig(uint32_t SwitchingMode)
0001d6  4601              MOV      r1,r0
;;;477    {
;;;478      uint32_t tmpreg_CFG;
;;;479    
;;;480      /* Check the parameters */
;;;481      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;482    
;;;483      tmpreg_CFG = MDR_ADC->ADC1_CFG;
0001d8  4a6d              LDR      r2,|L1.912|
0001da  6810              LDR      r0,[r2,#0]
;;;484      tmpreg_CFG &= ~ADC1_CFG_REG_CHCH;
0001dc  f4207000          BIC      r0,r0,#0x200
;;;485      tmpreg_CFG += SwitchingMode;
0001e0  4408              ADD      r0,r0,r1
;;;486      MDR_ADC->ADC1_CFG = tmpreg_CFG;
0001e2  6010              STR      r0,[r2,#0]
;;;487    }
0001e4  4770              BX       lr
;;;488    
                          ENDP

                  ADC2_ChannelSwithingConfig PROC
;;;493      */
;;;494    void ADC2_ChannelSwithingConfig(uint32_t SwitchingMode)
0001e6  4601              MOV      r1,r0
;;;495    {
;;;496      uint32_t tmpreg_CFG;
;;;497    
;;;498      /* Check the parameters */
;;;499      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;500    
;;;501      tmpreg_CFG = MDR_ADC->ADC2_CFG;
0001e8  4a69              LDR      r2,|L1.912|
0001ea  6850              LDR      r0,[r2,#4]
;;;502      tmpreg_CFG &= ~ADC2_CFG_REG_CHCH;
0001ec  f4207000          BIC      r0,r0,#0x200
;;;503      tmpreg_CFG += SwitchingMode;
0001f0  4408              ADD      r0,r0,r1
;;;504      MDR_ADC->ADC2_CFG = tmpreg_CFG;
0001f2  6050              STR      r0,[r2,#4]
;;;505    }
0001f4  4770              BX       lr
;;;506    
                          ENDP

                  ADC1_LevelsConfig PROC
;;;513      */
;;;514    void ADC1_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState)
0001f6  b510              PUSH     {r4,lr}
;;;515    {
0001f8  4603              MOV      r3,r0
;;;516      uint32_t tmpreg_CFG;
;;;517    
;;;518      /* Check the parameters */
;;;519      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(NewState));
;;;520      assert_param(IS_ADC_VALUE(LowLevel));
;;;521      assert_param(IS_ADC_VALUE(HighLevel));
;;;522    
;;;523      tmpreg_CFG = MDR_ADC->ADC1_CFG;
0001fa  4c65              LDR      r4,|L1.912|
0001fc  6820              LDR      r0,[r4,#0]
;;;524      tmpreg_CFG &= ~ADC1_CFG_REG_RNGC;
0001fe  f4206080          BIC      r0,r0,#0x400
;;;525      tmpreg_CFG += NewState;
000202  4410              ADD      r0,r0,r2
;;;526      MDR_ADC->ADC1_CFG = tmpreg_CFG;
000204  6020              STR      r0,[r4,#0]
;;;527    
;;;528      MDR_ADC->ADC1_L_LEVEL = LowLevel;
000206  6123              STR      r3,[r4,#0x10]
;;;529      MDR_ADC->ADC1_H_LEVEL = HighLevel;
000208  60a1              STR      r1,[r4,#8]
;;;530    }
00020a  bd10              POP      {r4,pc}
;;;531    
                          ENDP

                  ADC2_LevelsConfig PROC
;;;538      */
;;;539    void ADC2_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState)
00020c  b510              PUSH     {r4,lr}
;;;540    {
00020e  4603              MOV      r3,r0
;;;541      uint32_t tmpreg_CFG;
;;;542    
;;;543      /* Check the parameters */
;;;544      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(NewState));
;;;545      assert_param(IS_ADC_VALUE(LowLevel));
;;;546      assert_param(IS_ADC_VALUE(HighLevel));
;;;547    
;;;548      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000210  4c5f              LDR      r4,|L1.912|
000212  6860              LDR      r0,[r4,#4]
;;;549      tmpreg_CFG &= ~ADC2_CFG_REG_RNGC;
000214  f4206080          BIC      r0,r0,#0x400
;;;550      tmpreg_CFG += NewState;
000218  4410              ADD      r0,r0,r2
;;;551      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00021a  6060              STR      r0,[r4,#4]
;;;552    
;;;553      MDR_ADC->ADC2_L_LEVEL = LowLevel;
00021c  6163              STR      r3,[r4,#0x14]
;;;554      MDR_ADC->ADC2_H_LEVEL = HighLevel;
00021e  60e1              STR      r1,[r4,#0xc]
;;;555    }
000220  bd10              POP      {r4,pc}
;;;556    
                          ENDP

                  ADC1_SetLowLevel PROC
;;;561      */
;;;562    void ADC1_SetLowLevel(uint32_t LowLevel)
000222  495b              LDR      r1,|L1.912|
;;;563    {
;;;564      /* Check the parameters */
;;;565      assert_param(IS_ADC_VALUE(LowLevel));
;;;566    
;;;567      MDR_ADC->ADC1_L_LEVEL = LowLevel;
000224  6108              STR      r0,[r1,#0x10]
;;;568    }
000226  4770              BX       lr
;;;569    
                          ENDP

                  ADC2_SetLowLevel PROC
;;;574      */
;;;575    void ADC2_SetLowLevel(uint32_t LowLevel)
000228  4959              LDR      r1,|L1.912|
;;;576    {
;;;577      /* Check the parameters */
;;;578      assert_param(IS_ADC_VALUE(LowLevel));
;;;579    
;;;580      MDR_ADC->ADC2_L_LEVEL = LowLevel;
00022a  6148              STR      r0,[r1,#0x14]
;;;581    }
00022c  4770              BX       lr
;;;582    
                          ENDP

                  ADC1_SetHighLevel PROC
;;;587      */
;;;588    void ADC1_SetHighLevel(uint32_t HighLevel)
00022e  4958              LDR      r1,|L1.912|
;;;589    {
;;;590      /* Check the parameters */
;;;591      assert_param(IS_ADC_VALUE(HighLevel));
;;;592    
;;;593      MDR_ADC->ADC1_H_LEVEL = HighLevel;
000230  6088              STR      r0,[r1,#8]
;;;594    }
000232  4770              BX       lr
;;;595    
                          ENDP

                  ADC2_SetHighLevel PROC
;;;600      */
;;;601    void ADC2_SetHighLevel(uint32_t HighLevel)
000234  4956              LDR      r1,|L1.912|
;;;602    {
;;;603      /* Check the parameters */
;;;604      assert_param(IS_ADC_VALUE(HighLevel));
;;;605    
;;;606      MDR_ADC->ADC2_H_LEVEL = HighLevel;
000236  60c8              STR      r0,[r1,#0xc]
;;;607    }
000238  4770              BX       lr
;;;608    
                          ENDP

                  ADC1_Start PROC
;;;613      */
;;;614    void ADC1_Start(void)
00023a  4855              LDR      r0,|L1.912|
;;;615    {
;;;616      MDR_ADC->ADC1_CFG |= ADC1_CFG_REG_GO;
00023c  6800              LDR      r0,[r0,#0]
00023e  f0400002          ORR      r0,r0,#2
000242  4953              LDR      r1,|L1.912|
000244  6008              STR      r0,[r1,#0]
;;;617    }
000246  4770              BX       lr
;;;618    
                          ENDP

                  ADC2_Start PROC
;;;623      */
;;;624    void ADC2_Start(void)
000248  4851              LDR      r0,|L1.912|
;;;625    {
;;;626      MDR_ADC->ADC2_CFG |= ADC2_CFG_REG_GO;
00024a  6840              LDR      r0,[r0,#4]
00024c  f0400002          ORR      r0,r0,#2
000250  494f              LDR      r1,|L1.912|
000252  6048              STR      r0,[r1,#4]
;;;627    }
000254  4770              BX       lr
;;;628    
                          ENDP

                  ADC1_GetResult PROC
;;;633      */
;;;634    uint32_t ADC1_GetResult(void)
000256  484e              LDR      r0,|L1.912|
;;;635    {
;;;636      return MDR_ADC->ADC1_RESULT;
000258  6980              LDR      r0,[r0,#0x18]
;;;637    }
00025a  4770              BX       lr
;;;638    
                          ENDP

                  ADC2_GetResult PROC
;;;643      */
;;;644    uint32_t ADC2_GetResult(void)
00025c  484c              LDR      r0,|L1.912|
;;;645    {
;;;646      return MDR_ADC->ADC2_RESULT;
00025e  69c0              LDR      r0,[r0,#0x1c]
;;;647    }
000260  4770              BX       lr
;;;648    
                          ENDP

                  ADC_GetStatus PROC
;;;653      */
;;;654    uint32_t ADC_GetStatus(void)
000262  484b              LDR      r0,|L1.912|
;;;655    {
;;;656      return MDR_ADC->ADC1_STATUS + (MDR_ADC->ADC2_STATUS << 16);
000264  6a00              LDR      r0,[r0,#0x20]
000266  494a              LDR      r1,|L1.912|
000268  6a49              LDR      r1,[r1,#0x24]
00026a  eb004001          ADD      r0,r0,r1,LSL #16
;;;657    }
00026e  4770              BX       lr
;;;658    
                          ENDP

                  ADC1_GetStatus PROC
;;;663      */
;;;664    uint32_t ADC1_GetStatus(void)
000270  4847              LDR      r0,|L1.912|
;;;665    {
;;;666      return MDR_ADC->ADC1_STATUS;
000272  6a00              LDR      r0,[r0,#0x20]
;;;667    }
000274  4770              BX       lr
;;;668    
                          ENDP

                  ADC2_GetStatus PROC
;;;673      */
;;;674    uint32_t ADC2_GetStatus(void)
000276  4846              LDR      r0,|L1.912|
;;;675    {
;;;676      return MDR_ADC->ADC2_STATUS;
000278  6a40              LDR      r0,[r0,#0x24]
;;;677    }
00027a  4770              BX       lr
;;;678    
                          ENDP

                  ADC_GetFlagStatus PROC
;;;690      */
;;;691    FlagStatus ADC_GetFlagStatus(uint32_t Flag)
00027c  b500              PUSH     {lr}
;;;692    {
00027e  4603              MOV      r3,r0
;;;693      FlagStatus bitstatus;
;;;694    
;;;695      /* Check the parameters */
;;;696      assert_param(IS_ADC_STATUS_FLAG(Flag));
;;;697    
;;;698      if ((ADC_GetStatus() & Flag) == 0)
000280  f7fffffe          BL       ADC_GetStatus
000284  4218              TST      r0,r3
000286  d101              BNE      |L1.652|
;;;699      {
;;;700        bitstatus = RESET;
000288  2200              MOVS     r2,#0
00028a  e000              B        |L1.654|
                  |L1.652|
;;;701      }
;;;702      else
;;;703      {
;;;704        bitstatus = SET;
00028c  2201              MOVS     r2,#1
                  |L1.654|
;;;705      }
;;;706    
;;;707      return bitstatus;
00028e  4610              MOV      r0,r2
;;;708    }
000290  bd00              POP      {pc}
;;;709    
                          ENDP

                  ADC1_GetFlagStatus PROC
;;;718      */
;;;719    FlagStatus ADC1_GetFlagStatus(uint32_t Flag)
000292  4601              MOV      r1,r0
;;;720    {
;;;721      FlagStatus bitstatus;
;;;722    
;;;723      /* Check the parameters */
;;;724      assert_param(IS_ADCx_STATUS_FLAG(Flag));
;;;725    
;;;726      if ((MDR_ADC->ADC1_STATUS & Flag) == 0)
000294  4a3e              LDR      r2,|L1.912|
000296  6a12              LDR      r2,[r2,#0x20]
000298  420a              TST      r2,r1
00029a  d101              BNE      |L1.672|
;;;727      {
;;;728        bitstatus = RESET;
00029c  2000              MOVS     r0,#0
00029e  e000              B        |L1.674|
                  |L1.672|
;;;729      }
;;;730      else
;;;731      {
;;;732        bitstatus = SET;
0002a0  2001              MOVS     r0,#1
                  |L1.674|
;;;733      }
;;;734    
;;;735      return bitstatus;
;;;736    }
0002a2  4770              BX       lr
;;;737    
                          ENDP

                  ADC2_GetFlagStatus PROC
;;;746      */
;;;747    FlagStatus ADC2_GetFlagStatus(uint32_t Flag)
0002a4  4601              MOV      r1,r0
;;;748    {
;;;749      FlagStatus bitstatus;
;;;750    
;;;751      /* Check the parameters */
;;;752      assert_param(IS_ADCx_STATUS_FLAG(Flag));
;;;753    
;;;754      if ((MDR_ADC->ADC2_STATUS & Flag) == 0)
0002a6  4a3a              LDR      r2,|L1.912|
0002a8  6a52              LDR      r2,[r2,#0x24]
0002aa  420a              TST      r2,r1
0002ac  d101              BNE      |L1.690|
;;;755      {
;;;756        bitstatus = RESET;
0002ae  2000              MOVS     r0,#0
0002b0  e000              B        |L1.692|
                  |L1.690|
;;;757      }
;;;758      else
;;;759      {
;;;760        bitstatus = SET;
0002b2  2001              MOVS     r0,#1
                  |L1.692|
;;;761      }
;;;762    
;;;763      return bitstatus;
;;;764    }
0002b4  4770              BX       lr
;;;765    
                          ENDP

                  ADC1_ClearOverwriteFlag PROC
;;;770      */
;;;771    void ADC1_ClearOverwriteFlag(void)
0002b6  4836              LDR      r0,|L1.912|
;;;772    {
;;;773      MDR_ADC->ADC1_STATUS &= ~ADCx_FLAG_OVERWRITE;
0002b8  6a00              LDR      r0,[r0,#0x20]
0002ba  f0200001          BIC      r0,r0,#1
0002be  4934              LDR      r1,|L1.912|
0002c0  6208              STR      r0,[r1,#0x20]
;;;774    }
0002c2  4770              BX       lr
;;;775    
                          ENDP

                  ADC2_ClearOverwriteFlag PROC
;;;780      */
;;;781    void ADC2_ClearOverwriteFlag(void)
0002c4  4832              LDR      r0,|L1.912|
;;;782    {
;;;783      MDR_ADC->ADC2_STATUS &= ~ADCx_FLAG_OVERWRITE;
0002c6  6a40              LDR      r0,[r0,#0x24]
0002c8  f0200001          BIC      r0,r0,#1
0002cc  4930              LDR      r1,|L1.912|
0002ce  6248              STR      r0,[r1,#0x24]
;;;784    }
0002d0  4770              BX       lr
;;;785    
                          ENDP

                  ADC1_ClearOutOfRangeFlag PROC
;;;790      */
;;;791    void ADC1_ClearOutOfRangeFlag(void)
0002d2  482f              LDR      r0,|L1.912|
;;;792    {
;;;793      MDR_ADC->ADC1_STATUS &= ~ADCx_FLAG_OUT_OF_RANGE;
0002d4  6a00              LDR      r0,[r0,#0x20]
0002d6  f0200002          BIC      r0,r0,#2
0002da  492d              LDR      r1,|L1.912|
0002dc  6208              STR      r0,[r1,#0x20]
;;;794    }
0002de  4770              BX       lr
;;;795    
                          ENDP

                  ADC2_ClearOutOfRangeFlag PROC
;;;800      */
;;;801    void ADC2_ClearOutOfRangeFlag(void)
0002e0  482b              LDR      r0,|L1.912|
;;;802    {
;;;803      MDR_ADC->ADC2_STATUS &= ~ADCx_FLAG_OUT_OF_RANGE;
0002e2  6a40              LDR      r0,[r0,#0x24]
0002e4  f0200002          BIC      r0,r0,#2
0002e8  4929              LDR      r1,|L1.912|
0002ea  6248              STR      r0,[r1,#0x24]
;;;804    }
0002ec  4770              BX       lr
;;;805    
                          ENDP

                  ADC_ITConfig PROC
;;;817      */
;;;818    void ADC_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
0002ee  b530              PUSH     {r4,r5,lr}
;;;819    {
0002f0  4603              MOV      r3,r0
0002f2  460c              MOV      r4,r1
;;;820      uint32_t tmpreg_ADC1_IE;
;;;821      uint32_t tmpreg_ADC2_IE;
;;;822      uint32_t tmpreg_ADC_IT;
;;;823    
;;;824      /* Check the parameters */
;;;825      assert_param(IS_ADC_CONFIG_IT(ADC_IT));
;;;826      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;827    
;;;828      tmpreg_ADC1_IE = MDR_ADC->ADC1_STATUS;
0002f4  4d26              LDR      r5,|L1.912|
0002f6  6a29              LDR      r1,[r5,#0x20]
;;;829      tmpreg_ADC2_IE = MDR_ADC->ADC2_STATUS;
0002f8  6a6a              LDR      r2,[r5,#0x24]
;;;830      tmpreg_ADC_IT = ADC_IT << 2;
0002fa  0098              LSLS     r0,r3,#2
;;;831    
;;;832      /* Form new value */
;;;833      if (NewState != DISABLE)
0002fc  b124              CBZ      r4,|L1.776|
;;;834      {
;;;835        /* Enable the ADC Interrupt requests by setting bits in the ADCx_STATUS registers */
;;;836        tmpreg_ADC1_IE |= tmpreg_ADC_IT & 0xFFFF;
0002fe  b285              UXTH     r5,r0
000300  4329              ORRS     r1,r1,r5
;;;837        tmpreg_ADC2_IE |= tmpreg_ADC_IT >> 16;
000302  ea424210          ORR      r2,r2,r0,LSR #16
000306  e003              B        |L1.784|
                  |L1.776|
;;;838      }
;;;839      else
;;;840      {
;;;841        /* Disable the ADC Interrupt requests by clearing bits in the ADCx_STATUS registers */
;;;842        tmpreg_ADC1_IE &= ~(tmpreg_ADC_IT & 0xFFFF);
000308  b285              UXTH     r5,r0
00030a  43a9              BICS     r1,r1,r5
;;;843        tmpreg_ADC2_IE &= ~(tmpreg_ADC_IT >> 16);
00030c  ea224210          BIC      r2,r2,r0,LSR #16
                  |L1.784|
;;;844      }
;;;845    
;;;846      /* Configure ADCx_STATUS registers with new value */
;;;847      MDR_ADC->ADC1_STATUS = tmpreg_ADC1_IE;
000310  4d1f              LDR      r5,|L1.912|
000312  6229              STR      r1,[r5,#0x20]
;;;848      MDR_ADC->ADC2_STATUS = tmpreg_ADC2_IE;
000314  626a              STR      r2,[r5,#0x24]
;;;849    }
000316  bd30              POP      {r4,r5,pc}
;;;850    
                          ENDP

                  ADC1_ITConfig PROC
;;;860      */
;;;861    void ADC1_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
000318  460a              MOV      r2,r1
;;;862    {
;;;863      uint32_t tmpreg_ADC1_IE;
;;;864    
;;;865      /* Check the parameters */
;;;866      assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;867      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;868    
;;;869      tmpreg_ADC1_IE = MDR_ADC->ADC1_STATUS;
00031a  4b1d              LDR      r3,|L1.912|
00031c  6a19              LDR      r1,[r3,#0x20]
;;;870    
;;;871      /* Form new value */
;;;872      if (NewState != DISABLE)
00031e  b112              CBZ      r2,|L1.806|
;;;873      {
;;;874        /* Enable the ADC Interrupt requests by setting bits in the ADC1_STATUS register */
;;;875        tmpreg_ADC1_IE |= (ADC_IT << 2);
000320  ea410180          ORR      r1,r1,r0,LSL #2
000324  e001              B        |L1.810|
                  |L1.806|
;;;876      }
;;;877      else
;;;878      {
;;;879        /* Disable the ADC Interrupt requests by clearing bits in the ADC1_STATUS register */
;;;880        tmpreg_ADC1_IE &= ~(ADC_IT << 2);
000326  ea210180          BIC      r1,r1,r0,LSL #2
                  |L1.810|
;;;881      }
;;;882    
;;;883      /* Configure ADC1_STATUS registers with new value */
;;;884      MDR_ADC->ADC1_STATUS = tmpreg_ADC1_IE;
00032a  4b19              LDR      r3,|L1.912|
00032c  6219              STR      r1,[r3,#0x20]
;;;885    }
00032e  4770              BX       lr
;;;886    
                          ENDP

                  ADC2_ITConfig PROC
;;;896      */
;;;897    void ADC2_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
000330  460a              MOV      r2,r1
;;;898    {
;;;899      uint32_t tmpreg_ADC2_IE;
;;;900    
;;;901      /* Check the parameters */
;;;902      assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;903      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;904    
;;;905      tmpreg_ADC2_IE = MDR_ADC->ADC2_STATUS;
000332  4b17              LDR      r3,|L1.912|
000334  6a59              LDR      r1,[r3,#0x24]
;;;906    
;;;907      /* Form new value */
;;;908      if (NewState != DISABLE)
000336  b112              CBZ      r2,|L1.830|
;;;909      {
;;;910        /* Enable the ADC Interrupt requests by setting bits in the ADC2_STATUS register */
;;;911        tmpreg_ADC2_IE |= (ADC_IT << 2);
000338  ea410180          ORR      r1,r1,r0,LSL #2
00033c  e001              B        |L1.834|
                  |L1.830|
;;;912      }
;;;913      else
;;;914      {
;;;915        /* Disable the ADC Interrupt requests by clearing bits in the ADC2_STATUS register */
;;;916        tmpreg_ADC2_IE &= ~(ADC_IT << 2);
00033e  ea210180          BIC      r1,r1,r0,LSL #2
                  |L1.834|
;;;917      }
;;;918    
;;;919      /* Configure ADC2_STATUS registers with new value */
;;;920      MDR_ADC->ADC2_STATUS = tmpreg_ADC2_IE;
000342  4b13              LDR      r3,|L1.912|
000344  6259              STR      r1,[r3,#0x24]
;;;921    }
000346  4770              BX       lr
;;;922    
                          ENDP

                  ADC_GetITStatus PROC
;;;932      */
;;;933    ITStatus ADC_GetITStatus(uint32_t ADC_IT)
000348  b510              PUSH     {r4,lr}
;;;934    {
00034a  4604              MOV      r4,r0
;;;935      ITStatus bitstatus;
;;;936      uint32_t tmpreg;
;;;937    
;;;938      /* Check the parameters */
;;;939      assert_param(IS_ADC_CONFIG_IT(ADC_IT));
;;;940    
;;;941      tmpreg = ADC_GetStatus();
00034c  f7fffffe          BL       ADC_GetStatus
000350  4603              MOV      r3,r0
;;;942      tmpreg &= (tmpreg >> 2) & ADC_IT;
000352  ea040093          AND      r0,r4,r3,LSR #2
000356  4003              ANDS     r3,r3,r0
;;;943    
;;;944      if (tmpreg == 0)
000358  b90b              CBNZ     r3,|L1.862|
;;;945      {
;;;946        bitstatus = RESET;
00035a  2200              MOVS     r2,#0
00035c  e000              B        |L1.864|
                  |L1.862|
;;;947      }
;;;948      else
;;;949      {
;;;950        bitstatus = SET;
00035e  2201              MOVS     r2,#1
                  |L1.864|
;;;951      }
;;;952    
;;;953      return bitstatus;
000360  4610              MOV      r0,r2
;;;954    }
000362  bd10              POP      {r4,pc}
;;;955    
                          ENDP

                  ADC1_GetITStatus PROC
;;;963      */
;;;964    ITStatus ADC1_GetITStatus(uint32_t ADC_IT)
000364  4602              MOV      r2,r0
;;;965    {
;;;966      ITStatus bitstatus;
;;;967      uint32_t tmpreg;
;;;968    
;;;969      /* Check the parameters */
;;;970      assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;971    
;;;972      tmpreg = MDR_ADC->ADC1_STATUS;
000366  4b0a              LDR      r3,|L1.912|
000368  6a19              LDR      r1,[r3,#0x20]
;;;973      tmpreg &= (tmpreg >> 2) & ADC_IT;
00036a  ea020391          AND      r3,r2,r1,LSR #2
00036e  4019              ANDS     r1,r1,r3
;;;974    
;;;975      if (tmpreg == 0)
000370  b909              CBNZ     r1,|L1.886|
;;;976      {
;;;977        bitstatus = RESET;
000372  2000              MOVS     r0,#0
000374  e000              B        |L1.888|
                  |L1.886|
;;;978      }
;;;979      else
;;;980      {
;;;981        bitstatus = SET;
000376  2001              MOVS     r0,#1
                  |L1.888|
;;;982      }
;;;983    
;;;984      return bitstatus;
;;;985    }
000378  4770              BX       lr
;;;986    
                          ENDP

                  ADC2_GetITStatus PROC
;;;994      */
;;;995    ITStatus ADC2_GetITStatus(uint32_t ADC_IT)
00037a  4602              MOV      r2,r0
;;;996    {
;;;997      ITStatus bitstatus;
;;;998      uint32_t tmpreg;
;;;999    
;;;1000     /* Check the parameters */
;;;1001     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1002   
;;;1003     tmpreg = MDR_ADC->ADC2_STATUS;
00037c  4b04              LDR      r3,|L1.912|
00037e  6a59              LDR      r1,[r3,#0x24]
;;;1004     tmpreg &= (tmpreg >> 2) & ADC_IT;
000380  ea020391          AND      r3,r2,r1,LSR #2
000384  4019              ANDS     r1,r1,r3
;;;1005   
;;;1006     if (tmpreg == 0)
000386  b909              CBNZ     r1,|L1.908|
;;;1007     {
;;;1008       bitstatus = RESET;
000388  2000              MOVS     r0,#0
00038a  e000              B        |L1.910|
                  |L1.908|
;;;1009     }
;;;1010     else
;;;1011     {
;;;1012       bitstatus = SET;
00038c  2001              MOVS     r0,#1
                  |L1.910|
;;;1013     }
;;;1014   
;;;1015     return bitstatus;
;;;1016   }
00038e  4770              BX       lr
;;;1017   
                          ENDP

                  |L1.912|
                          DCD      0x40088000
                  |L1.916|
                          DCD      0xf1ff0000
                  |L1.920|
                          DCD      0xf1fb0003

;*** Start embedded assembler ***

#line 1 "..\\Library\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_adc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REVSH|
#line 130
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
