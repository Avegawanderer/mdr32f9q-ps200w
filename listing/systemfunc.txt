; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\systemfunc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\systemfunc.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\systemfunc.crf src\systemfunc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Setup_CPU_Clock PROC
;;;43     //-----------------------------------------------------------------//
;;;44     void Setup_CPU_Clock(void)
000000  b510              PUSH     {r4,lr}
;;;45     {
;;;46     	// Enable HSE
;;;47     	RST_CLK_HSEconfig(RST_CLK_HSE_ON);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       RST_CLK_HSEconfig
;;;48     	if (RST_CLK_HSEstatus() != SUCCESS)
000008  f7fffffe          BL       RST_CLK_HSEstatus
00000c  2801              CMP      r0,#1
00000e  d000              BEQ      |L1.18|
                  |L1.16|
;;;49     	{
;;;50     		while (1) {}	// Trap
000010  e7fe              B        |L1.16|
                  |L1.18|
;;;51     	}
;;;52     	
;;;53     	//-------------------------------//
;;;54     	// Setup CPU PLL and CPU_C1_SEL
;;;55     	// CPU_C1 = HSE,	PLL = x8
;;;56     	RST_CLK_CPU_PLLconfig(RST_CLK_CPU_PLLsrcHSEdiv1, RST_CLK_CPU_PLLmul8);
000012  2107              MOVS     r1,#7
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       RST_CLK_CPU_PLLconfig
;;;57     	RST_CLK_CPU_PLLcmd(ENABLE);
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       RST_CLK_CPU_PLLcmd
;;;58     	if (RST_CLK_CPU_PLLstatus() != SUCCESS)
000020  f7fffffe          BL       RST_CLK_CPU_PLLstatus
000024  2801              CMP      r0,#1
000026  d000              BEQ      |L1.42|
                  |L1.40|
;;;59     	{
;;;60     		while (1) {}	// Trap
000028  e7fe              B        |L1.40|
                  |L1.42|
;;;61     	}
;;;62     	// Setup CPU_C2 and CPU_C3
;;;63     	// CPU_C3 = CPU_C2
;;;64     	RST_CLK_CPUclkPrescaler(RST_CLK_CPUclkDIV1);
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       RST_CLK_CPUclkPrescaler
;;;65     	// CPU_C2 = CPU PLL output
;;;66     	RST_CLK_CPU_PLLuse(ENABLE);
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       RST_CLK_CPU_PLLuse
;;;67     	// Switch to CPU_C3
;;;68     	// HCLK = CPU_C3
;;;69     	RST_CLK_CPUclkSelection(RST_CLK_CPUclkCPU_C3);
000036  f44f7080          MOV      r0,#0x100
00003a  f7fffffe          BL       RST_CLK_CPUclkSelection
;;;70     	
;;;71     	//-------------------------------//
;;;72     	// Setup ADC clock
;;;73     	// ADC_C2 = CPU_C1
;;;74     	RST_CLK_ADCclkSelection(RST_CLK_ADCclkCPU_C1);
00003e  2020              MOVS     r0,#0x20
000040  f7fffffe          BL       RST_CLK_ADCclkSelection
;;;75     	// ADC_C3 = ADC_C2
;;;76     	RST_CLK_ADCclkPrescaler(RST_CLK_ADCclkDIV1);
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       RST_CLK_ADCclkPrescaler
;;;77     	// Enable ADC_CLK
;;;78     	RST_CLK_ADCclkEnable(ENABLE);
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       RST_CLK_ADCclkEnable
;;;79     	
;;;80     	// Update system clock variable
;;;81     	SystemCoreClockUpdate();
000050  f7fffffe          BL       SystemCoreClockUpdate
;;;82     	
;;;83     	// Enable clock on all ports (macro are defined in systemfunc.h)
;;;84     	RST_CLK_PCLKcmd(ALL_PORTS_CLK, ENABLE);
000054  2101              MOVS     r1,#1
000056  48fe              LDR      r0,|L1.1104|
000058  f7fffffe          BL       RST_CLK_PCLKcmd
;;;85     	// Enable clock on peripheral blocks used in design
;;;86     	RST_CLK_PCLKcmd(PERIPHERALS_CLK ,ENABLE);
00005c  e8bd4010          POP      {r4,lr}
000060  2101              MOVS     r1,#1
000062  48fc              LDR      r0,|L1.1108|
000064  f7ffbffe          B.W      RST_CLK_PCLKcmd
;;;87     }
;;;88     
                          ENDP

                  HW_PortInit PROC
;;;93     //-----------------------------------------------------------------//
;;;94     void HW_PortInit(void)
000068  e92d4ffe          PUSH     {r1-r11,lr}
;;;95     {
;;;96     	PORT_InitTypeDef PORT_InitStructure;
;;;97       
;;;98     	
;;;99     	PORT_DeInit(MDR_PORTA);
00006c  f8dfb3e8          LDR      r11,|L1.1112|
000070  4658              MOV      r0,r11
000072  f7fffffe          BL       PORT_DeInit
;;;100    	PORT_DeInit(MDR_PORTB);
000076  48f9              LDR      r0,|L1.1116|
000078  f7fffffe          BL       PORT_DeInit
;;;101    	PORT_DeInit(MDR_PORTC);
00007c  48f8              LDR      r0,|L1.1120|
00007e  f7fffffe          BL       PORT_DeInit
;;;102    	PORT_DeInit(MDR_PORTD);
000082  48f8              LDR      r0,|L1.1124|
000084  f7fffffe          BL       PORT_DeInit
;;;103    	PORT_DeInit(MDR_PORTE);
000088  48f7              LDR      r0,|L1.1128|
00008a  f7fffffe          BL       PORT_DeInit
;;;104    	PORT_DeInit(MDR_PORTF);
00008e  48f7              LDR      r0,|L1.1132|
000090  f7fffffe          BL       PORT_DeInit
;;;105    	
;;;106    	// default output value is 0
;;;107    	// Set some outputs the default design values of 1
;;;108    	//PORT_SetBits(MDR_PORTA, (1<<BUZ1) | (1<<BUZ2) );
;;;109    	PORT_SetBits(MDR_PORTB, (1<<LGREEN) | (1<<LRED) );
000094  21c0              MOVS     r1,#0xc0
000096  48f1              LDR      r0,|L1.1116|
000098  f7fffffe          BL       PORT_SetBits
;;;110    	
;;;111    	/*
;;;112    	   Reset PORT initialization structure parameters values 
;;;113      PORT_InitStruct->PORT_Pin        = PORT_Pin_All;
;;;114      PORT_InitStruct->PORT_OE         = PORT_OE_IN;
;;;115      PORT_InitStruct->PORT_PULL_UP    = PORT_PULL_UP_OFF;
;;;116      PORT_InitStruct->PORT_PULL_DOWN  = PORT_PULL_DOWN_OFF;
;;;117      PORT_InitStruct->PORT_PD_SHM     = PORT_PD_SHM_OFF;
;;;118      PORT_InitStruct->PORT_PD         = PORT_PD_DRIVER;
;;;119      PORT_InitStruct->PORT_GFEN       = PORT_GFEN_OFF;
;;;120      PORT_InitStruct->PORT_FUNC       = PORT_FUNC_PORT;
;;;121      PORT_InitStruct->PORT_SPEED      = PORT_OUTPUT_OFF;
;;;122      PORT_InitStruct->PORT_MODE       = PORT_MODE_ANALOG;
;;;123    	*/
;;;124    	
;;;125    	//================= PORTA =================//
;;;126    	PORT_StructInit(&PORT_InitStructure);
00009c  4668              MOV      r0,sp
00009e  f7fffffe          BL       PORT_StructInit
;;;127    	
;;;128    	// Typical digital inputs:
;;;129    	PORT_InitStructure.PORT_Pin   = (1<<OVERLD) | (1<<ENC_BTN);
0000a2  2021              MOVS     r0,#0x21
0000a4  f8ad0000          STRH     r0,[sp,#0]
;;;130    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
0000a8  2401              MOVS     r4,#1
0000aa  f88d400a          STRB     r4,[sp,#0xa]
;;;131    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0000ae  4669              MOV      r1,sp
0000b0  4658              MOV      r0,r11
0000b2  f7fffffe          BL       PORT_Init
;;;132    	
;;;133    	// Digital input with pull-up
;;;134    	PORT_InitStructure.PORT_Pin   = (1<<EEN);
0000b6  f04f0904          MOV      r9,#4
0000ba  f8ad9000          STRH     r9,[sp,#0]
;;;135    	PORT_InitStructure.PORT_PULL_UP  = PORT_PULL_UP_ON;
0000be  f88d4003          STRB     r4,[sp,#3]
;;;136    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0000c2  4669              MOV      r1,sp
0000c4  4658              MOV      r0,r11
0000c6  f7fffffe          BL       PORT_Init
;;;137    	
;;;138    	// Typical digital outputs:
;;;139    	PORT_InitStructure.PORT_Pin   = (1<<CLIM_SEL);
0000ca  2502              MOVS     r5,#2
0000cc  f8ad5000          STRH     r5,[sp,#0]
;;;140    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
0000d0  f88d4002          STRB     r4,[sp,#2]
;;;141    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
0000d4  f88d4009          STRB     r4,[sp,#9]
;;;142    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0000d8  4669              MOV      r1,sp
0000da  4658              MOV      r0,r11
0000dc  f7fffffe          BL       PORT_Init
;;;143    	
;;;144    	// Timer outputs to buzzer (TMR1.CH2, TMR1.CH2N)
;;;145    	PORT_InitStructure.PORT_Pin   = (1<<BUZ1) | (1<<BUZ2);
0000e0  2018              MOVS     r0,#0x18
0000e2  f8ad0000          STRH     r0,[sp,#0]
;;;146    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
0000e6  f88d5008          STRB     r5,[sp,#8]
;;;147    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0000ea  4669              MOV      r1,sp
0000ec  4658              MOV      r0,r11
0000ee  f7fffffe          BL       PORT_Init
;;;148    	
;;;149    	// USART1 pins	
;;;150    	PORT_StructInit(&PORT_InitStructure);
0000f2  4668              MOV      r0,sp
0000f4  f7fffffe          BL       PORT_StructInit
;;;151    	// TX pin
;;;152    	PORT_InitStructure.PORT_Pin   = 1<<TXD1;
0000f8  f04f0a80          MOV      r10,#0x80
0000fc  f8ada000          STRH     r10,[sp,#0]
;;;153    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
000100  f88d400a          STRB     r4,[sp,#0xa]
;;;154    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
000104  f88d5009          STRB     r5,[sp,#9]
;;;155    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_OVERRID;
000108  2603              MOVS     r6,#3
00010a  f88d6008          STRB     r6,[sp,#8]
;;;156    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
00010e  f88d4002          STRB     r4,[sp,#2]
;;;157    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
000112  4669              MOV      r1,sp
000114  4658              MOV      r0,r11
000116  f7fffffe          BL       PORT_Init
;;;158    	// RX pin
;;;159    	PORT_InitStructure.PORT_Pin   = 1<<RXD1;
00011a  2740              MOVS     r7,#0x40
00011c  f8ad7000          STRH     r7,[sp,#0]
;;;160    	PORT_InitStructure.PORT_OE    = PORT_OE_IN;
000120  f04f0800          MOV      r8,#0
000124  f88d8002          STRB     r8,[sp,#2]
;;;161    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
000128  4669              MOV      r1,sp
00012a  4658              MOV      r0,r11
00012c  f7fffffe          BL       PORT_Init
;;;162    	
;;;163    	// debug
;;;164    /*	PORT_StructInit(&PORT_InitStructure);
;;;165    	PORT_InitStructure.PORT_Pin   = (1<<TXD1) | (1<<RXD1);
;;;166    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
;;;167    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
;;;168    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
;;;169    	PORT_Init(MDR_PORTA, &PORT_InitStructure); */
;;;170    
;;;171    	//================= PORTB =================//
;;;172    	PORT_StructInit(&PORT_InitStructure);
000130  4668              MOV      r0,sp
000132  f7fffffe          BL       PORT_StructInit
;;;173    	
;;;174    	// Typical digital inputs: buttons and encoder
;;;175    	PORT_InitStructure.PORT_Pin   = (1<<SB_ESC) | (1<<SB_LEFT) | (1<<SB_RIGHT) | (1<<SB_OK) | (1<<SB_MODE) | (1<<ENCA) | (1<<ENCB) | (1<<PG) ;
000136  f2407037          MOV      r0,#0x737
00013a  f8ad0000          STRH     r0,[sp,#0]
;;;176    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
00013e  f88d400a          STRB     r4,[sp,#0xa]
;;;177    	PORT_Init(MDR_PORTB, &PORT_InitStructure);
000142  4669              MOV      r1,sp
000144  48c5              LDR      r0,|L1.1116|
000146  f7fffffe          BL       PORT_Init
;;;178    	
;;;179    	// Power good 
;;;180    	// TODO: add interrupt
;;;181    	PORT_InitStructure.PORT_Pin   = (1<<PG) ;
00014a  02a0              LSLS     r0,r4,#10
00014c  f8ad0000          STRH     r0,[sp,#0]
;;;182    	PORT_Init(MDR_PORTB, &PORT_InitStructure);
000150  4669              MOV      r1,sp
000152  48c2              LDR      r0,|L1.1116|
000154  f7fffffe          BL       PORT_Init
;;;183    	
;;;184    	// Leds and buttons SB_ON, SB_OFF
;;;185    	PORT_InitStructure.PORT_Pin   = (1<<LGREEN) | (1<<LRED);
000158  20c0              MOVS     r0,#0xc0
00015a  f8ad0000          STRH     r0,[sp,#0]
;;;186    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
00015e  f88d4002          STRB     r4,[sp,#2]
;;;187    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
000162  f88d4009          STRB     r4,[sp,#9]
;;;188    	PORT_Init(MDR_PORTB, &PORT_InitStructure);
000166  4669              MOV      r1,sp
000168  48bc              LDR      r0,|L1.1116|
00016a  f7fffffe          BL       PORT_Init
;;;189    
;;;190    	
;;;191    	//================= PORTC =================//
;;;192    	PORT_StructInit(&PORT_InitStructure);
00016e  4668              MOV      r0,sp
000170  f7fffffe          BL       PORT_StructInit
;;;193    	
;;;194    	// LCD Backlight (TMR3.CH1)
;;;195    	PORT_InitStructure.PORT_Pin   = (1<<LCD_BL);
000174  f8ad9000          STRH     r9,[sp,#0]
;;;196    	PORT_InitStructure.PORT_MODE = PORT_MODE_DIGITAL;
000178  f88d400a          STRB     r4,[sp,#0xa]
;;;197    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
00017c  f88d5008          STRB     r5,[sp,#8]
;;;198    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
000180  f88d4009          STRB     r4,[sp,#9]
;;;199    	PORT_Init(MDR_PORTC, &PORT_InitStructure);
000184  4669              MOV      r1,sp
000186  48b6              LDR      r0,|L1.1120|
000188  f7fffffe          BL       PORT_Init
;;;200    	
;;;201    	// I2C
;;;202    	PORT_InitStructure.PORT_Pin = (1<<SCL) | (1<<SDA);
00018c  f8ad6000          STRH     r6,[sp,#0]
;;;203    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
000190  f88d5009          STRB     r5,[sp,#9]
;;;204    	PORT_Init(MDR_PORTC, &PORT_InitStructure);
000194  4669              MOV      r1,sp
000196  48b2              LDR      r0,|L1.1120|
000198  f7fffffe          BL       PORT_Init
;;;205    	
;;;206    	
;;;207    	//================= PORTD =================//
;;;208    	PORT_StructInit(&PORT_InitStructure);
00019c  4668              MOV      r0,sp
00019e  f7fffffe          BL       PORT_StructInit
;;;209    	
;;;210    	// Analog functions
;;;211    	PORT_InitStructure.PORT_Pin   = (1<<VREF_P) | (1<<VREF_N) | (1<<TEMP_IN) | (1<<UADC) | (1<<IADC) ;
0001a2  2097              MOVS     r0,#0x97
0001a4  f8ad0000          STRH     r0,[sp,#0]
;;;212    	PORT_Init(MDR_PORTD, &PORT_InitStructure);
0001a8  4669              MOV      r1,sp
0001aa  48ae              LDR      r0,|L1.1124|
0001ac  f7fffffe          BL       PORT_Init
;;;213    	
;;;214    	// LCD CLK and CS
;;;215    	PORT_InitStructure.PORT_Pin   = (1<<LCD_CLK) | (1<<LCD_CS) ;
0001b0  2028              MOVS     r0,#0x28
0001b2  f8ad0000          STRH     r0,[sp,#0]
;;;216    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
0001b6  f88d400a          STRB     r4,[sp,#0xa]
;;;217    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
0001ba  f88d5008          STRB     r5,[sp,#8]
;;;218    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
0001be  f88d5009          STRB     r5,[sp,#9]
;;;219    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
0001c2  f88d4002          STRB     r4,[sp,#2]
;;;220    	PORT_Init(MDR_PORTD, &PORT_InitStructure);
0001c6  4669              MOV      r1,sp
0001c8  48a6              LDR      r0,|L1.1124|
0001ca  f7fffffe          BL       PORT_Init
;;;221    	
;;;222    	// MOSI 
;;;223    	PORT_InitStructure.PORT_Pin   = (1<<LCD_MOSI);
0001ce  f8ad7000          STRH     r7,[sp,#0]
;;;224    	PORT_InitStructure.PORT_PULL_DOWN = PORT_PULL_DOWN_ON;
0001d2  f88d4004          STRB     r4,[sp,#4]
;;;225    	PORT_Init(MDR_PORTD, &PORT_InitStructure);
0001d6  4669              MOV      r1,sp
0001d8  48a2              LDR      r0,|L1.1124|
0001da  f7fffffe          BL       PORT_Init
;;;226    	
;;;227    
;;;228    	
;;;229    	//================= PORTE =================//
;;;230    	PORT_StructInit(&PORT_InitStructure);
0001de  4668              MOV      r0,sp
0001e0  f7fffffe          BL       PORT_StructInit
;;;231    			
;;;232    	// LCD RST and SEL, Load disable output
;;;233    	PORT_InitStructure.PORT_Pin   = (1<<LCD_RST) | (1<<LCD_SEL) | (1<<LDIS);
0001e4  2045              MOVS     r0,#0x45
0001e6  f8ad0000          STRH     r0,[sp,#0]
;;;234    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
0001ea  f88d400a          STRB     r4,[sp,#0xa]
;;;235    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
0001ee  f88d5009          STRB     r5,[sp,#9]
;;;236    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
0001f2  f88d4002          STRB     r4,[sp,#2]
;;;237    	PORT_Init(MDR_PORTE, &PORT_InitStructure);
0001f6  4669              MOV      r1,sp
0001f8  489b              LDR      r0,|L1.1128|
0001fa  f7fffffe          BL       PORT_Init
;;;238    
;;;239    	// cooler PWM output (TMR3.CH3N)
;;;240    	PORT_InitStructure.PORT_Pin   = (1<<CPWM);
0001fe  f8ada000          STRH     r10,[sp,#0]
;;;241    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_OVERRID;
000202  f88d6008          STRB     r6,[sp,#8]
;;;242    	PORT_Init(MDR_PORTE, &PORT_InitStructure);
000206  4669              MOV      r1,sp
000208  4897              LDR      r0,|L1.1128|
00020a  f7fffffe          BL       PORT_Init
;;;243    	
;;;244    	// voltage and current PWM outputs (TMR2.CH1N, TMR2.CH3N)
;;;245    	PORT_InitStructure.PORT_Pin   = (1<<UPWM) | (1<<IPWM);
00020e  200a              MOVS     r0,#0xa
000210  f8ad0000          STRH     r0,[sp,#0]
;;;246    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
000214  f88d5008          STRB     r5,[sp,#8]
;;;247    	PORT_Init(MDR_PORTE, &PORT_InitStructure);
000218  4669              MOV      r1,sp
00021a  4893              LDR      r0,|L1.1128|
00021c  f7fffffe          BL       PORT_Init
;;;248    	
;;;249    	
;;;250    	
;;;251    	//================= PORTF =================//
;;;252    	PORT_StructInit(&PORT_InitStructure);
000220  4668              MOV      r0,sp
000222  f7fffffe          BL       PORT_StructInit
;;;253    	
;;;254    	// Feedback channel select, converter enable
;;;255    	PORT_InitStructure.PORT_Pin   = (1<<EN) | (1<<STAB_SEL) ;
000226  200c              MOVS     r0,#0xc
000228  f8ad0000          STRH     r0,[sp,#0]
;;;256    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
00022c  f88d400a          STRB     r4,[sp,#0xa]
;;;257    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
000230  f88d4009          STRB     r4,[sp,#9]
;;;258    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
000234  f88d4002          STRB     r4,[sp,#2]
;;;259    	PORT_Init(MDR_PORTF, &PORT_InitStructure);
000238  4669              MOV      r1,sp
00023a  488c              LDR      r0,|L1.1132|
00023c  f7fffffe          BL       PORT_Init
;;;260    	
;;;261    	// USART2 functions	
;;;262    	PORT_StructInit(&PORT_InitStructure);
000240  4668              MOV      r0,sp
000242  f7fffffe          BL       PORT_StructInit
;;;263    	// TX pin
;;;264    	PORT_InitStructure.PORT_Pin   = 1<<TXD2;
000246  f8ad5000          STRH     r5,[sp,#0]
;;;265    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
00024a  f88d400a          STRB     r4,[sp,#0xa]
;;;266    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
00024e  f88d5009          STRB     r5,[sp,#9]
;;;267    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_OVERRID;
000252  f88d6008          STRB     r6,[sp,#8]
;;;268    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
000256  f88d4002          STRB     r4,[sp,#2]
;;;269    	PORT_Init(MDR_PORTF, &PORT_InitStructure);
00025a  4669              MOV      r1,sp
00025c  4883              LDR      r0,|L1.1132|
00025e  f7fffffe          BL       PORT_Init
;;;270    	// RX pin
;;;271    	PORT_InitStructure.PORT_Pin   = 1<<RXD2;
000262  f8ad4000          STRH     r4,[sp,#0]
;;;272    	PORT_InitStructure.PORT_OE    = PORT_OE_IN;
000266  f88d8002          STRB     r8,[sp,#2]
;;;273    	PORT_Init(MDR_PORTF, &PORT_InitStructure);
00026a  4669              MOV      r1,sp
00026c  487f              LDR      r0,|L1.1132|
00026e  f7fffffe          BL       PORT_Init
;;;274    }
000272  e8bd8ffe          POP      {r1-r11,pc}
;;;275    
                          ENDP

                  HW_UARTInit PROC
;;;282    //-----------------------------------------------------------------//
;;;283    void HW_UARTInit(void)
000276  e92d47ff          PUSH     {r0-r10,lr}
;;;284    {
;;;285    	BaudRateStatus initStatus;
;;;286    	UART_InitTypeDef sUART;
;;;287    	UART_StructInit(&sUART);
00027a  4668              MOV      r0,sp
00027c  f7fffffe          BL       UART_StructInit
;;;288    	
;;;289    	//--------------- UART2 INIT ---------------//
;;;290    	UART_DeInit(MDR_UART2);
000280  f8df91ec          LDR      r9,|L1.1136|
000284  4648              MOV      r0,r9
000286  f7fffffe          BL       UART_DeInit
;;;291    	
;;;292    	sUART.UART_BaudRate                           = 115200;
00028a  f44f36e1          MOV      r6,#0x1c200
00028e  9600              STR      r6,[sp,#0]
;;;293    	sUART.UART_WordLength                         = UART_WordLength8b;
000290  2760              MOVS     r7,#0x60
000292  f8ad7004          STRH     r7,[sp,#4]
;;;294    	sUART.UART_StopBits                           = UART_StopBits1;
000296  2400              MOVS     r4,#0
000298  f8ad4006          STRH     r4,[sp,#6]
;;;295    	sUART.UART_Parity                             = UART_Parity_No;
00029c  f8ad4008          STRH     r4,[sp,#8]
;;;296    	sUART.UART_FIFOMode                           = UART_FIFO_ON;
0002a0  2510              MOVS     r5,#0x10
0002a2  f8ad500a          STRH     r5,[sp,#0xa]
;;;297    	sUART.UART_HardwareFlowControl                = (UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE );
0002a6  f44f7840          MOV      r8,#0x300
0002aa  f8ad800c          STRH     r8,[sp,#0xc]
;;;298    	
;;;299    	UART_BRGInit(MDR_UART2,UART_HCLKdiv1);
0002ae  2100              MOVS     r1,#0
0002b0  4648              MOV      r0,r9
0002b2  f7fffffe          BL       UART_BRGInit
;;;300    	initStatus = UART_Init(MDR_UART2,&sUART);
0002b6  4669              MOV      r1,sp
0002b8  4648              MOV      r0,r9
0002ba  f7fffffe          BL       UART_Init
;;;301    	UART_Cmd(MDR_UART2,ENABLE);
0002be  2101              MOVS     r1,#1
0002c0  4648              MOV      r0,r9
0002c2  f7fffffe          BL       UART_Cmd
;;;302    	
;;;303    	//--------------- UART1 INIT ---------------//
;;;304    	UART_DeInit(MDR_UART1);
0002c6  f8df91ac          LDR      r9,|L1.1140|
0002ca  4648              MOV      r0,r9
0002cc  f7fffffe          BL       UART_DeInit
;;;305    	
;;;306    	sUART.UART_BaudRate                           = 115200;
0002d0  9600              STR      r6,[sp,#0]
;;;307    	sUART.UART_WordLength                         = UART_WordLength8b;
0002d2  f8ad7004          STRH     r7,[sp,#4]
;;;308    	sUART.UART_StopBits                           = UART_StopBits1;
0002d6  f8ad4006          STRH     r4,[sp,#6]
;;;309    	sUART.UART_Parity                             = UART_Parity_No;
0002da  f8ad4008          STRH     r4,[sp,#8]
;;;310    	sUART.UART_FIFOMode                           = UART_FIFO_ON;
0002de  f8ad500a          STRH     r5,[sp,#0xa]
;;;311    	sUART.UART_HardwareFlowControl                = (UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE );
0002e2  f8ad800c          STRH     r8,[sp,#0xc]
;;;312    	
;;;313    	UART_BRGInit(MDR_UART1,UART_HCLKdiv1);
0002e6  2100              MOVS     r1,#0
0002e8  4648              MOV      r0,r9
0002ea  f7fffffe          BL       UART_BRGInit
;;;314    	initStatus = UART_Init(MDR_UART1,&sUART);
0002ee  4669              MOV      r1,sp
0002f0  4648              MOV      r0,r9
0002f2  f7fffffe          BL       UART_Init
;;;315    	UART_Cmd(MDR_UART1,ENABLE);
0002f6  2101              MOVS     r1,#1
0002f8  4648              MOV      r0,r9
0002fa  f7fffffe          BL       UART_Cmd
;;;316    	
;;;317    	//------------ UART DMA features------------//
;;;318    	//UART_DMAConfig(MDR_UART1,UART_IT_FIFO_LVL_8words,UART_IT_FIFO_LVL_8words);		// ?
;;;319    	//UART_DMAConfig(MDR_UART2,UART_IT_FIFO_LVL_8words,UART_IT_FIFO_LVL_8words);		//
;;;320    	
;;;321    	/* Enable UART1 DMA Rx and Tx request */
;;;322    	//UART_DMACmd(MDR_UART1,(UART_DMA_RXE | UART_DMA_TXE), ENABLE);
;;;323    	/* Enable UART2 DMA Rx and Tx request */
;;;324    	//UART_DMACmd(MDR_UART2,(UART_DMA_RXE | UART_DMA_TXE), ENABLE);
;;;325    }
0002fe  e8bd87ff          POP      {r0-r10,pc}
;;;326    
                          ENDP

                  HW_DMAInit PROC
;;;330    //-----------------------------------------------------------------//
;;;331    void HW_DMAInit(void)
000302  f7ffbffe          B.W      DMA_DeInit
;;;332    {
;;;333    	// Reset all DMA settings
;;;334    	DMA_DeInit();	
;;;335    	
;;;336    	/*
;;;337    		NVIC_EnableIRQ(DMA_IRQn);
;;;338    	
;;;339    	
;;;340    	*/
;;;341    }
;;;342    
                          ENDP

                  HW_SSPInit PROC
;;;351    //-----------------------------------------------------------------//
;;;352    void HW_SSPInit(void)
000306  b51f              PUSH     {r0-r4,lr}
;;;353    {
;;;354    	SSP_InitTypeDef sSSP;
;;;355    	SSP_StructInit (&sSSP);
000308  4668              MOV      r0,sp
00030a  f7fffffe          BL       SSP_StructInit
;;;356    
;;;357    	SSP_BRGInit(MDR_SSP2,SSP_HCLKdiv1);		// F_SSPCLK = HCLK / 1
00030e  4c5a              LDR      r4,|L1.1144|
000310  2100              MOVS     r1,#0
000312  4620              MOV      r0,r4
000314  f7fffffe          BL       SSP_BRGInit
;;;358    	
;;;359    	sSSP.SSP_SCR  = 0x04;		// 0 to 255
000318  2004              MOVS     r0,#4
00031a  f8ad0000          STRH     r0,[sp,#0]
;;;360    	sSSP.SSP_CPSDVSR = 2;		// even 2 to 254
00031e  2202              MOVS     r2,#2
000320  f8ad2002          STRH     r2,[sp,#2]
;;;361    	sSSP.SSP_Mode = SSP_ModeMaster;
000324  2100              MOVS     r1,#0
000326  f8ad1004          STRH     r1,[sp,#4]
;;;362    	sSSP.SSP_WordLength = SSP_WordLength9b;
00032a  2008              MOVS     r0,#8
00032c  f8ad0006          STRH     r0,[sp,#6]
;;;363    	sSSP.SSP_SPH = SSP_SPH_1Edge;
000330  f8ad1008          STRH     r1,[sp,#8]
;;;364    	sSSP.SSP_SPO = SSP_SPO_Low;
000334  f8ad100a          STRH     r1,[sp,#0xa]
;;;365    	sSSP.SSP_FRF = SSP_FRF_SPI_Motorola;
000338  f8ad100c          STRH     r1,[sp,#0xc]
;;;366    	sSSP.SSP_HardwareFlowControl = SSP_HardwareFlowControl_SSE;
00033c  f8ad200e          STRH     r2,[sp,#0xe]
;;;367    	SSP_Init (MDR_SSP2,&sSSP);
000340  4669              MOV      r1,sp
000342  4620              MOV      r0,r4
000344  f7fffffe          BL       SSP_Init
;;;368    
;;;369    	SSP_Cmd(MDR_SSP2, ENABLE);
000348  2101              MOVS     r1,#1
00034a  4620              MOV      r0,r4
00034c  f7fffffe          BL       SSP_Cmd
;;;370    }
000350  bd1f              POP      {r0-r4,pc}
;;;371    
                          ENDP

                  HW_I2CInit PROC
;;;376    //-----------------------------------------------------------------//
;;;377    void HW_I2CInit(void)
000352  b51c              PUSH     {r2-r4,lr}
;;;378    {
;;;379    	//--------------- I2C INIT ---------------//
;;;380    I2C_InitTypeDef I2C_InitStruct;
;;;381    	
;;;382    	// Enables I2C peripheral
;;;383    	I2C_Cmd(ENABLE);
000354  2001              MOVS     r0,#1
000356  f7fffffe          BL       I2C_Cmd
;;;384    	
;;;385    	// Initialize I2C_InitStruct
;;;386    	I2C_InitStruct.I2C_ClkDiv = 256;		// 0x0000 to 0xFFFF
00035a  f44f7080          MOV      r0,#0x100
00035e  9000              STR      r0,[sp,#0]
;;;387    	I2C_InitStruct.I2C_Speed = I2C_SPEED_UP_TO_400KHz;
000360  2000              MOVS     r0,#0
000362  9001              STR      r0,[sp,#4]
;;;388    
;;;389    	// Configure I2C parameters
;;;390    	I2C_Init(&I2C_InitStruct);
000364  4668              MOV      r0,sp
000366  f7fffffe          BL       I2C_Init
;;;391    }
00036a  bd1c              POP      {r2-r4,pc}
;;;392    
                          ENDP

                  HW_ADCInit PROC
;;;400    //-----------------------------------------------------------------//
;;;401    void HW_ADCInit(void)
00036c  b530              PUSH     {r4,r5,lr}
;;;402    {
00036e  b093              SUB      sp,sp,#0x4c
;;;403    	ADC_InitTypeDef sADC;
;;;404    	ADCx_InitTypeDef sADCx;
;;;405    	
;;;406    	// ADC Configuration
;;;407    	// Reset all ADC settings
;;;408    	ADC_DeInit();
000370  f7fffffe          BL       ADC_DeInit
;;;409    	ADC_StructInit(&sADC);
000374  a80c              ADD      r0,sp,#0x30
000376  f7fffffe          BL       ADC_StructInit
;;;410    
;;;411    	sADC.ADC_SynchronousMode      = ADC_SyncMode_Independent;
00037a  2400              MOVS     r4,#0
00037c  940c              STR      r4,[sp,#0x30]
;;;412    	sADC.ADC_StartDelay           = 10;
00037e  200a              MOVS     r0,#0xa
000380  900d              STR      r0,[sp,#0x34]
;;;413    	sADC.ADC_TempSensor           = ADC_TEMP_SENSOR_Enable;
000382  f44f3000          MOV      r0,#0x20000
000386  900e              STR      r0,[sp,#0x38]
;;;414    	sADC.ADC_TempSensorAmplifier  = ADC_TEMP_SENSOR_AMPLIFIER_Enable;
000388  0040              LSLS     r0,r0,#1
00038a  900f              STR      r0,[sp,#0x3c]
;;;415    	sADC.ADC_TempSensorConversion = ADC_TEMP_SENSOR_CONVERSION_Enable;
00038c  0040              LSLS     r0,r0,#1
00038e  9010              STR      r0,[sp,#0x40]
;;;416    	sADC.ADC_IntVRefConversion    = ADC_VREF_CONVERSION_Enable;
000390  0040              LSLS     r0,r0,#1
000392  9011              STR      r0,[sp,#0x44]
;;;417    	sADC.ADC_IntVRefTrimming      = 1;
000394  2501              MOVS     r5,#1
000396  9512              STR      r5,[sp,#0x48]
;;;418    	ADC_Init (&sADC);
000398  a80c              ADD      r0,sp,#0x30
00039a  f7fffffe          BL       ADC_Init
;;;419    
;;;420    	// ADC1 Configuration 
;;;421    	ADCx_StructInit (&sADCx);
00039e  a801              ADD      r0,sp,#4
0003a0  f7fffffe          BL       ADCx_StructInit
;;;422    	sADCx.ADC_ClockSource      = ADC_CLOCK_SOURCE_ADC;
0003a4  2004              MOVS     r0,#4
0003a6  9001              STR      r0,[sp,#4]
;;;423    	sADCx.ADC_SamplingMode     = ADC_SAMPLING_MODE_SINGLE_CONV;
0003a8  9402              STR      r4,[sp,#8]
;;;424    	sADCx.ADC_ChannelSwitching = ADC_CH_SWITCHING_Disable;
0003aa  9403              STR      r4,[sp,#0xc]
;;;425    	sADCx.ADC_ChannelNumber    = ADC_CH_TEMP_SENSOR;		
0003ac  201f              MOVS     r0,#0x1f
0003ae  9004              STR      r0,[sp,#0x10]
;;;426    	sADCx.ADC_Channels         = 0;
0003b0  9405              STR      r4,[sp,#0x14]
;;;427    	sADCx.ADC_LevelControl     = ADC_LEVEL_CONTROL_Disable;
0003b2  9406              STR      r4,[sp,#0x18]
;;;428    	sADCx.ADC_LowLevel         = 0;
0003b4  f8ad401c          STRH     r4,[sp,#0x1c]
;;;429    	sADCx.ADC_HighLevel        = 0;
0003b8  f8ad401e          STRH     r4,[sp,#0x1e]
;;;430    	sADCx.ADC_VRefSource       = ADC_VREF_SOURCE_EXTERNAL;
0003bc  02e8              LSLS     r0,r5,#11
0003be  9008              STR      r0,[sp,#0x20]
;;;431    	sADCx.ADC_IntVRefSource    = ADC_INT_VREF_SOURCE_EXACT;
0003c0  9509              STR      r5,[sp,#0x24]
;;;432    	sADCx.ADC_Prescaler        = ADC_CLK_div_128;
0003c2  f44f40e0          MOV      r0,#0x7000
0003c6  900a              STR      r0,[sp,#0x28]
;;;433    	sADCx.ADC_DelayGo          = 0;		// CHECKME
0003c8  940b              STR      r4,[sp,#0x2c]
;;;434    	ADC1_Init (&sADCx);
0003ca  a801              ADD      r0,sp,#4
0003cc  f7fffffe          BL       ADC1_Init
;;;435    	ADC2_Init (&sADCx);
0003d0  a801              ADD      r0,sp,#4
0003d2  f7fffffe          BL       ADC2_Init
;;;436    
;;;437    	// Disable ADC interupts
;;;438    	ADC1_ITConfig((ADCx_IT_END_OF_CONVERSION  | ADCx_IT_OUT_OF_RANGE), DISABLE);
0003d6  2100              MOVS     r1,#0
0003d8  2006              MOVS     r0,#6
0003da  f7fffffe          BL       ADC1_ITConfig
;;;439    	ADC2_ITConfig((ADCx_IT_END_OF_CONVERSION  | ADCx_IT_OUT_OF_RANGE), DISABLE);
0003de  2100              MOVS     r1,#0
0003e0  2006              MOVS     r0,#6
0003e2  f7fffffe          BL       ADC2_ITConfig
;;;440    
;;;441    	// ADC1 enable
;;;442    	ADC1_Cmd (ENABLE);
0003e6  2001              MOVS     r0,#1
0003e8  f7fffffe          BL       ADC1_Cmd
;;;443    	ADC2_Cmd (ENABLE);
0003ec  2001              MOVS     r0,#1
0003ee  f7fffffe          BL       ADC2_Cmd
;;;444    	
;;;445    	
;;;446    	//-------------------//
;;;447    /*	ADC1_SetChannel(ADC_CH_TEMP_SENSOR);
;;;448    	ADC1_Start();
;;;449    	while( ADC_GetFlagStatus(ADC1_FLAG_END_OF_CONVERSION)==RESET );
;;;450      temp_adc = ADC1_GetResult();
;;;451    	
;;;452    	ADC1_Start();
;;;453    	while( ADC_GetFlagStatus(ADC1_FLAG_END_OF_CONVERSION)==RESET );
;;;454      temp_adc = ADC1_GetResult();
;;;455    	
;;;456    	temp_adc = temp_adc;
;;;457    	*/
;;;458    	
;;;459    }
0003f2  b013              ADD      sp,sp,#0x4c
0003f4  bd30              POP      {r4,r5,pc}
;;;460    
                          ENDP

                  HW_TimersInit PROC
;;;469    //-----------------------------------------------------------------//
;;;470    void HW_TimersInit(void)
0003f6  e92d43f0          PUSH     {r4-r9,lr}
;;;471    {
0003fa  b091              SUB      sp,sp,#0x44
;;;472    	TIMER_CntInitTypeDef sTIM_CntInit;
;;;473    	TIMER_ChnInitTypeDef sTIM_ChnInit;
;;;474    	TIMER_ChnOutInitTypeDef sTIM_ChnOutInit;
;;;475    	
;;;476    	//======================= TIMER1 =======================//
;;;477    	// Timer1		CH2		-> BUZ+
;;;478    	//				CH2N	-> BUZ-
;;;479    	// TIMER_CLK = HCLK
;;;480    	// CLK = 1MHz
;;;481    	// Default buzzer freq = 1 / 500us = 2kHz
;;;482    	
;;;483    	// Initialize timer 1 counter
;;;484    	TIMER_CntStructInit(&sTIM_CntInit);
0003fc  a80b              ADD      r0,sp,#0x2c
0003fe  f7fffffe          BL       TIMER_CntStructInit
;;;485    	sTIM_CntInit.TIMER_Prescaler                = 0x1F;		// 32MHz / (31 + 1) = 1MHz
000402  201f              MOVS     r0,#0x1f
000404  f8ad002e          STRH     r0,[sp,#0x2e]
;;;486    	sTIM_CntInit.TIMER_Period                   = 499;		
000408  f24010f3          MOV      r0,#0x1f3
00040c  f8ad0030          STRH     r0,[sp,#0x30]
;;;487    	TIMER_CntInit (MDR_TIMER1,&sTIM_CntInit);
000410  4e1a              LDR      r6,|L1.1148|
000412  a90b              ADD      r1,sp,#0x2c
000414  4630              MOV      r0,r6
000416  f7fffffe          BL       TIMER_CntInit
;;;488    	
;;;489    	// Initialize timer 1 channel 2
;;;490    	TIMER_ChnStructInit(&sTIM_ChnInit);
00041a  a805              ADD      r0,sp,#0x14
00041c  f7fffffe          BL       TIMER_ChnStructInit
;;;491    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
000420  2400              MOVS     r4,#0
000422  f8ad4016          STRH     r4,[sp,#0x16]
;;;492    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format6;
000426  f44f6840          MOV      r8,#0xc00
00042a  f8ad801e          STRH     r8,[sp,#0x1e]
;;;493    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL2;
00042e  2501              MOVS     r5,#1
000430  f8ad5014          STRH     r5,[sp,#0x14]
;;;494    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_On_CNT_eq_0;
000434  f04f0908          MOV      r9,#8
000438  f8ad9026          STRH     r9,[sp,#0x26]
;;;495    	TIMER_ChnInit(MDR_TIMER1, &sTIM_ChnInit);
00043c  a905              ADD      r1,sp,#0x14
00043e  4630              MOV      r0,r6
000440  f7fffffe          BL       TIMER_ChnInit
;;;496    	
;;;497    	// Initialize timer 1 channel 2 output
;;;498    	TIMER_ChnOutStructInit(&sTIM_ChnOutInit);
000444  4668              MOV      r0,sp
000446  f7fffffe          BL       TIMER_ChnOutStructInit
;;;499    	sTIM_ChnOutInit.TIMER_CH_DirOut_Polarity          = TIMER_CHOPolarity_NonInverted;
00044a  f8ad4002          STRH     r4,[sp,#2]
;;;500    	sTIM_ChnOutInit.TIMER_CH_DirOut_Source            = TIMER_CH_OutSrc_Only_1;
00044e  e017              B        |L1.1152|
                  |L1.1104|
                          DCD      0x23e00000
                  |L1.1108|
                          DCD      0x0013c4e0
                  |L1.1112|
                          DCD      0x400a8000
                  |L1.1116|
                          DCD      0x400b0000
                  |L1.1120|
                          DCD      0x400b8000
                  |L1.1124|
                          DCD      0x400c0000
                  |L1.1128|
                          DCD      0x400c8000
                  |L1.1132|
                          DCD      0x400e8000
                  |L1.1136|
                          DCD      0x40038000
                  |L1.1140|
                          DCD      0x40030000
                  |L1.1144|
                          DCD      0x400a0000
                  |L1.1148|
                          DCD      0x40070000
                  |L1.1152|
000480  f8ad5004          STRH     r5,[sp,#4]
;;;501    	sTIM_ChnOutInit.TIMER_CH_DirOut_Mode              = TIMER_CH_OutMode_Output;
000484  f8ad5006          STRH     r5,[sp,#6]
;;;502    	sTIM_ChnOutInit.TIMER_CH_NegOut_Polarity          = TIMER_CHOPolarity_NonInverted;
000488  f8ad4008          STRH     r4,[sp,#8]
;;;503    	sTIM_ChnOutInit.TIMER_CH_NegOut_Source            = TIMER_CH_OutSrc_Only_1;
00048c  f8ad500a          STRH     r5,[sp,#0xa]
;;;504    	sTIM_ChnOutInit.TIMER_CH_NegOut_Mode              = TIMER_CH_OutMode_Output;
000490  f8ad500c          STRH     r5,[sp,#0xc]
;;;505    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL2;
000494  f8ad5000          STRH     r5,[sp,#0]
;;;506    	TIMER_ChnOutInit(MDR_TIMER1, &sTIM_ChnOutInit);
000498  4669              MOV      r1,sp
00049a  4630              MOV      r0,r6
00049c  f7fffffe          BL       TIMER_ChnOutInit
;;;507    
;;;508    	// Set default buzzer duty
;;;509    	MDR_TIMER1->CCR2 = 249;	
0004a0  20f9              MOVS     r0,#0xf9
0004a2  6170              STR      r0,[r6,#0x14]
;;;510      
;;;511    	// Enable TIMER1 counter clock
;;;512    	TIMER_BRGInit(MDR_TIMER1,TIMER_HCLKdiv1);
0004a4  2100              MOVS     r1,#0
0004a6  4630              MOV      r0,r6
0004a8  f7fffffe          BL       TIMER_BRGInit
;;;513    
;;;514    	// Enable TIMER1
;;;515    	TIMER_Cmd(MDR_TIMER1,ENABLE);
0004ac  2101              MOVS     r1,#1
0004ae  4630              MOV      r0,r6
0004b0  f7fffffe          BL       TIMER_Cmd
;;;516    	
;;;517    	
;;;518    	
;;;519    	//======================= TIMER2 =======================//
;;;520    	// Timer2		CH1N	-> UPWM
;;;521    	//				CH3N	-> IPWM
;;;522    	// 				CH2		-> HW control interrupt generation
;;;523    	// TIMER_CLK = HCLK
;;;524    	// CLK = 16MHz
;;;525    	// PWM frequency = 3906.25 Hz (T = 256us)
;;;526    	// PWM resolution = 12 bit
;;;527    	
;;;528    	// Initialize timer 2 counter
;;;529    	TIMER_CntStructInit(&sTIM_CntInit);
0004b4  a80b              ADD      r0,sp,#0x2c
0004b6  f7fffffe          BL       TIMER_CntStructInit
;;;530    	sTIM_CntInit.TIMER_Prescaler                = 0x1;		// CLK = 16MHz
0004ba  f8ad502e          STRH     r5,[sp,#0x2e]
;;;531    	sTIM_CntInit.TIMER_Period                   = 0xFFF;	// 16MHz / 4096 = 3906.25 Hz 
0004be  f64070ff          MOV      r0,#0xfff
0004c2  f8ad0030          STRH     r0,[sp,#0x30]
;;;532    	TIMER_CntInit (MDR_TIMER2,&sTIM_CntInit);
0004c6  4f89              LDR      r7,|L1.1772|
0004c8  a90b              ADD      r1,sp,#0x2c
0004ca  4638              MOV      r0,r7
0004cc  f7fffffe          BL       TIMER_CntInit
;;;533    
;;;534    	// Initialize timer 2 channels 1,3
;;;535    	TIMER_ChnStructInit(&sTIM_ChnInit);
0004d0  a805              ADD      r0,sp,#0x14
0004d2  f7fffffe          BL       TIMER_ChnStructInit
;;;536    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
0004d6  f8ad4016          STRH     r4,[sp,#0x16]
;;;537    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format6;
0004da  f8ad801e          STRH     r8,[sp,#0x1e]
;;;538    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_On_CNT_eq_0;
0004de  f8ad9026          STRH     r9,[sp,#0x26]
;;;539    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL1;			// voltage
0004e2  f8ad4014          STRH     r4,[sp,#0x14]
;;;540    	TIMER_ChnInit(MDR_TIMER2, &sTIM_ChnInit);
0004e6  a905              ADD      r1,sp,#0x14
0004e8  4638              MOV      r0,r7
0004ea  f7fffffe          BL       TIMER_ChnInit
;;;541    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL3;			// curret
0004ee  2602              MOVS     r6,#2
0004f0  f8ad6014          STRH     r6,[sp,#0x14]
;;;542    	TIMER_ChnInit(MDR_TIMER2, &sTIM_ChnInit);
0004f4  a905              ADD      r1,sp,#0x14
0004f6  4638              MOV      r0,r7
0004f8  f7fffffe          BL       TIMER_ChnInit
;;;543    	
;;;544    	// Initialize timer 2 channel 2 - used for HW control interrupt generation
;;;545    	TIMER_ChnStructInit(&sTIM_ChnInit);
0004fc  a805              ADD      r0,sp,#0x14
0004fe  f7fffffe          BL       TIMER_ChnStructInit
;;;546    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
000502  f8ad4016          STRH     r4,[sp,#0x16]
;;;547    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format1;	// REF output = 1 when CNT == CCR
000506  0268              LSLS     r0,r5,#9
000508  f8ad001e          STRH     r0,[sp,#0x1e]
;;;548    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL2;
00050c  f8ad5014          STRH     r5,[sp,#0x14]
;;;549    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_Immediately;
000510  f8ad4026          STRH     r4,[sp,#0x26]
;;;550    	TIMER_ChnInit(MDR_TIMER2, &sTIM_ChnInit);
000514  a905              ADD      r1,sp,#0x14
000516  4638              MOV      r0,r7
000518  f7fffffe          BL       TIMER_ChnInit
;;;551    	
;;;552    	// Initialize timer 2 channels 1,3 output
;;;553    	TIMER_ChnOutStructInit(&sTIM_ChnOutInit);
00051c  4668              MOV      r0,sp
00051e  f7fffffe          BL       TIMER_ChnOutStructInit
;;;554    	sTIM_ChnOutInit.TIMER_CH_NegOut_Polarity          = TIMER_CHOPolarity_Inverted;
000522  f8ad5008          STRH     r5,[sp,#8]
;;;555    	sTIM_ChnOutInit.TIMER_CH_NegOut_Source            = TIMER_CH_OutSrc_REF;
000526  f8ad600a          STRH     r6,[sp,#0xa]
;;;556    	sTIM_ChnOutInit.TIMER_CH_NegOut_Mode              = TIMER_CH_OutMode_Output;
00052a  f8ad500c          STRH     r5,[sp,#0xc]
;;;557    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL1;
00052e  f8ad4000          STRH     r4,[sp,#0]
;;;558    	TIMER_ChnOutInit(MDR_TIMER2, &sTIM_ChnOutInit);
000532  4669              MOV      r1,sp
000534  4638              MOV      r0,r7
000536  f7fffffe          BL       TIMER_ChnOutInit
;;;559    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL3;
00053a  f8ad6000          STRH     r6,[sp,#0]
;;;560    	TIMER_ChnOutInit(MDR_TIMER2, &sTIM_ChnOutInit);
00053e  4669              MOV      r1,sp
000540  4638              MOV      r0,r7
000542  f7fffffe          BL       TIMER_ChnOutInit
;;;561    	
;;;562    	// Set default voltage PWM duty cycle
;;;563    	MDR_TIMER2->CCR1 = 0;	
000546  613c              STR      r4,[r7,#0x10]
;;;564    	// Set default current PWM duty cycle
;;;565    	MDR_TIMER2->CCR3 = 0;	
000548  61bc              STR      r4,[r7,#0x18]
;;;566    	// Set default CCR for interrupt generation
;;;567    	MDR_TIMER2->CCR2 = 0;
00054a  617c              STR      r4,[r7,#0x14]
;;;568    	
;;;569    	// Enable interrupts
;;;570    	TIMER_ITConfig(MDR_TIMER2, TIMER_STATUS_CCR_REF_CH2, ENABLE);
00054c  2201              MOVS     r2,#1
00054e  0291              LSLS     r1,r2,#10
000550  4638              MOV      r0,r7
000552  f7fffffe          BL       TIMER_ITConfig
;;;571    	//TIMER_ITConfig(MDR_TIMER2, TIMER_STATUS_CNT_ZERO, ENABLE);
;;;572    	
;;;573    	// Enable TIMER2 counter clock
;;;574    	TIMER_BRGInit(MDR_TIMER2,TIMER_HCLKdiv1);
000556  2100              MOVS     r1,#0
000558  4638              MOV      r0,r7
00055a  f7fffffe          BL       TIMER_BRGInit
;;;575    
;;;576    	// Enable TIMER2
;;;577    	TIMER_Cmd(MDR_TIMER2,ENABLE);
00055e  2101              MOVS     r1,#1
000560  4638              MOV      r0,r7
000562  f7fffffe          BL       TIMER_Cmd
;;;578    	
;;;579    	
;;;580    	
;;;581    	//======================= TIMER3 =======================//
;;;582    	// Timer3		CH1 	-> LPWM (LCD backlight PWM) 
;;;583    	//				CH3N	-> CPWM (System cooler PWM)
;;;584    	// TIMER_CLK = HCLK
;;;585    	// CLK = 2MHz
;;;586    	// PWM frequency = 20kHz
;;;587    	// PWM resolution = 100
;;;588    	
;;;589    	// Initialize timer 3 counter
;;;590    	TIMER_CntStructInit(&sTIM_CntInit);
000566  a80b              ADD      r0,sp,#0x2c
000568  f7fffffe          BL       TIMER_CntStructInit
;;;591    	sTIM_CntInit.TIMER_Prescaler                = 0xF;		// 2MHz at 32MHz core clk
00056c  200f              MOVS     r0,#0xf
00056e  f8ad002e          STRH     r0,[sp,#0x2e]
;;;592    	sTIM_CntInit.TIMER_Period                   = 99;			// 20kHz at 2MHz
000572  2063              MOVS     r0,#0x63
000574  f8ad0030          STRH     r0,[sp,#0x30]
;;;593    	TIMER_CntInit (MDR_TIMER3,&sTIM_CntInit);
000578  4f5d              LDR      r7,|L1.1776|
00057a  a90b              ADD      r1,sp,#0x2c
00057c  4638              MOV      r0,r7
00057e  f7fffffe          BL       TIMER_CntInit
;;;594    		
;;;595    	// Initialize timer 3 channel 1
;;;596    	TIMER_ChnStructInit(&sTIM_ChnInit);
000582  a805              ADD      r0,sp,#0x14
000584  f7fffffe          BL       TIMER_ChnStructInit
;;;597    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL1;
000588  f8ad4014          STRH     r4,[sp,#0x14]
;;;598    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
00058c  f8ad4016          STRH     r4,[sp,#0x16]
;;;599    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format6;
000590  f8ad801e          STRH     r8,[sp,#0x1e]
;;;600    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_On_CNT_eq_0;
000594  f8ad9026          STRH     r9,[sp,#0x26]
;;;601    	TIMER_ChnInit(MDR_TIMER3, &sTIM_ChnInit);
000598  a905              ADD      r1,sp,#0x14
00059a  4638              MOV      r0,r7
00059c  f7fffffe          BL       TIMER_ChnInit
;;;602    
;;;603    	// Initialize timer 3 channel 1 output
;;;604    	TIMER_ChnOutStructInit(&sTIM_ChnOutInit);
0005a0  4668              MOV      r0,sp
0005a2  f7fffffe          BL       TIMER_ChnOutStructInit
;;;605    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL1;
0005a6  f8ad4000          STRH     r4,[sp,#0]
;;;606    	sTIM_ChnOutInit.TIMER_CH_DirOut_Source            = TIMER_CH_OutSrc_REF;
0005aa  f8ad6004          STRH     r6,[sp,#4]
;;;607    	sTIM_ChnOutInit.TIMER_CH_DirOut_Polarity          = TIMER_CHOPolarity_NonInverted;
0005ae  f8ad4002          STRH     r4,[sp,#2]
;;;608    	sTIM_ChnOutInit.TIMER_CH_DirOut_Mode              = TIMER_CH_OutMode_Output;
0005b2  f8ad5006          STRH     r5,[sp,#6]
;;;609    	TIMER_ChnOutInit(MDR_TIMER3, &sTIM_ChnOutInit);
0005b6  4669              MOV      r1,sp
0005b8  4638              MOV      r0,r7
0005ba  f7fffffe          BL       TIMER_ChnOutInit
;;;610    
;;;611    	// Initialize timer 3 channel 3
;;;612    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL3;
0005be  f8ad6014          STRH     r6,[sp,#0x14]
;;;613    	TIMER_ChnInit(MDR_TIMER3, &sTIM_ChnInit);
0005c2  a905              ADD      r1,sp,#0x14
0005c4  4638              MOV      r0,r7
0005c6  f7fffffe          BL       TIMER_ChnInit
;;;614    	
;;;615    	// Initialize timer 3 channel 3 output
;;;616    	sTIM_ChnOutInit.TIMER_CH_Number           	= TIMER_CHANNEL3;
0005ca  f8ad6000          STRH     r6,[sp,#0]
;;;617    	sTIM_ChnOutInit.TIMER_CH_DirOut_Source      = TIMER_CH_OutSrc_Only_0;
0005ce  f8ad4004          STRH     r4,[sp,#4]
;;;618    	sTIM_ChnOutInit.TIMER_CH_DirOut_Mode        = TIMER_CH_OutMode_Input;
0005d2  f8ad4006          STRH     r4,[sp,#6]
;;;619    	sTIM_ChnOutInit.TIMER_CH_NegOut_Source     	= TIMER_CH_OutSrc_REF;
0005d6  f8ad600a          STRH     r6,[sp,#0xa]
;;;620    	sTIM_ChnOutInit.TIMER_CH_NegOut_Polarity   	= TIMER_CHOPolarity_Inverted;
0005da  f8ad5008          STRH     r5,[sp,#8]
;;;621    	sTIM_ChnOutInit.TIMER_CH_NegOut_Mode       	= TIMER_CH_OutMode_Output;
0005de  f8ad500c          STRH     r5,[sp,#0xc]
;;;622    	TIMER_ChnOutInit(MDR_TIMER3, &sTIM_ChnOutInit);
0005e2  4669              MOV      r1,sp
0005e4  4638              MOV      r0,r7
0005e6  f7fffffe          BL       TIMER_ChnOutInit
;;;623    
;;;624    
;;;625    	// Set default PWM duty cycle for LCD backlight PWM	
;;;626    	MDR_TIMER3->CCR1 = 0;
0005ea  613c              STR      r4,[r7,#0x10]
;;;627    	
;;;628    	// Set default PWM duty cycle for system cooler PWM
;;;629    	MDR_TIMER3->CCR3 = 0;
0005ec  61bc              STR      r4,[r7,#0x18]
;;;630    
;;;631    	// Enable TIMER3 counter clock
;;;632    	TIMER_BRGInit(MDR_TIMER3,TIMER_HCLKdiv1);
0005ee  2100              MOVS     r1,#0
0005f0  4638              MOV      r0,r7
0005f2  f7fffffe          BL       TIMER_BRGInit
;;;633    
;;;634    	// Enable TIMER3
;;;635    	TIMER_Cmd(MDR_TIMER3,ENABLE);
0005f6  2101              MOVS     r1,#1
0005f8  4638              MOV      r0,r7
0005fa  f7fffffe          BL       TIMER_Cmd
;;;636    	
;;;637    
;;;638    
;;;639    }
0005fe  b011              ADD      sp,sp,#0x44
000600  e8bd83f0          POP      {r4-r9,pc}
;;;640    
                          ENDP

                  SetVoltagePWMPeriod PROC
;;;645    
;;;646    void SetVoltagePWMPeriod(uint16_t new_period)
000604  4939              LDR      r1,|L1.1772|
;;;647    {
;;;648    	MDR_TIMER2->CCR1 = new_period;	
000606  6108              STR      r0,[r1,#0x10]
;;;649    }
000608  4770              BX       lr
;;;650    
                          ENDP

                  SetCurrentPWMPeriod PROC
;;;651    void SetCurrentPWMPeriod(uint16_t new_period)
00060a  4938              LDR      r1,|L1.1772|
;;;652    {
;;;653    	MDR_TIMER2->CCR3 = new_period;	
00060c  6188              STR      r0,[r1,#0x18]
;;;654    }
00060e  4770              BX       lr
;;;655    
                          ENDP

                  SetCoolerSpeed PROC
;;;660    
;;;661    void SetCoolerSpeed(uint16_t speed)
000610  4937              LDR      r1,|L1.1776|
;;;662    {
;;;663    	MDR_TIMER3->CCR3 = speed;
000612  6188              STR      r0,[r1,#0x18]
;;;664    }
000614  4770              BX       lr
;;;665    
                          ENDP

                  LcdSetBacklight PROC
;;;673    //==============================================================//
;;;674    void LcdSetBacklight(uint16_t value)
000616  2864              CMP      r0,#0x64
;;;675    {
;;;676    	if (value>100) value = 100;
000618  d900              BLS      |L1.1564|
00061a  2064              MOVS     r0,#0x64
                  |L1.1564|
;;;677    		MDR_TIMER3->CCR1 = value;
00061c  4934              LDR      r1,|L1.1776|
00061e  6108              STR      r0,[r1,#0x10]
;;;678    }
000620  4770              BX       lr
;;;679    
                          ENDP

                  ProcessPowerOff PROC
;;;681    
;;;682    void ProcessPowerOff(void)
000622  b538              PUSH     {r3-r5,lr}
;;;683    {
;;;684    	uint32_t time_delay;
;;;685    	if (GetACLineStatus() == OFFLINE)
000624  f7fffffe          BL       GetACLineStatus
000628  2800              CMP      r0,#0
00062a  d15e              BNE      |L1.1770|
;;;686    	{	
;;;687    		__disable_irq();
00062c  b672              CPSID    i
;;;688    
;;;689    		SetConverterState(CONVERTER_OFF);		// safe because we're stopping in this function
00062e  2000              MOVS     r0,#0
000630  f7fffffe          BL       SetConverterState
;;;690    
;;;691    		//SysTickStop();
;;;692    		//StopBeep();
;;;693    
;;;694    		time_delay = DWT_StartDelayUs(5000);
000634  f2413088          MOV      r0,#0x1388
000638  f7fffffe          BL       DWT_StartDelayUs
00063c  4604              MOV      r4,r0
;;;695    
;;;696    		LcdSetBacklight(0);
00063e  2000              MOVS     r0,#0
000640  f7fffffe          BL       LcdSetBacklight
;;;697    		SetCoolerSpeed(0);
000644  2000              MOVS     r0,#0
000646  f7fffffe          BL       SetCoolerSpeed
;;;698    		SetVoltagePWMPeriod(0);
00064a  2000              MOVS     r0,#0
00064c  f7fffffe          BL       SetVoltagePWMPeriod
;;;699    		SetCurrentPWMPeriod(0);
000650  2000              MOVS     r0,#0
000652  f7fffffe          BL       SetCurrentPWMPeriod
;;;700    
;;;701    
;;;702    		// Put message
;;;703    		LcdFillBuffer(lcd0_buffer,0);
000656  2100              MOVS     r1,#0
000658  4826              LDR      r0,|L1.1780|
00065a  f7fffffe          BL       LcdFillBuffer
;;;704    		LcdFillBuffer(lcd1_buffer,0);
00065e  2100              MOVS     r1,#0
000660  4825              LDR      r0,|L1.1784|
000662  f7fffffe          BL       LcdFillBuffer
;;;705    		LcdPutNormalStr(0,10,"Power OFF",(tNormalFont*)&font_8x12,lcd0_buffer);
000666  4823              LDR      r0,|L1.1780|
000668  9000              STR      r0,[sp,#0]
00066a  4b24              LDR      r3,|L1.1788|
00066c  a224              ADR      r2,|L1.1792|
00066e  210a              MOVS     r1,#0xa
000670  2000              MOVS     r0,#0
000672  f7fffffe          BL       LcdPutNormalStr
;;;706    		LcdPutNormalStr(0,10,"Power OFF",(tNormalFont*)&font_8x12,lcd1_buffer);
000676  4820              LDR      r0,|L1.1784|
000678  9000              STR      r0,[sp,#0]
00067a  4b20              LDR      r3,|L1.1788|
00067c  a220              ADR      r2,|L1.1792|
00067e  210a              MOVS     r1,#0xa
000680  2000              MOVS     r0,#0
000682  f7fffffe          BL       LcdPutNormalStr
                  |L1.1670|
;;;707    
;;;708    
;;;709    
;;;710    		while(DWT_DelayInProgress(time_delay));
000686  4620              MOV      r0,r4
000688  f7fffffe          BL       DWT_DelayInProgress
00068c  2800              CMP      r0,#0
00068e  d1fa              BNE      |L1.1670|
;;;711    
;;;712    		SetFeedbackChannel(CHANNEL_12V);
000690  f7fffffe          BL       SetFeedbackChannel
;;;713    		SetCurrentLimit(CURRENT_LIM_HIGH); 
000694  2001              MOVS     r0,#1
000696  f7fffffe          BL       SetCurrentLimit
;;;714    		SetOutputLoad(LOAD_DISABLE); 
00069a  2001              MOVS     r0,#1
00069c  f7fffffe          BL       SetOutputLoad
;;;715    
;;;716    		LcdUpdateByCore(LCD0,lcd0_buffer);
0006a0  4914              LDR      r1,|L1.1780|
0006a2  2001              MOVS     r0,#1
0006a4  f7fffffe          BL       LcdUpdateByCore
;;;717    		LcdUpdateByCore(LCD1,lcd1_buffer);
0006a8  4913              LDR      r1,|L1.1784|
0006aa  2002              MOVS     r0,#2
0006ac  f7fffffe          BL       LcdUpdateByCore
;;;718    
;;;719    
;;;720    
;;;721    		time_delay = DWT_StartDelayUs(1000);
0006b0  f44f707a          MOV      r0,#0x3e8
0006b4  f7fffffe          BL       DWT_StartDelayUs
0006b8  4604              MOV      r4,r0
                  |L1.1722|
;;;722    		while(DWT_DelayInProgress(time_delay));
0006ba  4620              MOV      r0,r4
0006bc  f7fffffe          BL       DWT_DelayInProgress
0006c0  2800              CMP      r0,#0
0006c2  d1fa              BNE      |L1.1722|
;;;723    
;;;724    		PORT_DeInit(MDR_PORTA);
0006c4  4811              LDR      r0,|L1.1804|
0006c6  f7fffffe          BL       PORT_DeInit
;;;725    		PORT_DeInit(MDR_PORTB);
0006ca  4811              LDR      r0,|L1.1808|
0006cc  f7fffffe          BL       PORT_DeInit
;;;726    		PORT_DeInit(MDR_PORTC);
0006d0  4810              LDR      r0,|L1.1812|
0006d2  f7fffffe          BL       PORT_DeInit
;;;727    		PORT_DeInit(MDR_PORTD);
0006d6  4810              LDR      r0,|L1.1816|
0006d8  f7fffffe          BL       PORT_DeInit
;;;728    		PORT_DeInit(MDR_PORTE);
0006dc  480f              LDR      r0,|L1.1820|
0006de  f7fffffe          BL       PORT_DeInit
;;;729    		PORT_DeInit(MDR_PORTF);
0006e2  480f              LDR      r0,|L1.1824|
0006e4  f7fffffe          BL       PORT_DeInit
                  |L1.1768|
;;;730    
;;;731    		while(1);
0006e8  e7fe              B        |L1.1768|
                  |L1.1770|
;;;732    		 
;;;733    	}
;;;734    }
0006ea  bd38              POP      {r3-r5,pc}
;;;735    	
                          ENDP

                  |L1.1772|
                          DCD      0x40078000
                  |L1.1776|
                          DCD      0x40080000
                  |L1.1780|
                          DCD      lcd0_buffer
                  |L1.1784|
                          DCD      lcd1_buffer
                  |L1.1788|
                          DCD      font_8x12
                  |L1.1792|
000700  506f7765          DCB      "Power OFF",0
000704  72204f46
000708  4600    
00070a  00                DCB      0
00070b  00                DCB      0
                  |L1.1804|
                          DCD      0x400a8000
                  |L1.1808|
                          DCD      0x400b0000
                  |L1.1812|
                          DCD      0x400b8000
                  |L1.1816|
                          DCD      0x400c0000
                  |L1.1820|
                          DCD      0x400c8000
                  |L1.1824|
                          DCD      0x400e8000

;*** Start embedded assembler ***

#line 1 "src\\systemfunc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_systemfunc_c_b744d595____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_systemfunc_c_b744d595____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_systemfunc_c_b744d595____REVSH|
#line 130
|__asm___12_systemfunc_c_b744d595____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
