; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list -c --asm --interleave -o.\FLASH\systemfunc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\systemfunc.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -I.\src\gui -I.\src\gui\guiCore -I.\src\gui\guiWidgets -I.\src\gui\guiGraphics -I.\src\gui\utils -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\systemfunc.crf src\systemfunc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  my_DMA_GlobalInit PROC
;;;41     // Globally initializes DMA controller
;;;42     void my_DMA_GlobalInit(void)
000000  48fe              LDR      r0,|L1.1020|
;;;43     {
;;;44     	/* Check the CTRL_BASE_PTR initialisation */
;;;45     	// MDR_DMA->ALT_CTRL_BASE_PTR is automatically updated by DMA itself and is accessible for read only
;;;46     	MDR_DMA->CTRL_BASE_PTR = (uint32_t)DMA_ControlTable;
000002  49fd              LDR      r1,|L1.1016|
000004  6081              STR      r1,[r0,#8]
;;;47     	/* DMA configuration register */
;;;48     	//MDR_DMA->CFG = DMA_CFG_MASTER_ENABLE || 0 /*DMA_InitStruct->DMA_ProtCtrl*/;		// CHECKME
;;;49     	MDR_DMA->CFG = DMA_CFG_MASTER_ENABLE || DMA_AHB_Privileged;
000006  2101              MOVS     r1,#1
000008  6041              STR      r1,[r0,#4]
;;;50     }
00000a  4770              BX       lr
;;;51     
                          ENDP

                  my_DMA_ChannelInit PROC
;;;56     //	- DMA_ChannelInitStruct.ProtCtrl is unused
;;;57     void my_DMA_ChannelInit(uint8_t DMA_Channel, DMA_ChannelInitTypeDef* DMA_InitStruct)
00000c  e92d41f0          PUSH     {r4-r8,lr}
;;;58     {
000010  4607              MOV      r7,r0
000012  460d              MOV      r5,r1
;;;59     	// Make sure channel is disabled
;;;60     	MDR_DMA->CHNL_ENABLE_CLR = (1 << DMA_Channel);
000014  4ef9              LDR      r6,|L1.1020|
000016  2401              MOVS     r4,#1
000018  40bc              LSLS     r4,r4,r7
00001a  62f4              STR      r4,[r6,#0x2c]
;;;61     
;;;62     	/* Primary Control Data Init */
;;;63     	if (DMA_InitStruct->DMA_PriCtrlData)
00001c  6828              LDR      r0,[r5,#0]
00001e  b120              CBZ      r0,|L1.42|
;;;64     	{
;;;65     		DMA_CtrlDataInit(DMA_InitStruct->DMA_PriCtrlData, &DMA_ControlTable[DMA_Channel]);
000020  49f5              LDR      r1,|L1.1016|
000022  eb011107          ADD      r1,r1,r7,LSL #4
000026  f7fffffe          BL       DMA_CtrlDataInit
                  |L1.42|
;;;66     	}
;;;67     
;;;68     #if (DMA_AlternateData == 1)
;;;69     	/* Alternate Control Data Init */
;;;70     	if (DMA_InitStruct->DMA_AltCtrlData)
00002a  6868              LDR      r0,[r5,#4]
00002c  b120              CBZ      r0,|L1.56|
;;;71     	{
;;;72     		uint32_t ptr = (MDR_DMA->ALT_CTRL_BASE_PTR + (DMA_Channel * sizeof(DMA_CtrlDataTypeDef)));
00002e  68f1              LDR      r1,[r6,#0xc]
000030  eb011107          ADD      r1,r1,r7,LSL #4
;;;73     		DMA_CtrlDataInit(DMA_InitStruct->DMA_AltCtrlData, (DMA_CtrlDataTypeDef *)ptr);
000034  f7fffffe          BL       DMA_CtrlDataInit
                  |L1.56|
;;;74     	}
;;;75     #endif
;;;76     
;;;77     	/* Burst mode */
;;;78     	if (DMA_InitStruct->DMA_UseBurst == DMA_BurstSet)
000038  7b68              LDRB     r0,[r5,#0xd]
00003a  2801              CMP      r0,#1
00003c  d00a              BEQ      |L1.84|
;;;79     	{
;;;80     		MDR_DMA->CHNL_USEBURST_SET = (1 << DMA_Channel);
;;;81     	}
;;;82     	else
;;;83     	{
;;;84     		MDR_DMA->CHNL_USEBURST_CLR = (1 << DMA_Channel);
00003e  61f4              STR      r4,[r6,#0x1c]
                  |L1.64|
;;;85     	}
;;;86     
;;;87     	/* Channel mask clear - enable requests to channel */
;;;88     	MDR_DMA->CHNL_REQ_MASK_CLR = (1 << DMA_Channel);
000040  6274              STR      r4,[r6,#0x24]
;;;89       
;;;90     	/* Primary - Alternate control data structure selection */
;;;91     	if (DMA_InitStruct->DMA_SelectDataStructure == DMA_CTRL_DATA_PRIMARY)
000042  7ba8              LDRB     r0,[r5,#0xe]
000044  b140              CBZ      r0,|L1.88|
;;;92     	{
;;;93     		MDR_DMA->CHNL_PRI_ALT_CLR = (1 << DMA_Channel);       /* Use Primary */
;;;94     	}
;;;95     	else
;;;96     	{
;;;97     		MDR_DMA->CHNL_PRI_ALT_SET = (1 << DMA_Channel);       /* Use Alternate */
000046  6334              STR      r4,[r6,#0x30]
                  |L1.72|
;;;98     	}
;;;99     
;;;100    	/* Channel priority set */
;;;101    	if (DMA_InitStruct->DMA_Priority == DMA_Priority_High)
000048  7b28              LDRB     r0,[r5,#0xc]
00004a  2801              CMP      r0,#1
00004c  d006              BEQ      |L1.92|
;;;102    	{
;;;103    		MDR_DMA->CHNL_PRIORITY_SET = (1 << DMA_Channel);      /* High priority */
;;;104    	}
;;;105    	else
;;;106    	{
;;;107    		MDR_DMA->CHNL_PRIORITY_CLR = (1 << DMA_Channel);      /* Default priority */
00004e  63f4              STR      r4,[r6,#0x3c]
                  |L1.80|
;;;108    	}
;;;109    }
000050  e8bd81f0          POP      {r4-r8,pc}
                  |L1.84|
000054  61b4              STR      r4,[r6,#0x18]         ;80
000056  e7f3              B        |L1.64|
                  |L1.88|
000058  6374              STR      r4,[r6,#0x34]         ;93
00005a  e7f5              B        |L1.72|
                  |L1.92|
00005c  63b4              STR      r4,[r6,#0x38]         ;103
00005e  e7f7              B        |L1.80|
;;;110    
                          ENDP

                  Setup_CPU_Clock PROC
;;;120    //-----------------------------------------------------------------//
;;;121    void Setup_CPU_Clock(void)
000060  b510              PUSH     {r4,lr}
;;;122    {
;;;123    	// Enable HSE
;;;124    	RST_CLK_HSEconfig(RST_CLK_HSE_ON);
000062  2001              MOVS     r0,#1
000064  f7fffffe          BL       RST_CLK_HSEconfig
;;;125    	if (RST_CLK_HSEstatus() != SUCCESS)
000068  f7fffffe          BL       RST_CLK_HSEstatus
00006c  2801              CMP      r0,#1
00006e  d000              BEQ      |L1.114|
                  |L1.112|
;;;126    	{
;;;127    		while (1) {}	// Trap
000070  e7fe              B        |L1.112|
                  |L1.114|
;;;128    	}
;;;129    	
;;;130    	//-------------------------------//
;;;131    	// Setup CPU PLL and CPU_C1_SEL
;;;132    	// CPU_C1 = HSE,	PLL = x8
;;;133    	RST_CLK_CPU_PLLconfig(RST_CLK_CPU_PLLsrcHSEdiv1, RST_CLK_CPU_PLLmul8);
000072  2107              MOVS     r1,#7
000074  2002              MOVS     r0,#2
000076  f7fffffe          BL       RST_CLK_CPU_PLLconfig
;;;134    	RST_CLK_CPU_PLLcmd(ENABLE);
00007a  2001              MOVS     r0,#1
00007c  f7fffffe          BL       RST_CLK_CPU_PLLcmd
;;;135    	if (RST_CLK_CPU_PLLstatus() != SUCCESS)
000080  f7fffffe          BL       RST_CLK_CPU_PLLstatus
000084  2801              CMP      r0,#1
000086  d000              BEQ      |L1.138|
                  |L1.136|
;;;136    	{
;;;137    		while (1) {}	// Trap
000088  e7fe              B        |L1.136|
                  |L1.138|
;;;138    	}
;;;139    	// Setup CPU_C2 and CPU_C3
;;;140    	// CPU_C3 = CPU_C2
;;;141    	RST_CLK_CPUclkPrescaler(RST_CLK_CPUclkDIV1);
00008a  2000              MOVS     r0,#0
00008c  f7fffffe          BL       RST_CLK_CPUclkPrescaler
;;;142    	// CPU_C2 = CPU PLL output
;;;143    	RST_CLK_CPU_PLLuse(ENABLE);
000090  2001              MOVS     r0,#1
000092  f7fffffe          BL       RST_CLK_CPU_PLLuse
;;;144    	// Switch to CPU_C3
;;;145    	// HCLK = CPU_C3
;;;146    	RST_CLK_CPUclkSelection(RST_CLK_CPUclkCPU_C3);
000096  f44f7080          MOV      r0,#0x100
00009a  f7fffffe          BL       RST_CLK_CPUclkSelection
;;;147    	
;;;148    	//-------------------------------//
;;;149    	// Setup ADC clock
;;;150    	// ADC_C2 = CPU_C1
;;;151    	RST_CLK_ADCclkSelection(RST_CLK_ADCclkCPU_C1);
00009e  2020              MOVS     r0,#0x20
0000a0  f7fffffe          BL       RST_CLK_ADCclkSelection
;;;152    	// ADC_C3 = ADC_C2
;;;153    	RST_CLK_ADCclkPrescaler(RST_CLK_ADCclkDIV1);
0000a4  2000              MOVS     r0,#0
0000a6  f7fffffe          BL       RST_CLK_ADCclkPrescaler
;;;154    	// Enable ADC_CLK
;;;155    	RST_CLK_ADCclkEnable(ENABLE);
0000aa  2001              MOVS     r0,#1
0000ac  f7fffffe          BL       RST_CLK_ADCclkEnable
;;;156    	
;;;157    	// Update system clock variable
;;;158    	SystemCoreClockUpdate();
0000b0  f7fffffe          BL       SystemCoreClockUpdate
;;;159    	
;;;160    	// Enable clock on all ports (macro are defined in systemfunc.h)
;;;161    	RST_CLK_PCLKcmd(ALL_PORTS_CLK, ENABLE);
0000b4  2101              MOVS     r1,#1
0000b6  48d2              LDR      r0,|L1.1024|
0000b8  f7fffffe          BL       RST_CLK_PCLKcmd
;;;162    	// Enable clock on peripheral blocks used in design
;;;163    	RST_CLK_PCLKcmd(PERIPHERALS_CLK ,ENABLE);
0000bc  e8bd4010          POP      {r4,lr}
0000c0  2101              MOVS     r1,#1
0000c2  48d0              LDR      r0,|L1.1028|
0000c4  f7ffbffe          B.W      RST_CLK_PCLKcmd
;;;164    }
;;;165    
                          ENDP

                  HW_NVIC_init PROC
;;;168    
;;;169    void HW_NVIC_init(void)
0000c8  e92d41f0          PUSH     {r4-r8,lr}
;;;170    {
0000cc  49ce              LDR      r1,|L1.1032|
0000ce  6808              LDR      r0,[r1,#0]
0000d0  f64f02ff          MOV      r2,#0xf8ff
0000d4  4010              ANDS     r0,r0,r2
0000d6  4acd              LDR      r2,|L1.1036|
0000d8  f4407040          ORR      r0,r0,#0x300
0000dc  4310              ORRS     r0,r0,r2
0000de  6008              STR      r0,[r1,#0]
;;;171    	
;;;172    	// There are 3 bits of priority implemented in MDR32F9Qx device
;;;173    	// Setting all bits to pre-emption, see link below
;;;174    	// http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0552a/BABHGEAJ.html
;;;175    	NVIC_SetPriorityGrouping( 3 );
;;;176    	
;;;177    	pr[0] = NVIC_GetPriority(SVCall_IRQn);
0000e0  f06f0704          MVN      r7,#4
0000e4  4638              MOV      r0,r7
0000e6  f7fffffe          BL       NVIC_GetPriority
0000ea  4cc9              LDR      r4,|L1.1040|
0000ec  6020              STR      r0,[r4,#0]  ; pr
;;;178    	pr[1] = NVIC_GetPriority(PendSV_IRQn);
0000ee  10bd              ASRS     r5,r7,#2
0000f0  4628              MOV      r0,r5
0000f2  f7fffffe          BL       NVIC_GetPriority
0000f6  6060              STR      r0,[r4,#4]  ; pr
;;;179    	pr[2] = NVIC_GetPriority(SysTick_IRQn);
0000f8  106e              ASRS     r6,r5,#1
0000fa  4630              MOV      r0,r6
0000fc  f7fffffe          BL       NVIC_GetPriority
000100  60a0              STR      r0,[r4,#8]  ; pr
;;;180    	pr[3] = NVIC_GetPriority(DMA_IRQn);
000102  2005              MOVS     r0,#5
000104  f7fffffe          BL       NVIC_GetPriority
000108  60e0              STR      r0,[r4,#0xc]  ; pr
;;;181    	pr[4] = NVIC_GetPriority(Timer2_IRQn);
00010a  200f              MOVS     r0,#0xf
00010c  f7fffffe          BL       NVIC_GetPriority
000110  6120              STR      r0,[r4,#0x10]  ; pr
;;;182    
;;;183    	NVIC_SetPriority(DMA_IRQn,6);
000112  2106              MOVS     r1,#6
000114  2005              MOVS     r0,#5
000116  f7fffffe          BL       NVIC_SetPriority
;;;184    	NVIC_SetPriority(Timer2_IRQn,6);
00011a  2106              MOVS     r1,#6
00011c  200f              MOVS     r0,#0xf
00011e  f7fffffe          BL       NVIC_SetPriority
;;;185    
;;;186    	pr[0] = NVIC_GetPriority(SVCall_IRQn);
000122  4638              MOV      r0,r7
000124  f7fffffe          BL       NVIC_GetPriority
000128  6020              STR      r0,[r4,#0]  ; pr
;;;187    	pr[1] = NVIC_GetPriority(PendSV_IRQn);
00012a  4628              MOV      r0,r5
00012c  f7fffffe          BL       NVIC_GetPriority
000130  6060              STR      r0,[r4,#4]  ; pr
;;;188    	pr[2] = NVIC_GetPriority(SysTick_IRQn);
000132  4630              MOV      r0,r6
000134  f7fffffe          BL       NVIC_GetPriority
000138  60a0              STR      r0,[r4,#8]  ; pr
;;;189    	pr[3] = NVIC_GetPriority(DMA_IRQn);
00013a  2005              MOVS     r0,#5
00013c  f7fffffe          BL       NVIC_GetPriority
000140  60e0              STR      r0,[r4,#0xc]  ; pr
;;;190    	pr[4] = NVIC_GetPriority(Timer2_IRQn);
000142  200f              MOVS     r0,#0xf
000144  f7fffffe          BL       NVIC_GetPriority
000148  6120              STR      r0,[r4,#0x10]  ; pr
;;;191    	
;;;192    	
;;;193    }
00014a  e781              B        |L1.80|
;;;194    
                          ENDP

                  HW_NVIC_check PROC
;;;195    void HW_NVIC_check(void)
00014c  b510              PUSH     {r4,lr}
;;;196    {
;;;197    	
;;;198    	pr[0] = NVIC_GetPriority(SVCall_IRQn);
00014e  f06f0004          MVN      r0,#4
000152  f7fffffe          BL       NVIC_GetPriority
000156  4cae              LDR      r4,|L1.1040|
000158  6020              STR      r0,[r4,#0]  ; pr
;;;199    	pr[1] = NVIC_GetPriority(PendSV_IRQn);
00015a  f06f0001          MVN      r0,#1
00015e  f7fffffe          BL       NVIC_GetPriority
000162  6060              STR      r0,[r4,#4]  ; pr
;;;200    	pr[2] = NVIC_GetPriority(SysTick_IRQn);
000164  f04f30ff          MOV      r0,#0xffffffff
000168  f7fffffe          BL       NVIC_GetPriority
00016c  60a0              STR      r0,[r4,#8]  ; pr
;;;201    	
;;;202    	pr[3] = NVIC_GetPriority(DMA_IRQn);
00016e  2005              MOVS     r0,#5
000170  f7fffffe          BL       NVIC_GetPriority
000174  60e0              STR      r0,[r4,#0xc]  ; pr
;;;203    	pr[4] = NVIC_GetPriority(Timer2_IRQn);
000176  200f              MOVS     r0,#0xf
000178  f7fffffe          BL       NVIC_GetPriority
00017c  6120              STR      r0,[r4,#0x10]  ; pr
;;;204    	
;;;205    }
00017e  bd10              POP      {r4,pc}
;;;206    
                          ENDP

                  HW_PortInit PROC
;;;210    //-----------------------------------------------------------------//
;;;211    void HW_PortInit(void)
000180  e92d4ffe          PUSH     {r1-r11,lr}
;;;212    {
;;;213    	PORT_InitTypeDef PORT_InitStructure;
;;;214      
;;;215    	
;;;216    	PORT_DeInit(MDR_PORTA);
000184  f8dfb28c          LDR      r11,|L1.1044|
000188  4658              MOV      r0,r11
00018a  f7fffffe          BL       PORT_DeInit
;;;217    	PORT_DeInit(MDR_PORTB);
00018e  48a2              LDR      r0,|L1.1048|
000190  f7fffffe          BL       PORT_DeInit
;;;218    	PORT_DeInit(MDR_PORTC);
000194  48a1              LDR      r0,|L1.1052|
000196  f7fffffe          BL       PORT_DeInit
;;;219    	PORT_DeInit(MDR_PORTD);
00019a  48a1              LDR      r0,|L1.1056|
00019c  f7fffffe          BL       PORT_DeInit
;;;220    	PORT_DeInit(MDR_PORTE);
0001a0  48a0              LDR      r0,|L1.1060|
0001a2  f7fffffe          BL       PORT_DeInit
;;;221    	PORT_DeInit(MDR_PORTF);
0001a6  48a0              LDR      r0,|L1.1064|
0001a8  f7fffffe          BL       PORT_DeInit
;;;222    	
;;;223    	// default output value is 0
;;;224    	// Set some outputs the default design values of 1
;;;225    	//PORT_SetBits(MDR_PORTA, (1<<BUZ1) | (1<<BUZ2) );
;;;226    	PORT_SetBits(MDR_PORTB, (1<<LGREEN) | (1<<LRED) );
0001ac  21c0              MOVS     r1,#0xc0
0001ae  489a              LDR      r0,|L1.1048|
0001b0  f7fffffe          BL       PORT_SetBits
;;;227    	
;;;228    	/*
;;;229    	   Reset PORT initialization structure parameters values 
;;;230      PORT_InitStruct->PORT_Pin        = PORT_Pin_All;
;;;231      PORT_InitStruct->PORT_OE         = PORT_OE_IN;
;;;232      PORT_InitStruct->PORT_PULL_UP    = PORT_PULL_UP_OFF;
;;;233      PORT_InitStruct->PORT_PULL_DOWN  = PORT_PULL_DOWN_OFF;
;;;234      PORT_InitStruct->PORT_PD_SHM     = PORT_PD_SHM_OFF;
;;;235      PORT_InitStruct->PORT_PD         = PORT_PD_DRIVER;
;;;236      PORT_InitStruct->PORT_GFEN       = PORT_GFEN_OFF;
;;;237      PORT_InitStruct->PORT_FUNC       = PORT_FUNC_PORT;
;;;238      PORT_InitStruct->PORT_SPEED      = PORT_OUTPUT_OFF;
;;;239      PORT_InitStruct->PORT_MODE       = PORT_MODE_ANALOG;
;;;240    	*/
;;;241    	
;;;242    	//================= PORTA =================//
;;;243    	PORT_StructInit(&PORT_InitStructure);
0001b4  4668              MOV      r0,sp
0001b6  f7fffffe          BL       PORT_StructInit
;;;244    	
;;;245    	// Typical digital inputs:
;;;246    	PORT_InitStructure.PORT_Pin   = (1<<OVERLD) | (1<<ENC_BTN);
0001ba  2021              MOVS     r0,#0x21
0001bc  f8ad0000          STRH     r0,[sp,#0]
;;;247    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
0001c0  2401              MOVS     r4,#1
0001c2  f88d400a          STRB     r4,[sp,#0xa]
;;;248    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0001c6  4669              MOV      r1,sp
0001c8  4658              MOV      r0,r11
0001ca  f7fffffe          BL       PORT_Init
;;;249    	
;;;250    	// Digital input with pull-up
;;;251    	PORT_InitStructure.PORT_Pin   = (1<<EEN);
0001ce  f04f0904          MOV      r9,#4
0001d2  f8ad9000          STRH     r9,[sp,#0]
;;;252    	PORT_InitStructure.PORT_PULL_UP  = PORT_PULL_UP_ON;
0001d6  f88d4003          STRB     r4,[sp,#3]
;;;253    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0001da  4669              MOV      r1,sp
0001dc  4658              MOV      r0,r11
0001de  f7fffffe          BL       PORT_Init
;;;254    	
;;;255    	// Typical digital outputs:
;;;256    	PORT_InitStructure.PORT_Pin   = (1<<CLIM_SEL);
0001e2  2502              MOVS     r5,#2
0001e4  f8ad5000          STRH     r5,[sp,#0]
;;;257    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
0001e8  f88d4002          STRB     r4,[sp,#2]
;;;258    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
0001ec  f88d4009          STRB     r4,[sp,#9]
;;;259    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0001f0  4669              MOV      r1,sp
0001f2  4658              MOV      r0,r11
0001f4  f7fffffe          BL       PORT_Init
;;;260    	
;;;261    	// Timer outputs to buzzer (TMR1.CH2, TMR1.CH2N)
;;;262    	PORT_InitStructure.PORT_Pin   = (1<<BUZ1) | (1<<BUZ2);
0001f8  2018              MOVS     r0,#0x18
0001fa  f8ad0000          STRH     r0,[sp,#0]
;;;263    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
0001fe  f88d5008          STRB     r5,[sp,#8]
;;;264    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
000202  4669              MOV      r1,sp
000204  4658              MOV      r0,r11
000206  f7fffffe          BL       PORT_Init
;;;265    	
;;;266    	// USART1 pins	
;;;267    	PORT_StructInit(&PORT_InitStructure);
00020a  4668              MOV      r0,sp
00020c  f7fffffe          BL       PORT_StructInit
;;;268    	// TX pin
;;;269    	PORT_InitStructure.PORT_Pin   = 1<<TXD1;
000210  f04f0a80          MOV      r10,#0x80
000214  f8ada000          STRH     r10,[sp,#0]
;;;270    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
000218  f88d400a          STRB     r4,[sp,#0xa]
;;;271    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
00021c  f88d5009          STRB     r5,[sp,#9]
;;;272    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_OVERRID;
000220  2603              MOVS     r6,#3
000222  f88d6008          STRB     r6,[sp,#8]
;;;273    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
000226  f88d4002          STRB     r4,[sp,#2]
;;;274    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
00022a  4669              MOV      r1,sp
00022c  4658              MOV      r0,r11
00022e  f7fffffe          BL       PORT_Init
;;;275    	// RX pin
;;;276    	PORT_InitStructure.PORT_Pin   = 1<<RXD1;
000232  2740              MOVS     r7,#0x40
000234  f8ad7000          STRH     r7,[sp,#0]
;;;277    	PORT_InitStructure.PORT_OE    = PORT_OE_IN;
000238  f04f0800          MOV      r8,#0
00023c  f88d8002          STRB     r8,[sp,#2]
;;;278    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
000240  4669              MOV      r1,sp
000242  4658              MOV      r0,r11
000244  f7fffffe          BL       PORT_Init
;;;279    	
;;;280    	// debug
;;;281    /*	PORT_StructInit(&PORT_InitStructure);
;;;282    	PORT_InitStructure.PORT_Pin   = (1<<TXD1) | (1<<RXD1);
;;;283    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
;;;284    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
;;;285    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
;;;286    	PORT_Init(MDR_PORTA, &PORT_InitStructure); */
;;;287    
;;;288    	//================= PORTB =================//
;;;289    	PORT_StructInit(&PORT_InitStructure);
000248  4668              MOV      r0,sp
00024a  f7fffffe          BL       PORT_StructInit
;;;290    	
;;;291    	// Typical digital inputs: buttons and encoder
;;;292    	PORT_InitStructure.PORT_Pin   = (1<<SB_ESC) | (1<<SB_LEFT) | (1<<SB_RIGHT) | (1<<SB_OK) | (1<<SB_MODE) | (1<<ENCA) | (1<<ENCB) | (1<<PG) ;
00024e  f2407037          MOV      r0,#0x737
000252  f8ad0000          STRH     r0,[sp,#0]
;;;293    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
000256  f88d400a          STRB     r4,[sp,#0xa]
;;;294    	PORT_Init(MDR_PORTB, &PORT_InitStructure);
00025a  4669              MOV      r1,sp
00025c  486e              LDR      r0,|L1.1048|
00025e  f7fffffe          BL       PORT_Init
;;;295    	
;;;296    	// Power good 
;;;297    	// TODO: add interrupt
;;;298    	PORT_InitStructure.PORT_Pin   = (1<<PG) ;
000262  02a0              LSLS     r0,r4,#10
000264  f8ad0000          STRH     r0,[sp,#0]
;;;299    	PORT_Init(MDR_PORTB, &PORT_InitStructure);
000268  4669              MOV      r1,sp
00026a  486b              LDR      r0,|L1.1048|
00026c  f7fffffe          BL       PORT_Init
;;;300    	
;;;301    	// Leds and buttons SB_ON, SB_OFF
;;;302    	PORT_InitStructure.PORT_Pin   = (1<<LGREEN) | (1<<LRED);
000270  20c0              MOVS     r0,#0xc0
000272  f8ad0000          STRH     r0,[sp,#0]
;;;303    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
000276  f88d4002          STRB     r4,[sp,#2]
;;;304    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
00027a  f88d4009          STRB     r4,[sp,#9]
;;;305    	PORT_Init(MDR_PORTB, &PORT_InitStructure);
00027e  4669              MOV      r1,sp
000280  4865              LDR      r0,|L1.1048|
000282  f7fffffe          BL       PORT_Init
;;;306    
;;;307    	
;;;308    	//================= PORTC =================//
;;;309    	PORT_StructInit(&PORT_InitStructure);
000286  4668              MOV      r0,sp
000288  f7fffffe          BL       PORT_StructInit
;;;310    	
;;;311    	// LCD Backlight (TMR3.CH1)
;;;312    	PORT_InitStructure.PORT_Pin   = (1<<LCD_BL);
00028c  f8ad9000          STRH     r9,[sp,#0]
;;;313    	PORT_InitStructure.PORT_MODE = PORT_MODE_DIGITAL;
000290  f88d400a          STRB     r4,[sp,#0xa]
;;;314    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
000294  f88d5008          STRB     r5,[sp,#8]
;;;315    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
000298  f88d4009          STRB     r4,[sp,#9]
;;;316    	PORT_Init(MDR_PORTC, &PORT_InitStructure);
00029c  4669              MOV      r1,sp
00029e  485f              LDR      r0,|L1.1052|
0002a0  f7fffffe          BL       PORT_Init
;;;317    	
;;;318    	// I2C
;;;319    	PORT_InitStructure.PORT_Pin = (1<<SCL) | (1<<SDA);
0002a4  f8ad6000          STRH     r6,[sp,#0]
;;;320    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
0002a8  f88d5009          STRB     r5,[sp,#9]
;;;321    	PORT_Init(MDR_PORTC, &PORT_InitStructure);
0002ac  4669              MOV      r1,sp
0002ae  485b              LDR      r0,|L1.1052|
0002b0  f7fffffe          BL       PORT_Init
;;;322    	
;;;323    	
;;;324    	//================= PORTD =================//
;;;325    	PORT_StructInit(&PORT_InitStructure);
0002b4  4668              MOV      r0,sp
0002b6  f7fffffe          BL       PORT_StructInit
;;;326    	
;;;327    	// Analog functions
;;;328    	PORT_InitStructure.PORT_Pin   = (1<<VREF_P) | (1<<VREF_N) | (1<<TEMP_IN) | (1<<UADC) | (1<<IADC) ;
0002ba  2097              MOVS     r0,#0x97
0002bc  f8ad0000          STRH     r0,[sp,#0]
;;;329    	PORT_Init(MDR_PORTD, &PORT_InitStructure);
0002c0  4669              MOV      r1,sp
0002c2  4857              LDR      r0,|L1.1056|
0002c4  f7fffffe          BL       PORT_Init
;;;330    	
;;;331    	// LCD CLK and CS
;;;332    	PORT_InitStructure.PORT_Pin   = (1<<LCD_CLK) | (1<<LCD_CS) ;
0002c8  2028              MOVS     r0,#0x28
0002ca  f8ad0000          STRH     r0,[sp,#0]
;;;333    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
0002ce  f88d400a          STRB     r4,[sp,#0xa]
;;;334    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
0002d2  f88d5008          STRB     r5,[sp,#8]
;;;335    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
0002d6  f88d5009          STRB     r5,[sp,#9]
;;;336    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
0002da  f88d4002          STRB     r4,[sp,#2]
;;;337    	PORT_Init(MDR_PORTD, &PORT_InitStructure);
0002de  4669              MOV      r1,sp
0002e0  484f              LDR      r0,|L1.1056|
0002e2  f7fffffe          BL       PORT_Init
;;;338    	
;;;339    	// MOSI 
;;;340    	PORT_InitStructure.PORT_Pin   = (1<<LCD_MOSI);
0002e6  f8ad7000          STRH     r7,[sp,#0]
;;;341    	PORT_InitStructure.PORT_PULL_DOWN = PORT_PULL_DOWN_ON;
0002ea  f88d4004          STRB     r4,[sp,#4]
;;;342    	PORT_Init(MDR_PORTD, &PORT_InitStructure);
0002ee  4669              MOV      r1,sp
0002f0  484b              LDR      r0,|L1.1056|
0002f2  f7fffffe          BL       PORT_Init
;;;343    	
;;;344    
;;;345    	
;;;346    	//================= PORTE =================//
;;;347    	PORT_StructInit(&PORT_InitStructure);
0002f6  4668              MOV      r0,sp
0002f8  f7fffffe          BL       PORT_StructInit
;;;348    			
;;;349    	// LCD RST and SEL, Load disable output
;;;350    	PORT_InitStructure.PORT_Pin   = (1<<LCD_RST) | (1<<LCD_SEL) | (1<<LDIS);
0002fc  2045              MOVS     r0,#0x45
0002fe  f8ad0000          STRH     r0,[sp,#0]
;;;351    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
000302  f88d400a          STRB     r4,[sp,#0xa]
;;;352    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
000306  f88d5009          STRB     r5,[sp,#9]
;;;353    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
00030a  f88d4002          STRB     r4,[sp,#2]
;;;354    	PORT_Init(MDR_PORTE, &PORT_InitStructure);
00030e  4669              MOV      r1,sp
000310  4844              LDR      r0,|L1.1060|
000312  f7fffffe          BL       PORT_Init
;;;355    
;;;356    	// cooler PWM output (TMR3.CH3N)
;;;357    	PORT_InitStructure.PORT_Pin   = (1<<CPWM);
000316  f8ada000          STRH     r10,[sp,#0]
;;;358    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_OVERRID;
00031a  f88d6008          STRB     r6,[sp,#8]
;;;359    	PORT_Init(MDR_PORTE, &PORT_InitStructure);
00031e  4669              MOV      r1,sp
000320  4840              LDR      r0,|L1.1060|
000322  f7fffffe          BL       PORT_Init
;;;360    	
;;;361    	// voltage and current PWM outputs (TMR2.CH1N, TMR2.CH3N)
;;;362    	PORT_InitStructure.PORT_Pin   = (1<<UPWM) | (1<<IPWM);
000326  200a              MOVS     r0,#0xa
000328  f8ad0000          STRH     r0,[sp,#0]
;;;363    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
00032c  f88d5008          STRB     r5,[sp,#8]
;;;364    	PORT_Init(MDR_PORTE, &PORT_InitStructure);
000330  4669              MOV      r1,sp
000332  483c              LDR      r0,|L1.1060|
000334  f7fffffe          BL       PORT_Init
;;;365    	
;;;366    	
;;;367    	
;;;368    	//================= PORTF =================//
;;;369    	PORT_StructInit(&PORT_InitStructure);
000338  4668              MOV      r0,sp
00033a  f7fffffe          BL       PORT_StructInit
;;;370    	
;;;371    	// Feedback channel select, converter enable
;;;372    	PORT_InitStructure.PORT_Pin   = (1<<EN) | (1<<STAB_SEL) ;
00033e  200c              MOVS     r0,#0xc
000340  f8ad0000          STRH     r0,[sp,#0]
;;;373    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
000344  f88d400a          STRB     r4,[sp,#0xa]
;;;374    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
000348  f88d4009          STRB     r4,[sp,#9]
;;;375    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
00034c  f88d4002          STRB     r4,[sp,#2]
;;;376    	PORT_Init(MDR_PORTF, &PORT_InitStructure);
000350  4669              MOV      r1,sp
000352  4835              LDR      r0,|L1.1064|
000354  f7fffffe          BL       PORT_Init
;;;377    	
;;;378    	// USART2 functions	
;;;379    	PORT_StructInit(&PORT_InitStructure);
000358  4668              MOV      r0,sp
00035a  f7fffffe          BL       PORT_StructInit
;;;380    	// TX pin
;;;381    	PORT_InitStructure.PORT_Pin   = 1<<TXD2;
00035e  f8ad5000          STRH     r5,[sp,#0]
;;;382    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
000362  f88d400a          STRB     r4,[sp,#0xa]
;;;383    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
000366  f88d5009          STRB     r5,[sp,#9]
;;;384    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_OVERRID;
00036a  f88d6008          STRB     r6,[sp,#8]
;;;385    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
00036e  f88d4002          STRB     r4,[sp,#2]
;;;386    	PORT_Init(MDR_PORTF, &PORT_InitStructure);
000372  4669              MOV      r1,sp
000374  482c              LDR      r0,|L1.1064|
000376  f7fffffe          BL       PORT_Init
;;;387    	// RX pin
;;;388    	PORT_InitStructure.PORT_Pin   = 1<<RXD2;
00037a  f8ad4000          STRH     r4,[sp,#0]
;;;389    	PORT_InitStructure.PORT_OE    = PORT_OE_IN;
00037e  f88d8002          STRB     r8,[sp,#2]
;;;390    	PORT_Init(MDR_PORTF, &PORT_InitStructure);
000382  4669              MOV      r1,sp
000384  4828              LDR      r0,|L1.1064|
000386  f7fffffe          BL       PORT_Init
;;;391    }
00038a  e8bd8ffe          POP      {r1-r11,pc}
;;;392    
                          ENDP

                  HW_UARTInit PROC
;;;399    //-----------------------------------------------------------------//
;;;400    void HW_UARTInit(void)
00038e  e92d47ff          PUSH     {r0-r10,lr}
;;;401    {
;;;402    	BaudRateStatus initStatus;
;;;403    	UART_InitTypeDef sUART;
;;;404    	UART_StructInit(&sUART);
000392  4668              MOV      r0,sp
000394  f7fffffe          BL       UART_StructInit
;;;405    	
;;;406    	//--------------- UART2 INIT ---------------//
;;;407    	UART_DeInit(MDR_UART2);
000398  f8df9090          LDR      r9,|L1.1068|
00039c  4648              MOV      r0,r9
00039e  f7fffffe          BL       UART_DeInit
;;;408    	
;;;409    	sUART.UART_BaudRate                           = 115200;
0003a2  f44f36e1          MOV      r6,#0x1c200
0003a6  9600              STR      r6,[sp,#0]
;;;410    	sUART.UART_WordLength                         = UART_WordLength8b;
0003a8  2760              MOVS     r7,#0x60
0003aa  f8ad7004          STRH     r7,[sp,#4]
;;;411    	sUART.UART_StopBits                           = UART_StopBits1;
0003ae  2400              MOVS     r4,#0
0003b0  f8ad4006          STRH     r4,[sp,#6]
;;;412    	sUART.UART_Parity                             = UART_Parity_No;
0003b4  f8ad4008          STRH     r4,[sp,#8]
;;;413    	sUART.UART_FIFOMode                           = UART_FIFO_ON;
0003b8  f04f0810          MOV      r8,#0x10
0003bc  f8ad800a          STRH     r8,[sp,#0xa]
;;;414    	sUART.UART_HardwareFlowControl                = (UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE );
0003c0  00fd              LSLS     r5,r7,#3
0003c2  f8ad500c          STRH     r5,[sp,#0xc]
;;;415    	
;;;416    	UART_BRGInit(MDR_UART2,UART_HCLKdiv1);
0003c6  2100              MOVS     r1,#0
0003c8  4648              MOV      r0,r9
0003ca  f7fffffe          BL       UART_BRGInit
;;;417    	initStatus = UART_Init(MDR_UART2,&sUART);
0003ce  4669              MOV      r1,sp
0003d0  4648              MOV      r0,r9
0003d2  f7fffffe          BL       UART_Init
;;;418    	UART_Cmd(MDR_UART2,ENABLE);
0003d6  2101              MOVS     r1,#1
0003d8  4648              MOV      r0,r9
0003da  f7fffffe          BL       UART_Cmd
;;;419    	
;;;420    	//--------------- UART1 INIT ---------------//
;;;421    	UART_DeInit(MDR_UART1);
0003de  f8dfa050          LDR      r10,|L1.1072|
0003e2  4650              MOV      r0,r10
0003e4  f7fffffe          BL       UART_DeInit
;;;422    	
;;;423    	sUART.UART_BaudRate                           = 115200;
0003e8  9600              STR      r6,[sp,#0]
;;;424    	sUART.UART_WordLength                         = UART_WordLength8b;
0003ea  f8ad7004          STRH     r7,[sp,#4]
;;;425    	sUART.UART_StopBits                           = UART_StopBits1;
0003ee  f8ad4006          STRH     r4,[sp,#6]
;;;426    	sUART.UART_Parity                             = UART_Parity_No;
0003f2  f8ad4008          STRH     r4,[sp,#8]
;;;427    	sUART.UART_FIFOMode                           = UART_FIFO_ON;
0003f6  e01d              B        |L1.1076|
                  |L1.1016|
                          DCD      DMA_ControlTable
                  |L1.1020|
                          DCD      0x40028000
                  |L1.1024|
                          DCD      0x23e00000
                  |L1.1028|
                          DCD      0x0013c4e0
                  |L1.1032|
                          DCD      0xe000ed0c
                  |L1.1036|
                          DCD      0x05fa0000
                  |L1.1040|
                          DCD      ||.bss||
                  |L1.1044|
                          DCD      0x400a8000
                  |L1.1048|
                          DCD      0x400b0000
                  |L1.1052|
                          DCD      0x400b8000
                  |L1.1056|
                          DCD      0x400c0000
                  |L1.1060|
                          DCD      0x400c8000
                  |L1.1064|
                          DCD      0x400e8000
                  |L1.1068|
                          DCD      0x40038000
                  |L1.1072|
                          DCD      0x40030000
                  |L1.1076|
000434  f8ad800a          STRH     r8,[sp,#0xa]
;;;428    	sUART.UART_HardwareFlowControl                = (UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE );
000438  f8ad500c          STRH     r5,[sp,#0xc]
;;;429    	
;;;430    	UART_BRGInit(MDR_UART1,UART_HCLKdiv1);
00043c  2100              MOVS     r1,#0
00043e  4650              MOV      r0,r10
000440  f7fffffe          BL       UART_BRGInit
;;;431    	initStatus = UART_Init(MDR_UART1,&sUART);
000444  4669              MOV      r1,sp
000446  4650              MOV      r0,r10
000448  f7fffffe          BL       UART_Init
;;;432    	UART_Cmd(MDR_UART1,ENABLE);
00044c  2101              MOVS     r1,#1
00044e  4650              MOV      r0,r10
000450  f7fffffe          BL       UART_Cmd
;;;433    	
;;;434    	//------------ UART DMA features------------//
;;;435    	UART_DMAConfig(MDR_UART1,UART_IT_FIFO_LVL_8words,UART_IT_FIFO_LVL_8words);		// ?
000454  2202              MOVS     r2,#2
000456  4611              MOV      r1,r2
000458  4650              MOV      r0,r10
00045a  f7fffffe          BL       UART_DMAConfig
;;;436    	UART_DMAConfig(MDR_UART2,UART_IT_FIFO_LVL_8words,UART_IT_FIFO_LVL_8words);		//
00045e  2202              MOVS     r2,#2
000460  4611              MOV      r1,r2
000462  4648              MOV      r0,r9
000464  f7fffffe          BL       UART_DMAConfig
;;;437    	
;;;438    	/* Enable UART1 DMA Rx and Tx request */
;;;439    //	UART_DMACmd(MDR_UART1,(UART_DMA_RXE | UART_DMA_TXE), ENABLE);
;;;440    	/* Enable UART2 DMA Rx and Tx request */
;;;441    //	UART_DMACmd(MDR_UART2,(UART_DMA_RXE | UART_DMA_TXE), ENABLE);
;;;442    }
000468  e8bd87ff          POP      {r0-r10,pc}
;;;443    
                          ENDP

                  HW_DMAInit PROC
;;;447    //-----------------------------------------------------------------//
;;;448    void HW_DMAInit(void)
00046c  b570              PUSH     {r4-r6,lr}
;;;449    {
;;;450    	// Reset all DMA settings
;;;451    	DMA_DeInit();	
00046e  f7fffffe          BL       DMA_DeInit
;;;452    	
;;;453    	// Vital for proper DMA IRQ function
;;;454    	// Single requests from ADC?
;;;455    	MDR_DMA->CHNL_REQ_MASK_SET = 0xFFFFFFFF;	// Disable all requests
000472  48f8              LDR      r0,|L1.2132|
000474  f04f34ff          MOV      r4,#0xffffffff
000478  6204              STR      r4,[r0,#0x20]
;;;456    	MDR_DMA->CHNL_USEBURST_SET = 0xFFFFFFFF;	// disable sreq[]
00047a  6184              STR      r4,[r0,#0x18]
;;;457    	
;;;458    	// MDR32F9Qx false DMA requests workaround
;;;459    	// This must be executed next to clock setup
;;;460    	RST_CLK_PCLKcmd(RST_CLK_PCLK_SSP1 ,ENABLE);
00047c  1586              ASRS     r6,r0,#22
00047e  2101              MOVS     r1,#1
000480  4630              MOV      r0,r6
000482  f7fffffe          BL       RST_CLK_PCLKcmd
;;;461    	SSP_BRGInit(MDR_SSP1,SSP_HCLKdiv1);		
000486  4df4              LDR      r5,|L1.2136|
000488  2100              MOVS     r1,#0
00048a  4628              MOV      r0,r5
00048c  f7fffffe          BL       SSP_BRGInit
;;;462    	MDR_SSP1->DMACR = 0;					// Reset false requests
000490  2100              MOVS     r1,#0
000492  6269              STR      r1,[r5,#0x24]
;;;463    	MDR_SSP2->DMACR = 0;
000494  48f1              LDR      r0,|L1.2140|
000496  6241              STR      r1,[r0,#0x24]
;;;464    	RST_CLK_PCLKcmd(RST_CLK_PCLK_SSP1 ,DISABLE);
000498  4630              MOV      r0,r6
00049a  f7fffffe          BL       RST_CLK_PCLKcmd
;;;465    	
;;;466    	NVIC->ICPR[0] = 0xFFFFFFFF;		// Reset all pending interrupts
00049e  4af0              LDR      r2,|L1.2144|
0004a0  f8c241fc          STR      r4,[r2,#0x1fc]
;;;467    	NVIC->ICER[0] = 0xFFFFFFFF;		// Disable all interrupts
0004a4  f8c240fc          STR      r4,[r2,#0xfc]
;;;468    	
;;;469    	my_DMA_GlobalInit();
0004a8  f7fffffe          BL       my_DMA_GlobalInit
0004ac  2020              MOVS     r0,#0x20
0004ae  67d0              STR      r0,[r2,#0x7c]
;;;470    	
;;;471    	NVIC_EnableIRQ(DMA_IRQn);
;;;472    }
0004b0  bd70              POP      {r4-r6,pc}
;;;473    
                          ENDP

                  HW_SSPInit PROC
;;;482    //-----------------------------------------------------------------//
;;;483    void HW_SSPInit(void)
0004b2  b51f              PUSH     {r0-r4,lr}
;;;484    {
;;;485    	SSP_InitTypeDef sSSP;
;;;486    	SSP_StructInit (&sSSP);
0004b4  4668              MOV      r0,sp
0004b6  f7fffffe          BL       SSP_StructInit
;;;487    
;;;488    	SSP_BRGInit(MDR_SSP2,SSP_HCLKdiv1);		// F_SSPCLK = HCLK / 1
0004ba  4ce8              LDR      r4,|L1.2140|
0004bc  2100              MOVS     r1,#0
0004be  4620              MOV      r0,r4
0004c0  f7fffffe          BL       SSP_BRGInit
;;;489    	
;;;490    	sSSP.SSP_SCR  = 0x04;		// 0 to 255
0004c4  2004              MOVS     r0,#4
0004c6  f8ad0000          STRH     r0,[sp,#0]
;;;491    	sSSP.SSP_CPSDVSR = 2;		// even 2 to 254
0004ca  2202              MOVS     r2,#2
0004cc  f8ad2002          STRH     r2,[sp,#2]
;;;492    	sSSP.SSP_Mode = SSP_ModeMaster;
0004d0  2100              MOVS     r1,#0
0004d2  f8ad1004          STRH     r1,[sp,#4]
;;;493    	sSSP.SSP_WordLength = SSP_WordLength9b;
0004d6  2008              MOVS     r0,#8
0004d8  f8ad0006          STRH     r0,[sp,#6]
;;;494    	sSSP.SSP_SPH = SSP_SPH_1Edge;
0004dc  f8ad1008          STRH     r1,[sp,#8]
;;;495    	sSSP.SSP_SPO = SSP_SPO_Low;
0004e0  f8ad100a          STRH     r1,[sp,#0xa]
;;;496    	sSSP.SSP_FRF = SSP_FRF_SPI_Motorola;
0004e4  f8ad100c          STRH     r1,[sp,#0xc]
;;;497    	sSSP.SSP_HardwareFlowControl = SSP_HardwareFlowControl_SSE;
0004e8  f8ad200e          STRH     r2,[sp,#0xe]
;;;498    	SSP_Init (MDR_SSP2,&sSSP);
0004ec  4669              MOV      r1,sp
0004ee  4620              MOV      r0,r4
0004f0  f7fffffe          BL       SSP_Init
;;;499    
;;;500    	SSP_Cmd(MDR_SSP2, ENABLE);
0004f4  2101              MOVS     r1,#1
0004f6  4620              MOV      r0,r4
0004f8  f7fffffe          BL       SSP_Cmd
;;;501    }
0004fc  bd1f              POP      {r0-r4,pc}
;;;502    
                          ENDP

                  HW_I2CInit PROC
;;;507    //-----------------------------------------------------------------//
;;;508    void HW_I2CInit(void)
0004fe  b51c              PUSH     {r2-r4,lr}
;;;509    {
;;;510    	//--------------- I2C INIT ---------------//
;;;511    I2C_InitTypeDef I2C_InitStruct;
;;;512    	
;;;513    	// Enables I2C peripheral
;;;514    	I2C_Cmd(ENABLE);
000500  2001              MOVS     r0,#1
000502  f7fffffe          BL       I2C_Cmd
;;;515    	
;;;516    	// Initialize I2C_InitStruct
;;;517    	I2C_InitStruct.I2C_ClkDiv = 256;		// 0x0000 to 0xFFFF
000506  f44f7080          MOV      r0,#0x100
00050a  9000              STR      r0,[sp,#0]
;;;518    	I2C_InitStruct.I2C_Speed = I2C_SPEED_UP_TO_400KHz;
00050c  2000              MOVS     r0,#0
00050e  9001              STR      r0,[sp,#4]
;;;519    
;;;520    	// Configure I2C parameters
;;;521    	I2C_Init(&I2C_InitStruct);
000510  4668              MOV      r0,sp
000512  f7fffffe          BL       I2C_Init
;;;522    }
000516  bd1c              POP      {r2-r4,pc}
;;;523    
                          ENDP

                  HW_ADCInit PROC
;;;531    //-----------------------------------------------------------------//
;;;532    void HW_ADCInit(void)
000518  b530              PUSH     {r4,r5,lr}
;;;533    {
00051a  b093              SUB      sp,sp,#0x4c
;;;534    	ADC_InitTypeDef sADC;
;;;535    	ADCx_InitTypeDef sADCx;
;;;536    	
;;;537    	// ADC Configuration
;;;538    	// Reset all ADC settings
;;;539    	ADC_DeInit();
00051c  f7fffffe          BL       ADC_DeInit
;;;540    	ADC_StructInit(&sADC);
000520  a80c              ADD      r0,sp,#0x30
000522  f7fffffe          BL       ADC_StructInit
;;;541    
;;;542    	sADC.ADC_SynchronousMode      = ADC_SyncMode_Independent;
000526  2400              MOVS     r4,#0
000528  940c              STR      r4,[sp,#0x30]
;;;543    	sADC.ADC_StartDelay           = 10;
00052a  200a              MOVS     r0,#0xa
00052c  900d              STR      r0,[sp,#0x34]
;;;544    	sADC.ADC_TempSensor           = ADC_TEMP_SENSOR_Enable;
00052e  f44f3000          MOV      r0,#0x20000
000532  900e              STR      r0,[sp,#0x38]
;;;545    	sADC.ADC_TempSensorAmplifier  = ADC_TEMP_SENSOR_AMPLIFIER_Enable;
000534  0040              LSLS     r0,r0,#1
000536  900f              STR      r0,[sp,#0x3c]
;;;546    	sADC.ADC_TempSensorConversion = ADC_TEMP_SENSOR_CONVERSION_Enable;
000538  0040              LSLS     r0,r0,#1
00053a  9010              STR      r0,[sp,#0x40]
;;;547    	sADC.ADC_IntVRefConversion    = ADC_VREF_CONVERSION_Enable;
00053c  0040              LSLS     r0,r0,#1
00053e  9011              STR      r0,[sp,#0x44]
;;;548    	sADC.ADC_IntVRefTrimming      = 1;
000540  2501              MOVS     r5,#1
000542  9512              STR      r5,[sp,#0x48]
;;;549    	ADC_Init (&sADC);
000544  a80c              ADD      r0,sp,#0x30
000546  f7fffffe          BL       ADC_Init
;;;550    
;;;551    	// ADC1 Configuration 
;;;552    	ADCx_StructInit (&sADCx);
00054a  a801              ADD      r0,sp,#4
00054c  f7fffffe          BL       ADCx_StructInit
;;;553    	sADCx.ADC_ClockSource      = ADC_CLOCK_SOURCE_ADC;
000550  2004              MOVS     r0,#4
000552  9001              STR      r0,[sp,#4]
;;;554    	sADCx.ADC_SamplingMode     = ADC_SAMPLING_MODE_SINGLE_CONV;
000554  9402              STR      r4,[sp,#8]
;;;555    	sADCx.ADC_ChannelSwitching = ADC_CH_SWITCHING_Disable;
000556  9403              STR      r4,[sp,#0xc]
;;;556    	sADCx.ADC_ChannelNumber    = ADC_CH_TEMP_SENSOR;		
000558  201f              MOVS     r0,#0x1f
00055a  9004              STR      r0,[sp,#0x10]
;;;557    	sADCx.ADC_Channels         = 0;
00055c  9405              STR      r4,[sp,#0x14]
;;;558    	sADCx.ADC_LevelControl     = ADC_LEVEL_CONTROL_Disable;
00055e  9406              STR      r4,[sp,#0x18]
;;;559    	sADCx.ADC_LowLevel         = 0;
000560  f8ad401c          STRH     r4,[sp,#0x1c]
;;;560    	sADCx.ADC_HighLevel        = 0;
000564  f8ad401e          STRH     r4,[sp,#0x1e]
;;;561    	sADCx.ADC_VRefSource       = ADC_VREF_SOURCE_EXTERNAL;
000568  02e8              LSLS     r0,r5,#11
00056a  9008              STR      r0,[sp,#0x20]
;;;562    	sADCx.ADC_IntVRefSource    = ADC_INT_VREF_SOURCE_EXACT;
00056c  9509              STR      r5,[sp,#0x24]
;;;563    	sADCx.ADC_Prescaler        = ADC_CLK_div_128;
00056e  f44f40e0          MOV      r0,#0x7000
000572  900a              STR      r0,[sp,#0x28]
;;;564    	sADCx.ADC_DelayGo          = 0;		// CHECKME
000574  940b              STR      r4,[sp,#0x2c]
;;;565    	ADC1_Init (&sADCx);
000576  a801              ADD      r0,sp,#4
000578  f7fffffe          BL       ADC1_Init
;;;566    	ADC2_Init (&sADCx);
00057c  a801              ADD      r0,sp,#4
00057e  f7fffffe          BL       ADC2_Init
;;;567    
;;;568    	// Disable ADC interupts
;;;569    	ADC1_ITConfig((ADCx_IT_END_OF_CONVERSION  | ADCx_IT_OUT_OF_RANGE), DISABLE);
000582  2100              MOVS     r1,#0
000584  2006              MOVS     r0,#6
000586  f7fffffe          BL       ADC1_ITConfig
;;;570    	ADC2_ITConfig((ADCx_IT_END_OF_CONVERSION  | ADCx_IT_OUT_OF_RANGE), DISABLE);
00058a  2100              MOVS     r1,#0
00058c  2006              MOVS     r0,#6
00058e  f7fffffe          BL       ADC2_ITConfig
;;;571    
;;;572    	// ADC1 enable
;;;573    	ADC1_Cmd (ENABLE);
000592  2001              MOVS     r0,#1
000594  f7fffffe          BL       ADC1_Cmd
;;;574    	ADC2_Cmd (ENABLE);
000598  2001              MOVS     r0,#1
00059a  f7fffffe          BL       ADC2_Cmd
;;;575    	
;;;576    	
;;;577    	//-------------------//
;;;578    /*	ADC1_SetChannel(ADC_CH_TEMP_SENSOR);
;;;579    	ADC1_Start();
;;;580    	while( ADC_GetFlagStatus(ADC1_FLAG_END_OF_CONVERSION)==RESET );
;;;581      temp_adc = ADC1_GetResult();
;;;582    	
;;;583    	ADC1_Start();
;;;584    	while( ADC_GetFlagStatus(ADC1_FLAG_END_OF_CONVERSION)==RESET );
;;;585      temp_adc = ADC1_GetResult();
;;;586    	
;;;587    	temp_adc = temp_adc;
;;;588    	*/
;;;589    	
;;;590    }
00059e  b013              ADD      sp,sp,#0x4c
0005a0  bd30              POP      {r4,r5,pc}
;;;591    
                          ENDP

                  HW_TimersInit PROC
;;;600    //-----------------------------------------------------------------//
;;;601    void HW_TimersInit(void)
0005a2  e92d43f0          PUSH     {r4-r9,lr}
;;;602    {
0005a6  b091              SUB      sp,sp,#0x44
;;;603    	TIMER_CntInitTypeDef sTIM_CntInit;
;;;604    	TIMER_ChnInitTypeDef sTIM_ChnInit;
;;;605    	TIMER_ChnOutInitTypeDef sTIM_ChnOutInit;
;;;606    	
;;;607    	//======================= TIMER1 =======================//
;;;608    	// Timer1		CH2		-> BUZ+
;;;609    	//				CH2N	-> BUZ-
;;;610    	// TIMER_CLK = HCLK
;;;611    	// CLK = 1MHz
;;;612    	// Default buzzer freq = 1 / 500us = 2kHz
;;;613    	
;;;614    	// Initialize timer 1 counter
;;;615    	TIMER_CntStructInit(&sTIM_CntInit);
0005a8  a80b              ADD      r0,sp,#0x2c
0005aa  f7fffffe          BL       TIMER_CntStructInit
;;;616    	sTIM_CntInit.TIMER_Prescaler                = 0x1F;		// 32MHz / (31 + 1) = 1MHz
0005ae  201f              MOVS     r0,#0x1f
0005b0  f8ad002e          STRH     r0,[sp,#0x2e]
;;;617    	sTIM_CntInit.TIMER_Period                   = 499;		
0005b4  f24010f3          MOV      r0,#0x1f3
0005b8  f8ad0030          STRH     r0,[sp,#0x30]
;;;618    	TIMER_CntInit (MDR_TIMER1,&sTIM_CntInit);
0005bc  4ea9              LDR      r6,|L1.2148|
0005be  a90b              ADD      r1,sp,#0x2c
0005c0  4630              MOV      r0,r6
0005c2  f7fffffe          BL       TIMER_CntInit
;;;619    	
;;;620    	// Initialize timer 1 channel 2
;;;621    	TIMER_ChnStructInit(&sTIM_ChnInit);
0005c6  a805              ADD      r0,sp,#0x14
0005c8  f7fffffe          BL       TIMER_ChnStructInit
;;;622    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
0005cc  2400              MOVS     r4,#0
0005ce  f8ad4016          STRH     r4,[sp,#0x16]
;;;623    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format6;
0005d2  f44f6840          MOV      r8,#0xc00
0005d6  f8ad801e          STRH     r8,[sp,#0x1e]
;;;624    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL2;
0005da  2501              MOVS     r5,#1
0005dc  f8ad5014          STRH     r5,[sp,#0x14]
;;;625    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_On_CNT_eq_0;
0005e0  f04f0908          MOV      r9,#8
0005e4  f8ad9026          STRH     r9,[sp,#0x26]
;;;626    	TIMER_ChnInit(MDR_TIMER1, &sTIM_ChnInit);
0005e8  a905              ADD      r1,sp,#0x14
0005ea  4630              MOV      r0,r6
0005ec  f7fffffe          BL       TIMER_ChnInit
;;;627    	
;;;628    	// Initialize timer 1 channel 2 output
;;;629    	TIMER_ChnOutStructInit(&sTIM_ChnOutInit);
0005f0  4668              MOV      r0,sp
0005f2  f7fffffe          BL       TIMER_ChnOutStructInit
;;;630    	sTIM_ChnOutInit.TIMER_CH_DirOut_Polarity          = TIMER_CHOPolarity_NonInverted;
0005f6  f8ad4002          STRH     r4,[sp,#2]
;;;631    	sTIM_ChnOutInit.TIMER_CH_DirOut_Source            = TIMER_CH_OutSrc_Only_1;
0005fa  f8ad5004          STRH     r5,[sp,#4]
;;;632    	sTIM_ChnOutInit.TIMER_CH_DirOut_Mode              = TIMER_CH_OutMode_Output;
0005fe  f8ad5006          STRH     r5,[sp,#6]
;;;633    	sTIM_ChnOutInit.TIMER_CH_NegOut_Polarity          = TIMER_CHOPolarity_NonInverted;
000602  f8ad4008          STRH     r4,[sp,#8]
;;;634    	sTIM_ChnOutInit.TIMER_CH_NegOut_Source            = TIMER_CH_OutSrc_Only_1;
000606  f8ad500a          STRH     r5,[sp,#0xa]
;;;635    	sTIM_ChnOutInit.TIMER_CH_NegOut_Mode              = TIMER_CH_OutMode_Output;
00060a  f8ad500c          STRH     r5,[sp,#0xc]
;;;636    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL2;
00060e  f8ad5000          STRH     r5,[sp,#0]
;;;637    	TIMER_ChnOutInit(MDR_TIMER1, &sTIM_ChnOutInit);
000612  4669              MOV      r1,sp
000614  4630              MOV      r0,r6
000616  f7fffffe          BL       TIMER_ChnOutInit
;;;638    
;;;639    	// Set default buzzer duty
;;;640    	MDR_TIMER1->CCR2 = 249;	
00061a  20f9              MOVS     r0,#0xf9
00061c  6170              STR      r0,[r6,#0x14]
;;;641      
;;;642    	// Enable TIMER1 counter clock
;;;643    	TIMER_BRGInit(MDR_TIMER1,TIMER_HCLKdiv1);
00061e  2100              MOVS     r1,#0
000620  4630              MOV      r0,r6
000622  f7fffffe          BL       TIMER_BRGInit
;;;644    
;;;645    	// Enable TIMER1
;;;646    	TIMER_Cmd(MDR_TIMER1,ENABLE);
000626  2101              MOVS     r1,#1
000628  4630              MOV      r0,r6
00062a  f7fffffe          BL       TIMER_Cmd
;;;647    	
;;;648    	
;;;649    	
;;;650    	//======================= TIMER2 =======================//
;;;651    	// Timer2		CH1N	-> UPWM
;;;652    	//				CH3N	-> IPWM
;;;653    	// 				CH2		-> HW control interrupt generation
;;;654    	// TIMER_CLK = HCLK
;;;655    	// CLK = 16MHz
;;;656    	// PWM frequency = 3906.25 Hz (T = 256us)
;;;657    	// PWM resolution = 12 bit
;;;658    	
;;;659    	// Initialize timer 2 counter
;;;660    	TIMER_CntStructInit(&sTIM_CntInit);
00062e  a80b              ADD      r0,sp,#0x2c
000630  f7fffffe          BL       TIMER_CntStructInit
;;;661    	sTIM_CntInit.TIMER_Prescaler                = 0x1;		// CLK = 16MHz
000634  f8ad502e          STRH     r5,[sp,#0x2e]
;;;662    	sTIM_CntInit.TIMER_Period                   = 0xFFF;	// 16MHz / 4096 = 3906.25 Hz 
000638  f64070ff          MOV      r0,#0xfff
00063c  f8ad0030          STRH     r0,[sp,#0x30]
;;;663    	TIMER_CntInit (MDR_TIMER2,&sTIM_CntInit);
000640  4f89              LDR      r7,|L1.2152|
000642  a90b              ADD      r1,sp,#0x2c
000644  4638              MOV      r0,r7
000646  f7fffffe          BL       TIMER_CntInit
;;;664    
;;;665    	// Initialize timer 2 channels 1,3
;;;666    	TIMER_ChnStructInit(&sTIM_ChnInit);
00064a  a805              ADD      r0,sp,#0x14
00064c  f7fffffe          BL       TIMER_ChnStructInit
;;;667    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
000650  f8ad4016          STRH     r4,[sp,#0x16]
;;;668    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format6;
000654  f8ad801e          STRH     r8,[sp,#0x1e]
;;;669    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_On_CNT_eq_0;
000658  f8ad9026          STRH     r9,[sp,#0x26]
;;;670    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL1;			// voltage
00065c  f8ad4014          STRH     r4,[sp,#0x14]
;;;671    	TIMER_ChnInit(MDR_TIMER2, &sTIM_ChnInit);
000660  a905              ADD      r1,sp,#0x14
000662  4638              MOV      r0,r7
000664  f7fffffe          BL       TIMER_ChnInit
;;;672    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL3;			// curret
000668  2602              MOVS     r6,#2
00066a  f8ad6014          STRH     r6,[sp,#0x14]
;;;673    	TIMER_ChnInit(MDR_TIMER2, &sTIM_ChnInit);
00066e  a905              ADD      r1,sp,#0x14
000670  4638              MOV      r0,r7
000672  f7fffffe          BL       TIMER_ChnInit
;;;674    	
;;;675    	// Initialize timer 2 channel 2 - used for HW control interrupt generation
;;;676    	TIMER_ChnStructInit(&sTIM_ChnInit);
000676  a805              ADD      r0,sp,#0x14
000678  f7fffffe          BL       TIMER_ChnStructInit
;;;677    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
00067c  f8ad4016          STRH     r4,[sp,#0x16]
;;;678    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format1;	// REF output = 1 when CNT == CCR
000680  0268              LSLS     r0,r5,#9
000682  f8ad001e          STRH     r0,[sp,#0x1e]
;;;679    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL2;
000686  f8ad5014          STRH     r5,[sp,#0x14]
;;;680    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_Immediately;
00068a  f8ad4026          STRH     r4,[sp,#0x26]
;;;681    	TIMER_ChnInit(MDR_TIMER2, &sTIM_ChnInit);
00068e  a905              ADD      r1,sp,#0x14
000690  4638              MOV      r0,r7
000692  f7fffffe          BL       TIMER_ChnInit
;;;682    	
;;;683    	// Initialize timer 2 channels 1,3 output
;;;684    	TIMER_ChnOutStructInit(&sTIM_ChnOutInit);
000696  4668              MOV      r0,sp
000698  f7fffffe          BL       TIMER_ChnOutStructInit
;;;685    	sTIM_ChnOutInit.TIMER_CH_NegOut_Polarity          = TIMER_CHOPolarity_Inverted;
00069c  f8ad5008          STRH     r5,[sp,#8]
;;;686    	sTIM_ChnOutInit.TIMER_CH_NegOut_Source            = TIMER_CH_OutSrc_REF;
0006a0  f8ad600a          STRH     r6,[sp,#0xa]
;;;687    	sTIM_ChnOutInit.TIMER_CH_NegOut_Mode              = TIMER_CH_OutMode_Output;
0006a4  f8ad500c          STRH     r5,[sp,#0xc]
;;;688    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL1;
0006a8  f8ad4000          STRH     r4,[sp,#0]
;;;689    	TIMER_ChnOutInit(MDR_TIMER2, &sTIM_ChnOutInit);
0006ac  4669              MOV      r1,sp
0006ae  4638              MOV      r0,r7
0006b0  f7fffffe          BL       TIMER_ChnOutInit
;;;690    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL3;
0006b4  f8ad6000          STRH     r6,[sp,#0]
;;;691    	TIMER_ChnOutInit(MDR_TIMER2, &sTIM_ChnOutInit);
0006b8  4669              MOV      r1,sp
0006ba  4638              MOV      r0,r7
0006bc  f7fffffe          BL       TIMER_ChnOutInit
;;;692    	
;;;693    	// Set default voltage PWM duty cycle
;;;694    	MDR_TIMER2->CCR1 = 0;	
0006c0  613c              STR      r4,[r7,#0x10]
;;;695    	// Set default current PWM duty cycle
;;;696    	MDR_TIMER2->CCR3 = 0;	
0006c2  61bc              STR      r4,[r7,#0x18]
;;;697    	// Set default CCR for interrupt generation
;;;698    	MDR_TIMER2->CCR2 = 0;
0006c4  617c              STR      r4,[r7,#0x14]
;;;699    	
;;;700    	// Enable interrupts
;;;701    	TIMER_ITConfig(MDR_TIMER2, TIMER_STATUS_CCR_REF_CH2, ENABLE);
0006c6  2201              MOVS     r2,#1
0006c8  0291              LSLS     r1,r2,#10
0006ca  4638              MOV      r0,r7
0006cc  f7fffffe          BL       TIMER_ITConfig
;;;702    	//TIMER_ITConfig(MDR_TIMER2, TIMER_STATUS_CNT_ZERO, ENABLE);
;;;703    	
;;;704    	// Enable TIMER2 counter clock
;;;705    	TIMER_BRGInit(MDR_TIMER2,TIMER_HCLKdiv1);
0006d0  2100              MOVS     r1,#0
0006d2  4638              MOV      r0,r7
0006d4  f7fffffe          BL       TIMER_BRGInit
;;;706    
;;;707    	// Enable TIMER2
;;;708    	TIMER_Cmd(MDR_TIMER2,ENABLE);
0006d8  2101              MOVS     r1,#1
0006da  4638              MOV      r0,r7
0006dc  f7fffffe          BL       TIMER_Cmd
;;;709    	
;;;710    	
;;;711    	
;;;712    	//======================= TIMER3 =======================//
;;;713    	// Timer3		CH1 	-> LPWM (LCD backlight PWM) 
;;;714    	//				CH3N	-> CPWM (System cooler PWM)
;;;715    	// TIMER_CLK = HCLK
;;;716    	// CLK = 2MHz
;;;717    	// PWM frequency = 20kHz
;;;718    	// PWM resolution = 100
;;;719    	
;;;720    	// Initialize timer 3 counter
;;;721    	TIMER_CntStructInit(&sTIM_CntInit);
0006e0  a80b              ADD      r0,sp,#0x2c
0006e2  f7fffffe          BL       TIMER_CntStructInit
;;;722    	sTIM_CntInit.TIMER_Prescaler                = 0xF;		// 2MHz at 32MHz core clk
0006e6  200f              MOVS     r0,#0xf
0006e8  f8ad002e          STRH     r0,[sp,#0x2e]
;;;723    	sTIM_CntInit.TIMER_Period                   = 99;			// 20kHz at 2MHz
0006ec  2063              MOVS     r0,#0x63
0006ee  f8ad0030          STRH     r0,[sp,#0x30]
;;;724    	TIMER_CntInit (MDR_TIMER3,&sTIM_CntInit);
0006f2  4f5e              LDR      r7,|L1.2156|
0006f4  a90b              ADD      r1,sp,#0x2c
0006f6  4638              MOV      r0,r7
0006f8  f7fffffe          BL       TIMER_CntInit
;;;725    		
;;;726    	// Initialize timer 3 channel 1
;;;727    	TIMER_ChnStructInit(&sTIM_ChnInit);
0006fc  a805              ADD      r0,sp,#0x14
0006fe  f7fffffe          BL       TIMER_ChnStructInit
;;;728    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL1;
000702  f8ad4014          STRH     r4,[sp,#0x14]
;;;729    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
000706  f8ad4016          STRH     r4,[sp,#0x16]
;;;730    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format6;
00070a  f8ad801e          STRH     r8,[sp,#0x1e]
;;;731    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_On_CNT_eq_0;
00070e  f8ad9026          STRH     r9,[sp,#0x26]
;;;732    	TIMER_ChnInit(MDR_TIMER3, &sTIM_ChnInit);
000712  a905              ADD      r1,sp,#0x14
000714  4638              MOV      r0,r7
000716  f7fffffe          BL       TIMER_ChnInit
;;;733    
;;;734    	// Initialize timer 3 channel 1 output
;;;735    	TIMER_ChnOutStructInit(&sTIM_ChnOutInit);
00071a  4668              MOV      r0,sp
00071c  f7fffffe          BL       TIMER_ChnOutStructInit
;;;736    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL1;
000720  f8ad4000          STRH     r4,[sp,#0]
;;;737    	sTIM_ChnOutInit.TIMER_CH_DirOut_Source            = TIMER_CH_OutSrc_REF;
000724  f8ad6004          STRH     r6,[sp,#4]
;;;738    	sTIM_ChnOutInit.TIMER_CH_DirOut_Polarity          = TIMER_CHOPolarity_NonInverted;
000728  f8ad4002          STRH     r4,[sp,#2]
;;;739    	sTIM_ChnOutInit.TIMER_CH_DirOut_Mode              = TIMER_CH_OutMode_Output;
00072c  f8ad5006          STRH     r5,[sp,#6]
;;;740    	TIMER_ChnOutInit(MDR_TIMER3, &sTIM_ChnOutInit);
000730  4669              MOV      r1,sp
000732  4638              MOV      r0,r7
000734  f7fffffe          BL       TIMER_ChnOutInit
;;;741    
;;;742    	// Initialize timer 3 channel 3
;;;743    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL3;
000738  f8ad6014          STRH     r6,[sp,#0x14]
;;;744    	TIMER_ChnInit(MDR_TIMER3, &sTIM_ChnInit);
00073c  a905              ADD      r1,sp,#0x14
00073e  4638              MOV      r0,r7
000740  f7fffffe          BL       TIMER_ChnInit
;;;745    	
;;;746    	// Initialize timer 3 channel 3 output
;;;747    	sTIM_ChnOutInit.TIMER_CH_Number           	= TIMER_CHANNEL3;
000744  f8ad6000          STRH     r6,[sp,#0]
;;;748    	sTIM_ChnOutInit.TIMER_CH_DirOut_Source      = TIMER_CH_OutSrc_Only_0;
000748  f8ad4004          STRH     r4,[sp,#4]
;;;749    	sTIM_ChnOutInit.TIMER_CH_DirOut_Mode        = TIMER_CH_OutMode_Input;
00074c  f8ad4006          STRH     r4,[sp,#6]
;;;750    	sTIM_ChnOutInit.TIMER_CH_NegOut_Source     	= TIMER_CH_OutSrc_REF;
000750  f8ad600a          STRH     r6,[sp,#0xa]
;;;751    	sTIM_ChnOutInit.TIMER_CH_NegOut_Polarity   	= TIMER_CHOPolarity_Inverted;
000754  f8ad5008          STRH     r5,[sp,#8]
;;;752    	sTIM_ChnOutInit.TIMER_CH_NegOut_Mode       	= TIMER_CH_OutMode_Output;
000758  f8ad500c          STRH     r5,[sp,#0xc]
;;;753    	TIMER_ChnOutInit(MDR_TIMER3, &sTIM_ChnOutInit);
00075c  4669              MOV      r1,sp
00075e  4638              MOV      r0,r7
000760  f7fffffe          BL       TIMER_ChnOutInit
;;;754    
;;;755    
;;;756    	// Set default PWM duty cycle for LCD backlight PWM	
;;;757    	MDR_TIMER3->CCR1 = 0;
000764  613c              STR      r4,[r7,#0x10]
;;;758    	
;;;759    	// Set default PWM duty cycle for system cooler PWM
;;;760    	MDR_TIMER3->CCR3 = 0;
000766  61bc              STR      r4,[r7,#0x18]
;;;761    
;;;762    	// Enable TIMER3 counter clock
;;;763    	TIMER_BRGInit(MDR_TIMER3,TIMER_HCLKdiv1);
000768  2100              MOVS     r1,#0
00076a  4638              MOV      r0,r7
00076c  f7fffffe          BL       TIMER_BRGInit
;;;764    
;;;765    	// Enable TIMER3
;;;766    	TIMER_Cmd(MDR_TIMER3,ENABLE);
000770  2101              MOVS     r1,#1
000772  4638              MOV      r0,r7
000774  f7fffffe          BL       TIMER_Cmd
;;;767    	
;;;768    
;;;769    
;;;770    }
000778  b011              ADD      sp,sp,#0x44
00077a  e8bd83f0          POP      {r4-r9,pc}
;;;771    
                          ENDP

                  SetVoltagePWMPeriod PROC
;;;776    
;;;777    void SetVoltagePWMPeriod(uint16_t new_period)
00077e  493a              LDR      r1,|L1.2152|
;;;778    {
;;;779    	MDR_TIMER2->CCR1 = new_period;	
000780  6108              STR      r0,[r1,#0x10]
;;;780    }
000782  4770              BX       lr
;;;781    
                          ENDP

                  SetCurrentPWMPeriod PROC
;;;782    void SetCurrentPWMPeriod(uint16_t new_period)
000784  4938              LDR      r1,|L1.2152|
;;;783    {
;;;784    	MDR_TIMER2->CCR3 = new_period;	
000786  6188              STR      r0,[r1,#0x18]
;;;785    }
000788  4770              BX       lr
;;;786    
                          ENDP

                  SetCoolerSpeed PROC
;;;791    
;;;792    void SetCoolerSpeed(uint16_t speed)
00078a  4938              LDR      r1,|L1.2156|
;;;793    {
;;;794    	MDR_TIMER3->CCR3 = speed;
00078c  6188              STR      r0,[r1,#0x18]
;;;795    }
00078e  4770              BX       lr
;;;796    
                          ENDP

                  LcdSetBacklight PROC
;;;804    //==============================================================//
;;;805    void LcdSetBacklight(uint16_t value)
000790  2864              CMP      r0,#0x64
;;;806    {
;;;807    	if (value>100) value = 100;
000792  d900              BLS      |L1.1942|
000794  2064              MOVS     r0,#0x64
                  |L1.1942|
;;;808    		MDR_TIMER3->CCR1 = value;
000796  4935              LDR      r1,|L1.2156|
000798  6108              STR      r0,[r1,#0x10]
;;;809    }
00079a  4770              BX       lr
;;;810    
                          ENDP

                  ProcessPowerOff PROC
;;;812    
;;;813    void ProcessPowerOff(void)
00079c  b510              PUSH     {r4,lr}
;;;814    {
;;;815    	uint32_t time_delay;
;;;816    	if (GetACLineStatus() == OFFLINE)
00079e  f7fffffe          BL       GetACLineStatus
0007a2  2800              CMP      r0,#0
0007a4  d17b              BNE      |L1.2206|
;;;817    	{	
;;;818    		__disable_irq();
0007a6  b672              CPSID    i
;;;819    
;;;820    		SetConverterState(CONVERTER_OFF);		// safe because we're stopping in this function
0007a8  2000              MOVS     r0,#0
0007aa  f7fffffe          BL       SetConverterState
;;;821    
;;;822    		//SysTickStop();
;;;823    		//StopBeep();
;;;824    
;;;825    		time_delay = DWT_StartDelayUs(5000);
0007ae  f2413088          MOV      r0,#0x1388
0007b2  f7fffffe          BL       DWT_StartDelayUs
0007b6  4604              MOV      r4,r0
;;;826    
;;;827    		LcdSetBacklight(0);
0007b8  2000              MOVS     r0,#0
0007ba  f7fffffe          BL       LcdSetBacklight
;;;828    		SetCoolerSpeed(0);
0007be  2000              MOVS     r0,#0
0007c0  f7fffffe          BL       SetCoolerSpeed
;;;829    		SetVoltagePWMPeriod(0);
0007c4  2000              MOVS     r0,#0
0007c6  f7fffffe          BL       SetVoltagePWMPeriod
;;;830    		SetCurrentPWMPeriod(0);
0007ca  2000              MOVS     r0,#0
0007cc  f7fffffe          BL       SetCurrentPWMPeriod
;;;831    
;;;832    
;;;833    		// Put message
;;;834    		//LcdFillBuffer(lcd0_buffer,0);
;;;835    		//LcdFillBuffer(lcd1_buffer,0);
;;;836    		LCD_FillWholeBuffer(0);
0007d0  2000              MOVS     r0,#0
0007d2  f7fffffe          BL       LCD_FillWholeBuffer
;;;837    		//LcdPutNormalStr(0,10,"Power OFF",(tNormalFont*)&font_8x12,lcd0_buffer);
;;;838    		//LcdPutNormalStr(0,10,"Power OFF",(tNormalFont*)&font_8x12,lcd1_buffer);
;;;839    		LCD_SetPixelOutputMode(PIXEL_MODE_REWRITE);
0007d6  2000              MOVS     r0,#0
0007d8  f7fffffe          BL       LCD_SetPixelOutputMode
;;;840    		LCD_SetFont(&font_h11);
0007dc  4824              LDR      r0,|L1.2160|
0007de  f7fffffe          BL       LCD_SetFont
;;;841    		LCD_PrintString("Power OFF", 0, 10, IMAGE_MODE_NORMAL);
0007e2  2301              MOVS     r3,#1
0007e4  220a              MOVS     r2,#0xa
0007e6  2100              MOVS     r1,#0
0007e8  a022              ADR      r0,|L1.2164|
0007ea  f7fffffe          BL       LCD_PrintString
;;;842    		LCD_PrintString("Power OFF", 96+0, 10, IMAGE_MODE_NORMAL);
0007ee  2301              MOVS     r3,#1
0007f0  220a              MOVS     r2,#0xa
0007f2  2160              MOVS     r1,#0x60
0007f4  a01f              ADR      r0,|L1.2164|
0007f6  f7fffffe          BL       LCD_PrintString
                  |L1.2042|
;;;843    
;;;844    
;;;845    
;;;846    		while(DWT_DelayInProgress(time_delay));
0007fa  4620              MOV      r0,r4
0007fc  f7fffffe          BL       DWT_DelayInProgress
000800  2800              CMP      r0,#0
000802  d1fa              BNE      |L1.2042|
;;;847    
;;;848    		SetFeedbackChannel(CHANNEL_12V);
000804  f7fffffe          BL       SetFeedbackChannel
;;;849    		SetCurrentLimit(CURRENT_LIM_HIGH); 
000808  2001              MOVS     r0,#1
00080a  f7fffffe          BL       SetCurrentLimit
;;;850    		SetOutputLoad(LOAD_DISABLE); 
00080e  2001              MOVS     r0,#1
000810  f7fffffe          BL       SetOutputLoad
;;;851    
;;;852    //		LcdUpdateByCore(LCD0,lcd0_buffer);
;;;853    //		LcdUpdateByCore(LCD1,lcd1_buffer);
;;;854    		LcdUpdateBothByCore(lcdBuffer);
000814  481a              LDR      r0,|L1.2176|
000816  f7fffffe          BL       LcdUpdateBothByCore
;;;855    
;;;856    
;;;857    
;;;858    		time_delay = DWT_StartDelayUs(1000);
00081a  f44f707a          MOV      r0,#0x3e8
00081e  f7fffffe          BL       DWT_StartDelayUs
000822  4604              MOV      r4,r0
                  |L1.2084|
;;;859    		while(DWT_DelayInProgress(time_delay));
000824  4620              MOV      r0,r4
000826  f7fffffe          BL       DWT_DelayInProgress
00082a  2800              CMP      r0,#0
00082c  d1fa              BNE      |L1.2084|
;;;860    
;;;861    		PORT_DeInit(MDR_PORTA);
00082e  4815              LDR      r0,|L1.2180|
000830  f7fffffe          BL       PORT_DeInit
;;;862    		PORT_DeInit(MDR_PORTB);
000834  4814              LDR      r0,|L1.2184|
000836  f7fffffe          BL       PORT_DeInit
;;;863    		PORT_DeInit(MDR_PORTC);
00083a  4814              LDR      r0,|L1.2188|
00083c  f7fffffe          BL       PORT_DeInit
;;;864    		PORT_DeInit(MDR_PORTD);
000840  4813              LDR      r0,|L1.2192|
000842  f7fffffe          BL       PORT_DeInit
;;;865    		PORT_DeInit(MDR_PORTE);
000846  4813              LDR      r0,|L1.2196|
000848  f7fffffe          BL       PORT_DeInit
;;;866    		PORT_DeInit(MDR_PORTF);
00084c  4812              LDR      r0,|L1.2200|
00084e  f7fffffe          BL       PORT_DeInit
                  |L1.2130|
;;;867    
;;;868    		while(1);
000852  e7fe              B        |L1.2130|
                  |L1.2132|
                          DCD      0x40028000
                  |L1.2136|
                          DCD      0x40040000
                  |L1.2140|
                          DCD      0x400a0000
                  |L1.2144|
                          DCD      0xe000e084
                  |L1.2148|
                          DCD      0x40070000
                  |L1.2152|
                          DCD      0x40078000
                  |L1.2156|
                          DCD      0x40080000
                  |L1.2160|
                          DCD      font_h11
                  |L1.2164|
000874  506f7765          DCB      "Power OFF",0
000878  72204f46
00087c  4600    
00087e  00                DCB      0
00087f  00                DCB      0
                  |L1.2176|
                          DCD      lcdBuffer
                  |L1.2180|
                          DCD      0x400a8000
                  |L1.2184|
                          DCD      0x400b0000
                  |L1.2188|
                          DCD      0x400b8000
                  |L1.2192|
                          DCD      0x400c0000
                  |L1.2196|
                          DCD      0x400c8000
                  |L1.2200|
                          DCD      0x400e8000
00089c  e7ff              B        |L1.2206|
                  |L1.2206|
;;;869    		 
;;;870    	}
;;;871    }
00089e  bd10              POP      {r4,pc}
;;;872    
                          ENDP

                  hard_fault_handler_c PROC
;;;894    // called from HardFault_Handler in file startup_MDR32F9x.s
;;;895    void hard_fault_handler_c (unsigned int * hardfault_args)
0008a0  4914              LDR      r1,|L1.2292|
;;;896    {
;;;897    
;;;898      dbg_struct.stacked_r0 = ((unsigned long) hardfault_args[0]);
0008a2  6802              LDR      r2,[r0,#0]
0008a4  600a              STR      r2,[r1,#0]  ; dbg_struct
;;;899      dbg_struct.stacked_r1 = ((unsigned long) hardfault_args[1]);
0008a6  6842              LDR      r2,[r0,#4]
0008a8  604a              STR      r2,[r1,#4]  ; dbg_struct
;;;900      dbg_struct.stacked_r2 = ((unsigned long) hardfault_args[2]);
0008aa  6882              LDR      r2,[r0,#8]
0008ac  608a              STR      r2,[r1,#8]  ; dbg_struct
;;;901      dbg_struct.stacked_r3 = ((unsigned long) hardfault_args[3]);
0008ae  68c2              LDR      r2,[r0,#0xc]
0008b0  60ca              STR      r2,[r1,#0xc]  ; dbg_struct
;;;902     
;;;903      dbg_struct.stacked_r12 = ((unsigned long) hardfault_args[4]);
0008b2  6902              LDR      r2,[r0,#0x10]
0008b4  610a              STR      r2,[r1,#0x10]  ; dbg_struct
;;;904      dbg_struct.stacked_lr = ((unsigned long) hardfault_args[5]);
0008b6  6942              LDR      r2,[r0,#0x14]
0008b8  614a              STR      r2,[r1,#0x14]  ; dbg_struct
;;;905      dbg_struct.stacked_pc = ((unsigned long) hardfault_args[6]);
0008ba  6982              LDR      r2,[r0,#0x18]
0008bc  618a              STR      r2,[r1,#0x18]  ; dbg_struct
;;;906      dbg_struct.stacked_psr = ((unsigned long) hardfault_args[7]);
0008be  69c0              LDR      r0,[r0,#0x1c]
0008c0  61c8              STR      r0,[r1,#0x1c]  ; dbg_struct
                  |L1.2242|
;;;907     /*
;;;908      printf ("\n\n[Hard fault handler - all numbers in hex]\n");
;;;909      printf ("R0 = %x\n", stacked_r0);
;;;910      printf ("R1 = %x\n", stacked_r1);
;;;911      printf ("R2 = %x\n", stacked_r2);
;;;912      printf ("R3 = %x\n", stacked_r3);
;;;913      printf ("R12 = %x\n", stacked_r12);
;;;914      printf ("LR [R14] = %x  subroutine call return address\n", stacked_lr);
;;;915      printf ("PC [R15] = %x  program counter\n", stacked_pc);
;;;916      printf ("PSR = %x\n", stacked_psr);
;;;917      printf ("BFAR = %x\n", (*((volatile unsigned long *)(0xE000ED38))));
;;;918      printf ("CFSR = %x\n", (*((volatile unsigned long *)(0xE000ED28))));
;;;919      printf ("HFSR = %x\n", (*((volatile unsigned long *)(0xE000ED2C))));
;;;920      printf ("DFSR = %x\n", (*((volatile unsigned long *)(0xE000ED30))));
;;;921      printf ("AFSR = %x\n", (*((volatile unsigned long *)(0xE000ED3C))));
;;;922      printf ("SCB_SHCSR = %x\n", SCB->SHCSR);
;;;923     */
;;;924      while (1);
0008c2  e7fe              B        |L1.2242|
;;;925    }
;;;926    
                          ENDP

                  NVIC_SetPriority PROC
;;;1389    */
;;;1390   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
0008c4  0749              LSLS     r1,r1,#29
;;;1391   {
;;;1392     if(IRQn < 0) {
;;;1393       SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
0008c6  0e09              LSRS     r1,r1,#24
0008c8  2800              CMP      r0,#0                 ;1392
0008ca  da04              BGE      |L1.2262|
0008cc  4a0a              LDR      r2,|L1.2296|
0008ce  f000000f          AND      r0,r0,#0xf
0008d2  5481              STRB     r1,[r0,r2]
;;;1394     else {
;;;1395       NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
;;;1396   }
0008d4  4770              BX       lr
                  |L1.2262|
0008d6  4a09              LDR      r2,|L1.2300|
0008d8  5481              STRB     r1,[r0,r2]            ;1395
0008da  4770              BX       lr
;;;1397   
                          ENDP

                  NVIC_GetPriority PROC
;;;1409    */
;;;1410   __STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
0008dc  2800              CMP      r0,#0
;;;1411   {
;;;1412   
;;;1413     if(IRQn < 0) {
0008de  da05              BGE      |L1.2284|
;;;1414       return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
0008e0  4905              LDR      r1,|L1.2296|
0008e2  f000000f          AND      r0,r0,#0xf
0008e6  5c40              LDRB     r0,[r0,r1]
0008e8  0940              LSRS     r0,r0,#5
;;;1415     else {
;;;1416       return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
;;;1417   }
0008ea  4770              BX       lr
                  |L1.2284|
0008ec  4903              LDR      r1,|L1.2300|
0008ee  5c40              LDRB     r0,[r0,r1]            ;1416
0008f0  0940              LSRS     r0,r0,#5              ;1416
0008f2  4770              BX       lr
;;;1418   
                          ENDP

                  |L1.2292|
                          DCD      ||.bss||+0x3c
                  |L1.2296|
                          DCD      0xe000ed14
                  |L1.2300|
                          DCD      0xe000e400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||pr||
                          %        60
                  dbg_struct
                          %        56

;*** Start embedded assembler ***

#line 1 "src\\systemfunc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_systemfunc_c_993797dc____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_systemfunc_c_993797dc____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_systemfunc_c_993797dc____REVSH|
#line 130
|__asm___12_systemfunc_c_993797dc____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
