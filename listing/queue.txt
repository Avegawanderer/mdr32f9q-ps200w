; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list -c --asm --interleave -o.\FLASH\queue.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\queue.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -I.\src\gui -I.\src\gui\guiCore -I.\src\gui\guiWidgets -I.\src\gui\guiGraphics -I.\src\gui\utils -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\queue.crf ..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\queue.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  xQueueGenericReset PROC
;;;238    
;;;239    portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;240    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;241    xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
;;;242    
;;;243    	configASSERT( pxQueue );
;;;244    
;;;245    	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;246    	{
;;;247    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
00000a  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
00000e  6820              LDR      r0,[r4,#0]
000010  fb010002          MLA      r0,r1,r2,r0
000014  6060              STR      r0,[r4,#4]
;;;248    		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
000016  2000              MOVS     r0,#0
000018  63a0              STR      r0,[r4,#0x38]
;;;249    		pxQueue->pcWriteTo = pxQueue->pcHead;
00001a  6820              LDR      r0,[r4,#0]
00001c  60a0              STR      r0,[r4,#8]
;;;250    		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
00001e  6be0              LDR      r0,[r4,#0x3c]
000020  6c22              LDR      r2,[r4,#0x40]
000022  6821              LDR      r1,[r4,#0]
000024  1e40              SUBS     r0,r0,#1
000026  fb001002          MLA      r0,r0,r2,r1
00002a  60e0              STR      r0,[r4,#0xc]
;;;251    		pxQueue->xRxLock = queueUNLOCKED;
00002c  f04f30ff          MOV      r0,#0xffffffff
000030  6460              STR      r0,[r4,#0x44]
;;;252    		pxQueue->xTxLock = queueUNLOCKED;
000032  64a0              STR      r0,[r4,#0x48]
;;;253    
;;;254    		if( xNewQueue == pdFALSE )
;;;255    		{
;;;256    			/* If there are tasks blocked waiting to read from the queue, then
;;;257    			the tasks will remain blocked as after this function exits the queue
;;;258    			will still be empty.  If there are tasks blocked waiting to	write to
;;;259    			the queue, then one should be unblocked as after this function exits
;;;260    			it will be possible to write to it. */
;;;261    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;262    			{
;;;263    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
000034  f1040010          ADD      r0,r4,#0x10
000038  b14d              CBZ      r5,|L1.78|
;;;264    				{
;;;265    					portYIELD_WITHIN_API();
;;;266    				}
;;;267    			}
;;;268    		}
;;;269    		else
;;;270    		{
;;;271    			/* Ensure the event queues start in the correct state. */
;;;272    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
00003a  f7fffffe          BL       vListInitialise
;;;273    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
00003e  f1040024          ADD      r0,r4,#0x24
000042  f7fffffe          BL       vListInitialise
                  |L1.70|
;;;274    		}
;;;275    	}
;;;276    	taskEXIT_CRITICAL();
000046  f7fffffe          BL       vPortExitCritical
;;;277    
;;;278    	/* A value is returned for calling semantic consistency with previous
;;;279    	versions. */
;;;280    	return pdPASS;
00004a  2001              MOVS     r0,#1
;;;281    }
00004c  bd70              POP      {r4-r6,pc}
                  |L1.78|
00004e  6921              LDR      r1,[r4,#0x10]         ;261
000050  2900              CMP      r1,#0                 ;261
000052  d0f8              BEQ      |L1.70|
000054  f7fffffe          BL       xTaskRemoveFromEventList
000058  2801              CMP      r0,#1                 ;263
00005a  d1f4              BNE      |L1.70|
00005c  f7fffffe          BL       vPortYield
000060  e7f1              B        |L1.70|
;;;282    /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericCreate PROC
;;;283    
;;;284    xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
000062  e92d41f0          PUSH     {r4-r8,lr}
;;;285    {
000066  4605              MOV      r5,r0
000068  460f              MOV      r7,r1
;;;286    xQUEUE *pxNewQueue;
;;;287    size_t xQueueSizeInBytes;
;;;288    xQueueHandle xReturn = NULL;
00006a  2600              MOVS     r6,#0
;;;289    
;;;290    	/* Remove compiler warnings about unused parameters should
;;;291    	configUSE_TRACE_FACILITY not be set to 1. */
;;;292    	( void ) ucQueueType;
;;;293    
;;;294    	/* Allocate the new queue structure. */
;;;295    	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
00006c  b1b5              CBZ      r5,|L1.156|
;;;296    	{
;;;297    		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
00006e  204c              MOVS     r0,#0x4c
000070  f7fffffe          BL       pvPortMalloc
000074  4604              MOV      r4,r0
;;;298    		if( pxNewQueue != NULL )
000076  b18c              CBZ      r4,|L1.156|
;;;299    		{
;;;300    			/* Create the list of pointers to queue items.  The queue is one byte
;;;301    			longer than asked for to make wrap checking easier/faster. */
;;;302    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000078  fb05f007          MUL      r0,r5,r7
00007c  1c40              ADDS     r0,r0,#1
;;;303    
;;;304    			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
00007e  f7fffffe          BL       pvPortMalloc
000082  6020              STR      r0,[r4,#0]
;;;305    			if( pxNewQueue->pcHead != NULL )
000084  b138              CBZ      r0,|L1.150|
;;;306    			{
;;;307    				/* Initialise the queue members as described above where the
;;;308    				queue type is defined. */
;;;309    				pxNewQueue->uxLength = uxQueueLength;
000086  63e5              STR      r5,[r4,#0x3c]
;;;310    				pxNewQueue->uxItemSize = uxItemSize;
000088  6427              STR      r7,[r4,#0x40]
;;;311    				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
00008a  2101              MOVS     r1,#1
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       xQueueGenericReset
;;;312    
;;;313    				#if ( configUSE_TRACE_FACILITY == 1 )
;;;314    				{
;;;315    					pxNewQueue->ucQueueType = ucQueueType;
;;;316    				}
;;;317    				#endif /* configUSE_TRACE_FACILITY */
;;;318    
;;;319    				#if( configUSE_QUEUE_SETS == 1 )
;;;320    				{
;;;321    					pxNewQueue->pxQueueSetContainer = NULL;
;;;322    				}
;;;323    				#endif /* configUSE_QUEUE_SETS */
;;;324    
;;;325    				traceQUEUE_CREATE( pxNewQueue );
;;;326    				xReturn = pxNewQueue;
000092  4626              MOV      r6,r4
000094  e002              B        |L1.156|
                  |L1.150|
;;;327    			}
;;;328    			else
;;;329    			{
;;;330    				traceQUEUE_CREATE_FAILED( ucQueueType );
;;;331    				vPortFree( pxNewQueue );
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       vPortFree
                  |L1.156|
;;;332    			}
;;;333    		}
;;;334    	}
;;;335    
;;;336    	configASSERT( xReturn );
;;;337    
;;;338    	return xReturn;
00009c  4630              MOV      r0,r6
                  |L1.158|
;;;339    }
00009e  e8bd81f0          POP      {r4-r8,pc}
;;;340    /*-----------------------------------------------------------*/
                          ENDP

                  prvUnlockQueue PROC
;;;1471   
;;;1472   static void prvUnlockQueue( xQUEUE *pxQueue )
0000a2  b570              PUSH     {r4-r6,lr}
;;;1473   {
0000a4  4604              MOV      r4,r0
;;;1474   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;1475   
;;;1476   	/* The lock counts contains the number of extra data items placed or
;;;1477   	removed from the queue while the queue was locked.  When a queue is
;;;1478   	locked items can be added or removed, but the event lists cannot be
;;;1479   	updated. */
;;;1480   	taskENTER_CRITICAL();
0000a6  f7fffffe          BL       vPortEnterCritical
;;;1481   	{
;;;1482   		/* See if data was added to the queue while it was locked. */
;;;1483   		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
;;;1484   		{
;;;1485   			/* Data was posted while the queue was locked.  Are any tasks
;;;1486   			blocked waiting for data to become available? */
;;;1487   			#if ( configUSE_QUEUE_SETS == 1 )
;;;1488   			{
;;;1489   				if( pxQueue->pxQueueSetContainer != NULL )
;;;1490   				{
;;;1491   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
;;;1492   					{
;;;1493   						/* The queue is a member of a queue set, and posting to
;;;1494   						the queue set caused a higher priority task to unblock.
;;;1495   						A context switch is required. */
;;;1496   						vTaskMissedYield();
;;;1497   					}
;;;1498   				}
;;;1499   				else
;;;1500   				{
;;;1501   					/* Tasks that are removed from the event list will get added to
;;;1502   					the pending ready list as the scheduler is still suspended. */
;;;1503   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1504   					{
;;;1505   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1506   						{
;;;1507   							/* The task waiting has a higher priority so record that a
;;;1508   							context	switch is required. */
;;;1509   							vTaskMissedYield();
;;;1510   						}
;;;1511   					}
;;;1512   					else
;;;1513   					{
;;;1514   						break;
;;;1515   					}
;;;1516   				}
;;;1517   			}
;;;1518   			#else /* configUSE_QUEUE_SETS */
;;;1519   			{
;;;1520   				/* Tasks that are removed from the event list will get added to
;;;1521   				the pending ready list as the scheduler is still suspended. */
;;;1522   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1523   				{
;;;1524   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000aa  f1040524          ADD      r5,r4,#0x24
;;;1525   					{
;;;1526   						/* The task waiting has a higher priority so record that a
;;;1527   						context	switch is required. */
;;;1528   						vTaskMissedYield();
;;;1529   					}
;;;1530   				}
;;;1531   				else
;;;1532   				{
;;;1533   					break;
;;;1534   				}
;;;1535   			}
;;;1536   			#endif /* configUSE_QUEUE_SETS */
;;;1537   
;;;1538   			--( pxQueue->xTxLock );
0000ae  e00a              B        |L1.198|
                  |L1.176|
0000b0  6a60              LDR      r0,[r4,#0x24]         ;1522
0000b2  b158              CBZ      r0,|L1.204|
0000b4  4628              MOV      r0,r5                 ;1524
0000b6  f7fffffe          BL       xTaskRemoveFromEventList
0000ba  b108              CBZ      r0,|L1.192|
0000bc  f7fffffe          BL       vTaskMissedYield
                  |L1.192|
0000c0  6ca0              LDR      r0,[r4,#0x48]
0000c2  1e40              SUBS     r0,r0,#1
0000c4  64a0              STR      r0,[r4,#0x48]
                  |L1.198|
0000c6  6ca0              LDR      r0,[r4,#0x48]         ;1483
0000c8  2800              CMP      r0,#0                 ;1483
0000ca  dcf1              BGT      |L1.176|
                  |L1.204|
;;;1539   		}
;;;1540   
;;;1541   		pxQueue->xTxLock = queueUNLOCKED;
0000cc  f04f35ff          MOV      r5,#0xffffffff
0000d0  64a5              STR      r5,[r4,#0x48]
;;;1542   	}
;;;1543   	taskEXIT_CRITICAL();
0000d2  f7fffffe          BL       vPortExitCritical
;;;1544   
;;;1545   	/* Do the same for the Rx lock. */
;;;1546   	taskENTER_CRITICAL();
0000d6  f7fffffe          BL       vPortEnterCritical
;;;1547   	{
;;;1548   		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
;;;1549   		{
;;;1550   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1551   			{
;;;1552   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
0000da  f1040610          ADD      r6,r4,#0x10
;;;1553   				{
;;;1554   					vTaskMissedYield();
;;;1555   				}
;;;1556   
;;;1557   				--( pxQueue->xRxLock );
;;;1558   			}
;;;1559   			else
;;;1560   			{
;;;1561   				break;
0000de  e00a              B        |L1.246|
                  |L1.224|
0000e0  6920              LDR      r0,[r4,#0x10]         ;1550
0000e2  b158              CBZ      r0,|L1.252|
0000e4  4630              MOV      r0,r6                 ;1552
0000e6  f7fffffe          BL       xTaskRemoveFromEventList
0000ea  b108              CBZ      r0,|L1.240|
0000ec  f7fffffe          BL       vTaskMissedYield
                  |L1.240|
0000f0  6c60              LDR      r0,[r4,#0x44]         ;1557
0000f2  1e40              SUBS     r0,r0,#1              ;1557
0000f4  6460              STR      r0,[r4,#0x44]         ;1557
                  |L1.246|
0000f6  6c60              LDR      r0,[r4,#0x44]         ;1548
0000f8  2800              CMP      r0,#0                 ;1548
0000fa  dcf1              BGT      |L1.224|
                  |L1.252|
;;;1562   			}
;;;1563   		}
;;;1564   
;;;1565   		pxQueue->xRxLock = queueUNLOCKED;
0000fc  6465              STR      r5,[r4,#0x44]
;;;1566   	}
;;;1567   	taskEXIT_CRITICAL();
0000fe  e8bd4070          POP      {r4-r6,lr}
000102  f7ffbffe          B.W      vPortExitCritical
;;;1568   }
;;;1569   /*-----------------------------------------------------------*/
                          ENDP

                  prvIsQueueFull PROC
;;;1609   
;;;1610   static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
000106  b510              PUSH     {r4,lr}
;;;1611   {
000108  4604              MOV      r4,r0
;;;1612   signed portBASE_TYPE xReturn;
;;;1613   
;;;1614   	taskENTER_CRITICAL();
00010a  f7fffffe          BL       vPortEnterCritical
;;;1615   	{
;;;1616   		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
00010e  6ba0              LDR      r0,[r4,#0x38]
000110  6be1              LDR      r1,[r4,#0x3c]
000112  4288              CMP      r0,r1
000114  d101              BNE      |L1.282|
;;;1617   		{
;;;1618   			xReturn = pdTRUE;
000116  2401              MOVS     r4,#1
000118  e000              B        |L1.284|
                  |L1.282|
;;;1619   		}
;;;1620   		else
;;;1621   		{
;;;1622   			xReturn = pdFALSE;
00011a  2400              MOVS     r4,#0
                  |L1.284|
;;;1623   		}
;;;1624   	}
;;;1625   	taskEXIT_CRITICAL();
00011c  f7fffffe          BL       vPortExitCritical
;;;1626   
;;;1627   	return xReturn;
000120  4620              MOV      r0,r4
;;;1628   }
000122  bd10              POP      {r4,pc}
;;;1629   /*-----------------------------------------------------------*/
                          ENDP

                  prvCopyDataToQueue PROC
;;;1407   
;;;1408   static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
000124  b570              PUSH     {r4-r6,lr}
;;;1409   {
000126  4604              MOV      r4,r0
000128  4615              MOV      r5,r2
;;;1410   	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
00012a  6c22              LDR      r2,[r4,#0x40]
00012c  b312              CBZ      r2,|L1.372|
;;;1411   	{
;;;1412   		#if ( configUSE_MUTEXES == 1 )
;;;1413   		{
;;;1414   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1415   			{
;;;1416   				/* The mutex is no longer being held. */
;;;1417   				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
;;;1418   				pxQueue->pxMutexHolder = NULL;
;;;1419   			}
;;;1420   		}
;;;1421   		#endif /* configUSE_MUTEXES */
;;;1422   	}
;;;1423   	else if( xPosition == queueSEND_TO_BACK )
00012e  b17d              CBZ      r5,|L1.336|
;;;1424   	{
;;;1425   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
;;;1426   		pxQueue->pcWriteTo += pxQueue->uxItemSize;
;;;1427   		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
;;;1428   		{
;;;1429   			pxQueue->pcWriteTo = pxQueue->pcHead;
;;;1430   		}
;;;1431   	}
;;;1432   	else
;;;1433   	{
;;;1434   		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000130  68e0              LDR      r0,[r4,#0xc]
000132  f7fffffe          BL       __aeabi_memcpy
;;;1435   		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
000136  68e1              LDR      r1,[r4,#0xc]
000138  6c20              LDR      r0,[r4,#0x40]
00013a  1a09              SUBS     r1,r1,r0
00013c  60e1              STR      r1,[r4,#0xc]
;;;1436   		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00013e  6822              LDR      r2,[r4,#0]
000140  4291              CMP      r1,r2
000142  d202              BCS      |L1.330|
;;;1437   		{
;;;1438   			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
000144  6861              LDR      r1,[r4,#4]
000146  1a08              SUBS     r0,r1,r0
000148  60e0              STR      r0,[r4,#0xc]
                  |L1.330|
;;;1439   		}
;;;1440   
;;;1441   		if( xPosition == queueOVERWRITE )
00014a  2d02              CMP      r5,#2
00014c  d00d              BEQ      |L1.362|
00014e  e011              B        |L1.372|
                  |L1.336|
000150  68a0              LDR      r0,[r4,#8]            ;1425
000152  f7fffffe          BL       __aeabi_memcpy
000156  6c21              LDR      r1,[r4,#0x40]         ;1426
000158  68a0              LDR      r0,[r4,#8]            ;1426
00015a  4408              ADD      r0,r0,r1              ;1426
00015c  60a0              STR      r0,[r4,#8]            ;1426
00015e  6861              LDR      r1,[r4,#4]            ;1427
000160  4288              CMP      r0,r1                 ;1427
000162  d307              BCC      |L1.372|
000164  6820              LDR      r0,[r4,#0]            ;1429
000166  60a0              STR      r0,[r4,#8]            ;1429
000168  e004              B        |L1.372|
                  |L1.362|
;;;1442   		{
;;;1443   			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
00016a  6ba0              LDR      r0,[r4,#0x38]
00016c  b110              CBZ      r0,|L1.372|
;;;1444   			{
;;;1445   				/* An item is not being added but overwritten, so subtract
;;;1446   				one from the recorded number of items in the queue so when
;;;1447   				one is added again below the number of recorded items remains
;;;1448   				correct. */
;;;1449   				--( pxQueue->uxMessagesWaiting );
00016e  6ba0              LDR      r0,[r4,#0x38]
000170  1e40              SUBS     r0,r0,#1
000172  63a0              STR      r0,[r4,#0x38]
                  |L1.372|
;;;1450   			}
;;;1451   		}
;;;1452   	}
;;;1453   
;;;1454   	++( pxQueue->uxMessagesWaiting );
000174  6ba0              LDR      r0,[r4,#0x38]
000176  1c40              ADDS     r0,r0,#1
000178  63a0              STR      r0,[r4,#0x38]
;;;1455   }
00017a  bd70              POP      {r4-r6,pc}
;;;1456   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericSend PROC
;;;553    
;;;554    signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
00017c  e92d41ff          PUSH     {r0-r8,lr}
;;;555    {
000180  b082              SUB      sp,sp,#8
000182  4604              MOV      r4,r0
000184  4688              MOV      r8,r1
000186  461f              MOV      r7,r3
;;;556    signed portBASE_TYPE xEntryTimeSet = pdFALSE;
000188  2500              MOVS     r5,#0
00018a  2600              MOVS     r6,#0
                  |L1.396|
;;;557    xTimeOutType xTimeOut;
;;;558    xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
;;;559    
;;;560    	configASSERT( pxQueue );
;;;561    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;562    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;563    
;;;564    	/* This function relaxes the coding standard somewhat to allow return
;;;565    	statements within the function itself.  This is done in the interest
;;;566    	of execution time efficiency. */
;;;567    	for( ;; )
;;;568    	{
;;;569    		taskENTER_CRITICAL();
00018c  f7fffffe          BL       vPortEnterCritical
;;;570    		{
;;;571    			/* Is there room on the queue now?  The running task must be
;;;572    			the highest priority task wanting to access the queue.  If
;;;573    			the head item in the queue is to be overwritten then it does
;;;574    			not matter if the queue is full. */
;;;575    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000190  6ba0              LDR      r0,[r4,#0x38]
000192  6be1              LDR      r1,[r4,#0x3c]
000194  4288              CMP      r0,r1
000196  d305              BCC      |L1.420|
000198  2f02              CMP      r7,#2
00019a  d003              BEQ      |L1.420|
;;;576    			{
;;;577    				traceQUEUE_SEND( pxQueue );
;;;578    				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;579    
;;;580    				#if ( configUSE_QUEUE_SETS == 1 )
;;;581    				{
;;;582    					if( pxQueue->pxQueueSetContainer != NULL )
;;;583    					{
;;;584    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;585    						{
;;;586    							/* The queue is a member of a queue set, and posting
;;;587    							to the queue set caused a higher priority task to
;;;588    							unblock. A context switch is required. */
;;;589    							portYIELD_WITHIN_API();
;;;590    						}
;;;591    					}
;;;592    					else
;;;593    					{
;;;594    						/* If there was a task waiting for data to arrive on the
;;;595    						queue then unblock it now. */
;;;596    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;597    						{
;;;598    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
;;;599    							{
;;;600    								/* The unblocked task has a priority higher than
;;;601    								our own so yield immediately.  Yes it is ok to
;;;602    								do this from within the critical section - the
;;;603    								kernel takes care of that. */
;;;604    								portYIELD_WITHIN_API();
;;;605    							}
;;;606    						}
;;;607    					}
;;;608    				}
;;;609    				#else /* configUSE_QUEUE_SETS */
;;;610    				{
;;;611    					/* If there was a task waiting for data to arrive on the
;;;612    					queue then unblock it now. */
;;;613    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;614    					{
;;;615    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
;;;616    						{
;;;617    							/* The unblocked task has a priority higher than
;;;618    							our own so yield immediately.  Yes it is ok to do
;;;619    							this from within the critical section - the kernel
;;;620    							takes care of that. */
;;;621    							portYIELD_WITHIN_API();
;;;622    						}
;;;623    					}
;;;624    				}
;;;625    				#endif /* configUSE_QUEUE_SETS */
;;;626    
;;;627    				taskEXIT_CRITICAL();
;;;628    
;;;629    				/* Return to the original privilege level before exiting the
;;;630    				function. */
;;;631    				return pdPASS;
;;;632    			}
;;;633    			else
;;;634    			{
;;;635    				if( xTicksToWait == ( portTickType ) 0 )
00019c  9804              LDR      r0,[sp,#0x10]
00019e  b1a8              CBZ      r0,|L1.460|
;;;636    				{
;;;637    					/* The queue was full and no block time is specified (or
;;;638    					the block time has expired) so leave now. */
;;;639    					taskEXIT_CRITICAL();
;;;640    
;;;641    					/* Return to the original privilege level before exiting
;;;642    					the function. */
;;;643    					traceQUEUE_SEND_FAILED( pxQueue );
;;;644    					return errQUEUE_FULL;
;;;645    				}
;;;646    				else if( xEntryTimeSet == pdFALSE )
0001a0  b1c5              CBZ      r5,|L1.468|
0001a2  e01b              B        |L1.476|
                  |L1.420|
0001a4  463a              MOV      r2,r7                 ;578
0001a6  4641              MOV      r1,r8                 ;578
0001a8  4620              MOV      r0,r4                 ;578
0001aa  f7fffffe          BL       prvCopyDataToQueue
0001ae  6a60              LDR      r0,[r4,#0x24]         ;613
0001b0  b138              CBZ      r0,|L1.450|
0001b2  f1040024          ADD      r0,r4,#0x24           ;615
0001b6  f7fffffe          BL       xTaskRemoveFromEventList
0001ba  2801              CMP      r0,#1                 ;615
0001bc  d101              BNE      |L1.450|
0001be  f7fffffe          BL       vPortYield
                  |L1.450|
0001c2  f7fffffe          BL       vPortExitCritical
0001c6  2001              MOVS     r0,#1                 ;631
                  |L1.456|
;;;647    				{
;;;648    					/* The queue was full and a block time was specified so
;;;649    					configure the timeout structure. */
;;;650    					vTaskSetTimeOutState( &xTimeOut );
;;;651    					xEntryTimeSet = pdTRUE;
;;;652    				}
;;;653    				else
;;;654    				{
;;;655    					/* Entry time was already set. */
;;;656    				}
;;;657    			}
;;;658    		}
;;;659    		taskEXIT_CRITICAL();
;;;660    
;;;661    		/* Interrupts and other tasks can send to and receive from the queue
;;;662    		now the critical section has been exited. */
;;;663    
;;;664    		vTaskSuspendAll();
;;;665    		prvLockQueue( pxQueue );
;;;666    
;;;667    		/* Update the timeout state to see if it has expired yet. */
;;;668    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;669    		{
;;;670    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;671    			{
;;;672    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;673    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;674    
;;;675    				/* Unlocking the queue means queue events can effect the
;;;676    				event list.  It is possible	that interrupts occurring now
;;;677    				remove this task from the event	list again - but as the
;;;678    				scheduler is suspended the task will go onto the pending
;;;679    				ready last instead of the actual ready list. */
;;;680    				prvUnlockQueue( pxQueue );
;;;681    
;;;682    				/* Resuming the scheduler will move tasks from the pending
;;;683    				ready list into the ready list - so it is feasible that this
;;;684    				task is already in a ready list before it yields - in which
;;;685    				case the yield will not cause a context switch unless there
;;;686    				is also a higher priority task in the pending ready list. */
;;;687    				if( xTaskResumeAll() == pdFALSE )
;;;688    				{
;;;689    					portYIELD_WITHIN_API();
;;;690    				}
;;;691    			}
;;;692    			else
;;;693    			{
;;;694    				/* Try again. */
;;;695    				prvUnlockQueue( pxQueue );
;;;696    				( void ) xTaskResumeAll();
;;;697    			}
;;;698    		}
;;;699    		else
;;;700    		{
;;;701    			/* The timeout has expired. */
;;;702    			prvUnlockQueue( pxQueue );
;;;703    			( void ) xTaskResumeAll();
;;;704    
;;;705    			/* Return to the original privilege level before exiting the
;;;706    			function. */
;;;707    			traceQUEUE_SEND_FAILED( pxQueue );
;;;708    			return errQUEUE_FULL;
;;;709    		}
;;;710    	}
;;;711    }
0001c8  b006              ADD      sp,sp,#0x18
0001ca  e768              B        |L1.158|
                  |L1.460|
0001cc  f7fffffe          BL       vPortExitCritical
0001d0  2000              MOVS     r0,#0                 ;644
0001d2  e7f9              B        |L1.456|
                  |L1.468|
0001d4  4668              MOV      r0,sp                 ;650
0001d6  f7fffffe          BL       vTaskSetTimeOutState
0001da  2501              MOVS     r5,#1                 ;651
                  |L1.476|
0001dc  f7fffffe          BL       vPortExitCritical
0001e0  f7fffffe          BL       vTaskSuspendAll
0001e4  f7fffffe          BL       vPortEnterCritical
0001e8  6c60              LDR      r0,[r4,#0x44]         ;665
0001ea  1c40              ADDS     r0,r0,#1              ;665
0001ec  d100              BNE      |L1.496|
0001ee  6466              STR      r6,[r4,#0x44]         ;665
                  |L1.496|
0001f0  6ca0              LDR      r0,[r4,#0x48]         ;665
0001f2  1c40              ADDS     r0,r0,#1              ;665
0001f4  d100              BNE      |L1.504|
0001f6  64a6              STR      r6,[r4,#0x48]         ;665
                  |L1.504|
0001f8  f7fffffe          BL       vPortExitCritical
0001fc  a904              ADD      r1,sp,#0x10           ;668
0001fe  4668              MOV      r0,sp                 ;668
000200  f7fffffe          BL       xTaskCheckForTimeOut
000204  b130              CBZ      r0,|L1.532|
000206  4620              MOV      r0,r4                 ;702
000208  f7fffffe          BL       prvUnlockQueue
00020c  f7fffffe          BL       xTaskResumeAll
000210  2000              MOVS     r0,#0                 ;708
000212  e7d9              B        |L1.456|
                  |L1.532|
000214  4620              MOV      r0,r4                 ;670
000216  f7fffffe          BL       prvIsQueueFull
00021a  b170              CBZ      r0,|L1.570|
00021c  f1040010          ADD      r0,r4,#0x10           ;673
000220  9904              LDR      r1,[sp,#0x10]         ;673
000222  f7fffffe          BL       vTaskPlaceOnEventList
000226  4620              MOV      r0,r4                 ;680
000228  f7fffffe          BL       prvUnlockQueue
00022c  f7fffffe          BL       xTaskResumeAll
000230  2800              CMP      r0,#0                 ;687
000232  d1ab              BNE      |L1.396|
000234  f7fffffe          BL       vPortYield
000238  e7a8              B        |L1.396|
                  |L1.570|
00023a  4620              MOV      r0,r4                 ;695
00023c  f7fffffe          BL       prvUnlockQueue
000240  f7fffffe          BL       xTaskResumeAll
000244  e7a2              B        |L1.396|
;;;712    /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericSendFromISR PROC
;;;923    
;;;924    signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
000246  e92d41f0          PUSH     {r4-r8,lr}
;;;925    {
00024a  4604              MOV      r4,r0
00024c  460f              MOV      r7,r1
00024e  4615              MOV      r5,r2
000250  461e              MOV      r6,r3
;;;926    signed portBASE_TYPE xReturn;
;;;927    unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;928    xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
;;;929    
;;;930    	configASSERT( pxQueue );
;;;931    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;932    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;933    
;;;934    	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;935    	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;936    	above the maximum system call priority are keep permanently enabled, even
;;;937    	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;938    	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;939    	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;940    	failure if a FreeRTOS API function is called from an interrupt that has been
;;;941    	assigned a priority above the configured maximum system call priority.
;;;942    	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;943    	that have been assigned a priority at or (logically) below the maximum
;;;944    	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;945    	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;946    	More information (albeit Cortex-M specific) is provided on the following
;;;947    	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;948    	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;949    
;;;950    	/* Similar to xQueueGenericSend, except we don't block if there is no room
;;;951    	in the queue.  Also we don't directly wake a task that was blocked on a
;;;952    	queue read, instead we return a flag to say whether a context switch is
;;;953    	required or not (i.e. has a task with a higher priority than us been woken
;;;954    	by this	post). */
;;;955    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000252  f7fffffe          BL       ulPortSetInterruptMask
000256  4680              MOV      r8,r0
;;;956    	{
;;;957    		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000258  6ba0              LDR      r0,[r4,#0x38]
00025a  6be1              LDR      r1,[r4,#0x3c]
00025c  4288              CMP      r0,r1
00025e  d307              BCC      |L1.624|
000260  2e02              CMP      r6,#2
000262  d005              BEQ      |L1.624|
;;;958    		{
;;;959    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;960    
;;;961    			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;962    
;;;963    			/* If the queue is locked we do not alter the event list.  This will
;;;964    			be done when the queue is unlocked later. */
;;;965    			if( pxQueue->xTxLock == queueUNLOCKED )
;;;966    			{
;;;967    				#if ( configUSE_QUEUE_SETS == 1 )
;;;968    				{
;;;969    					if( pxQueue->pxQueueSetContainer != NULL )
;;;970    					{
;;;971    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;972    						{
;;;973    							/* The queue is a member of a queue set, and posting
;;;974    							to the queue set caused a higher priority task to
;;;975    							unblock.  A context switch is required. */
;;;976    							if( pxHigherPriorityTaskWoken != NULL )
;;;977    							{
;;;978    								*pxHigherPriorityTaskWoken = pdTRUE;
;;;979    							}
;;;980    						}
;;;981    					}
;;;982    					else
;;;983    					{
;;;984    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;985    						{
;;;986    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;987    							{
;;;988    								/* The task waiting has a higher priority so record that a
;;;989    								context	switch is required. */
;;;990    								if( pxHigherPriorityTaskWoken != NULL )
;;;991    								{
;;;992    									*pxHigherPriorityTaskWoken = pdTRUE;
;;;993    								}
;;;994    							}
;;;995    						}
;;;996    					}
;;;997    				}
;;;998    				#else /* configUSE_QUEUE_SETS */
;;;999    				{
;;;1000   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1001   					{
;;;1002   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1003   						{
;;;1004   							/* The task waiting has a higher priority so record that a
;;;1005   							context	switch is required. */
;;;1006   							if( pxHigherPriorityTaskWoken != NULL )
;;;1007   							{
;;;1008   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1009   							}
;;;1010   						}
;;;1011   					}
;;;1012   				}
;;;1013   				#endif /* configUSE_QUEUE_SETS */
;;;1014   			}
;;;1015   			else
;;;1016   			{
;;;1017   				/* Increment the lock count so the task that unlocks the queue
;;;1018   				knows that data was posted while it was locked. */
;;;1019   				++( pxQueue->xTxLock );
;;;1020   			}
;;;1021   
;;;1022   			xReturn = pdPASS;
;;;1023   		}
;;;1024   		else
;;;1025   		{
;;;1026   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1027   			xReturn = errQUEUE_FULL;
000264  2400              MOVS     r4,#0
                  |L1.614|
;;;1028   		}
;;;1029   	}
;;;1030   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000266  4640              MOV      r0,r8
000268  f7fffffe          BL       vPortClearInterruptMask
;;;1031   
;;;1032   	return xReturn;
00026c  4620              MOV      r0,r4
;;;1033   }
00026e  e716              B        |L1.158|
                  |L1.624|
000270  4632              MOV      r2,r6                 ;961
000272  4639              MOV      r1,r7                 ;961
000274  4620              MOV      r0,r4                 ;961
000276  f7fffffe          BL       prvCopyDataToQueue
00027a  6ca0              LDR      r0,[r4,#0x48]         ;965
00027c  1c40              ADDS     r0,r0,#1              ;965
00027e  d004              BEQ      |L1.650|
000280  6ca0              LDR      r0,[r4,#0x48]         ;1019
000282  1c40              ADDS     r0,r0,#1              ;1019
000284  64a0              STR      r0,[r4,#0x48]         ;1019
                  |L1.646|
000286  2401              MOVS     r4,#1                 ;1022
000288  e7ed              B        |L1.614|
                  |L1.650|
00028a  6a60              LDR      r0,[r4,#0x24]         ;1000
00028c  2800              CMP      r0,#0                 ;1000
00028e  d0fa              BEQ      |L1.646|
000290  f1040024          ADD      r0,r4,#0x24           ;1002
000294  f7fffffe          BL       xTaskRemoveFromEventList
000298  2800              CMP      r0,#0                 ;1002
00029a  d0f4              BEQ      |L1.646|
00029c  2d00              CMP      r5,#0                 ;1006
00029e  d0f2              BEQ      |L1.646|
0002a0  2001              MOVS     r0,#1                 ;1008
0002a2  6028              STR      r0,[r5,#0]            ;1008
0002a4  e7ef              B        |L1.646|
;;;1034   /*-----------------------------------------------------------*/
                          ENDP

                  prvIsQueueEmpty PROC
;;;1570   
;;;1571   static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
0002a6  b510              PUSH     {r4,lr}
;;;1572   {
0002a8  4604              MOV      r4,r0
;;;1573   signed portBASE_TYPE xReturn;
;;;1574   
;;;1575   	taskENTER_CRITICAL();
0002aa  f7fffffe          BL       vPortEnterCritical
;;;1576   	{
;;;1577   		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
0002ae  6ba0              LDR      r0,[r4,#0x38]
0002b0  b120              CBZ      r0,|L1.700|
;;;1578   		{
;;;1579   			xReturn = pdTRUE;
;;;1580   		}
;;;1581   		else
;;;1582   		{
;;;1583   			xReturn = pdFALSE;
0002b2  2400              MOVS     r4,#0
                  |L1.692|
;;;1584   		}
;;;1585   	}
;;;1586   	taskEXIT_CRITICAL();
0002b4  f7fffffe          BL       vPortExitCritical
;;;1587   
;;;1588   	return xReturn;
0002b8  4620              MOV      r0,r4
;;;1589   }
0002ba  bd10              POP      {r4,pc}
                  |L1.700|
0002bc  2401              MOVS     r4,#1                 ;1579
0002be  e7f9              B        |L1.692|
;;;1590   /*-----------------------------------------------------------*/
                          ENDP

                  prvCopyDataFromQueue PROC
;;;1457   
;;;1458   static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
0002c0  b430              PUSH     {r4,r5}
;;;1459   {
0002c2  460c              MOV      r4,r1
;;;1460   	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
0002c4  6803              LDR      r3,[r0,#0]
0002c6  2b00              CMP      r3,#0
0002c8  d00c              BEQ      |L1.740|
;;;1461   	{
;;;1462   		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
0002ca  6c02              LDR      r2,[r0,#0x40]
0002cc  68c1              LDR      r1,[r0,#0xc]
0002ce  4411              ADD      r1,r1,r2
0002d0  60c1              STR      r1,[r0,#0xc]
;;;1463   		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
0002d2  6845              LDR      r5,[r0,#4]
0002d4  42a9              CMP      r1,r5
0002d6  d300              BCC      |L1.730|
;;;1464   		{
;;;1465   			pxQueue->u.pcReadFrom = pxQueue->pcHead;
0002d8  60c3              STR      r3,[r0,#0xc]
                  |L1.730|
;;;1466   		}
;;;1467   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
0002da  68c1              LDR      r1,[r0,#0xc]
0002dc  4620              MOV      r0,r4
0002de  bc30              POP      {r4,r5}
0002e0  f7ffbffe          B.W      __aeabi_memcpy
                  |L1.740|
;;;1468   	}
;;;1469   }
0002e4  bc30              POP      {r4,r5}
0002e6  4770              BX       lr
;;;1470   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericReceive PROC
;;;1035   
;;;1036   signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, const void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
0002e8  e92d41ff          PUSH     {r0-r8,lr}
;;;1037   {
0002ec  b082              SUB      sp,sp,#8
0002ee  4604              MOV      r4,r0
0002f0  4688              MOV      r8,r1
0002f2  461f              MOV      r7,r3
;;;1038   signed portBASE_TYPE xEntryTimeSet = pdFALSE;
0002f4  2500              MOVS     r5,#0
0002f6  2600              MOVS     r6,#0
                  |L1.760|
;;;1039   xTimeOutType xTimeOut;
;;;1040   signed char *pcOriginalReadPosition;
;;;1041   xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
;;;1042   
;;;1043   	configASSERT( pxQueue );
;;;1044   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;1045   
;;;1046   	/* This function relaxes the coding standard somewhat to allow return
;;;1047   	statements within the function itself.  This is done in the interest
;;;1048   	of execution time efficiency. */
;;;1049   
;;;1050   	for( ;; )
;;;1051   	{
;;;1052   		taskENTER_CRITICAL();
0002f8  f7fffffe          BL       vPortEnterCritical
;;;1053   		{
;;;1054   			/* Is there data in the queue now?  To be running we must be
;;;1055   			the highest priority task wanting to access the queue. */
;;;1056   			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
0002fc  6ba0              LDR      r0,[r4,#0x38]
0002fe  b310              CBZ      r0,|L1.838|
;;;1057   			{
;;;1058   				/* Remember the read position in case the queue is only being
;;;1059   				peeked. */
;;;1060   				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
000300  68e5              LDR      r5,[r4,#0xc]
;;;1061   
;;;1062   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000302  4641              MOV      r1,r8
000304  4620              MOV      r0,r4
000306  f7fffffe          BL       prvCopyDataFromQueue
;;;1063   
;;;1064   				if( xJustPeeking == pdFALSE )
00030a  b16f              CBZ      r7,|L1.808|
;;;1065   				{
;;;1066   					traceQUEUE_RECEIVE( pxQueue );
;;;1067   
;;;1068   					/* Actually removing data, not just peeking. */
;;;1069   					--( pxQueue->uxMessagesWaiting );
;;;1070   
;;;1071   					#if ( configUSE_MUTEXES == 1 )
;;;1072   					{
;;;1073   						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1074   						{
;;;1075   							/* Record the information required to implement
;;;1076   							priority inheritance should it become necessary. */
;;;1077   							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
;;;1078   						}
;;;1079   					}
;;;1080   					#endif
;;;1081   
;;;1082   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1083   					{
;;;1084   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
;;;1085   						{
;;;1086   							portYIELD_WITHIN_API();
;;;1087   						}
;;;1088   					}
;;;1089   				}
;;;1090   				else
;;;1091   				{
;;;1092   					traceQUEUE_PEEK( pxQueue );
;;;1093   
;;;1094   					/* The data is not being removed, so reset the read
;;;1095   					pointer. */
;;;1096   					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
00030c  60e5              STR      r5,[r4,#0xc]
;;;1097   
;;;1098   					/* The data is being left in the queue, so see if there are
;;;1099   					any other tasks waiting for the data. */
;;;1100   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00030e  6a60              LDR      r0,[r4,#0x24]
000310  b130              CBZ      r0,|L1.800|
;;;1101   					{
;;;1102   						/* Tasks that are removed from the event list will get added to
;;;1103   						the pending ready list as the scheduler is still suspended. */
;;;1104   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000312  f1040024          ADD      r0,r4,#0x24
000316  f7fffffe          BL       xTaskRemoveFromEventList
00031a  b108              CBZ      r0,|L1.800|
;;;1105   						{
;;;1106   							/* The task waiting has a higher priority than this task. */
;;;1107   							portYIELD_WITHIN_API();
00031c  f7fffffe          BL       vPortYield
                  |L1.800|
;;;1108   						}
;;;1109   					}
;;;1110   				}
;;;1111   
;;;1112   				taskEXIT_CRITICAL();
000320  f7fffffe          BL       vPortExitCritical
;;;1113   				return pdPASS;
000324  2001              MOVS     r0,#1
;;;1114   			}
;;;1115   			else
;;;1116   			{
;;;1117   				if( xTicksToWait == ( portTickType ) 0 )
;;;1118   				{
;;;1119   					/* The queue was empty and no block time is specified (or
;;;1120   					the block time has expired) so leave now. */
;;;1121   					taskEXIT_CRITICAL();
;;;1122   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1123   					return errQUEUE_EMPTY;
;;;1124   				}
;;;1125   				else if( xEntryTimeSet == pdFALSE )
;;;1126   				{
;;;1127   					/* The queue was empty and a block time was specified so
;;;1128   					configure the timeout structure. */
;;;1129   					vTaskSetTimeOutState( &xTimeOut );
;;;1130   					xEntryTimeSet = pdTRUE;
;;;1131   				}
;;;1132   				else
;;;1133   				{
;;;1134   					/* Entry time was already set. */
;;;1135   				}
;;;1136   			}
;;;1137   		}
;;;1138   		taskEXIT_CRITICAL();
;;;1139   
;;;1140   		/* Interrupts and other tasks can send to and receive from the queue
;;;1141   		now the critical section has been exited. */
;;;1142   
;;;1143   		vTaskSuspendAll();
;;;1144   		prvLockQueue( pxQueue );
;;;1145   
;;;1146   		/* Update the timeout state to see if it has expired yet. */
;;;1147   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1148   		{
;;;1149   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1150   			{
;;;1151   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1152   
;;;1153   				#if ( configUSE_MUTEXES == 1 )
;;;1154   				{
;;;1155   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1156   					{
;;;1157   						portENTER_CRITICAL();
;;;1158   						{
;;;1159   							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1160   						}
;;;1161   						portEXIT_CRITICAL();
;;;1162   					}
;;;1163   				}
;;;1164   				#endif
;;;1165   
;;;1166   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1167   				prvUnlockQueue( pxQueue );
;;;1168   				if( xTaskResumeAll() == pdFALSE )
;;;1169   				{
;;;1170   					portYIELD_WITHIN_API();
;;;1171   				}
;;;1172   			}
;;;1173   			else
;;;1174   			{
;;;1175   				/* Try again. */
;;;1176   				prvUnlockQueue( pxQueue );
;;;1177   				( void ) xTaskResumeAll();
;;;1178   			}
;;;1179   		}
;;;1180   		else
;;;1181   		{
;;;1182   			prvUnlockQueue( pxQueue );
;;;1183   			( void ) xTaskResumeAll();
;;;1184   			traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1185   			return errQUEUE_EMPTY;
;;;1186   		}
;;;1187   	}
;;;1188   }
000326  e74f              B        |L1.456|
                  |L1.808|
000328  6ba0              LDR      r0,[r4,#0x38]         ;1069
00032a  1e40              SUBS     r0,r0,#1              ;1069
00032c  63a0              STR      r0,[r4,#0x38]         ;1069
00032e  6920              LDR      r0,[r4,#0x10]         ;1082
000330  2800              CMP      r0,#0                 ;1082
000332  d0f5              BEQ      |L1.800|
000334  f1040010          ADD      r0,r4,#0x10           ;1084
000338  f7fffffe          BL       xTaskRemoveFromEventList
00033c  2801              CMP      r0,#1                 ;1084
00033e  d1ef              BNE      |L1.800|
000340  f7fffffe          BL       vPortYield
000344  e7ec              B        |L1.800|
                  |L1.838|
000346  9804              LDR      r0,[sp,#0x10]         ;1117
000348  b108              CBZ      r0,|L1.846|
00034a  b125              CBZ      r5,|L1.854|
00034c  e007              B        |L1.862|
                  |L1.846|
00034e  f7fffffe          BL       vPortExitCritical
000352  2000              MOVS     r0,#0                 ;1123
000354  e738              B        |L1.456|
                  |L1.854|
000356  4668              MOV      r0,sp                 ;1129
000358  f7fffffe          BL       vTaskSetTimeOutState
00035c  2501              MOVS     r5,#1                 ;1130
                  |L1.862|
00035e  f7fffffe          BL       vPortExitCritical
000362  f7fffffe          BL       vTaskSuspendAll
000366  f7fffffe          BL       vPortEnterCritical
00036a  6c60              LDR      r0,[r4,#0x44]         ;1144
00036c  1c40              ADDS     r0,r0,#1              ;1144
00036e  d100              BNE      |L1.882|
000370  6466              STR      r6,[r4,#0x44]         ;1144
                  |L1.882|
000372  6ca0              LDR      r0,[r4,#0x48]         ;1144
000374  1c40              ADDS     r0,r0,#1              ;1144
000376  d100              BNE      |L1.890|
000378  64a6              STR      r6,[r4,#0x48]         ;1144
                  |L1.890|
00037a  f7fffffe          BL       vPortExitCritical
00037e  a904              ADD      r1,sp,#0x10           ;1147
000380  4668              MOV      r0,sp                 ;1147
000382  f7fffffe          BL       xTaskCheckForTimeOut
000386  b130              CBZ      r0,|L1.918|
000388  4620              MOV      r0,r4                 ;1182
00038a  f7fffffe          BL       prvUnlockQueue
00038e  f7fffffe          BL       xTaskResumeAll
000392  2000              MOVS     r0,#0                 ;1185
000394  e718              B        |L1.456|
                  |L1.918|
000396  4620              MOV      r0,r4                 ;1149
000398  f7fffffe          BL       prvIsQueueEmpty
00039c  b170              CBZ      r0,|L1.956|
00039e  f1040024          ADD      r0,r4,#0x24           ;1166
0003a2  9904              LDR      r1,[sp,#0x10]         ;1166
0003a4  f7fffffe          BL       vTaskPlaceOnEventList
0003a8  4620              MOV      r0,r4                 ;1167
0003aa  f7fffffe          BL       prvUnlockQueue
0003ae  f7fffffe          BL       xTaskResumeAll
0003b2  2800              CMP      r0,#0                 ;1168
0003b4  d1a0              BNE      |L1.760|
0003b6  f7fffffe          BL       vPortYield
0003ba  e79d              B        |L1.760|
                  |L1.956|
0003bc  4620              MOV      r0,r4                 ;1176
0003be  f7fffffe          BL       prvUnlockQueue
0003c2  f7fffffe          BL       xTaskResumeAll
0003c6  e797              B        |L1.760|
;;;1189   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueReceiveFromISR PROC
;;;1190   
;;;1191   signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, const void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
0003c8  e92d41f0          PUSH     {r4-r8,lr}
;;;1192   {
0003cc  4604              MOV      r4,r0
0003ce  460f              MOV      r7,r1
0003d0  4615              MOV      r5,r2
;;;1193   signed portBASE_TYPE xReturn;
;;;1194   unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1195   xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
;;;1196   
;;;1197   	configASSERT( pxQueue );
;;;1198   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;1199   
;;;1200   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1201   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1202   	above the maximum system call priority are keep permanently enabled, even
;;;1203   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1204   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1205   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1206   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1207   	assigned a priority above the configured maximum system call priority.
;;;1208   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1209   	that have been assigned a priority at or (logically) below the maximum
;;;1210   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1211   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1212   	More information (albeit Cortex-M specific) is provided on the following
;;;1213   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1214   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1215   
;;;1216   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0003d2  f7fffffe          BL       ulPortSetInterruptMask
0003d6  4606              MOV      r6,r0
;;;1217   	{
;;;1218   		/* Cannot block in an ISR, so check there is data available. */
;;;1219   		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
0003d8  6ba0              LDR      r0,[r4,#0x38]
0003da  b1e0              CBZ      r0,|L1.1046|
;;;1220   		{
;;;1221   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1222   
;;;1223   			prvCopyDataFromQueue( pxQueue, pvBuffer );
0003dc  4639              MOV      r1,r7
0003de  4620              MOV      r0,r4
0003e0  f7fffffe          BL       prvCopyDataFromQueue
;;;1224   			--( pxQueue->uxMessagesWaiting );
0003e4  6ba0              LDR      r0,[r4,#0x38]
0003e6  1e40              SUBS     r0,r0,#1
0003e8  63a0              STR      r0,[r4,#0x38]
;;;1225   
;;;1226   			/* If the queue is locked the event list will not be modified.
;;;1227   			Instead update the lock count so the task that unlocks the queue
;;;1228   			will know that an ISR has removed data while the queue was
;;;1229   			locked. */
;;;1230   			if( pxQueue->xRxLock == queueUNLOCKED )
0003ea  6c60              LDR      r0,[r4,#0x44]
0003ec  1c40              ADDS     r0,r0,#1
0003ee  d004              BEQ      |L1.1018|
;;;1231   			{
;;;1232   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1233   				{
;;;1234   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
;;;1235   					{
;;;1236   						/* The task waiting has a higher priority than us so
;;;1237   						force a context switch. */
;;;1238   						if( pxHigherPriorityTaskWoken != NULL )
;;;1239   						{
;;;1240   							*pxHigherPriorityTaskWoken = pdTRUE;
;;;1241   						}
;;;1242   					}
;;;1243   				}
;;;1244   			}
;;;1245   			else
;;;1246   			{
;;;1247   				/* Increment the lock count so the task that unlocks the queue
;;;1248   				knows that data was removed while it was locked. */
;;;1249   				++( pxQueue->xRxLock );
0003f0  6c60              LDR      r0,[r4,#0x44]
0003f2  1c40              ADDS     r0,r0,#1
0003f4  6460              STR      r0,[r4,#0x44]
                  |L1.1014|
;;;1250   			}
;;;1251   
;;;1252   			xReturn = pdPASS;
0003f6  2401              MOVS     r4,#1
0003f8  e00e              B        |L1.1048|
                  |L1.1018|
0003fa  6920              LDR      r0,[r4,#0x10]         ;1232
0003fc  2800              CMP      r0,#0                 ;1232
0003fe  d0fa              BEQ      |L1.1014|
000400  f1040010          ADD      r0,r4,#0x10           ;1234
000404  f7fffffe          BL       xTaskRemoveFromEventList
000408  2800              CMP      r0,#0                 ;1234
00040a  d0f4              BEQ      |L1.1014|
00040c  2d00              CMP      r5,#0                 ;1238
00040e  d0f2              BEQ      |L1.1014|
000410  2001              MOVS     r0,#1                 ;1240
000412  6028              STR      r0,[r5,#0]            ;1240
000414  e7ef              B        |L1.1014|
                  |L1.1046|
;;;1253   		}
;;;1254   		else
;;;1255   		{
;;;1256   			xReturn = pdFAIL;
000416  2400              MOVS     r4,#0
                  |L1.1048|
;;;1257   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1258   		}
;;;1259   	}
;;;1260   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000418  4630              MOV      r0,r6
00041a  f7fffffe          BL       vPortClearInterruptMask
;;;1261   
;;;1262   	return xReturn;
00041e  4620              MOV      r0,r4
;;;1263   }
000420  e63d              B        |L1.158|
;;;1264   /*-----------------------------------------------------------*/
                          ENDP

                  xQueuePeekFromISR PROC
;;;1265   
;;;1266   signed portBASE_TYPE xQueuePeekFromISR( xQueueHandle xQueue, const void * const pvBuffer )
000422  e92d41f0          PUSH     {r4-r8,lr}
;;;1267   {
000426  4604              MOV      r4,r0
000428  460f              MOV      r7,r1
;;;1268   signed portBASE_TYPE xReturn;
;;;1269   unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1270   signed char *pcOriginalReadPosition;
;;;1271   xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
;;;1272   
;;;1273   	configASSERT( pxQueue );
;;;1274   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;1275   
;;;1276   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1277   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1278   	above the maximum system call priority are keep permanently enabled, even
;;;1279   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1280   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1281   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1282   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1283   	assigned a priority above the configured maximum system call priority.
;;;1284   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1285   	that have been assigned a priority at or (logically) below the maximum
;;;1286   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1287   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1288   	More information (albeit Cortex-M specific) is provided on the following
;;;1289   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1290   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1291   
;;;1292   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00042a  f7fffffe          BL       ulPortSetInterruptMask
00042e  4606              MOV      r6,r0
;;;1293   	{
;;;1294   		/* Cannot block in an ISR, so check there is data available. */
;;;1295   		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
000430  6ba0              LDR      r0,[r4,#0x38]
000432  b138              CBZ      r0,|L1.1092|
;;;1296   		{
;;;1297   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1298   
;;;1299   			/* Remember the read position so it can be reset as nothing is
;;;1300   			actually being removed from the queue. */
;;;1301   			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
000434  68e5              LDR      r5,[r4,#0xc]
;;;1302   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000436  4639              MOV      r1,r7
000438  4620              MOV      r0,r4
00043a  f7fffffe          BL       prvCopyDataFromQueue
;;;1303   			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
00043e  60e5              STR      r5,[r4,#0xc]
;;;1304   
;;;1305   			xReturn = pdPASS;
000440  2401              MOVS     r4,#1
000442  e000              B        |L1.1094|
                  |L1.1092|
;;;1306   		}
;;;1307   		else
;;;1308   		{
;;;1309   			xReturn = pdFAIL;
000444  2400              MOVS     r4,#0
                  |L1.1094|
;;;1310   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1311   		}
;;;1312   	}
;;;1313   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000446  4630              MOV      r0,r6
000448  f7fffffe          BL       vPortClearInterruptMask
;;;1314   
;;;1315   	return xReturn;
00044c  4620              MOV      r0,r4
;;;1316   }
00044e  e626              B        |L1.158|
;;;1317   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueMessagesWaiting PROC
;;;1318   
;;;1319   unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
000450  b510              PUSH     {r4,lr}
;;;1320   {
000452  4604              MOV      r4,r0
;;;1321   unsigned portBASE_TYPE uxReturn;
;;;1322   
;;;1323   	configASSERT( xQueue );
;;;1324   
;;;1325   	taskENTER_CRITICAL();
000454  f7fffffe          BL       vPortEnterCritical
;;;1326   		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
000458  6ba4              LDR      r4,[r4,#0x38]
;;;1327   	taskEXIT_CRITICAL();
00045a  f7fffffe          BL       vPortExitCritical
;;;1328   
;;;1329   	return uxReturn;
00045e  4620              MOV      r0,r4
;;;1330   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000460  bd10              POP      {r4,pc}
;;;1331   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueSpacesAvailable PROC
;;;1332   
;;;1333   unsigned portBASE_TYPE uxQueueSpacesAvailable( const xQueueHandle xQueue )
000462  b510              PUSH     {r4,lr}
;;;1334   {
000464  4604              MOV      r4,r0
;;;1335   unsigned portBASE_TYPE uxReturn;
;;;1336   xQUEUE *pxQueue;
;;;1337   
;;;1338   	pxQueue = ( xQUEUE * ) xQueue;
;;;1339   	configASSERT( pxQueue );
;;;1340   
;;;1341   	taskENTER_CRITICAL();
000466  f7fffffe          BL       vPortEnterCritical
;;;1342   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
00046a  e9d4100e          LDRD     r1,r0,[r4,#0x38]
00046e  1a44              SUBS     r4,r0,r1
;;;1343   	taskEXIT_CRITICAL();
000470  f7fffffe          BL       vPortExitCritical
;;;1344   
;;;1345   	return uxReturn;
000474  4620              MOV      r0,r4
;;;1346   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000476  bd10              POP      {r4,pc}
;;;1347   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueMessagesWaitingFromISR PROC
;;;1348   
;;;1349   unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
000478  6b80              LDR      r0,[r0,#0x38]
;;;1350   {
;;;1351   unsigned portBASE_TYPE uxReturn;
;;;1352   
;;;1353   	configASSERT( xQueue );
;;;1354   
;;;1355   	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
;;;1356   
;;;1357   	return uxReturn;
;;;1358   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00047a  4770              BX       lr
;;;1359   /*-----------------------------------------------------------*/
                          ENDP

                  vQueueDelete PROC
;;;1360   
;;;1361   void vQueueDelete( xQueueHandle xQueue )
00047c  b510              PUSH     {r4,lr}
;;;1362   {
00047e  4604              MOV      r4,r0
;;;1363   xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
;;;1364   
;;;1365   	configASSERT( pxQueue );
;;;1366   
;;;1367   	traceQUEUE_DELETE( pxQueue );
;;;1368   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1369   	{
;;;1370   		vQueueUnregisterQueue( pxQueue );
;;;1371   	}
;;;1372   	#endif
;;;1373   	vPortFree( pxQueue->pcHead );
000480  6820              LDR      r0,[r4,#0]
000482  f7fffffe          BL       vPortFree
;;;1374   	vPortFree( pxQueue );
000486  4620              MOV      r0,r4
000488  e8bd4010          POP      {r4,lr}
00048c  f7ffbffe          B.W      vPortFree
;;;1375   }
;;;1376   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueIsQueueEmptyFromISR PROC
;;;1591   
;;;1592   signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
000490  6b80              LDR      r0,[r0,#0x38]
;;;1593   {
;;;1594   signed portBASE_TYPE xReturn;
;;;1595   
;;;1596   	configASSERT( xQueue );
;;;1597   	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
000492  b108              CBZ      r0,|L1.1176|
;;;1598   	{
;;;1599   		xReturn = pdTRUE;
;;;1600   	}
;;;1601   	else
;;;1602   	{
;;;1603   		xReturn = pdFALSE;
000494  2000              MOVS     r0,#0
;;;1604   	}
;;;1605   
;;;1606   	return xReturn;
;;;1607   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000496  4770              BX       lr
                  |L1.1176|
000498  2001              MOVS     r0,#1                 ;1599
00049a  4770              BX       lr
;;;1608   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueIsQueueFullFromISR PROC
;;;1630   
;;;1631   signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
00049c  6b81              LDR      r1,[r0,#0x38]
;;;1632   {
;;;1633   signed portBASE_TYPE xReturn;
;;;1634   
;;;1635   	configASSERT( xQueue );
;;;1636   	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
00049e  6bc0              LDR      r0,[r0,#0x3c]
0004a0  4281              CMP      r1,r0
0004a2  d101              BNE      |L1.1192|
;;;1637   	{
;;;1638   		xReturn = pdTRUE;
0004a4  2001              MOVS     r0,#1
;;;1639   	}
;;;1640   	else
;;;1641   	{
;;;1642   		xReturn = pdFALSE;
;;;1643   	}
;;;1644   
;;;1645   	return xReturn;
;;;1646   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
0004a6  4770              BX       lr
                  |L1.1192|
0004a8  2000              MOVS     r0,#0                 ;1642
0004aa  4770              BX       lr
;;;1647   /*-----------------------------------------------------------*/
                          ENDP

