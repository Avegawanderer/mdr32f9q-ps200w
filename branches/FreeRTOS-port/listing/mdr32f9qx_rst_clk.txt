; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\mdr32f9qx_rst_clk.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\mdr32f9qx_rst_clk.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -I.\src\gui -I.\src\gui\guiCore -I.\src\gui\guiWidgets -I.\src\gui\guiGraphics -I.\src\gui\utils -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\mdr32f9qx_rst_clk.crf ..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_rst_clk.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RST_CLK_PCLKcmd PROC
;;;958      */
;;;959    void RST_CLK_PCLKcmd(uint32_t RST_CLK_PCLK, FunctionalState NewState)
000000  4afe              LDR      r2,|L1.1020|
;;;960    {
;;;961      /* Check the parameters */
;;;962      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;963      assert_param(IS_RST_CLK_PCLK(RST_CLK_PCLK));
;;;964      if (NewState != DISABLE)
000002  b119              CBZ      r1,|L1.12|
;;;965      {
;;;966        MDR_RST_CLK->PER_CLOCK |= RST_CLK_PCLK;
000004  69d1              LDR      r1,[r2,#0x1c]
000006  4301              ORRS     r1,r1,r0
000008  61d1              STR      r1,[r2,#0x1c]
;;;967      }
;;;968      else
;;;969      {
;;;970        MDR_RST_CLK->PER_CLOCK &= ~RST_CLK_PCLK;
;;;971      }
;;;972    }
00000a  4770              BX       lr
                  |L1.12|
00000c  69d1              LDR      r1,[r2,#0x1c]         ;970
00000e  4381              BICS     r1,r1,r0              ;970
000010  61d1              STR      r1,[r2,#0x1c]         ;970
000012  4770              BX       lr
;;;973    
                          ENDP

                  RST_CLK_CPUclkSelection PROC
;;;614      */
;;;615    void RST_CLK_CPUclkSelection(uint32_t CPU_CLK)
000014  4af9              LDR      r2,|L1.1020|
;;;616    {
;;;617      uint32_t temp;
;;;618    
;;;619      /* Check the parameters */
;;;620      assert_param(IS_RST_CPU_CLK(CPU_CLK));
;;;621    
;;;622      temp = MDR_RST_CLK->CPU_CLOCK;
000016  68d1              LDR      r1,[r2,#0xc]
;;;623      /* Clear CPU_C3_SEL bits */
;;;624      temp &= CPU_HCLK_SELclr;
000018  f4217140          BIC      r1,r1,#0x300
;;;625      /* Set the CPU_C3_SEL bits */
;;;626      temp |= CPU_CLK;
00001c  4301              ORRS     r1,r1,r0
;;;627      /* Store the new value */
;;;628      MDR_RST_CLK->CPU_CLOCK = temp;
00001e  60d1              STR      r1,[r2,#0xc]
;;;629    }
000020  4770              BX       lr
;;;630    
                          ENDP

                  RST_CLK_GetFlagStatus PROC
;;;1183     */
;;;1184   FlagStatus RST_CLK_GetFlagStatus(uint32_t RST_CLK_FLAG)
000022  f3c01142          UBFX     r1,r0,#5,#3
;;;1185   {
;;;1186     uint32_t statusreg;
;;;1187     FlagStatus bitstatus;
;;;1188   
;;;1189     /* Check the parameters */
;;;1190     assert_param(IS_RST_CLK_FLAG(RST_CLK_FLAG));
;;;1191   
;;;1192     /* Get the register */
;;;1193     if ((FLAG_SFR_MASK & RST_CLK_FLAG) == (uint32_t)0x20) /* The flag to check is in CLOCK_STATUS register */
000026  2901              CMP      r1,#1
000028  d009              BEQ      |L1.62|
;;;1194     {
;;;1195       statusreg = MDR_RST_CLK->CLOCK_STATUS;
;;;1196     }
;;;1197     else                                                  /* The flag to check is in REG_0F register */
;;;1198     {
;;;1199       statusreg = MDR_BKP->REG_0F;
00002a  49f5              LDR      r1,|L1.1024|
00002c  6bc9              LDR      r1,[r1,#0x3c]
                  |L1.46|
;;;1200     }
;;;1201   
;;;1202     /* Get the flag status on proper position */
;;;1203     if ((statusreg & ((uint32_t)1 << (RST_CLK_FLAG & FLAG_MASK))) != (uint32_t)0x00)
00002e  f000021f          AND      r2,r0,#0x1f
000032  2001              MOVS     r0,#1
000034  4090              LSLS     r0,r0,r2
000036  4208              TST      r0,r1
000038  d004              BEQ      |L1.68|
;;;1204     {
;;;1205       bitstatus = SET;
00003a  2001              MOVS     r0,#1
;;;1206     }
;;;1207     else
;;;1208     {
;;;1209       bitstatus = RESET;
;;;1210     }
;;;1211   
;;;1212     /* Return the flag status */
;;;1213     return bitstatus;
;;;1214   }
00003c  4770              BX       lr
                  |L1.62|
00003e  49ef              LDR      r1,|L1.1020|
000040  6809              LDR      r1,[r1,#0]            ;1195
000042  e7f4              B        |L1.46|
                  |L1.68|
000044  2000              MOVS     r0,#0                 ;1209
000046  4770              BX       lr
;;;1215   
                          ENDP

                  RST_CLK_HSIstatus PROC
;;;373      */
;;;374    ErrorStatus RST_CLK_HSIstatus(void)
000048  b510              PUSH     {r4,lr}
;;;375    {
;;;376      __IO uint32_t startCounter = 0;
00004a  2300              MOVS     r3,#0
;;;377      ErrorStatus state;
;;;378      FlagStatus flag;
;;;379    
;;;380      /* Wait until HSI is ready or time out is occure */
;;;381      do
;;;382      {
;;;383        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY);
;;;384        startCounter++;
;;;385      } while ((startCounter < HSIonTimeOut) && (flag == RESET));
00004c  f44f64c0          MOV      r4,#0x600
                  |L1.80|
000050  2017              MOVS     r0,#0x17              ;383
000052  f7fffffe          BL       RST_CLK_GetFlagStatus
000056  1c5b              ADDS     r3,r3,#1              ;384
000058  42a3              CMP      r3,r4
00005a  d201              BCS      |L1.96|
00005c  2800              CMP      r0,#0
00005e  d0f7              BEQ      |L1.80|
                  |L1.96|
;;;386    
;;;387      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY) != RESET)
000060  2017              MOVS     r0,#0x17
000062  f7fffffe          BL       RST_CLK_GetFlagStatus
000066  b108              CBZ      r0,|L1.108|
;;;388      {
;;;389        state = SUCCESS;
000068  2001              MOVS     r0,#1
;;;390      }
;;;391      else
;;;392      {
;;;393        state = ERROR;
;;;394      }
;;;395      return state;
;;;396    }
00006a  bd10              POP      {r4,pc}
                  |L1.108|
00006c  2000              MOVS     r0,#0                 ;393
00006e  bd10              POP      {r4,pc}
;;;397    
                          ENDP

                  RST_CLK_HSIcmd PROC
;;;340      */
;;;341    void RST_CLK_HSIcmd(FunctionalState NewState)
000070  49e4              LDR      r1,|L1.1028|
;;;342    {
;;;343      /* Check the parameters */
;;;344      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;345    
;;;346      *(__IO uint32_t *) HSION_BB = (uint32_t)NewState;
000072  6008              STR      r0,[r1,#0]
;;;347    }
000074  4770              BX       lr
;;;348    
                          ENDP

                  RST_CLK_WarmDeInit PROC
;;;183      */
;;;184    void RST_CLK_WarmDeInit(void)
000076  b500              PUSH     {lr}
;;;185    {
;;;186      /* Prepare HSI clk */
;;;187      RST_CLK_HSIcmd(ENABLE);
000078  2001              MOVS     r0,#1
00007a  f7fffffe          BL       RST_CLK_HSIcmd
;;;188      RST_CLK_HSIstatus();
00007e  f7fffffe          BL       RST_CLK_HSIstatus
;;;189      RST_CLK_CPUclkSelection(RST_CLK_CPUclkHSI);
000082  2000              MOVS     r0,#0
000084  f7fffffe          BL       RST_CLK_CPUclkSelection
;;;190    
;;;191      /* Reset CPU_CLOCK bits */
;;;192      MDR_RST_CLK->CPU_CLOCK   &= (uint32_t)0x00000000;
000088  48dc              LDR      r0,|L1.1020|
00008a  68c1              LDR      r1,[r0,#0xc]
00008c  2100              MOVS     r1,#0
00008e  60c1              STR      r1,[r0,#0xc]
;;;193    
;;;194      /* Reset PLL_CONTROL bits */
;;;195      MDR_RST_CLK->PLL_CONTROL &= (uint32_t)0x00000000;
000090  6842              LDR      r2,[r0,#4]
000092  6041              STR      r1,[r0,#4]
;;;196    
;;;197      /* Reset HSEON and HSEBYP bits */
;;;198      MDR_RST_CLK->HS_CONTROL  &= (uint32_t)0x00000000;
000094  6882              LDR      r2,[r0,#8]
000096  6081              STR      r1,[r0,#8]
;;;199    
;;;200      /* Reset USB_CLOCK bits */
;;;201      MDR_RST_CLK->USB_CLOCK   &= (uint32_t)0x00000000;
000098  6902              LDR      r2,[r0,#0x10]
00009a  6101              STR      r1,[r0,#0x10]
;;;202    
;;;203      /* Reset ADC_MCO_CLOCK bits */
;;;204      MDR_RST_CLK->ADC_MCO_CLOCK   &= (uint32_t)0x00000000;
00009c  6942              LDR      r2,[r0,#0x14]
00009e  6141              STR      r1,[r0,#0x14]
;;;205    
;;;206      /* Reset RTC_CLOCK bits */
;;;207      MDR_RST_CLK->RTC_CLOCK   &= (uint32_t)0x00000000;
0000a0  6982              LDR      r2,[r0,#0x18]
0000a2  6181              STR      r1,[r0,#0x18]
;;;208    
;;;209      /* Reset all clock but RTC_CLK bit */
;;;210      MDR_RST_CLK->PER_CLOCK   = (uint32_t)PCLK_BIT(MDR_RST_CLK_BASE) | (uint32_t)PCLK_BIT(MDR_BKP_BASE);
0000a4  49d8              LDR      r1,|L1.1032|
0000a6  61c1              STR      r1,[r0,#0x1c]
;;;211    }
0000a8  bd00              POP      {pc}
;;;212    
                          ENDP

                  RST_CLK_DeInit PROC
;;;168      */
;;;169    void RST_CLK_DeInit(void)
0000aa  b500              PUSH     {lr}
;;;170    {
;;;171      RST_CLK_WarmDeInit();
0000ac  f7fffffe          BL       RST_CLK_WarmDeInit
;;;172      /* Reset REG_0F bits to zero but HSION bit */
;;;173      RST_CLK_PCLKcmd(RST_CLK_PCLK_BKP, ENABLE);
0000b0  2101              MOVS     r1,#1
0000b2  06c8              LSLS     r0,r1,#27
0000b4  f7fffffe          BL       RST_CLK_PCLKcmd
;;;174      MDR_BKP->REG_0F |= (uint32_t)((1<<22)|(1<<15)); /* HSION & LSION */
0000b8  48d1              LDR      r0,|L1.1024|
0000ba  6bc1              LDR      r1,[r0,#0x3c]
0000bc  f4410181          ORR      r1,r1,#0x408000
0000c0  63c1              STR      r1,[r0,#0x3c]
;;;175      MDR_BKP->REG_0F &= (uint32_t)((1<<22)|(1<<15));
0000c2  6bc1              LDR      r1,[r0,#0x3c]
0000c4  f4010181          AND      r1,r1,#0x408000
0000c8  63c1              STR      r1,[r0,#0x3c]
;;;176    }
0000ca  bd00              POP      {pc}
;;;177    
                          ENDP

                  RST_CLK_HSEconfig PROC
;;;220      */
;;;221    void RST_CLK_HSEconfig(uint32_t RST_CLK_HSE)
0000cc  49cb              LDR      r1,|L1.1020|
;;;222    {
;;;223      /* Check the parameters */
;;;224      assert_param(IS_RST_CLK_HSE(RST_CLK_HSE));
;;;225      /* Reset HSEON and HSEBYP bits before configuring the HSE */
;;;226      MDR_RST_CLK->HS_CONTROL &= ~((uint32_t)(RST_CLK_HSE_ON | RST_CLK_HSE_Bypass));
0000ce  688a              LDR      r2,[r1,#8]
0000d0  f0220203          BIC      r2,r2,#3
0000d4  608a              STR      r2,[r1,#8]
;;;227      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;228      switch (RST_CLK_HSE)
0000d6  2801              CMP      r0,#1
0000d8  d006              BEQ      |L1.232|
0000da  2802              CMP      r0,#2
0000dc  d103              BNE      |L1.230|
;;;229      {
;;;230        case RST_CLK_HSE_ON:
;;;231          /* Set HSEON bit */
;;;232          MDR_RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON;
;;;233          break;
;;;234    
;;;235        case RST_CLK_HSE_Bypass:
;;;236          /* Set HSEBYP and HSEON bits */
;;;237          MDR_RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON | RST_CLK_HSE_Bypass;
0000de  6888              LDR      r0,[r1,#8]
0000e0  f0400003          ORR      r0,r0,#3
0000e4  6088              STR      r0,[r1,#8]
                  |L1.230|
;;;238          break;
;;;239    
;;;240        default:
;;;241          break;
;;;242      }
;;;243    }
0000e6  4770              BX       lr
                  |L1.232|
0000e8  6888              LDR      r0,[r1,#8]            ;232
0000ea  f0400001          ORR      r0,r0,#1              ;232
0000ee  6088              STR      r0,[r1,#8]            ;232
0000f0  4770              BX       lr
;;;244    
                          ENDP

                  RST_CLK_HSEstatus PROC
;;;249      */
;;;250    ErrorStatus RST_CLK_HSEstatus(void)
0000f2  b510              PUSH     {r4,lr}
;;;251    {
;;;252      __IO uint32_t startCounter = 0;
0000f4  2300              MOVS     r3,#0
;;;253      ErrorStatus state;
;;;254      FlagStatus flag;
;;;255    
;;;256      /* Wait until HSE is ready or time out is occure */
;;;257      do
;;;258      {
;;;259        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY);
;;;260        startCounter++;
;;;261      } while ((startCounter < HSEonTimeOut) && (flag == RESET));
0000f6  f44f64c0          MOV      r4,#0x600
                  |L1.250|
0000fa  2022              MOVS     r0,#0x22              ;259
0000fc  f7fffffe          BL       RST_CLK_GetFlagStatus
000100  1c5b              ADDS     r3,r3,#1              ;260
000102  42a3              CMP      r3,r4
000104  d201              BCS      |L1.266|
000106  2800              CMP      r0,#0
000108  d0f7              BEQ      |L1.250|
                  |L1.266|
;;;262    
;;;263      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY) != RESET)
00010a  2022              MOVS     r0,#0x22
00010c  f7fffffe          BL       RST_CLK_GetFlagStatus
000110  b108              CBZ      r0,|L1.278|
;;;264      {
;;;265        state = SUCCESS;
000112  2001              MOVS     r0,#1
;;;266      }
;;;267      else
;;;268      {
;;;269        state = ERROR;
;;;270      }
;;;271      return state;
;;;272    }
000114  bd10              POP      {r4,pc}
                  |L1.278|
000116  2000              MOVS     r0,#0                 ;269
000118  bd10              POP      {r4,pc}
;;;273    
                          ENDP

                  RST_CLK_LSEconfig PROC
;;;281      */
;;;282    void RST_CLK_LSEconfig(uint32_t RST_CLK_LSE)
00011a  49b9              LDR      r1,|L1.1024|
;;;283    {
;;;284      /* Check the parameters */
;;;285      assert_param(IS_RST_CLK_LSE(RST_CLK_LSE));
;;;286      /* Reset LSEON and LSEBYP bits before configuring the LSE */
;;;287      MDR_BKP->REG_0F &= ~((uint32_t)(RST_CLK_LSE_ON | RST_CLK_LSE_Bypass));
00011c  6bca              LDR      r2,[r1,#0x3c]
00011e  f0220203          BIC      r2,r2,#3
000122  63ca              STR      r2,[r1,#0x3c]
;;;288      switch (RST_CLK_LSE)
000124  2801              CMP      r0,#1
000126  d006              BEQ      |L1.310|
000128  2802              CMP      r0,#2
00012a  d103              BNE      |L1.308|
;;;289      {
;;;290        case RST_CLK_LSE_ON:
;;;291          /* Set LSEON bit */
;;;292          MDR_BKP->REG_0F |= RST_CLK_LSE_ON;
;;;293          break;
;;;294    
;;;295        case RST_CLK_LSE_Bypass:
;;;296          /* Set LSEBYP and LSEON bits */
;;;297          MDR_BKP->REG_0F |= (RST_CLK_LSE_ON | RST_CLK_LSE_Bypass);
00012c  6bc8              LDR      r0,[r1,#0x3c]
00012e  f0400003          ORR      r0,r0,#3
000132  63c8              STR      r0,[r1,#0x3c]
                  |L1.308|
;;;298          break;
;;;299    
;;;300        default:
;;;301          break;
;;;302      }
;;;303    }
000134  4770              BX       lr
                  |L1.310|
000136  6bc8              LDR      r0,[r1,#0x3c]         ;292
000138  f0400001          ORR      r0,r0,#1              ;292
00013c  63c8              STR      r0,[r1,#0x3c]         ;292
00013e  4770              BX       lr
;;;304    
                          ENDP

                  RST_CLK_LSEstatus PROC
;;;309      */
;;;310    ErrorStatus RST_CLK_LSEstatus(void)
000140  b510              PUSH     {r4,lr}
;;;311    {
;;;312      __IO uint32_t startCounter = 0;
000142  2300              MOVS     r3,#0
;;;313      ErrorStatus state;
;;;314      FlagStatus flag;
;;;315    
;;;316     /* Wait until LSE is ready or time out is occure */
;;;317     do
;;;318      {
;;;319        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY);
;;;320        startCounter++;
;;;321      } while ((startCounter < LSEonTimeOut) && (flag == RESET));
000144  f44f64c0          MOV      r4,#0x600
                  |L1.328|
000148  200d              MOVS     r0,#0xd               ;319
00014a  f7fffffe          BL       RST_CLK_GetFlagStatus
00014e  1c5b              ADDS     r3,r3,#1              ;320
000150  42a3              CMP      r3,r4
000152  d201              BCS      |L1.344|
000154  2800              CMP      r0,#0
000156  d0f7              BEQ      |L1.328|
                  |L1.344|
;;;322    
;;;323      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY) != RESET)
000158  200d              MOVS     r0,#0xd
00015a  f7fffffe          BL       RST_CLK_GetFlagStatus
00015e  b108              CBZ      r0,|L1.356|
;;;324      {
;;;325        state = SUCCESS;
000160  2001              MOVS     r0,#1
;;;326      }
;;;327      else
;;;328      {
;;;329        state = ERROR;
;;;330      }
;;;331      return state;
;;;332    }
000162  bd10              POP      {r4,pc}
                  |L1.356|
000164  2000              MOVS     r0,#0                 ;329
000166  bd10              POP      {r4,pc}
;;;333    
                          ENDP

                  RST_CLK_HSIadjust PROC
;;;354      */
;;;355    void RST_CLK_HSIadjust(uint32_t HSItrimValue)
000168  4aa5              LDR      r2,|L1.1024|
;;;356    {
;;;357      uint32_t temp;
;;;358      /* Check the parameters */
;;;359      assert_param(IS_RCC_CLK_HSI_TRIM_VALUE(HSItrimValue));
;;;360      temp = MDR_BKP->REG_0F;
00016a  6bd1              LDR      r1,[r2,#0x3c]
;;;361      /* Clear HSITRIM[5:0] bits */
;;;362      temp &= ~HSITRIM_MASK;
00016c  f021517c          BIC      r1,r1,#0x3f000000
;;;363      /* Set the HSITRIM[5:0] bits according to HSItrimValue value */
;;;364      temp |= (uint32_t)HSItrimValue << HSITRIM_OFFSET;
000170  ea416000          ORR      r0,r1,r0,LSL #24
;;;365      /* Store the new value */
;;;366      MDR_BKP->REG_0F = temp;
000174  63d0              STR      r0,[r2,#0x3c]
;;;367    }
000176  4770              BX       lr
;;;368    
                          ENDP

                  RST_CLK_LSIcmd PROC
;;;404      */
;;;405    void RST_CLK_LSIcmd(FunctionalState NewState)
000178  49a2              LDR      r1,|L1.1028|
;;;406    {
;;;407      /* Check the parameters */
;;;408      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;409    
;;;410      *(__IO uint32_t *) LSION_BB = (uint32_t)NewState;
00017a  391c              SUBS     r1,r1,#0x1c
00017c  6008              STR      r0,[r1,#0]
;;;411    }
00017e  4770              BX       lr
;;;412    
                          ENDP

                  RST_CLK_LSIadjust PROC
;;;418      */
;;;419    void RST_CLK_LSIadjust(uint32_t LSItrimValue)
000180  4a9f              LDR      r2,|L1.1024|
;;;420    {
;;;421      uint32_t temp;
;;;422      /* Check the parameters */
;;;423      assert_param(IS_RCC_CLK_LSI_TRIM_VALUE(LSItrimValue));
;;;424      temp = MDR_BKP->REG_0F;
000182  6bd1              LDR      r1,[r2,#0x3c]
;;;425      /* Clear LSITRIM[4:0] bits */
;;;426      temp &= ~LSITRIM_MASK;
000184  f42111f8          BIC      r1,r1,#0x1f0000
;;;427      /* Set the LSITRIM[4:0] bits according to LSItrimValue value */
;;;428      temp |= (uint32_t)LSItrimValue << LSITRIM_OFFSET;
000188  ea414000          ORR      r0,r1,r0,LSL #16
;;;429      /* Store the new value */
;;;430      MDR_BKP->REG_0F = temp;
00018c  63d0              STR      r0,[r2,#0x3c]
;;;431    }
00018e  4770              BX       lr
;;;432    
                          ENDP

                  RST_CLK_LSIstatus PROC
;;;437      */
;;;438    ErrorStatus RST_CLK_LSIstatus(void)
000190  b510              PUSH     {r4,lr}
;;;439    {
;;;440      __IO uint32_t startCounter = 0;
000192  2300              MOVS     r3,#0
;;;441      ErrorStatus state;
;;;442      FlagStatus flag;
;;;443    
;;;444      /* Wait until LSI is ready or time out is occure */
;;;445      do
;;;446      {
;;;447        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY);
;;;448        startCounter++;
;;;449      } while ((startCounter < LSIonTimeOut) && (flag == RESET));
000194  f44f64c0          MOV      r4,#0x600
                  |L1.408|
000198  2015              MOVS     r0,#0x15              ;447
00019a  f7fffffe          BL       RST_CLK_GetFlagStatus
00019e  1c5b              ADDS     r3,r3,#1              ;448
0001a0  42a3              CMP      r3,r4
0001a2  d201              BCS      |L1.424|
0001a4  2800              CMP      r0,#0
0001a6  d0f7              BEQ      |L1.408|
                  |L1.424|
;;;450    
;;;451      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY) != RESET)
0001a8  2015              MOVS     r0,#0x15
0001aa  f7fffffe          BL       RST_CLK_GetFlagStatus
0001ae  b108              CBZ      r0,|L1.436|
;;;452      {
;;;453        state = SUCCESS;
0001b0  2001              MOVS     r0,#1
;;;454      }
;;;455      else
;;;456      {
;;;457        state = ERROR;
;;;458      }
;;;459      return (state);
;;;460    }
0001b2  bd10              POP      {r4,pc}
                  |L1.436|
0001b4  2000              MOVS     r0,#0                 ;457
0001b6  bd10              POP      {r4,pc}
;;;461    
                          ENDP

                  RST_CLK_CPU_PLLconfig PROC
;;;488      */
;;;489    void RST_CLK_CPU_PLLconfig(uint32_t RST_CLK_CPU_PLLsource, uint32_t RST_CLK_CPU_PLLmul)
0001b8  4a90              LDR      r2,|L1.1020|
;;;490    {
;;;491      uint32_t temp;
;;;492    
;;;493      /* Check the parameters */
;;;494      assert_param(IS_RST_CLK_CPU_PLL_SOURCE(RST_CLK_CPU_PLLsource));
;;;495      assert_param(IS_RST_CLK_CPU_PLL_MUL(RST_CLK_CPU_PLLmul));
;;;496    
;;;497      /* Select CPUPLL source */
;;;498      temp = MDR_RST_CLK->CPU_CLOCK;
0001ba  68d3              LDR      r3,[r2,#0xc]
;;;499      /* Clear CPU_C1_SEL bits */
;;;500      temp &= CPU_C1_SELclr;
0001bc  f0230303          BIC      r3,r3,#3
;;;501      /* Set the CPU_C1_SEL bits */
;;;502      temp |= RST_CLK_CPU_PLLsource;
0001c0  4303              ORRS     r3,r3,r0
;;;503      /* Store the new value */
;;;504      MDR_RST_CLK->CPU_CLOCK = temp;
0001c2  60d3              STR      r3,[r2,#0xc]
;;;505    
;;;506      /* Set CPUPLL multiplier */
;;;507      temp = MDR_RST_CLK->PLL_CONTROL;
0001c4  6850              LDR      r0,[r2,#4]
;;;508      /* Clear PLLMUL[3:0] bits */
;;;509      temp &= PLLCPUmulclr;
0001c6  f4206070          BIC      r0,r0,#0xf00
;;;510      /* Set the PLLMUL[3:0] bits */
;;;511      temp |= (RST_CLK_CPU_PLLmul<<PLLCPUMUL_OFFSET);
0001ca  ea402001          ORR      r0,r0,r1,LSL #8
;;;512      /* Store the new value */
;;;513      MDR_RST_CLK->PLL_CONTROL = temp;
0001ce  6050              STR      r0,[r2,#4]
;;;514    
;;;515      if ( *(__IO uint32_t *) PLLCPUON_BB)
0001d0  488e              LDR      r0,|L1.1036|
0001d2  f8d01088          LDR      r1,[r0,#0x88]
0001d6  2900              CMP      r1,#0
0001d8  d004              BEQ      |L1.484|
;;;516      {
;;;517         *(__IO uint32_t *) PLLCPUPLD_BB = (uint32_t)0x01;
0001da  2101              MOVS     r1,#1
0001dc  f8401f8c          STR      r1,[r0,#0x8c]!
;;;518         *(__IO uint32_t *) PLLCPUPLD_BB = (uint32_t)0x00;
0001e0  2100              MOVS     r1,#0
0001e2  6001              STR      r1,[r0,#0]
                  |L1.484|
;;;519      }
;;;520    }
0001e4  4770              BX       lr
;;;521    
                          ENDP

                  RST_CLK_CPU_PLLuse PROC
;;;526      */
;;;527    void RST_CLK_CPU_PLLuse(FunctionalState UsePLL)
0001e6  498a              LDR      r1,|L1.1040|
;;;528    {
;;;529      /* Check the parameters */
;;;530      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;531    
;;;532      *(__IO uint32_t *) CPU_C2_SEL_BB = (uint32_t)UsePLL;
0001e8  6008              STR      r0,[r1,#0]
;;;533    }
0001ea  4770              BX       lr
;;;534    
                          ENDP

                  RST_CLK_CPU_PLLcmd PROC
;;;539      */
;;;540    void RST_CLK_CPU_PLLcmd(FunctionalState NewState)
0001ec  4989              LDR      r1,|L1.1044|
;;;541    {
;;;542      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;543    
;;;544      *(__IO uint32_t *) PLLCPUON_BB = (uint32_t)NewState;
0001ee  6008              STR      r0,[r1,#0]
;;;545    }
0001f0  4770              BX       lr
;;;546    
                          ENDP

                  RST_CLK_CPU_PLLstatus PROC
;;;551      */
;;;552    ErrorStatus RST_CLK_CPU_PLLstatus(void)
0001f2  b510              PUSH     {r4,lr}
;;;553    {
;;;554      __IO uint32_t startCounter = 0;
0001f4  2300              MOVS     r3,#0
;;;555      ErrorStatus state;
;;;556      FlagStatus flag;
;;;557    
;;;558      /* Wait until CPUPLL is ready or time out is occure */
;;;559      do
;;;560      {
;;;561        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY);
;;;562        startCounter++;
;;;563      } while ((startCounter < PLLCPUonTimeOut) && (flag == RESET));
0001f6  f44f64c0          MOV      r4,#0x600
                  |L1.506|
0001fa  2021              MOVS     r0,#0x21              ;561
0001fc  f7fffffe          BL       RST_CLK_GetFlagStatus
000200  1c5b              ADDS     r3,r3,#1              ;562
000202  42a3              CMP      r3,r4
000204  d201              BCS      |L1.522|
000206  2800              CMP      r0,#0
000208  d0f7              BEQ      |L1.506|
                  |L1.522|
;;;564    
;;;565      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY) != RESET)
00020a  2021              MOVS     r0,#0x21
00020c  f7fffffe          BL       RST_CLK_GetFlagStatus
000210  b108              CBZ      r0,|L1.534|
;;;566      {
;;;567        state = SUCCESS;
000212  2001              MOVS     r0,#1
;;;568      }
;;;569      else
;;;570      {
;;;571        state = ERROR;
;;;572      }
;;;573      return state;
;;;574    }
000214  bd10              POP      {r4,pc}
                  |L1.534|
000216  2000              MOVS     r0,#0                 ;571
000218  bd10              POP      {r4,pc}
;;;575    
                          ENDP

                  RST_CLK_CPUclkPrescaler PROC
;;;589      */
;;;590    void RST_CLK_CPUclkPrescaler(uint32_t CPUclkDivValue)
00021a  4a78              LDR      r2,|L1.1020|
;;;591    {
;;;592      uint32_t temp;
;;;593    
;;;594      /* Check the parameters */
;;;595      assert_param(IS_RST_CLK_CPUclkDIV(CPUclkDivValue));
;;;596    
;;;597      temp = MDR_RST_CLK->CPU_CLOCK;
00021c  68d1              LDR      r1,[r2,#0xc]
;;;598      /* Clear CPU_C3_SEL bits */
;;;599      temp &= CPU_C3_SELclr;
00021e  f02101f0          BIC      r1,r1,#0xf0
;;;600      /* Set the CPU_C3_SEL bits */
;;;601      temp |= (CPUclkDivValue << RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos);
000222  ea411000          ORR      r0,r1,r0,LSL #4
;;;602      /* Store the new value */
;;;603      MDR_RST_CLK->CPU_CLOCK = temp;
000226  60d0              STR      r0,[r2,#0xc]
;;;604    }
000228  4770              BX       lr
;;;605    
                          ENDP

                  RST_CLK_USB_PLLconfig PROC
;;;657      */
;;;658    void RST_CLK_USB_PLLconfig(uint32_t RST_CLK_USB_PLLsource, uint32_t RST_CLK_USB_PLLmul)
00022a  4a74              LDR      r2,|L1.1020|
;;;659    {
;;;660      uint32_t temp;
;;;661    
;;;662      /* Check the parameters */
;;;663      assert_param(IS_RST_CLK_USB_PLL_SOURCE(RST_CLK_USB_PLLsource));
;;;664      assert_param(IS_RST_CLK_USB_PLL_MUL(RST_CLK_USB_PLLmul));
;;;665    
;;;666      /* Select USBPLL source */
;;;667      temp = MDR_RST_CLK->USB_CLOCK;
00022c  6913              LDR      r3,[r2,#0x10]
;;;668      /* Clear USB_C1_SEL bits */
;;;669      temp &= USB_C1_SELclr;
00022e  f0230303          BIC      r3,r3,#3
;;;670      /* Set the USB_C1_SEL bits */
;;;671      temp |= RST_CLK_USB_PLLsource;
000232  4303              ORRS     r3,r3,r0
;;;672      /* Store the new value */
;;;673      MDR_RST_CLK->USB_CLOCK = temp;
000234  6113              STR      r3,[r2,#0x10]
;;;674    
;;;675      /* Set USBPLL multiplier */
;;;676      temp = MDR_RST_CLK->PLL_CONTROL;
000236  6850              LDR      r0,[r2,#4]
;;;677      /* Clear PLLMUL[3:0] bits */
;;;678      temp &= PLLUSBmulclr;
000238  f02000f0          BIC      r0,r0,#0xf0
;;;679      /* Set the PLLMUL[3:0] bits */
;;;680      temp |= (RST_CLK_USB_PLLmul<<PLLUSBMUL_OFFSET);
00023c  ea401001          ORR      r0,r0,r1,LSL #4
;;;681      /* Store the new value */
;;;682      MDR_RST_CLK->PLL_CONTROL = temp;
000240  6050              STR      r0,[r2,#4]
;;;683    
;;;684      if ( *(__IO uint32_t *) PLLUSBON_BB)
000242  4872              LDR      r0,|L1.1036|
000244  f8d01080          LDR      r1,[r0,#0x80]
000248  2900              CMP      r1,#0
00024a  d004              BEQ      |L1.598|
;;;685      {
;;;686        *(__IO uint32_t *) PLLUSBRLD_BB  = (uint32_t)0x01;
00024c  2101              MOVS     r1,#1
00024e  f8401f84          STR      r1,[r0,#0x84]!
;;;687        *(__IO uint32_t *) PLLUSBRLD_BB  = (uint32_t)0x00;
000252  2100              MOVS     r1,#0
000254  6001              STR      r1,[r0,#0]
                  |L1.598|
;;;688      }
;;;689    }
000256  4770              BX       lr
;;;690    
                          ENDP

                  RST_CLK_USB_PLLuse PROC
;;;695      */
;;;696    void RST_CLK_USB_PLLuse(FunctionalState UsePLL)
000258  496f              LDR      r1,|L1.1048|
;;;697    {
;;;698      /* Check the parameters */
;;;699      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;700    
;;;701      *(__IO uint32_t *) USB_C2_SEL_BB = (uint32_t)UsePLL;
00025a  6008              STR      r0,[r1,#0]
;;;702    }
00025c  4770              BX       lr
;;;703    
                          ENDP

                  RST_CLK_USB_PLLcmd PROC
;;;708      */
;;;709    void RST_CLK_USB_PLLcmd(FunctionalState NewState)
00025e  496f              LDR      r1,|L1.1052|
;;;710    {
;;;711      /* Check the parameters */
;;;712      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;713    
;;;714      *(__IO uint32_t *) PLLUSBON_BB = (uint32_t)NewState;
000260  6008              STR      r0,[r1,#0]
;;;715    }
000262  4770              BX       lr
;;;716    
                          ENDP

                  RST_CLK_USB_PLLstatus PROC
;;;721      */
;;;722    ErrorStatus RST_CLK_USB_PLLstatus(void)
000264  b510              PUSH     {r4,lr}
;;;723    {
;;;724      __IO uint32_t startCounter = 0;
000266  2300              MOVS     r3,#0
;;;725      ErrorStatus state;
;;;726      FlagStatus flag;
;;;727    
;;;728      /* Wait until USBPLL is ready or time out is occure */
;;;729      do
;;;730      {
;;;731        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY);
;;;732        startCounter++;
;;;733      } while ((startCounter < PLLUSBonTimeOut) && (flag == RESET));
000268  f44f64c0          MOV      r4,#0x600
                  |L1.620|
00026c  2020              MOVS     r0,#0x20              ;731
00026e  f7fffffe          BL       RST_CLK_GetFlagStatus
000272  1c5b              ADDS     r3,r3,#1              ;732
000274  42a3              CMP      r3,r4
000276  d201              BCS      |L1.636|
000278  2800              CMP      r0,#0
00027a  d0f7              BEQ      |L1.620|
                  |L1.636|
;;;734    
;;;735      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY) != RESET)
00027c  2020              MOVS     r0,#0x20
00027e  f7fffffe          BL       RST_CLK_GetFlagStatus
000282  b108              CBZ      r0,|L1.648|
;;;736      {
;;;737        state = SUCCESS;
000284  2001              MOVS     r0,#1
;;;738      }
;;;739      else
;;;740      {
;;;741        state = ERROR;
;;;742      }
;;;743      return state;
;;;744    }
000286  bd10              POP      {r4,pc}
                  |L1.648|
000288  2000              MOVS     r0,#0                 ;741
00028a  bd10              POP      {r4,pc}
;;;745    
                          ENDP

                  RST_CLK_USBclkPrescaler PROC
;;;752      */
;;;753    void RST_CLK_USBclkPrescaler(FunctionalState NewState)
00028c  4964              LDR      r1,|L1.1056|
;;;754    {
;;;755      /* Check the parameters */
;;;756      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;757    
;;;758      *(__IO uint32_t *) USB_CLK_EN_BB = (uint32_t)NewState;
00028e  6008              STR      r0,[r1,#0]
;;;759    }
000290  4770              BX       lr
;;;760    
                          ENDP

                  RST_CLK_USBclkEnable PROC
;;;767      */
;;;768    void RST_CLK_USBclkEnable(FunctionalState NewState)
000292  4964              LDR      r1,|L1.1060|
;;;769    {
;;;770      /* Check the parameters */
;;;771      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;772    
;;;773      *(__IO uint32_t *) USB_C3_SEL_BB = (uint32_t)NewState;
000294  6008              STR      r0,[r1,#0]
;;;774    }
000296  4770              BX       lr
;;;775    
                          ENDP

                  RST_CLK_ADCclkSelection PROC
;;;787      */
;;;788    void RST_CLK_ADCclkSelection(uint32_t ADC_CLK)
000298  4a58              LDR      r2,|L1.1020|
;;;789    {
;;;790      uint32_t temp;
;;;791    
;;;792      /* Check the parameters */
;;;793      assert_param(IS_RST_CLK_ADCclk(ADC_CLK));
;;;794    
;;;795      /* Select ADC_CLK source */
;;;796      temp = MDR_RST_CLK->ADC_MCO_CLOCK;
00029a  6951              LDR      r1,[r2,#0x14]
;;;797      /* Clear ADC_C1,C2 SEL bits */
;;;798      temp &= ADC_C12_SELclr;
00029c  f0210133          BIC      r1,r1,#0x33
;;;799      /* Set the ADC_C1,C2 SEL bits */
;;;800      temp |= ADC_CLK;
0002a0  4301              ORRS     r1,r1,r0
;;;801      /* Store the new value */
;;;802      MDR_RST_CLK->ADC_MCO_CLOCK = temp;
0002a2  6151              STR      r1,[r2,#0x14]
;;;803    }
0002a4  4770              BX       lr
;;;804    
                          ENDP

                  RST_CLK_ADCclkPrescaler PROC
;;;819      */
;;;820    void RST_CLK_ADCclkPrescaler(uint32_t ADCclkDivValue)
0002a6  4a55              LDR      r2,|L1.1020|
;;;821    {
;;;822      uint32_t temp;
;;;823    
;;;824      /* Check the parameters */
;;;825      assert_param(IS_RST_CLK_ADCclkDivValue(ADCclkDivValue));
;;;826    
;;;827      temp = MDR_RST_CLK->ADC_MCO_CLOCK;
0002a8  6951              LDR      r1,[r2,#0x14]
;;;828      /* Clear ADC_C3_SEL bits */
;;;829      temp &= ADC_C3_SELclr;
0002aa  f4216170          BIC      r1,r1,#0xf00
;;;830      /* Set the ADC_C3_SEL bits */
;;;831      temp |= ADCclkDivValue<<ADC_C3_SEL_OFFSET;
0002ae  ea412000          ORR      r0,r1,r0,LSL #8
;;;832      /* Store the new value */
;;;833      MDR_RST_CLK->ADC_MCO_CLOCK = temp;
0002b2  6150              STR      r0,[r2,#0x14]
;;;834    }
0002b4  4770              BX       lr
;;;835    
                          ENDP

                  RST_CLK_ADCclkEnable PROC
;;;842      */
;;;843    void RST_CLK_ADCclkEnable(FunctionalState NewState)
0002b6  495c              LDR      r1,|L1.1064|
;;;844    {
;;;845      /* Check the parameters */
;;;846      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;847    
;;;848      *(__IO uint32_t *) ADC_CLK_EN_BB = (uint32_t)NewState;
0002b8  6008              STR      r0,[r1,#0]
;;;849    }
0002ba  4770              BX       lr
;;;850    
                          ENDP

                  RST_CLK_HSIclkPrescaler PROC
;;;865      */
;;;866    void RST_CLK_HSIclkPrescaler(uint32_t HSIclkDivValue)
0002bc  4a4f              LDR      r2,|L1.1020|
;;;867    {
;;;868      uint32_t temp;
;;;869    
;;;870      /* Check the parameters */
;;;871      assert_param(IS_RST_CLK_HSIclkDivValue(HSIclkDivValue));
;;;872    
;;;873      temp = MDR_RST_CLK->RTC_CLOCK;
0002be  6991              LDR      r1,[r2,#0x18]
;;;874      /* Clear HSI_SEL bits */
;;;875      temp &= HSI_SELclr;
0002c0  f02101f0          BIC      r1,r1,#0xf0
;;;876      /* Set the HSI_SEL bits */
;;;877      temp |= HSIclkDivValue<<HSI_SEL_OFFSET;
0002c4  ea411000          ORR      r0,r1,r0,LSL #4
;;;878      /* Store the new value */
;;;879      MDR_RST_CLK->RTC_CLOCK = temp;
0002c8  6190              STR      r0,[r2,#0x18]
;;;880    }
0002ca  4770              BX       lr
;;;881    
                          ENDP

                  RST_CLK_RTC_HSIclkEnable PROC
;;;888      */
;;;889    void RST_CLK_RTC_HSIclkEnable(FunctionalState NewState)
0002cc  4957              LDR      r1,|L1.1068|
;;;890    {
;;;891      /* Check the parameters */
;;;892      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;893    
;;;894      *(__IO uint32_t *) HSI_RTC_EN_BB = (uint32_t)NewState;
0002ce  6008              STR      r0,[r1,#0]
;;;895    }
0002d0  4770              BX       lr
;;;896    
                          ENDP

                  RST_CLK_HSEclkPrescaler PROC
;;;911      */
;;;912    void RST_CLK_HSEclkPrescaler(uint32_t HSEclkDivValue)
0002d2  4a4a              LDR      r2,|L1.1020|
;;;913    {
;;;914      uint32_t temp;
;;;915    
;;;916      /* Check the parameters */
;;;917      assert_param(IS_RST_CLK_HSEclkDivValue(HSEclkDivValue));
;;;918    
;;;919      temp = MDR_RST_CLK->RTC_CLOCK;
0002d4  6991              LDR      r1,[r2,#0x18]
;;;920      /* Clear HSE_SEL bits */
;;;921      temp &= HSE_SELclr;
0002d6  f021010f          BIC      r1,r1,#0xf
;;;922      /* Set the HSE_SEL bits */
;;;923      temp |= HSEclkDivValue<<HSE_SEL_OFFSET;
0002da  4301              ORRS     r1,r1,r0
;;;924      /* Store the new value */
;;;925      MDR_RST_CLK->RTC_CLOCK = temp;
0002dc  6191              STR      r1,[r2,#0x18]
;;;926    }
0002de  4770              BX       lr
;;;927    
                          ENDP

                  RST_CLK_RTC_HSEclkEnable PROC
;;;934      */
;;;935    void RST_CLK_RTC_HSEclkEnable(FunctionalState NewState)
0002e0  4953              LDR      r1,|L1.1072|
;;;936    {
;;;937      /* Check the parameters */
;;;938      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;939    
;;;940      *(__IO uint32_t *) HSE_RTC_EN_BB = (uint32_t)NewState;
0002e2  6008              STR      r0,[r1,#0]
;;;941    }
0002e4  4770              BX       lr
;;;942    
                          ENDP

                  RST_CLK_GetClocksFreq PROC
;;;980      */
;;;981    void RST_CLK_GetClocksFreq(RST_CLK_FreqTypeDef* RST_CLK_Clocks)
0002e6  e92d4ff0          PUSH     {r4-r11,lr}
;;;982    {
;;;983      uint32_t cpu_c1_freq, cpu_c2_freq, cpu_c3_freq;
;;;984      uint32_t usb_c1_freq, usb_c2_freq, usb_c3_freq;
;;;985      uint32_t adc_c1_freq, adc_c2_freq, adc_c3_freq;
;;;986      uint32_t hsi_c1_freq, hse_c1_freq;
;;;987      uint32_t pll_mul;
;;;988      uint32_t temp;
;;;989    
;;;990      /* Check the parameter */
;;;991      assert_param(RST_CLK_Clocks != 0);
;;;992    
;;;993      /* Compute CPU_CLK, USB_CLK, ADC_CLK, RTCHSI, RTCHSE clocks frequencies */
;;;994    
;;;995      /* Compute CPU_CLK frequency */
;;;996    
;;;997      /* Determine CPU_C1 frequency */
;;;998      if (*(__IO uint32_t *) CPU_C1_SEL1_BB)
0002ea  f8dfb120          LDR      r11,|L1.1036|
0002ee  f8db1184          LDR      r1,[r11,#0x184]
;;;999      {
;;;1000       cpu_c1_freq = HSE_Value;
0002f2  f8dfa140          LDR      r10,|L1.1076|
;;;1001     }
;;;1002     else
;;;1003     {
;;;1004       cpu_c1_freq = HSI_Value;
0002f6  ea4f054a          LSL      r5,r10,#1
0002fa  b109              CBZ      r1,|L1.768|
0002fc  4651              MOV      r1,r10                ;1000
0002fe  e000              B        |L1.770|
                  |L1.768|
000300  4629              MOV      r1,r5
                  |L1.770|
;;;1005     }
;;;1006   
;;;1007     if (*(__IO uint32_t *) CPU_C1_SEL0_BB)
000302  f8db2180          LDR      r2,[r11,#0x180]
000306  b102              CBZ      r2,|L1.778|
;;;1008     {
;;;1009       cpu_c1_freq /= 2;
000308  0849              LSRS     r1,r1,#1
                  |L1.778|
;;;1010     }
;;;1011   
;;;1012     /* Determine CPU_C2 frequency */
;;;1013     cpu_c2_freq = cpu_c1_freq;
00030a  460b              MOV      r3,r1
;;;1014   
;;;1015     if (*(__IO uint32_t *) CPU_C2_SEL_BB != 0)
00030c  f8db2188          LDR      r2,[r11,#0x188]
;;;1016     {
;;;1017       /* Determine CPU PLL output frequency */
;;;1018       pll_mul = ((MDR_RST_CLK->PLL_CONTROL >> RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos) & (uint32_t)0x0F) + 1;
000310  f8dfc0e8          LDR      r12,|L1.1020|
000314  b12a              CBZ      r2,|L1.802|
000316  f8dc2004          LDR      r2,[r12,#4]
00031a  f3c22203          UBFX     r2,r2,#8,#4
00031e  1c52              ADDS     r2,r2,#1
;;;1019       cpu_c2_freq *= pll_mul;
000320  4353              MULS     r3,r2,r3
                  |L1.802|
;;;1020     }
;;;1021   
;;;1022     /*Select CPU_CLK from HSI, CPU_C3, LSE, LSI cases */
;;;1023     switch ((MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_HCLK_SEL_Pos) & (uint32_t)0x03)
000322  f8dc200c          LDR      r2,[r12,#0xc]
;;;1024     {
;;;1025       case 0 :
;;;1026         /* HSI */
;;;1027         RST_CLK_Clocks->CPU_CLK_Frequency = HSI_Value;
;;;1028         break;
;;;1029       case 1 :
;;;1030         /* CPU_C3 */
;;;1031         /* Determine CPU_C3 frequency */
;;;1032         if (( MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos & (uint32_t)0x08) == 0x00)
;;;1033         {
;;;1034           cpu_c3_freq = cpu_c2_freq;
;;;1035         }
;;;1036         else
;;;1037         {
;;;1038           cpu_c3_freq = cpu_c2_freq/(1 << ((MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos & (uint32_t)0x07) + 1));
;;;1039         }
;;;1040         RST_CLK_Clocks->CPU_CLK_Frequency = cpu_c3_freq;
;;;1041         break;
;;;1042       case 2 :
;;;1043         /* LSE */
;;;1044         RST_CLK_Clocks->CPU_CLK_Frequency = LSE_Value;
000326  f44f4800          MOV      r8,#0x8000
00032a  f3c22201          UBFX     r2,r2,#8,#2           ;1023
;;;1045         break;
;;;1046       default : /* case 3 */
;;;1047         /* LSI */
;;;1048         RST_CLK_Clocks->CPU_CLK_Frequency = LSI_Value;
00032e  f6494940          MOV      r9,#0x9c40
000332  2701              MOVS     r7,#1                 ;1038
000334  b152              CBZ      r2,|L1.844|
000336  2a01              CMP      r2,#1                 ;1023
000338  d00a              BEQ      |L1.848|
00033a  2a02              CMP      r2,#2                 ;1023
00033c  d01b              BEQ      |L1.886|
00033e  f8c09000          STR      r9,[r0,#0]
                  |L1.834|
;;;1049         break;
;;;1050     }
;;;1051   
;;;1052     /* Compute USB_CLK frequency */
;;;1053   
;;;1054     /* Determine USB_C1 frequency */
;;;1055     if (*(__IO uint32_t *) USB_C1_SEL1_BB)
000342  f8db2204          LDR      r2,[r11,#0x204]
000346  b1ca              CBZ      r2,|L1.892|
;;;1056     {
;;;1057       usb_c1_freq = HSE_Value;
000348  4652              MOV      r2,r10
00034a  e018              B        |L1.894|
                  |L1.844|
00034c  6005              STR      r5,[r0,#0]            ;1027
00034e  e7f8              B        |L1.834|
                  |L1.848|
000350  f8dc200c          LDR      r2,[r12,#0xc]         ;1032
000354  ea4f1212          LSR      r2,r2,#4              ;1032
000358  0712              LSLS     r2,r2,#28             ;1032
00035a  d401              BMI      |L1.864|
00035c  461a              MOV      r2,r3                 ;1034
00035e  e008              B        |L1.882|
                  |L1.864|
000360  f8dc200c          LDR      r2,[r12,#0xc]         ;1038
000364  f3c21202          UBFX     r2,r2,#4,#3           ;1038
000368  1c52              ADDS     r2,r2,#1              ;1038
00036a  fa07f202          LSL      r2,r7,r2              ;1038
00036e  fbb3f2f2          UDIV     r2,r3,r2              ;1038
                  |L1.882|
000372  6002              STR      r2,[r0,#0]            ;1040
000374  e7e5              B        |L1.834|
                  |L1.886|
000376  f8c08000          STR      r8,[r0,#0]            ;1044
00037a  e7e2              B        |L1.834|
                  |L1.892|
;;;1058     }
;;;1059     else
;;;1060     {
;;;1061       usb_c1_freq = HSI_Value;
00037c  462a              MOV      r2,r5
                  |L1.894|
;;;1062     }
;;;1063   
;;;1064     if (*(__IO uint32_t *) USB_C1_SEL0_BB)
00037e  f8db4200          LDR      r4,[r11,#0x200]
000382  b104              CBZ      r4,|L1.902|
;;;1065     {
;;;1066       usb_c1_freq /= 2;
000384  0852              LSRS     r2,r2,#1
                  |L1.902|
;;;1067     }
;;;1068   
;;;1069     /* Determine USB_C2 frequency */
;;;1070     usb_c2_freq = usb_c1_freq;
000386  4614              MOV      r4,r2
;;;1071   
;;;1072     if (*(__IO uint32_t *) USB_C2_SEL_BB != 0)
000388  f8db6208          LDR      r6,[r11,#0x208]
00038c  b12e              CBZ      r6,|L1.922|
;;;1073     {
;;;1074       /* Determine USB PLL output frequency */
;;;1075       pll_mul = ((MDR_RST_CLK->PLL_CONTROL >> RST_CLK_PLL_CONTROL_PLL_USB_MUL_Pos) & (uint32_t)0x0F) + 1;
00038e  f8dc6004          LDR      r6,[r12,#4]
000392  f3c61603          UBFX     r6,r6,#4,#4
000396  1c76              ADDS     r6,r6,#1
;;;1076       usb_c2_freq *= pll_mul;
000398  4374              MULS     r4,r6,r4
                  |L1.922|
;;;1077     }
;;;1078   
;;;1079     /* Determine USB_C3 frequency */
;;;1080     usb_c3_freq = usb_c2_freq;
00039a  4626              MOV      r6,r4
;;;1081     if (*(__IO uint32_t *) USB_C3_SEL_BB != 0)
00039c  f8dbb210          LDR      r11,[r11,#0x210]
0003a0  f1bb0f00          CMP      r11,#0
0003a4  d000              BEQ      |L1.936|
;;;1082     {
;;;1083       usb_c3_freq /= 2;
0003a6  0876              LSRS     r6,r6,#1
                  |L1.936|
;;;1084     }
;;;1085   
;;;1086     RST_CLK_Clocks->USB_CLK_Frequency = usb_c3_freq;
0003a8  6046              STR      r6,[r0,#4]
;;;1087   
;;;1088     /* Compute RTCHSI_CLK frequency */
;;;1089     temp = MDR_RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSI_SEL_Pos;
0003aa  f8dc6018          LDR      r6,[r12,#0x18]
0003ae  0936              LSRS     r6,r6,#4
;;;1090     if ((temp & 0x08U) == 0)
0003b0  ea5f7b06          LSLS     r11,r6,#28
0003b4  d507              BPL      |L1.966|
;;;1091     {
;;;1092       hsi_c1_freq = HSI_Value;
;;;1093     }
;;;1094     else
;;;1095     {
;;;1096       temp = 1 << ((temp & 0x07U) + 1);
0003b6  f0060b07          AND      r11,r6,#7
0003ba  f10b0b01          ADD      r11,r11,#1
0003be  fa07f60b          LSL      r6,r7,r11
;;;1097       hsi_c1_freq = HSI_Value/temp;
0003c2  fbb5f5f6          UDIV     r5,r5,r6
                  |L1.966|
;;;1098     }
;;;1099     RST_CLK_Clocks->RTCHSI_Frequency = hsi_c1_freq;
0003c6  60c5              STR      r5,[r0,#0xc]
;;;1100   
;;;1101     /* Compute RTCHSE_CLK frequency */
;;;1102     temp = MDR_RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSE_SEL_Pos;
0003c8  f8dc6018          LDR      r6,[r12,#0x18]
;;;1103     if ((temp & 0x08U) == 0)
0003cc  ea5f7b06          LSLS     r11,r6,#28
0003d0  d507              BPL      |L1.994|
;;;1104     {
;;;1105       hse_c1_freq = HSE_Value;
;;;1106     }
;;;1107     else
;;;1108     {
;;;1109       temp = 1 << ((temp & 0x07U) + 1);
0003d2  f0060b07          AND      r11,r6,#7
0003d6  f10b0b01          ADD      r11,r11,#1
0003da  fa07f60b          LSL      r6,r7,r11
;;;1110       hse_c1_freq = HSE_Value/temp;
0003de  fbbafaf6          UDIV     r10,r10,r6
                  |L1.994|
;;;1111     }
;;;1112     RST_CLK_Clocks->RTCHSE_Frequency = hse_c1_freq;
0003e2  f8c0a010          STR      r10,[r0,#0x10]
;;;1113   
;;;1114     /* Compute ADC_CLK frequency */
;;;1115   
;;;1116     /* Select ADC_C1 from CPU_C1, LSI, USB_C1, CPU_C2, USB_C2 cases */
;;;1117     switch ((MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Pos) & (uint32_t)0x03)
0003e6  f8dc6014          LDR      r6,[r12,#0x14]
0003ea  f0160603          ANDS     r6,r6,#3
0003ee  d004              BEQ      |L1.1018|
0003f0  2e01              CMP      r6,#1
0003f2  d039              BEQ      |L1.1128|
0003f4  2e02              CMP      r6,#2
0003f6  d039              BEQ      |L1.1132|
;;;1118     {
;;;1119       case 0 :
;;;1120         /* CPU_C1 */
;;;1121         adc_c1_freq = cpu_c1_freq;
;;;1122         break;
;;;1123       case 1 :
;;;1124         /* USB_C1 */
;;;1125         adc_c1_freq = usb_c1_freq;
;;;1126         break;
;;;1127       case 2 :
;;;1128         /* CPU_C2 */
;;;1129         adc_c1_freq = cpu_c2_freq;
;;;1130         break;
;;;1131       default : /* case 3 */
;;;1132         /* USB_C2 */
;;;1133         adc_c1_freq = usb_c2_freq;
0003f8  4621              MOV      r1,r4
                  |L1.1018|
;;;1134         break;
;;;1135     }
;;;1136   
;;;1137     /* Select ADC_C2 from LSE, LSI, ADC_C1, HSI_C1 cases */
;;;1138     switch ((MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Pos) & (uint32_t)0x03)
0003fa  e01d              B        |L1.1080|
                  |L1.1020|
                          DCD      0x40020000
                  |L1.1024|
                          DCD      0x400d8000
                  |L1.1028|
                          DCD      0x43b007d8
                  |L1.1032|
                          DCD      0x08000010
                  |L1.1036|
                          DCD      0x42400000
                  |L1.1040|
                          DCD      0x42400188
                  |L1.1044|
                          DCD      0x42400088
                  |L1.1048|
                          DCD      0x42400208
                  |L1.1052|
                          DCD      0x42400080
                  |L1.1056|
                          DCD      0x42400220
                  |L1.1060|
                          DCD      0x42400210
                  |L1.1064|
                          DCD      0x424002b4
                  |L1.1068|
                          DCD      0x42400324
                  |L1.1072|
                          DCD      0x42400320
                  |L1.1076|
                          DCD      0x003d0900
                  |L1.1080|
000438  f8dc2014          LDR      r2,[r12,#0x14]
00043c  f3c21201          UBFX     r2,r2,#4,#2
000440  b1b2              CBZ      r2,|L1.1136|
000442  2a01              CMP      r2,#1
000444  d016              BEQ      |L1.1140|
000446  2a02              CMP      r2,#2
000448  d000              BEQ      |L1.1100|
;;;1139     {
;;;1140       case 0 :
;;;1141         /* LSE */
;;;1142         adc_c2_freq = LSE_Value;
;;;1143         break;
;;;1144       case 1 :
;;;1145         /* LSI */
;;;1146         adc_c2_freq = LSI_Value;
;;;1147         break;
;;;1148       case 2 :
;;;1149         /* ADC_C1 */
;;;1150         adc_c2_freq = adc_c1_freq;
;;;1151         break;
;;;1152       default : /* case 3 */
;;;1153         /* HSI_C1 */
;;;1154         adc_c2_freq = hsi_c1_freq;
00044a  4629              MOV      r1,r5
                  |L1.1100|
;;;1155         break;
;;;1156     }
;;;1157   
;;;1158     temp = MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Pos;
00044c  f8dc2014          LDR      r2,[r12,#0x14]
000450  0a12              LSRS     r2,r2,#8
;;;1159     if ((temp & 0x08U) == 0)
000452  0713              LSLS     r3,r2,#28
000454  d505              BPL      |L1.1122|
;;;1160     {
;;;1161       adc_c3_freq = adc_c2_freq;
;;;1162     }
;;;1163     else
;;;1164     {
;;;1165       temp = 1 << ((temp & 0x07U) + 1);
000456  f0020207          AND      r2,r2,#7
00045a  1c52              ADDS     r2,r2,#1
00045c  4097              LSLS     r7,r7,r2
;;;1166       adc_c3_freq = adc_c2_freq/temp;
00045e  fbb1f1f7          UDIV     r1,r1,r7
                  |L1.1122|
;;;1167     }
;;;1168   
;;;1169     RST_CLK_Clocks->ADC_CLK_Frequency = adc_c3_freq;
000462  6081              STR      r1,[r0,#8]
;;;1170   }
000464  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.1128|
000468  4611              MOV      r1,r2                 ;1125
00046a  e7c6              B        |L1.1018|
                  |L1.1132|
00046c  4619              MOV      r1,r3                 ;1129
00046e  e7c4              B        |L1.1018|
                  |L1.1136|
000470  4641              MOV      r1,r8                 ;1142
000472  e7eb              B        |L1.1100|
                  |L1.1140|
000474  4649              MOV      r1,r9                 ;1146
000476  e7e9              B        |L1.1100|
;;;1171   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Library\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_rst_clk.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REVSH|
#line 130
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
