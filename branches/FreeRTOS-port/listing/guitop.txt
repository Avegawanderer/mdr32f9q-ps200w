; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\guitop.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\guitop.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -I.\src\gui -I.\src\gui\guiCore -I.\src\gui\guiWidgets -I.\src\gui\guiGraphics -I.\src\gui\utils -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\guitop.crf src\guiTop.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  encodeGuiKey PROC
;;;43     // Encode physical buttons into GUI virtual keys
;;;44     static uint8_t encodeGuiKey(uint16_t btnCode)
000000  2804              CMP      r0,#4
;;;45     {
;;;46     	switch (btnCode)
000002  d011              BEQ      |L1.40|
000004  dc04              BGT      |L1.16|
000006  2801              CMP      r0,#1
000008  d008              BEQ      |L1.28|
00000a  2802              CMP      r0,#2
00000c  d104              BNE      |L1.24|
00000e  e009              B        |L1.36|
                  |L1.16|
000010  2808              CMP      r0,#8
000012  d005              BEQ      |L1.32|
000014  2810              CMP      r0,#0x10
000016  d009              BEQ      |L1.44|
                  |L1.24|
;;;47     	{
;;;48     		case BTN_ESC:
;;;49     			return GUI_KEY_ESC;
;;;50     		case BTN_OK:
;;;51     			return GUI_KEY_OK;
;;;52     		case BTN_LEFT:
;;;53     			return GUI_KEY_LEFT;
;;;54     		case BTN_RIGHT:
;;;55     			return GUI_KEY_RIGHT;
;;;56     		case BTN_ENCODER:
;;;57     			return GUI_KEY_ENCODER;
;;;58     		default: 
;;;59     			return 0;
000018  2000              MOVS     r0,#0
;;;60     	}
;;;61     }
00001a  4770              BX       lr
                  |L1.28|
00001c  2001              MOVS     r0,#1                 ;49
00001e  4770              BX       lr
                  |L1.32|
000020  2002              MOVS     r0,#2                 ;51
000022  4770              BX       lr
                  |L1.36|
000024  2003              MOVS     r0,#3                 ;53
000026  4770              BX       lr
                  |L1.40|
000028  2004              MOVS     r0,#4                 ;55
00002a  4770              BX       lr
                  |L1.44|
00002c  2007              MOVS     r0,#7                 ;57
00002e  4770              BX       lr
;;;62     
                          ENDP

                  encodeGuiKeyEvent PROC
;;;63     // Encode physical buttons events into GUI virtual events
;;;64     static uint8_t encodeGuiKeyEvent(uint16_t btnEvent)
000030  b2c0              UXTB     r0,r0
;;;65     {
;;;66     	return (uint8_t)btnEvent;
;;;67     }
000032  4770              BX       lr
;;;68     
                          ENDP

                  GUI_Init PROC
;;;70     // GUI initialization
;;;71     void GUI_Init(void)
000034  4770              BX       lr
;;;72     {
;;;73     
;;;74     	
;;;75     	// Get values from converter - must be already initialized
;;;76     	
;;;77     	
;;;78     	// Restore values from settings
;;;79     
;;;80     }
;;;81     
                          ENDP

                  vTaskGUI PROC
;;;83     
;;;84     void vTaskGUI(void *pvParameters) 
000036  b51f              PUSH     {r0-r4,lr}
;;;85     {
;;;86     	gui_incoming_msg_t msg;
;;;87     	uint8_t guiKeyCode;
;;;88     	uint8_t guiKeyEvent;
;;;89     	int16_t encoder_delta;
;;;90     	guiEvent_t guiEvent;
;;;91     	
;;;92     	// Initialize
;;;93     	xQueueGUI = xQueueCreate( 10, sizeof( gui_incoming_msg_t ) );		// GUI queue can contain 10 elements of type gui_incoming_msg_t
000038  2200              MOVS     r2,#0
00003a  2108              MOVS     r1,#8
00003c  200a              MOVS     r0,#0xa
00003e  f7fffffe          BL       xQueueGenericCreate
000042  4d7e              LDR      r5,|L1.572|
000044  6028              STR      r0,[r5,#0]  ; xQueueGUI
;;;94     	if( xQueueGUI == 0 )
000046  b1c0              CBZ      r0,|L1.122|
;;;95     	{
;;;96     		// Queue was not created and must not be used.
;;;97     		while(1);
;;;98     	}
;;;99     	
;;;100    	// Create all GUI elements and prepare core
;;;101    	guiMainForm_Initialize();
000048  f7fffffe          BL       guiMainForm_Initialize
;;;102        guiCore_Init((guiGenericWidget_t *)&guiMainForm);
00004c  487c              LDR      r0,|L1.576|
00004e  f7fffffe          BL       guiCore_Init
;;;103    	// GUI is ready, but initial welcome screen is what will be displayed.
;;;104    	// When all other systems init will be done, GUI should be sent 
;;;105    	// a special message to start operate normally.
;;;106    	
;;;107    	
;;;108    	while(1)
;;;109    	{
;;;110    		xQueueReceive(xQueueGUI, &msg, portMAX_DELAY);
;;;111    		switch (msg.type)
;;;112    		{
;;;113    			case GUI_TASK_RESTORE_ALL:
;;;114    				setVoltageSetting(regulation_setting_p->voltage.setting);
000052  4c7c              LDR      r4,|L1.580|
000054  f04f36ff          MOV      r6,#0xffffffff        ;110
                  |L1.88|
000058  2300              MOVS     r3,#0                 ;110
00005a  4632              MOV      r2,r6                 ;110
00005c  a902              ADD      r1,sp,#8              ;110
00005e  6828              LDR      r0,[r5,#0]            ;110  ; xQueueGUI
000060  f7fffffe          BL       xQueueGenericReceive
000064  9802              LDR      r0,[sp,#8]            ;111
000066  280c              CMP      r0,#0xc               ;111
000068  d2f6              BCS      |L1.88|
00006a  e8dff000          TBB      [pc,r0]               ;111
00006e  273a              DCB      0x27,0x3a
000070  4c072d53          DCB      0x4c,0x07,0x2d,0x53
000074  60656b87          DCB      0x60,0x65,0x6b,0x87
000078  ac78              DCB      0xac,0x78
                  |L1.122|
00007a  e7fe              B        |L1.122|
00007c  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
00007e  8840              LDRH     r0,[r0,#2]
000080  f7fffffe          BL       setVoltageSetting
;;;115    				setCurrentSetting(regulation_setting_p->current->setting);
000084  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
000086  6b40              LDR      r0,[r0,#0x34]
000088  8800              LDRH     r0,[r0,#0]
00008a  f7fffffe          BL       setCurrentSetting
;;;116    				setCurrentLimitIndicator( (regulation_setting_p->current->RANGE == CURRENT_RANGE_HIGH) ? GUI_CURRENT_RANGE_HIGH : GUI_CURRENT_RANGE_LOW );
00008e  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
000090  6b40              LDR      r0,[r0,#0x34]
000092  7b80              LDRB     r0,[r0,#0xe]
000094  f3c00080          UBFX     r0,r0,#2,#1
000098  f7fffffe          BL       setCurrentLimitIndicator
;;;117    				//	FIXME - GUI_CURRENT_LIM_HIGH
;;;118    				setFeedbackChannelIndicator(regulation_setting_p->CHANNEL);
00009c  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
00009e  7800              LDRB     r0,[r0,#0]
0000a0  f3c00000          UBFX     r0,r0,#0,#1
0000a4  f7fffffe          BL       setFeedbackChannelIndicator
;;;119    				// Retore other values from EEPROM
;;;120    				// TODO
;;;121    				
;;;122    				// Start normal GUI operation
;;;123    				guiEvent.type = GUI_EVENT_START;
0000a8  20f0              MOVS     r0,#0xf0
0000aa  f88d0000          STRB     r0,[sp,#0]
;;;124    				guiCore_AddMessageToQueue((guiGenericWidget_t *)&guiMainForm, &guiEvent);
0000ae  4669              MOV      r1,sp
0000b0  4863              LDR      r0,|L1.576|
0000b2  f7fffffe          BL       guiCore_AddMessageToQueue
;;;125    				guiCore_ProcessMessageQueue();
0000b6  f7fffffe          BL       guiCore_ProcessMessageQueue
;;;126    				break;
0000ba  e7cd              B        |L1.88|
;;;127    			case GUI_TASK_REDRAW:
;;;128    				// Draw GUI
;;;129    				guiCore_RedrawAll();
0000bc  f7fffffe          BL       guiCore_RedrawAll
;;;130    				// Flush buffer to LCDs
;;;131    				LcdUpdateBothByCore(lcdBuffer);
0000c0  4861              LDR      r0,|L1.584|
0000c2  f7fffffe          BL       LcdUpdateBothByCore
;;;132    				break;
0000c6  e7c7              B        |L1.88|
;;;133    			case GUI_TASK_EEPROM_STATE:
;;;134    				guiEvent.type = GUI_EVENT_EEPROM_MESSAGE;
0000c8  20f1              MOVS     r0,#0xf1
0000ca  f88d0000          STRB     r0,[sp,#0]
;;;135    				guiEvent.spec = (uint8_t)msg.data;
0000ce  9803              LDR      r0,[sp,#0xc]
0000d0  f88d0001          STRB     r0,[sp,#1]
;;;136    				guiCore_AddMessageToQueue((guiGenericWidget_t *)&guiMainForm, &guiEvent);
0000d4  4669              MOV      r1,sp
0000d6  485a              LDR      r0,|L1.576|
0000d8  f7fffffe          BL       guiCore_AddMessageToQueue
;;;137    				guiCore_ProcessMessageQueue();
0000dc  f7fffffe          BL       guiCore_ProcessMessageQueue
;;;138    				break;
0000e0  e7ba              B        |L1.88|
;;;139    			case GUI_TASK_PROCESS_BUTTONS:
;;;140    				// msg.data[31:16] = key code, 	msg.data[15:0] = key event type
;;;141    				guiKeyCode = encodeGuiKey((uint16_t)msg.data);
0000e2  9803              LDR      r0,[sp,#0xc]
0000e4  b280              UXTH     r0,r0
0000e6  f7fffffe          BL       encodeGuiKey
0000ea  4607              MOV      r7,r0
;;;142    				if (guiKeyCode == 0)
0000ec  2f00              CMP      r7,#0
0000ee  d0b3              BEQ      |L1.88|
;;;143    					break;
;;;144    				guiKeyEvent = encodeGuiKeyEvent((uint16_t)(msg.data >> 16));
0000f0  9803              LDR      r0,[sp,#0xc]
0000f2  0c00              LSRS     r0,r0,#16
0000f4  f7fffffe          BL       encodeGuiKeyEvent
0000f8  4601              MOV      r1,r0
;;;145    				if (guiKeyEvent == 0)
0000fa  2900              CMP      r1,#0
0000fc  d0ac              BEQ      |L1.88|
;;;146    					break;
;;;147    				guiCore_ProcessKeyEvent(guiKeyCode, guiKeyEvent);
0000fe  4638              MOV      r0,r7
000100  f7fffffe          BL       guiCore_ProcessKeyEvent
;;;148    				break;
000104  e7a8              B        |L1.88|
;;;149    			case GUI_TASK_PROCESS_ENCODER:
;;;150    				encoder_delta = (int16_t)msg.data;
000106  9803              LDR      r0,[sp,#0xc]
000108  b200              SXTH     r0,r0
;;;151    				if (encoder_delta)
00010a  2800              CMP      r0,#0
00010c  d0a4              BEQ      |L1.88|
;;;152    					guiCore_ProcessEncoderEvent(encoder_delta);
00010e  f7fffffe          BL       guiCore_ProcessEncoderEvent
000112  e7a1              B        |L1.88|
;;;153    				break;
;;;154    			case GUI_TASK_UPDATE_VOLTAGE_CURRENT:
;;;155    				setVoltageIndicator(voltage_adc);
000114  484d              LDR      r0,|L1.588|
000116  8800              LDRH     r0,[r0,#0]  ; voltage_adc
000118  f7fffffe          BL       setVoltageIndicator
;;;156    				setCurrentIndicator(current_adc);
00011c  484c              LDR      r0,|L1.592|
00011e  8800              LDRH     r0,[r0,#0]  ; current_adc
000120  f7fffffe          BL       setCurrentIndicator
;;;157    				setPowerIndicator(power_adc);
000124  484b              LDR      r0,|L1.596|
000126  6800              LDR      r0,[r0,#0]  ; power_adc
000128  f7fffffe          BL       setPowerIndicator
;;;158    				break;
00012c  e794              B        |L1.88|
;;;159    			case GUI_TASK_UPDATE_VOLTAGE_SETTING:
;;;160    				setVoltageSetting(regulation_setting_p->voltage.setting);
00012e  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
000130  8840              LDRH     r0,[r0,#2]
000132  f7fffffe          BL       setVoltageSetting
;;;161    				break;
000136  e78f              B        |L1.88|
;;;162    			case GUI_TASK_UPDATE_CURRENT_SETTING:
;;;163    				setCurrentSetting(regulation_setting_p->current->setting);
000138  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
00013a  6b40              LDR      r0,[r0,#0x34]
00013c  8800              LDRH     r0,[r0,#0]
00013e  f7fffffe          BL       setCurrentSetting
;;;164    				break;
000142  e789              B        |L1.88|
;;;165    			case GUI_TASK_UPDATE_CURRENT_LIMIT:
;;;166    				setCurrentLimitIndicator( (regulation_setting_p->current->RANGE == CURRENT_RANGE_HIGH) ? GUI_CURRENT_RANGE_HIGH : GUI_CURRENT_RANGE_LOW );
000144  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
000146  6b40              LDR      r0,[r0,#0x34]
000148  7b80              LDRB     r0,[r0,#0xe]
00014a  f3c00080          UBFX     r0,r0,#2,#1
00014e  f7fffffe          BL       setCurrentLimitIndicator
;;;167    				// CHECKME - possibly conveter module has to send GUI_TASK_UPDATE_CURRENT_SETTING message when updating limit
;;;168    				setCurrentSetting(regulation_setting_p->current->setting);			
000152  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
000154  6b40              LDR      r0,[r0,#0x34]
000156  8800              LDRH     r0,[r0,#0]
000158  f7fffffe          BL       setCurrentSetting
;;;169    				break;
00015c  e77c              B        |L1.88|
;;;170    			case GUI_TASK_UPDATE_SOFT_LIMIT_SETTINGS:
;;;171    				setLowVoltageLimitSetting(regulation_setting_p->voltage.enable_low_limit, regulation_setting_p->voltage.limit_low);
00015e  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
000160  8901              LDRH     r1,[r0,#8]
000162  7c00              LDRB     r0,[r0,#0x10]
000164  f3c00000          UBFX     r0,r0,#0,#1
000168  f7fffffe          BL       setLowVoltageLimitSetting
;;;172    				setHighVoltageLimitSetting(regulation_setting_p->voltage.enable_high_limit, regulation_setting_p->voltage.limit_high);
00016c  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
00016e  8941              LDRH     r1,[r0,#0xa]
000170  7c00              LDRB     r0,[r0,#0x10]
000172  f3c00040          UBFX     r0,r0,#1,#1
000176  f7fffffe          BL       setHighVoltageLimitSetting
;;;173    				break;
00017a  e76d              B        |L1.88|
;;;174    			case GUI_TASK_UPDATE_FEEDBACK_CHANNEL:
;;;175    				setFeedbackChannelIndicator( (regulation_setting_p->CHANNEL == CHANNEL_5V) ? GUI_CHANNEL_5V : GUI_CHANNEL_12V );
00017c  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
00017e  7800              LDRB     r0,[r0,#0]
000180  f3c00000          UBFX     r0,r0,#0,#1
000184  f7fffffe          BL       setFeedbackChannelIndicator
;;;176    				// CHECKME - same as above
;;;177    				setVoltageSetting(regulation_setting_p->voltage.setting);
000188  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
00018a  8840              LDRH     r0,[r0,#2]
00018c  f7fffffe          BL       setVoltageSetting
;;;178    				setCurrentSetting(regulation_setting_p->current->setting);
000190  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
000192  6b40              LDR      r0,[r0,#0x34]
000194  8800              LDRH     r0,[r0,#0]
000196  f7fffffe          BL       setCurrentSetting
;;;179    				setCurrentLimitIndicator( (regulation_setting_p->current->RANGE == CURRENT_RANGE_HIGH) ? GUI_CURRENT_RANGE_HIGH : GUI_CURRENT_RANGE_LOW );
00019a  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
00019c  6b40              LDR      r0,[r0,#0x34]
00019e  7b80              LDRB     r0,[r0,#0xe]
0001a0  f3c00080          UBFX     r0,r0,#2,#1
0001a4  f7fffffe          BL       setCurrentLimitIndicator
;;;180    				setLowVoltageLimitSetting(regulation_setting_p->voltage.enable_low_limit, regulation_setting_p->voltage.limit_low);
0001a8  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
0001aa  8901              LDRH     r1,[r0,#8]
0001ac  7c00              LDRB     r0,[r0,#0x10]
0001ae  f3c00000          UBFX     r0,r0,#0,#1
0001b2  f7fffffe          BL       setLowVoltageLimitSetting
;;;181    				setHighVoltageLimitSetting(regulation_setting_p->voltage.enable_high_limit, regulation_setting_p->voltage.limit_high);
0001b6  6820              LDR      r0,[r4,#0]  ; regulation_setting_p
0001b8  8941              LDRH     r1,[r0,#0xa]
0001ba  7c00              LDRB     r0,[r0,#0x10]
0001bc  f3c00040          UBFX     r0,r0,#1,#1
0001c0  f7fffffe          BL       setHighVoltageLimitSetting
;;;182    				break;
0001c4  e748              B        |L1.88|
;;;183    			case GUI_TASK_UPDATE_TEMPERATURE_INDICATOR:
;;;184    				setTemperatureIndicator(converter_temp_celsius);
0001c6  4824              LDR      r0,|L1.600|
0001c8  f9b00000          LDRSH    r0,[r0,#0]  ; converter_temp_celsius
0001cc  f7fffffe          BL       setTemperatureIndicator
;;;185    				break;
0001d0  e742              B        |L1.88|
;;;186    		}
;;;187    	}
;;;188    }
;;;189    
                          ENDP

                  applyGuiVoltageSetting PROC
;;;196    // Apply voltage setting
;;;197    void applyGuiVoltageSetting(uint16_t new_set_voltage)
0001d2  4922              LDR      r1,|L1.604|
;;;198    {
;;;199    	converter_msg.type = CONVERTER_SET_VOLTAGE;
0001d4  2207              MOVS     r2,#7
0001d6  600a              STR      r2,[r1,#0]  ; converter_msg
;;;200    	converter_msg.data.a = new_set_voltage;
0001d8  6048              STR      r0,[r1,#4]  ; converter_msg
;;;201    	xQueueSendToBack(xQueueConverter, &converter_msg, 0);
0001da  4821              LDR      r0,|L1.608|
0001dc  2300              MOVS     r3,#0
0001de  461a              MOV      r2,r3
0001e0  6800              LDR      r0,[r0,#0]  ; xQueueConverter
0001e2  f7ffbffe          B.W      xQueueGenericSend
;;;202    }
;;;203    
                          ENDP

                  applyGuiVoltageLimit PROC
;;;204    void applyGuiVoltageLimit(uint8_t type, uint8_t enable, uint16_t value)
0001e6  b430              PUSH     {r4,r5}
;;;205    {
;;;206    	converter_msg.type = CONVERTER_SET_VOLTAGE_LIMIT;
0001e8  4b1c              LDR      r3,|L1.604|
0001ea  2408              MOVS     r4,#8
0001ec  601c              STR      r4,[r3,#0]  ; converter_msg
;;;207    	converter_msg.voltage_limit_setting.mode = type;		// 1 - high, 0 - low
0001ee  8098              STRH     r0,[r3,#4]
;;;208    	converter_msg.voltage_limit_setting.enable = enable;
0001f0  80d9              STRH     r1,[r3,#6]
;;;209    	converter_msg.voltage_limit_setting.value = value;
0001f2  609a              STR      r2,[r3,#8]  ; converter_msg
;;;210    	xQueueSendToBack(xQueueConverter, &converter_msg, 0);
0001f4  481a              LDR      r0,|L1.608|
0001f6  2300              MOVS     r3,#0
0001f8  461a              MOV      r2,r3
0001fa  6800              LDR      r0,[r0,#0]  ; xQueueConverter
0001fc  bc30              POP      {r4,r5}
0001fe  4917              LDR      r1,|L1.604|
000200  f7ffbffe          B.W      xQueueGenericSend
;;;211    }
;;;212    
                          ENDP

                  applyGuiCurrentSetting PROC
;;;213    // Apply current setting
;;;214    void applyGuiCurrentSetting(uint16_t new_set_current)
000204  4915              LDR      r1,|L1.604|
;;;215    {
;;;216    	converter_msg.type = CONVERTER_SET_CURRENT;
000206  2209              MOVS     r2,#9
000208  600a              STR      r2,[r1,#0]  ; converter_msg
;;;217    	converter_msg.data.a = new_set_current;
00020a  6048              STR      r0,[r1,#4]  ; converter_msg
;;;218    	xQueueSendToBack(xQueueConverter, &converter_msg, 0);
00020c  4814              LDR      r0,|L1.608|
00020e  2300              MOVS     r3,#0
000210  461a              MOV      r2,r3
000212  6800              LDR      r0,[r0,#0]  ; xQueueConverter
000214  f7ffbffe          B.W      xQueueGenericSend
;;;219    }
;;;220    
                          ENDP

                  applyGuiCurrentRange PROC
;;;221    // Apply new current range
;;;222    void applyGuiCurrentRange(uint8_t new_range)
000218  4910              LDR      r1,|L1.604|
;;;223    {
;;;224    	converter_msg.type = CONVERTER_SET_CURRENT_RANGE;
00021a  2206              MOVS     r2,#6
00021c  600a              STR      r2,[r1,#0]  ; converter_msg
;;;225    	if (new_range == GUI_CURRENT_RANGE_HIGH)
00021e  2801              CMP      r0,#1
000220  d008              BEQ      |L1.564|
;;;226    		converter_msg.data.a = CURRENT_RANGE_HIGH;
;;;227    	else
;;;228    		converter_msg.data.a = CURRENT_RANGE_LOW;
000222  2000              MOVS     r0,#0
000224  6048              STR      r0,[r1,#4]  ; converter_msg
                  |L1.550|
;;;229    	xQueueSendToBack(xQueueConverter, &converter_msg, 0);
000226  480e              LDR      r0,|L1.608|
000228  2300              MOVS     r3,#0
00022a  461a              MOV      r2,r3
00022c  490b              LDR      r1,|L1.604|
00022e  6800              LDR      r0,[r0,#0]  ; xQueueConverter
000230  f7ffbffe          B.W      xQueueGenericSend
                  |L1.564|
000234  2001              MOVS     r0,#1                 ;226
000236  6048              STR      r0,[r1,#4]            ;226  ; converter_msg
000238  e7f5              B        |L1.550|
;;;230    }
;;;231    
                          ENDP

00023a  0000              DCW      0x0000
                  |L1.572|
                          DCD      ||.data||
                  |L1.576|
                          DCD      guiMainForm
                  |L1.580|
                          DCD      regulation_setting_p
                  |L1.584|
                          DCD      lcdBuffer
                  |L1.588|
                          DCD      voltage_adc
                  |L1.592|
                          DCD      current_adc
                  |L1.596|
                          DCD      power_adc
                  |L1.600|
                          DCD      converter_temp_celsius
                  |L1.604|
                          DCD      ||.bss||
                  |L1.608|
                          DCD      xQueueConverter

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  converter_msg
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  xQueueGUI
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "src\\guiTop.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_guiTop_c_GUI_Init____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_guiTop_c_GUI_Init____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_guiTop_c_GUI_Init____REVSH|
#line 130
|__asm___8_guiTop_c_GUI_Init____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
