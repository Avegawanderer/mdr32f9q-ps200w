; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list -c --asm --interleave -o.\FLASH\list.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\list.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -I.\src\gui -I.\src\gui\guiCore -I.\src\gui\guiWidgets -I.\src\gui\guiGraphics -I.\src\gui\utils -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\list.crf ..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\list.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  vListInitialise PROC
;;;74     
;;;75     void vListInitialise( xList * const pxList )
000000  f1000108          ADD      r1,r0,#8
;;;76     {
;;;77     	/* The list structure contains a list item which is used to mark the
;;;78     	end of the list.  To initialise the list the list end is inserted
;;;79     	as the only list entry. */
;;;80     	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
000004  6041              STR      r1,[r0,#4]
;;;81     
;;;82     	/* The list end value is the highest possible value in the list to
;;;83     	ensure it remains at the end of the list. */
;;;84     	pxList->xListEnd.xItemValue = portMAX_DELAY;
000006  f04f32ff          MOV      r2,#0xffffffff
00000a  6082              STR      r2,[r0,#8]
;;;85     
;;;86     	/* The list end next and previous pointers point to itself so we know
;;;87     	when the list is empty. */
;;;88     	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
00000c  60c1              STR      r1,[r0,#0xc]
;;;89     	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
00000e  6101              STR      r1,[r0,#0x10]
;;;90     
;;;91     	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
000010  2100              MOVS     r1,#0
000012  6001              STR      r1,[r0,#0]
;;;92     }
000014  4770              BX       lr
;;;93     /*-----------------------------------------------------------*/
                          ENDP

                  vListInitialiseItem PROC
;;;94     
;;;95     void vListInitialiseItem( xListItem * const pxItem )
000016  2100              MOVS     r1,#0
;;;96     {
;;;97     	/* Make sure the list item is not recorded as being on a list. */
;;;98     	pxItem->pvContainer = NULL;
000018  6101              STR      r1,[r0,#0x10]
;;;99     }
00001a  4770              BX       lr
;;;100    /*-----------------------------------------------------------*/
                          ENDP

                  vListInsertEnd PROC
;;;101    
;;;102    void vListInsertEnd( xList * const pxList, xListItem * const pxNewListItem )
00001c  6842              LDR      r2,[r0,#4]
;;;103    {
;;;104    xListItem * pxIndex;
;;;105    
;;;106    	/* Insert a new list item into pxList, but rather than sort the list,
;;;107    	makes the new list item the last item to be removed by a call to
;;;108    	pvListGetOwnerOfNextEntry. */
;;;109    	pxIndex = pxList->pxIndex;
;;;110    
;;;111    	pxNewListItem->pxNext = pxIndex;
00001e  604a              STR      r2,[r1,#4]
;;;112    	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
000020  6893              LDR      r3,[r2,#8]
000022  608b              STR      r3,[r1,#8]
;;;113    	pxIndex->pxPrevious->pxNext = pxNewListItem;
000024  6893              LDR      r3,[r2,#8]
000026  6059              STR      r1,[r3,#4]
;;;114    	pxIndex->pxPrevious = pxNewListItem;
000028  6091              STR      r1,[r2,#8]
;;;115    
;;;116    	/* Remember which list the item is in. */
;;;117    	pxNewListItem->pvContainer = ( void * ) pxList;
00002a  6108              STR      r0,[r1,#0x10]
;;;118    
;;;119    	( pxList->uxNumberOfItems )++;
00002c  6801              LDR      r1,[r0,#0]
00002e  1c49              ADDS     r1,r1,#1
000030  6001              STR      r1,[r0,#0]
;;;120    }
000032  4770              BX       lr
;;;121    /*-----------------------------------------------------------*/
                          ENDP

                  vListInsert PROC
;;;122    
;;;123    void vListInsert( xList * const pxList, xListItem * const pxNewListItem )
000034  b530              PUSH     {r4,r5,lr}
;;;124    {
;;;125    xListItem *pxIterator;
;;;126    portTickType xValueOfInsertion;
;;;127    
;;;128    	/* Insert the new list item into the list, sorted in ulListItem order. */
;;;129    	xValueOfInsertion = pxNewListItem->xItemValue;
000036  680c              LDR      r4,[r1,#0]
;;;130    
;;;131    	/* If the list already contains a list item with the same item value then
;;;132    	the new list item should be placed after it.  This ensures that TCB's which
;;;133    	are stored in ready lists (all of which have the same ulListItem value)
;;;134    	get an equal share of the CPU.  However, if the xItemValue is the same as
;;;135    	the back marker the iteration loop below will not end.  This means we need
;;;136    	to guard against this by checking the value first and modifying the
;;;137    	algorithm slightly if necessary. */
;;;138    	if( xValueOfInsertion == portMAX_DELAY )
000038  1c62              ADDS     r2,r4,#1
00003a  d002              BEQ      |L1.66|
;;;139    	{
;;;140    		pxIterator = pxList->xListEnd.pxPrevious;
;;;141    	}
;;;142    	else
;;;143    	{
;;;144    		/* *** NOTE ***********************************************************
;;;145    		If you find your application is crashing here then likely causes are:
;;;146    			1) Stack overflow -
;;;147    			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
;;;148    			2) Incorrect interrupt priority assignment, especially on Cortex-M3
;;;149    			   parts where numerically high priority values denote low actual
;;;150    			   interrupt priories, which can seem counter intuitive.  See
;;;151    			   configMAX_SYSCALL_INTERRUPT_PRIORITY on http://www.freertos.org/a00110.html
;;;152    			3) Calling an API function from within a critical section or when
;;;153    			   the scheduler is suspended, or calling an API function that does
;;;154    			   not end in "FromISR" from an interrupt.
;;;155    			4) Using a queue or semaphore before it has been initialised or
;;;156    			   before the scheduler has been started (are interrupts firing
;;;157    			   before vTaskStartScheduler() has been called?).
;;;158    		See http://www.freertos.org/FAQHelp.html for more tips.
;;;159    		**********************************************************************/
;;;160    
;;;161    		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
00003c  f1000208          ADD      r2,r0,#8
000040  e002              B        |L1.72|
                  |L1.66|
000042  6902              LDR      r2,[r0,#0x10]         ;140
000044  e004              B        |L1.80|
                  |L1.70|
000046  461a              MOV      r2,r3
                  |L1.72|
000048  6853              LDR      r3,[r2,#4]
00004a  681d              LDR      r5,[r3,#0]
00004c  42a5              CMP      r5,r4
00004e  d9fa              BLS      |L1.70|
                  |L1.80|
;;;162    		{
;;;163    			/* There is nothing to do here, we are just iterating to the
;;;164    			wanted insertion position. */
;;;165    		}
;;;166    	}
;;;167    
;;;168    	pxNewListItem->pxNext = pxIterator->pxNext;
000050  6853              LDR      r3,[r2,#4]
000052  604b              STR      r3,[r1,#4]
;;;169    	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
000054  6099              STR      r1,[r3,#8]
;;;170    	pxNewListItem->pxPrevious = pxIterator;
000056  608a              STR      r2,[r1,#8]
;;;171    	pxIterator->pxNext = pxNewListItem;
000058  6051              STR      r1,[r2,#4]
;;;172    
;;;173    	/* Remember which list the item is in.  This allows fast removal of the
;;;174    	item later. */
;;;175    	pxNewListItem->pvContainer = ( void * ) pxList;
00005a  6108              STR      r0,[r1,#0x10]
;;;176    
;;;177    	( pxList->uxNumberOfItems )++;
00005c  6801              LDR      r1,[r0,#0]
00005e  1c49              ADDS     r1,r1,#1
000060  6001              STR      r1,[r0,#0]
;;;178    }
000062  bd30              POP      {r4,r5,pc}
;;;179    /*-----------------------------------------------------------*/
                          ENDP

                  uxListRemove PROC
;;;180    
;;;181    unsigned portBASE_TYPE uxListRemove( xListItem * const pxItemToRemove )
000064  e9d02101          LDRD     r2,r1,[r0,#4]
;;;182    {
;;;183    xList * pxList;
;;;184    
;;;185    	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
000068  6091              STR      r1,[r2,#8]
;;;186    	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
00006a  e9d01201          LDRD     r1,r2,[r0,#4]
00006e  6051              STR      r1,[r2,#4]
;;;187    
;;;188    	/* The list item knows which list it is in.  Obtain the list from the list
;;;189    	item. */
;;;190    	pxList = ( xList * ) pxItemToRemove->pvContainer;
000070  6901              LDR      r1,[r0,#0x10]
;;;191    
;;;192    	/* Make sure the index is left pointing to a valid item. */
;;;193    	if( pxList->pxIndex == pxItemToRemove )
000072  684a              LDR      r2,[r1,#4]
000074  4282              CMP      r2,r0
000076  d101              BNE      |L1.124|
;;;194    	{
;;;195    		pxList->pxIndex = pxItemToRemove->pxPrevious;
000078  6882              LDR      r2,[r0,#8]
00007a  604a              STR      r2,[r1,#4]
                  |L1.124|
;;;196    	}
;;;197    
;;;198    	pxItemToRemove->pvContainer = NULL;
00007c  2200              MOVS     r2,#0
00007e  6102              STR      r2,[r0,#0x10]
;;;199    	( pxList->uxNumberOfItems )--;
000080  6808              LDR      r0,[r1,#0]
000082  1e40              SUBS     r0,r0,#1
000084  6008              STR      r0,[r1,#0]
;;;200    
;;;201    	return pxList->uxNumberOfItems;
;;;202    }
000086  4770              BX       lr
;;;203    /*-----------------------------------------------------------*/
                          ENDP

