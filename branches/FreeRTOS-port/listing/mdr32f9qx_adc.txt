; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\mdr32f9qx_adc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\mdr32f9qx_adc.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\mdr32f9qx_adc.crf ..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;45       */
;;;46     void ADC_DeInit(void)
000000  48cd              LDR      r0,|L1.824|
;;;47     {
;;;48       MDR_ADC->ADC1_CFG = 0;
000002  2100              MOVS     r1,#0
000004  6001              STR      r1,[r0,#0]
;;;49       MDR_ADC->ADC2_CFG = 0;
000006  6041              STR      r1,[r0,#4]
;;;50       MDR_ADC->ADC1_H_LEVEL = 0;
000008  6081              STR      r1,[r0,#8]
;;;51       MDR_ADC->ADC2_H_LEVEL = 0;
00000a  60c1              STR      r1,[r0,#0xc]
;;;52       MDR_ADC->ADC1_L_LEVEL = 0;
00000c  6101              STR      r1,[r0,#0x10]
;;;53       MDR_ADC->ADC2_L_LEVEL = 0;
00000e  6141              STR      r1,[r0,#0x14]
;;;54       MDR_ADC->ADC1_RESULT;
000010  6982              LDR      r2,[r0,#0x18]
;;;55       MDR_ADC->ADC2_RESULT;
000012  69c2              LDR      r2,[r0,#0x1c]
;;;56       MDR_ADC->ADC1_STATUS = 0;
000014  6201              STR      r1,[r0,#0x20]
;;;57       MDR_ADC->ADC2_STATUS = 0;
000016  6241              STR      r1,[r0,#0x24]
;;;58       MDR_ADC->ADC1_CHSEL = 0;
000018  6281              STR      r1,[r0,#0x28]
;;;59       MDR_ADC->ADC2_CHSEL = 0;
00001a  62c1              STR      r1,[r0,#0x2c]
;;;60     }
00001c  4770              BX       lr
;;;61     
                          ENDP

                  ADC_Init PROC
;;;69       */
;;;70     void ADC_Init(const ADC_InitTypeDef* ADC_InitStruct)
00001e  6882              LDR      r2,[r0,#8]
;;;71     {
;;;72       uint32_t tmpreg_CFG;
;;;73       uint32_t tmpreg_MSK;
;;;74     
;;;75       /* Check the parameters */
;;;76       assert_param(IS_ADC_SYNC_MODE(ADC_InitStruct->ADC_SynchronousMode));
;;;77       assert_param(IS_ADC_START_DELAY_VALUE(ADC_InitStruct->ADC_StartDelay));
;;;78       assert_param(IS_ADC_TEMP_SENSOR_CONFIG(ADC_InitStruct->ADC_TempSensor));
;;;79       assert_param(IS_ADC_TEMP_SENSOR_AMP_CONFIG(ADC_InitStruct->ADC_TempSensorAmplifier));
;;;80       assert_param(IS_ADC_TEMP_SENSOR_CONVERSION_CONFIG(ADC_InitStruct->ADC_TempSensorConversion));
;;;81       assert_param(IS_ADC_VREF_CONVERSION_CONFIG(ADC_InitStruct->ADC_IntVRefConversion));
;;;82       assert_param(IS_ADC_VREF_TRIMMING_VALUE(ADC_InitStruct->ADC_IntVRefTrimming));
;;;83     
;;;84       tmpreg_CFG = ADC_InitStruct->ADC_SynchronousMode
000020  6801              LDR      r1,[r0,#0]
000022  6843              LDR      r3,[r0,#4]
000024  4411              ADD      r1,r1,r2
000026  68c2              LDR      r2,[r0,#0xc]
000028  eb027203          ADD      r2,r2,r3,LSL #28
00002c  4411              ADD      r1,r1,r2
00002e  6902              LDR      r2,[r0,#0x10]
000030  4411              ADD      r1,r1,r2
000032  6942              LDR      r2,[r0,#0x14]
000034  6980              LDR      r0,[r0,#0x18]
000036  4411              ADD      r1,r1,r2
000038  eb015040          ADD      r0,r1,r0,LSL #21
;;;85                  + (ADC_InitStruct->ADC_StartDelay << ADC1_CFG_DELAY_ADC_Pos)
;;;86                  + ADC_InitStruct->ADC_TempSensor
;;;87                  + ADC_InitStruct->ADC_TempSensorAmplifier
;;;88                  + ADC_InitStruct->ADC_TempSensorConversion
;;;89                  + ADC_InitStruct->ADC_IntVRefConversion
;;;90                  + (ADC_InitStruct->ADC_IntVRefTrimming << ADC1_CFG_TR_Pos);
;;;91     
;;;92       tmpreg_MSK = ADC1_CFG_SYNC_CONVER
00003c  4bbf              LDR      r3,|L1.828|
;;;93                  | ADC1_CFG_DELAY_ADC_Msk
;;;94                  | ADC1_CFG_TS_EN
;;;95                  | ADC1_CFG_TS_BUF_EN
;;;96                  | ADC1_CFG_SEL_TS
;;;97                  | ADC1_CFG_SEL_VREF
;;;98                  | ADC1_CFG_TR_Msk;
;;;99     
;;;100      MDR_ADC->ADC1_CFG = (MDR_ADC->ADC1_CFG & ~tmpreg_MSK) + tmpreg_CFG;
00003e  49be              LDR      r1,|L1.824|
000040  680a              LDR      r2,[r1,#0]
000042  439a              BICS     r2,r2,r3
000044  4410              ADD      r0,r0,r2
000046  6008              STR      r0,[r1,#0]
;;;101    }
000048  4770              BX       lr
;;;102    
                          ENDP

                  ADC_StructInit PROC
;;;108      */
;;;109    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
00004a  2100              MOVS     r1,#0
;;;110    {
;;;111      ADC_InitStruct->ADC_SynchronousMode      = ADC_SyncMode_Independent;
00004c  6001              STR      r1,[r0,#0]
;;;112      ADC_InitStruct->ADC_StartDelay           = 0;
00004e  6041              STR      r1,[r0,#4]
;;;113      ADC_InitStruct->ADC_TempSensor           = ADC_TEMP_SENSOR_Disable;
000050  6081              STR      r1,[r0,#8]
;;;114      ADC_InitStruct->ADC_TempSensorAmplifier  = ADC_TEMP_SENSOR_AMPLIFIER_Disable;
000052  60c1              STR      r1,[r0,#0xc]
;;;115      ADC_InitStruct->ADC_TempSensorConversion = ADC_TEMP_SENSOR_CONVERSION_Disable;
000054  6101              STR      r1,[r0,#0x10]
;;;116      ADC_InitStruct->ADC_IntVRefConversion    = ADC_VREF_CONVERSION_Disable;
000056  6141              STR      r1,[r0,#0x14]
;;;117      ADC_InitStruct->ADC_IntVRefTrimming      = 0;
000058  6181              STR      r1,[r0,#0x18]
;;;118    }
00005a  4770              BX       lr
;;;119    
                          ENDP

                  ADC_SetTrim PROC
;;;124      */
;;;125    void ADC_SetTrim(uint32_t Trim)
00005c  4ab6              LDR      r2,|L1.824|
;;;126    {
;;;127      uint32_t tmpreg_CFG;
;;;128    
;;;129      /* Check the parameters */
;;;130      assert_param(IS_ADC_VREF_TRIMMING_VALUE(Trim));
;;;131    
;;;132      tmpreg_CFG = MDR_ADC->ADC1_CFG & ~ADC1_CFG_TR_Msk;
00005e  6811              LDR      r1,[r2,#0]
000060  f02171f0          BIC      r1,r1,#0x1e00000
;;;133      MDR_ADC->ADC1_CFG = tmpreg_CFG + (Trim << ADC1_CFG_TR_Pos);
000064  eb015040          ADD      r0,r1,r0,LSL #21
000068  6010              STR      r0,[r2,#0]
;;;134    }
00006a  4770              BX       lr
;;;135    
                          ENDP

                  ADC1_Init PROC
;;;143      */
;;;144    void ADC1_Init(const ADCx_InitTypeDef* ADCx_InitStruct)
00006c  b530              PUSH     {r4,r5,lr}
;;;145    {
;;;146      uint32_t tmpreg_CFG1;
;;;147      uint32_t tmpreg_CFG2;
;;;148    
;;;149      /* Check the parameters */
;;;150      assert_param(IS_ADC_CLOCK_SOURCE_CONFIG(ADCx_InitStruct->ADC_ClockSource));
;;;151      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(ADCx_InitStruct->ADC_SamplingMode));
;;;152      assert_param(IS_ADC_CH_SWITCHING_CONFIG(ADCx_InitStruct->ADC_ChannelSwitching));
;;;153      assert_param(IS_ADC1_CH_NUM(ADCx_InitStruct->ADC_ChannelNumber));
;;;154      assert_param(IS_ADC1_CH_MASK(ADCx_InitStruct->ADC_Channels));
;;;155      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(ADCx_InitStruct->ADC_LevelControl));
;;;156      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_LowLevel));
;;;157      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_HighLevel));
;;;158      assert_param(IS_ADC_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_VRefSource));
;;;159      assert_param(IS_ADC_INT_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_IntVRefSource));
;;;160      assert_param(IS_ADC_CLK_div_VALUE(ADCx_InitStruct->ADC_Prescaler));
;;;161      assert_param(IS_ADC_DELAY_GO_VALUE(ADCx_InitStruct->ADC_DelayGo));
;;;162    
;;;163      tmpreg_CFG1 = MDR_ADC->ADC1_CFG;
00006e  49b2              LDR      r1,|L1.824|
000070  680a              LDR      r2,[r1,#0]
;;;164    
;;;165      tmpreg_CFG1 &= ~(ADC1_CFG_REG_CLKS
000072  4bb2              LDR      r3,|L1.828|
000074  1cdb              ADDS     r3,r3,#3
000076  401a              ANDS     r2,r2,r3
;;;166                     | ADC1_CFG_REG_SAMPLE
;;;167                     | ADC1_CFG_REG_CHCH
;;;168                     | ADC1_CFG_REG_CHS_Msk
;;;169                     | ADC1_CFG_REG_RNGC
;;;170                     | ADC1_CFG_M_REF
;;;171                     | ADC1_CFG_REG_DIVCLK_Msk
;;;172                     | ADC1_CFG_DELAY_GO_Msk);
;;;173    
;;;174      tmpreg_CFG1 += ADCx_InitStruct->ADC_ClockSource
000078  e9d03400          LDRD     r3,r4,[r0,#0]
00007c  4423              ADD      r3,r3,r4
00007e  e9d04502          LDRD     r4,r5,[r0,#8]
000082  eb041405          ADD      r4,r4,r5,LSL #4
000086  4423              ADD      r3,r3,r4
000088  6944              LDR      r4,[r0,#0x14]
00008a  4423              ADD      r3,r3,r4
00008c  69c4              LDR      r4,[r0,#0x1c]
00008e  4423              ADD      r3,r3,r4
000090  6a44              LDR      r4,[r0,#0x24]
000092  4423              ADD      r3,r3,r4
000094  6a84              LDR      r4,[r0,#0x28]
000096  eb036344          ADD      r3,r3,r4,LSL #25
00009a  4413              ADD      r3,r3,r2
;;;175                   + ADCx_InitStruct->ADC_SamplingMode
;;;176                   + ADCx_InitStruct->ADC_ChannelSwitching
;;;177                   + (ADCx_InitStruct->ADC_ChannelNumber << ADC1_CFG_REG_CHS_Pos)
;;;178                   + ADCx_InitStruct->ADC_LevelControl
;;;179                   + ADCx_InitStruct->ADC_VRefSource
;;;180                   + ADCx_InitStruct->ADC_Prescaler
;;;181                   + (ADCx_InitStruct->ADC_DelayGo << ADC1_CFG_DELAY_GO_Pos);
;;;182    
;;;183      tmpreg_CFG2 = MDR_ADC->ADC2_CFG;
00009c  684a              LDR      r2,[r1,#4]
;;;184      tmpreg_CFG2 &= ~ADC2_CFG_ADC1_OP;
00009e  f4223200          BIC      r2,r2,#0x20000
;;;185      tmpreg_CFG2 += ADCx_InitStruct->ADC_IntVRefSource << ADC2_CFG_ADC1_OP_Pos;
0000a2  6a04              LDR      r4,[r0,#0x20]
0000a4  eb024244          ADD      r2,r2,r4,LSL #17
;;;186    
;;;187      MDR_ADC->ADC1_CFG = tmpreg_CFG1;
0000a8  600b              STR      r3,[r1,#0]
;;;188      MDR_ADC->ADC2_CFG = tmpreg_CFG2;
0000aa  604a              STR      r2,[r1,#4]
;;;189    
;;;190      MDR_ADC->ADC1_L_LEVEL = ADCx_InitStruct->ADC_LowLevel;
0000ac  8b02              LDRH     r2,[r0,#0x18]
0000ae  610a              STR      r2,[r1,#0x10]
;;;191      MDR_ADC->ADC1_H_LEVEL = ADCx_InitStruct->ADC_HighLevel;
0000b0  8b42              LDRH     r2,[r0,#0x1a]
0000b2  608a              STR      r2,[r1,#8]
;;;192      MDR_ADC->ADC1_CHSEL   = ADCx_InitStruct->ADC_Channels;
0000b4  6900              LDR      r0,[r0,#0x10]
0000b6  6288              STR      r0,[r1,#0x28]
;;;193    }
0000b8  bd30              POP      {r4,r5,pc}
;;;194    
                          ENDP

                  ADC2_Init PROC
;;;202      */
;;;203    void ADC2_Init(const ADCx_InitTypeDef* ADCx_InitStruct)
0000ba  b530              PUSH     {r4,r5,lr}
;;;204    {
;;;205      uint32_t tmpreg_CFG2;
;;;206    
;;;207      /* Check the parameters */
;;;208      assert_param(IS_ADC_CLOCK_SOURCE_CONFIG(ADCx_InitStruct->ADC_ClockSource));
;;;209      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(ADCx_InitStruct->ADC_SamplingMode));
;;;210      assert_param(IS_ADC_CH_SWITCHING_CONFIG(ADCx_InitStruct->ADC_ChannelSwitching));
;;;211      assert_param(IS_ADC2_CH_NUM(ADCx_InitStruct->ADC_ChannelNumber));
;;;212      assert_param(IS_ADC2_CH_MASK(ADCx_InitStruct->ADC_Channels));
;;;213      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(ADCx_InitStruct->ADC_LevelControl));
;;;214      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_LowLevel));
;;;215      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_HighLevel));
;;;216      assert_param(IS_ADC_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_VRefSource));
;;;217      assert_param(IS_ADC_INT_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_IntVRefSource));
;;;218      assert_param(IS_ADC_CLK_div_VALUE(ADCx_InitStruct->ADC_Prescaler));
;;;219      assert_param(IS_ADC_DELAY_GO_VALUE(ADCx_InitStruct->ADC_DelayGo));
;;;220    
;;;221      tmpreg_CFG2 = MDR_ADC->ADC2_CFG;
0000bc  499e              LDR      r1,|L1.824|
0000be  684a              LDR      r2,[r1,#4]
;;;222    
;;;223      tmpreg_CFG2 &= ~(ADC2_CFG_REG_CLKS
0000c0  4b9f              LDR      r3,|L1.832|
0000c2  401a              ANDS     r2,r2,r3
;;;224                     | ADC2_CFG_REG_SAMPLE
;;;225                     | ADC2_CFG_REG_CHCH
;;;226                     | ADC2_CFG_REG_CHS_Msk
;;;227                     | ADC2_CFG_REG_RNGC
;;;228                     | ADC2_CFG_M_REF
;;;229                     | ADC2_CFG_ADC2_OP
;;;230                     | ADC2_CFG_REG_DIVCLK_Msk
;;;231                     | ADC2_CFG_DELAY_GO_Msk);
;;;232    
;;;233      tmpreg_CFG2 += ADCx_InitStruct->ADC_ClockSource
0000c4  e9d03400          LDRD     r3,r4,[r0,#0]
0000c8  4423              ADD      r3,r3,r4
0000ca  e9d04502          LDRD     r4,r5,[r0,#8]
0000ce  eb041405          ADD      r4,r4,r5,LSL #4
0000d2  4423              ADD      r3,r3,r4
0000d4  6944              LDR      r4,[r0,#0x14]
0000d6  4423              ADD      r3,r3,r4
0000d8  69c4              LDR      r4,[r0,#0x1c]
0000da  4423              ADD      r3,r3,r4
0000dc  6a04              LDR      r4,[r0,#0x20]
0000de  eb034384          ADD      r3,r3,r4,LSL #18
0000e2  6a44              LDR      r4,[r0,#0x24]
0000e4  4423              ADD      r3,r3,r4
0000e6  6a84              LDR      r4,[r0,#0x28]
0000e8  eb036344          ADD      r3,r3,r4,LSL #25
0000ec  441a              ADD      r2,r2,r3
;;;234                   + ADCx_InitStruct->ADC_SamplingMode
;;;235                   + ADCx_InitStruct->ADC_ChannelSwitching
;;;236                   + (ADCx_InitStruct->ADC_ChannelNumber << ADC2_CFG_REG_CHS_Pos)
;;;237                   + ADCx_InitStruct->ADC_LevelControl
;;;238                   + ADCx_InitStruct->ADC_VRefSource
;;;239                   + (ADCx_InitStruct->ADC_IntVRefSource << ADC2_CFG_ADC2_OP_Pos)
;;;240                   + ADCx_InitStruct->ADC_Prescaler
;;;241                   + (ADCx_InitStruct->ADC_DelayGo << ADC2_CFG_DELAY_GO_Pos);
;;;242    
;;;243      MDR_ADC->ADC2_CFG = tmpreg_CFG2;
0000ee  604a              STR      r2,[r1,#4]
;;;244      MDR_ADC->ADC2_L_LEVEL = ADCx_InitStruct->ADC_LowLevel;
0000f0  8b02              LDRH     r2,[r0,#0x18]
0000f2  614a              STR      r2,[r1,#0x14]
;;;245      MDR_ADC->ADC2_H_LEVEL = ADCx_InitStruct->ADC_HighLevel;
0000f4  8b42              LDRH     r2,[r0,#0x1a]
0000f6  60ca              STR      r2,[r1,#0xc]
;;;246      MDR_ADC->ADC2_CHSEL   = ADCx_InitStruct->ADC_Channels;
0000f8  6900              LDR      r0,[r0,#0x10]
0000fa  62c8              STR      r0,[r1,#0x2c]
;;;247    }
0000fc  bd30              POP      {r4,r5,pc}
;;;248    
                          ENDP

                  ADCx_StructInit PROC
;;;254      */
;;;255    void ADCx_StructInit(ADCx_InitTypeDef* ADCx_InitStruct)
0000fe  2100              MOVS     r1,#0
;;;256    {
;;;257      ADCx_InitStruct->ADC_ClockSource      = ADC_CLOCK_SOURCE_CPU;
000100  6001              STR      r1,[r0,#0]
;;;258      ADCx_InitStruct->ADC_SamplingMode     = ADC_SAMPLING_MODE_SINGLE_CONV;
000102  6041              STR      r1,[r0,#4]
;;;259      ADCx_InitStruct->ADC_ChannelSwitching = ADC_CH_SWITCHING_Disable;
000104  6081              STR      r1,[r0,#8]
;;;260      ADCx_InitStruct->ADC_ChannelNumber    = ADC_CH_ADC0;
000106  60c1              STR      r1,[r0,#0xc]
;;;261      ADCx_InitStruct->ADC_Channels         = 0;
000108  6101              STR      r1,[r0,#0x10]
;;;262      ADCx_InitStruct->ADC_LevelControl     = ADC_LEVEL_CONTROL_Disable;
00010a  6141              STR      r1,[r0,#0x14]
;;;263      ADCx_InitStruct->ADC_LowLevel         = 0;
00010c  8301              STRH     r1,[r0,#0x18]
;;;264      ADCx_InitStruct->ADC_HighLevel        = 0;
00010e  8341              STRH     r1,[r0,#0x1a]
;;;265      ADCx_InitStruct->ADC_VRefSource       = ADC_VREF_SOURCE_INTERNAL;
000110  61c1              STR      r1,[r0,#0x1c]
;;;266      ADCx_InitStruct->ADC_IntVRefSource    = ADC_INT_VREF_SOURCE_INEXACT;
000112  6201              STR      r1,[r0,#0x20]
;;;267      ADCx_InitStruct->ADC_Prescaler        = ADC_CLK_div_None;
000114  6241              STR      r1,[r0,#0x24]
;;;268      ADCx_InitStruct->ADC_DelayGo          = 0;
000116  6281              STR      r1,[r0,#0x28]
;;;269    }
000118  4770              BX       lr
;;;270    
                          ENDP

                  ADC1_Cmd PROC
;;;276      */
;;;277    void ADC1_Cmd(FunctionalState NewState)
00011a  4a87              LDR      r2,|L1.824|
;;;278    {
;;;279      uint32_t tmpreg_CFG;
;;;280    
;;;281      /* Check the parameters */
;;;282      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;283    
;;;284      tmpreg_CFG = MDR_ADC->ADC1_CFG;
00011c  6811              LDR      r1,[r2,#0]
;;;285    
;;;286      /* Form new value */
;;;287      if (NewState != DISABLE)
00011e  b110              CBZ      r0,|L1.294|
;;;288      {
;;;289        /* Enable ADC1 by setting the Cfg_REG_ADON bit in the ADC1_CFG register */
;;;290        tmpreg_CFG |= ADC1_CFG_REG_ADON;
000120  f0410001          ORR      r0,r1,#1
000124  e001              B        |L1.298|
                  |L1.294|
;;;291      }
;;;292      else
;;;293      {
;;;294        /* Disable ADC1 by resetting the Cfg_REG_ADON bit in the ADC1_CFG register */
;;;295        tmpreg_CFG &= ~ADC1_CFG_REG_ADON;
000126  f0210001          BIC      r0,r1,#1
                  |L1.298|
;;;296      }
;;;297    
;;;298      /* Configure ADC1_CFG register with new value */
;;;299      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00012a  6010              STR      r0,[r2,#0]
;;;300    }
00012c  4770              BX       lr
;;;301    
                          ENDP

                  ADC2_Cmd PROC
;;;307      */
;;;308    void ADC2_Cmd(FunctionalState NewState)
00012e  4a82              LDR      r2,|L1.824|
;;;309    {
;;;310      uint32_t tmpreg_CFG;
;;;311    
;;;312      /* Check the parameters */
;;;313      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;314    
;;;315      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000130  6851              LDR      r1,[r2,#4]
;;;316    
;;;317      /* Form new value */
;;;318      if (NewState != DISABLE)
000132  b110              CBZ      r0,|L1.314|
;;;319      {
;;;320        /* Enable ADC2 by setting the Cfg_REG_ADON bit in the ADC2_CFG register */
;;;321        tmpreg_CFG |= ADC2_CFG_REG_ADON;
000134  f0410001          ORR      r0,r1,#1
000138  e001              B        |L1.318|
                  |L1.314|
;;;322      }
;;;323      else
;;;324      {
;;;325        /* Disable ADC2 by resetting the Cfg_REG_ADON bit in the ADC2_CFG register */
;;;326        tmpreg_CFG &= ~ADC2_CFG_REG_ADON;
00013a  f0210001          BIC      r0,r1,#1
                  |L1.318|
;;;327      }
;;;328    
;;;329      /* Configure ADC2_CFG register with new value */
;;;330      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00013e  6050              STR      r0,[r2,#4]
;;;331    }
000140  4770              BX       lr
;;;332    
                          ENDP

                  ADC1_SetChannel PROC
;;;337      */
;;;338    void ADC1_SetChannel(uint32_t Channel)
000142  4a7d              LDR      r2,|L1.824|
;;;339    {
;;;340      uint32_t tmpreg_CFG;
;;;341    
;;;342      /* Check the parameters */
;;;343      assert_param(IS_ADC1_CH_NUM(Channel));
;;;344    
;;;345      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000144  6811              LDR      r1,[r2,#0]
;;;346      tmpreg_CFG &= ~ADC1_CFG_REG_CHS_Msk;
000146  f42171f8          BIC      r1,r1,#0x1f0
;;;347      tmpreg_CFG += Channel << ADC1_CFG_REG_CHS_Pos;
00014a  eb011000          ADD      r0,r1,r0,LSL #4
;;;348      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00014e  6010              STR      r0,[r2,#0]
;;;349    }
000150  4770              BX       lr
;;;350    
                          ENDP

                  ADC2_SetChannel PROC
;;;355      */
;;;356    void ADC2_SetChannel(uint32_t Channel)
000152  4a79              LDR      r2,|L1.824|
;;;357    {
;;;358      uint32_t tmpreg_CFG;
;;;359    
;;;360      /* Check the parameters */
;;;361      assert_param(IS_ADC2_CH_NUM(Channel));
;;;362    
;;;363      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000154  6851              LDR      r1,[r2,#4]
;;;364      tmpreg_CFG &= ~ADC2_CFG_REG_CHS_Msk;
000156  f42171f8          BIC      r1,r1,#0x1f0
;;;365      tmpreg_CFG += Channel << ADC2_CFG_REG_CHS_Pos;
00015a  eb011000          ADD      r0,r1,r0,LSL #4
;;;366      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00015e  6050              STR      r0,[r2,#4]
;;;367    }
000160  4770              BX       lr
;;;368    
                          ENDP

                  ADC1_SetChannels PROC
;;;373      */
;;;374    void ADC1_SetChannels(uint32_t ChannelMask)
000162  4975              LDR      r1,|L1.824|
;;;375    {
;;;376      /* Check the parameters */
;;;377      assert_param(IS_ADC1_CH_MASK(ChannelMask));
;;;378    
;;;379      MDR_ADC->ADC1_CHSEL = ChannelMask;
000164  6288              STR      r0,[r1,#0x28]
;;;380    }
000166  4770              BX       lr
;;;381    
                          ENDP

                  ADC2_SetChannels PROC
;;;386      */
;;;387    void ADC2_SetChannels(uint32_t ChannelMask)
000168  4973              LDR      r1,|L1.824|
;;;388    {
;;;389      /* Check the parameters */
;;;390      assert_param(IS_ADC2_CH_MASK(ChannelMask));
;;;391    
;;;392      MDR_ADC->ADC2_CHSEL = ChannelMask;
00016a  62c8              STR      r0,[r1,#0x2c]
;;;393    }
00016c  4770              BX       lr
;;;394    
                          ENDP

                  ADC1_OperationModeConfig PROC
;;;400      */
;;;401    void ADC1_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode)
00016e  4b72              LDR      r3,|L1.824|
;;;402    {
;;;403      uint32_t tmpreg_CFG;
;;;404    
;;;405      /* Check the parameters */
;;;406      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;407      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;408    
;;;409      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000170  681a              LDR      r2,[r3,#0]
;;;410      tmpreg_CFG &= ~(ADC1_CFG_REG_SAMPLE | ADC1_CFG_REG_CHCH);
000172  f4227202          BIC      r2,r2,#0x208
;;;411      tmpreg_CFG += SamplingMode + SwitchingMode;
000176  4408              ADD      r0,r0,r1
000178  4410              ADD      r0,r0,r2
;;;412      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00017a  6018              STR      r0,[r3,#0]
;;;413    }
00017c  4770              BX       lr
;;;414    
                          ENDP

                  ADC2_OperationModeConfig PROC
;;;420      */
;;;421    void ADC2_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode)
00017e  4b6e              LDR      r3,|L1.824|
;;;422    {
;;;423      uint32_t tmpreg_CFG;
;;;424    
;;;425      /* Check the parameters */
;;;426      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;427      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;428    
;;;429      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000180  685a              LDR      r2,[r3,#4]
;;;430      tmpreg_CFG &= ~(ADC2_CFG_REG_SAMPLE | ADC2_CFG_REG_CHCH);
000182  f4227202          BIC      r2,r2,#0x208
;;;431      tmpreg_CFG += SamplingMode + SwitchingMode;
000186  4408              ADD      r0,r0,r1
000188  4410              ADD      r0,r0,r2
;;;432      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00018a  6058              STR      r0,[r3,#4]
;;;433    }
00018c  4770              BX       lr
;;;434    
                          ENDP

                  ADC1_SamplingModeConfig PROC
;;;439      */
;;;440    void ADC1_SamplingModeConfig(uint32_t SamplingMode)
00018e  4a6a              LDR      r2,|L1.824|
;;;441    {
;;;442      uint32_t tmpreg_CFG;
;;;443    
;;;444      /* Check the parameters */
;;;445      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;446    
;;;447      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000190  6811              LDR      r1,[r2,#0]
;;;448      tmpreg_CFG &= ~ADC1_CFG_REG_SAMPLE;
000192  f0210108          BIC      r1,r1,#8
;;;449      tmpreg_CFG += SamplingMode;
000196  4408              ADD      r0,r0,r1
;;;450      MDR_ADC->ADC1_CFG = tmpreg_CFG;
000198  6010              STR      r0,[r2,#0]
;;;451    }
00019a  4770              BX       lr
;;;452    
                          ENDP

                  ADC2_SamplingModeConfig PROC
;;;457      */
;;;458    void ADC2_SamplingModeConfig(uint32_t SamplingMode)
00019c  4a66              LDR      r2,|L1.824|
;;;459    {
;;;460      uint32_t tmpreg_CFG;
;;;461    
;;;462      /* Check the parameters */
;;;463      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;464    
;;;465      tmpreg_CFG = MDR_ADC->ADC2_CFG;
00019e  6851              LDR      r1,[r2,#4]
;;;466      tmpreg_CFG &= ~ADC2_CFG_REG_SAMPLE;
0001a0  f0210108          BIC      r1,r1,#8
;;;467      tmpreg_CFG += SamplingMode;
0001a4  4408              ADD      r0,r0,r1
;;;468      MDR_ADC->ADC2_CFG = tmpreg_CFG;
0001a6  6050              STR      r0,[r2,#4]
;;;469    }
0001a8  4770              BX       lr
;;;470    
                          ENDP

                  ADC1_ChannelSwithingConfig PROC
;;;475      */
;;;476    void ADC1_ChannelSwithingConfig(uint32_t SwitchingMode)
0001aa  4a63              LDR      r2,|L1.824|
;;;477    {
;;;478      uint32_t tmpreg_CFG;
;;;479    
;;;480      /* Check the parameters */
;;;481      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;482    
;;;483      tmpreg_CFG = MDR_ADC->ADC1_CFG;
0001ac  6811              LDR      r1,[r2,#0]
;;;484      tmpreg_CFG &= ~ADC1_CFG_REG_CHCH;
0001ae  f4217100          BIC      r1,r1,#0x200
;;;485      tmpreg_CFG += SwitchingMode;
0001b2  4408              ADD      r0,r0,r1
;;;486      MDR_ADC->ADC1_CFG = tmpreg_CFG;
0001b4  6010              STR      r0,[r2,#0]
;;;487    }
0001b6  4770              BX       lr
;;;488    
                          ENDP

                  ADC2_ChannelSwithingConfig PROC
;;;493      */
;;;494    void ADC2_ChannelSwithingConfig(uint32_t SwitchingMode)
0001b8  4a5f              LDR      r2,|L1.824|
;;;495    {
;;;496      uint32_t tmpreg_CFG;
;;;497    
;;;498      /* Check the parameters */
;;;499      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;500    
;;;501      tmpreg_CFG = MDR_ADC->ADC2_CFG;
0001ba  6851              LDR      r1,[r2,#4]
;;;502      tmpreg_CFG &= ~ADC2_CFG_REG_CHCH;
0001bc  f4217100          BIC      r1,r1,#0x200
;;;503      tmpreg_CFG += SwitchingMode;
0001c0  4408              ADD      r0,r0,r1
;;;504      MDR_ADC->ADC2_CFG = tmpreg_CFG;
0001c2  6050              STR      r0,[r2,#4]
;;;505    }
0001c4  4770              BX       lr
;;;506    
                          ENDP

                  ADC1_LevelsConfig PROC
;;;513      */
;;;514    void ADC1_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState)
0001c6  b510              PUSH     {r4,lr}
;;;515    {
;;;516      uint32_t tmpreg_CFG;
;;;517    
;;;518      /* Check the parameters */
;;;519      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(NewState));
;;;520      assert_param(IS_ADC_VALUE(LowLevel));
;;;521      assert_param(IS_ADC_VALUE(HighLevel));
;;;522    
;;;523      tmpreg_CFG = MDR_ADC->ADC1_CFG;
0001c8  4b5b              LDR      r3,|L1.824|
0001ca  681c              LDR      r4,[r3,#0]
;;;524      tmpreg_CFG &= ~ADC1_CFG_REG_RNGC;
0001cc  f4246480          BIC      r4,r4,#0x400
;;;525      tmpreg_CFG += NewState;
0001d0  4422              ADD      r2,r2,r4
;;;526      MDR_ADC->ADC1_CFG = tmpreg_CFG;
0001d2  601a              STR      r2,[r3,#0]
;;;527    
;;;528      MDR_ADC->ADC1_L_LEVEL = LowLevel;
0001d4  6118              STR      r0,[r3,#0x10]
;;;529      MDR_ADC->ADC1_H_LEVEL = HighLevel;
0001d6  6099              STR      r1,[r3,#8]
;;;530    }
0001d8  bd10              POP      {r4,pc}
;;;531    
                          ENDP

                  ADC2_LevelsConfig PROC
;;;538      */
;;;539    void ADC2_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState)
0001da  b510              PUSH     {r4,lr}
;;;540    {
;;;541      uint32_t tmpreg_CFG;
;;;542    
;;;543      /* Check the parameters */
;;;544      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(NewState));
;;;545      assert_param(IS_ADC_VALUE(LowLevel));
;;;546      assert_param(IS_ADC_VALUE(HighLevel));
;;;547    
;;;548      tmpreg_CFG = MDR_ADC->ADC2_CFG;
0001dc  4b56              LDR      r3,|L1.824|
0001de  685c              LDR      r4,[r3,#4]
;;;549      tmpreg_CFG &= ~ADC2_CFG_REG_RNGC;
0001e0  f4246480          BIC      r4,r4,#0x400
;;;550      tmpreg_CFG += NewState;
0001e4  4422              ADD      r2,r2,r4
;;;551      MDR_ADC->ADC2_CFG = tmpreg_CFG;
0001e6  605a              STR      r2,[r3,#4]
;;;552    
;;;553      MDR_ADC->ADC2_L_LEVEL = LowLevel;
0001e8  6158              STR      r0,[r3,#0x14]
;;;554      MDR_ADC->ADC2_H_LEVEL = HighLevel;
0001ea  60d9              STR      r1,[r3,#0xc]
;;;555    }
0001ec  bd10              POP      {r4,pc}
;;;556    
                          ENDP

                  ADC1_SetLowLevel PROC
;;;561      */
;;;562    void ADC1_SetLowLevel(uint32_t LowLevel)
0001ee  4952              LDR      r1,|L1.824|
;;;563    {
;;;564      /* Check the parameters */
;;;565      assert_param(IS_ADC_VALUE(LowLevel));
;;;566    
;;;567      MDR_ADC->ADC1_L_LEVEL = LowLevel;
0001f0  6108              STR      r0,[r1,#0x10]
;;;568    }
0001f2  4770              BX       lr
;;;569    
                          ENDP

                  ADC2_SetLowLevel PROC
;;;574      */
;;;575    void ADC2_SetLowLevel(uint32_t LowLevel)
0001f4  4950              LDR      r1,|L1.824|
;;;576    {
;;;577      /* Check the parameters */
;;;578      assert_param(IS_ADC_VALUE(LowLevel));
;;;579    
;;;580      MDR_ADC->ADC2_L_LEVEL = LowLevel;
0001f6  6148              STR      r0,[r1,#0x14]
;;;581    }
0001f8  4770              BX       lr
;;;582    
                          ENDP

                  ADC1_SetHighLevel PROC
;;;587      */
;;;588    void ADC1_SetHighLevel(uint32_t HighLevel)
0001fa  494f              LDR      r1,|L1.824|
;;;589    {
;;;590      /* Check the parameters */
;;;591      assert_param(IS_ADC_VALUE(HighLevel));
;;;592    
;;;593      MDR_ADC->ADC1_H_LEVEL = HighLevel;
0001fc  6088              STR      r0,[r1,#8]
;;;594    }
0001fe  4770              BX       lr
;;;595    
                          ENDP

                  ADC2_SetHighLevel PROC
;;;600      */
;;;601    void ADC2_SetHighLevel(uint32_t HighLevel)
000200  494d              LDR      r1,|L1.824|
;;;602    {
;;;603      /* Check the parameters */
;;;604      assert_param(IS_ADC_VALUE(HighLevel));
;;;605    
;;;606      MDR_ADC->ADC2_H_LEVEL = HighLevel;
000202  60c8              STR      r0,[r1,#0xc]
;;;607    }
000204  4770              BX       lr
;;;608    
                          ENDP

                  ADC1_Start PROC
;;;613      */
;;;614    void ADC1_Start(void)
000206  484c              LDR      r0,|L1.824|
;;;615    {
;;;616      MDR_ADC->ADC1_CFG |= ADC1_CFG_REG_GO;
000208  6801              LDR      r1,[r0,#0]
00020a  f0410102          ORR      r1,r1,#2
00020e  6001              STR      r1,[r0,#0]
;;;617    }
000210  4770              BX       lr
;;;618    
                          ENDP

                  ADC2_Start PROC
;;;623      */
;;;624    void ADC2_Start(void)
000212  4849              LDR      r0,|L1.824|
;;;625    {
;;;626      MDR_ADC->ADC2_CFG |= ADC2_CFG_REG_GO;
000214  6841              LDR      r1,[r0,#4]
000216  f0410102          ORR      r1,r1,#2
00021a  6041              STR      r1,[r0,#4]
;;;627    }
00021c  4770              BX       lr
;;;628    
                          ENDP

                  ADC1_GetResult PROC
;;;633      */
;;;634    uint32_t ADC1_GetResult(void)
00021e  4846              LDR      r0,|L1.824|
;;;635    {
;;;636      return MDR_ADC->ADC1_RESULT;
000220  6980              LDR      r0,[r0,#0x18]
;;;637    }
000222  4770              BX       lr
;;;638    
                          ENDP

                  ADC2_GetResult PROC
;;;643      */
;;;644    uint32_t ADC2_GetResult(void)
000224  4844              LDR      r0,|L1.824|
;;;645    {
;;;646      return MDR_ADC->ADC2_RESULT;
000226  69c0              LDR      r0,[r0,#0x1c]
;;;647    }
000228  4770              BX       lr
;;;648    
                          ENDP

                  ADC_GetStatus PROC
;;;653      */
;;;654    uint32_t ADC_GetStatus(void)
00022a  4843              LDR      r0,|L1.824|
;;;655    {
;;;656      return MDR_ADC->ADC1_STATUS + (MDR_ADC->ADC2_STATUS << 16);
00022c  6a01              LDR      r1,[r0,#0x20]
00022e  6a40              LDR      r0,[r0,#0x24]
000230  eb014000          ADD      r0,r1,r0,LSL #16
;;;657    }
000234  4770              BX       lr
;;;658    
                          ENDP

                  ADC1_GetStatus PROC
;;;663      */
;;;664    uint32_t ADC1_GetStatus(void)
000236  4840              LDR      r0,|L1.824|
;;;665    {
;;;666      return MDR_ADC->ADC1_STATUS;
000238  6a00              LDR      r0,[r0,#0x20]
;;;667    }
00023a  4770              BX       lr
;;;668    
                          ENDP

                  ADC2_GetStatus PROC
;;;673      */
;;;674    uint32_t ADC2_GetStatus(void)
00023c  483e              LDR      r0,|L1.824|
;;;675    {
;;;676      return MDR_ADC->ADC2_STATUS;
00023e  6a40              LDR      r0,[r0,#0x24]
;;;677    }
000240  4770              BX       lr
;;;678    
                          ENDP

                  ADC_GetFlagStatus PROC
;;;690      */
;;;691    FlagStatus ADC_GetFlagStatus(uint32_t Flag)
000242  b500              PUSH     {lr}
;;;692    {
000244  4602              MOV      r2,r0
;;;693      FlagStatus bitstatus;
;;;694    
;;;695      /* Check the parameters */
;;;696      assert_param(IS_ADC_STATUS_FLAG(Flag));
;;;697    
;;;698      if ((ADC_GetStatus() & Flag) == 0)
000246  f7fffffe          BL       ADC_GetStatus
00024a  4210              TST      r0,r2
00024c  d001              BEQ      |L1.594|
;;;699      {
;;;700        bitstatus = RESET;
;;;701      }
;;;702      else
;;;703      {
;;;704        bitstatus = SET;
00024e  2001              MOVS     r0,#1
;;;705      }
;;;706    
;;;707      return bitstatus;
;;;708    }
000250  bd00              POP      {pc}
                  |L1.594|
000252  2000              MOVS     r0,#0                 ;700
000254  bd00              POP      {pc}
;;;709    
                          ENDP

                  ADC1_GetFlagStatus PROC
;;;718      */
;;;719    FlagStatus ADC1_GetFlagStatus(uint32_t Flag)
000256  4938              LDR      r1,|L1.824|
;;;720    {
;;;721      FlagStatus bitstatus;
;;;722    
;;;723      /* Check the parameters */
;;;724      assert_param(IS_ADCx_STATUS_FLAG(Flag));
;;;725    
;;;726      if ((MDR_ADC->ADC1_STATUS & Flag) == 0)
000258  6a09              LDR      r1,[r1,#0x20]
00025a  4201              TST      r1,r0
00025c  d001              BEQ      |L1.610|
;;;727      {
;;;728        bitstatus = RESET;
;;;729      }
;;;730      else
;;;731      {
;;;732        bitstatus = SET;
00025e  2001              MOVS     r0,#1
;;;733      }
;;;734    
;;;735      return bitstatus;
;;;736    }
000260  4770              BX       lr
                  |L1.610|
000262  2000              MOVS     r0,#0                 ;728
000264  4770              BX       lr
;;;737    
                          ENDP

                  ADC2_GetFlagStatus PROC
;;;746      */
;;;747    FlagStatus ADC2_GetFlagStatus(uint32_t Flag)
000266  4934              LDR      r1,|L1.824|
;;;748    {
;;;749      FlagStatus bitstatus;
;;;750    
;;;751      /* Check the parameters */
;;;752      assert_param(IS_ADCx_STATUS_FLAG(Flag));
;;;753    
;;;754      if ((MDR_ADC->ADC2_STATUS & Flag) == 0)
000268  6a49              LDR      r1,[r1,#0x24]
00026a  4201              TST      r1,r0
00026c  d001              BEQ      |L1.626|
;;;755      {
;;;756        bitstatus = RESET;
;;;757      }
;;;758      else
;;;759      {
;;;760        bitstatus = SET;
00026e  2001              MOVS     r0,#1
;;;761      }
;;;762    
;;;763      return bitstatus;
;;;764    }
000270  4770              BX       lr
                  |L1.626|
000272  2000              MOVS     r0,#0                 ;756
000274  4770              BX       lr
;;;765    
                          ENDP

                  ADC1_ClearOverwriteFlag PROC
;;;770      */
;;;771    void ADC1_ClearOverwriteFlag(void)
000276  4830              LDR      r0,|L1.824|
;;;772    {
;;;773      MDR_ADC->ADC1_STATUS &= ~ADCx_FLAG_OVERWRITE;
000278  6a01              LDR      r1,[r0,#0x20]
00027a  f0210101          BIC      r1,r1,#1
00027e  6201              STR      r1,[r0,#0x20]
;;;774    }
000280  4770              BX       lr
;;;775    
                          ENDP

                  ADC2_ClearOverwriteFlag PROC
;;;780      */
;;;781    void ADC2_ClearOverwriteFlag(void)
000282  482d              LDR      r0,|L1.824|
;;;782    {
;;;783      MDR_ADC->ADC2_STATUS &= ~ADCx_FLAG_OVERWRITE;
000284  6a41              LDR      r1,[r0,#0x24]
000286  f0210101          BIC      r1,r1,#1
00028a  6241              STR      r1,[r0,#0x24]
;;;784    }
00028c  4770              BX       lr
;;;785    
                          ENDP

                  ADC1_ClearOutOfRangeFlag PROC
;;;790      */
;;;791    void ADC1_ClearOutOfRangeFlag(void)
00028e  482a              LDR      r0,|L1.824|
;;;792    {
;;;793      MDR_ADC->ADC1_STATUS &= ~ADCx_FLAG_OUT_OF_RANGE;
000290  6a01              LDR      r1,[r0,#0x20]
000292  f0210102          BIC      r1,r1,#2
000296  6201              STR      r1,[r0,#0x20]
;;;794    }
000298  4770              BX       lr
;;;795    
                          ENDP

                  ADC2_ClearOutOfRangeFlag PROC
;;;800      */
;;;801    void ADC2_ClearOutOfRangeFlag(void)
00029a  4827              LDR      r0,|L1.824|
;;;802    {
;;;803      MDR_ADC->ADC2_STATUS &= ~ADCx_FLAG_OUT_OF_RANGE;
00029c  6a41              LDR      r1,[r0,#0x24]
00029e  f0210102          BIC      r1,r1,#2
0002a2  6241              STR      r1,[r0,#0x24]
;;;804    }
0002a4  4770              BX       lr
;;;805    
                          ENDP

                  ADC_ITConfig PROC
;;;817      */
;;;818    void ADC_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
0002a6  b570              PUSH     {r4-r6,lr}
;;;819    {
;;;820      uint32_t tmpreg_ADC1_IE;
;;;821      uint32_t tmpreg_ADC2_IE;
;;;822      uint32_t tmpreg_ADC_IT;
;;;823    
;;;824      /* Check the parameters */
;;;825      assert_param(IS_ADC_CONFIG_IT(ADC_IT));
;;;826      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;827    
;;;828      tmpreg_ADC1_IE = MDR_ADC->ADC1_STATUS;
0002a8  4e23              LDR      r6,|L1.824|
0002aa  6a33              LDR      r3,[r6,#0x20]
;;;829      tmpreg_ADC2_IE = MDR_ADC->ADC2_STATUS;
0002ac  6a75              LDR      r5,[r6,#0x24]
;;;830      tmpreg_ADC_IT = ADC_IT << 2;
0002ae  0084              LSLS     r4,r0,#2
0002b0  0480              LSLS     r0,r0,#18
;;;831    
;;;832      /* Form new value */
;;;833      if (NewState != DISABLE)
;;;834      {
;;;835        /* Enable the ADC Interrupt requests by setting bits in the ADCx_STATUS registers */
;;;836        tmpreg_ADC1_IE |= tmpreg_ADC_IT & 0xFFFF;
0002b2  0c02              LSRS     r2,r0,#16
0002b4  b121              CBZ      r1,|L1.704|
0002b6  ea420003          ORR      r0,r2,r3
;;;837        tmpreg_ADC2_IE |= tmpreg_ADC_IT >> 16;
0002ba  ea454114          ORR      r1,r5,r4,LSR #16
0002be  e003              B        |L1.712|
                  |L1.704|
;;;838      }
;;;839      else
;;;840      {
;;;841        /* Disable the ADC Interrupt requests by clearing bits in the ADCx_STATUS registers */
;;;842        tmpreg_ADC1_IE &= ~(tmpreg_ADC_IT & 0xFFFF);
0002c0  ea230002          BIC      r0,r3,r2
;;;843        tmpreg_ADC2_IE &= ~(tmpreg_ADC_IT >> 16);
0002c4  ea254114          BIC      r1,r5,r4,LSR #16
                  |L1.712|
;;;844      }
;;;845    
;;;846      /* Configure ADCx_STATUS registers with new value */
;;;847      MDR_ADC->ADC1_STATUS = tmpreg_ADC1_IE;
0002c8  6230              STR      r0,[r6,#0x20]
;;;848      MDR_ADC->ADC2_STATUS = tmpreg_ADC2_IE;
0002ca  6271              STR      r1,[r6,#0x24]
;;;849    }
0002cc  bd70              POP      {r4-r6,pc}
;;;850    
                          ENDP

                  ADC1_ITConfig PROC
;;;860      */
;;;861    void ADC1_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
0002ce  4b1a              LDR      r3,|L1.824|
;;;862    {
;;;863      uint32_t tmpreg_ADC1_IE;
;;;864    
;;;865      /* Check the parameters */
;;;866      assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;867      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;868    
;;;869      tmpreg_ADC1_IE = MDR_ADC->ADC1_STATUS;
0002d0  6a1a              LDR      r2,[r3,#0x20]
;;;870    
;;;871      /* Form new value */
;;;872      if (NewState != DISABLE)
0002d2  b111              CBZ      r1,|L1.730|
;;;873      {
;;;874        /* Enable the ADC Interrupt requests by setting bits in the ADC1_STATUS register */
;;;875        tmpreg_ADC1_IE |= (ADC_IT << 2);
0002d4  ea420080          ORR      r0,r2,r0,LSL #2
0002d8  e001              B        |L1.734|
                  |L1.730|
;;;876      }
;;;877      else
;;;878      {
;;;879        /* Disable the ADC Interrupt requests by clearing bits in the ADC1_STATUS register */
;;;880        tmpreg_ADC1_IE &= ~(ADC_IT << 2);
0002da  ea220080          BIC      r0,r2,r0,LSL #2
                  |L1.734|
;;;881      }
;;;882    
;;;883      /* Configure ADC1_STATUS registers with new value */
;;;884      MDR_ADC->ADC1_STATUS = tmpreg_ADC1_IE;
0002de  6218              STR      r0,[r3,#0x20]
;;;885    }
0002e0  4770              BX       lr
;;;886    
                          ENDP

                  ADC2_ITConfig PROC
;;;896      */
;;;897    void ADC2_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
0002e2  4b15              LDR      r3,|L1.824|
;;;898    {
;;;899      uint32_t tmpreg_ADC2_IE;
;;;900    
;;;901      /* Check the parameters */
;;;902      assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;903      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;904    
;;;905      tmpreg_ADC2_IE = MDR_ADC->ADC2_STATUS;
0002e4  6a5a              LDR      r2,[r3,#0x24]
;;;906    
;;;907      /* Form new value */
;;;908      if (NewState != DISABLE)
0002e6  b111              CBZ      r1,|L1.750|
;;;909      {
;;;910        /* Enable the ADC Interrupt requests by setting bits in the ADC2_STATUS register */
;;;911        tmpreg_ADC2_IE |= (ADC_IT << 2);
0002e8  ea420080          ORR      r0,r2,r0,LSL #2
0002ec  e001              B        |L1.754|
                  |L1.750|
;;;912      }
;;;913      else
;;;914      {
;;;915        /* Disable the ADC Interrupt requests by clearing bits in the ADC2_STATUS register */
;;;916        tmpreg_ADC2_IE &= ~(ADC_IT << 2);
0002ee  ea220080          BIC      r0,r2,r0,LSL #2
                  |L1.754|
;;;917      }
;;;918    
;;;919      /* Configure ADC2_STATUS registers with new value */
;;;920      MDR_ADC->ADC2_STATUS = tmpreg_ADC2_IE;
0002f2  6258              STR      r0,[r3,#0x24]
;;;921    }
0002f4  4770              BX       lr
;;;922    
                          ENDP

                  ADC_GetITStatus PROC
;;;932      */
;;;933    ITStatus ADC_GetITStatus(uint32_t ADC_IT)
0002f6  b500              PUSH     {lr}
;;;934    {
0002f8  4602              MOV      r2,r0
;;;935      ITStatus bitstatus;
;;;936      uint32_t tmpreg;
;;;937    
;;;938      /* Check the parameters */
;;;939      assert_param(IS_ADC_CONFIG_IT(ADC_IT));
;;;940    
;;;941      tmpreg = ADC_GetStatus();
0002fa  f7fffffe          BL       ADC_GetStatus
;;;942      tmpreg &= (tmpreg >> 2) & ADC_IT;
0002fe  ea020190          AND      r1,r2,r0,LSR #2
000302  4001              ANDS     r1,r1,r0
;;;943    
;;;944      if (tmpreg == 0)
000304  b109              CBZ      r1,|L1.778|
;;;945      {
;;;946        bitstatus = RESET;
;;;947      }
;;;948      else
;;;949      {
;;;950        bitstatus = SET;
000306  2001              MOVS     r0,#1
;;;951      }
;;;952    
;;;953      return bitstatus;
;;;954    }
000308  bd00              POP      {pc}
                  |L1.778|
00030a  2000              MOVS     r0,#0                 ;946
00030c  bd00              POP      {pc}
;;;955    
                          ENDP

                  ADC1_GetITStatus PROC
;;;963      */
;;;964    ITStatus ADC1_GetITStatus(uint32_t ADC_IT)
00030e  490a              LDR      r1,|L1.824|
;;;965    {
;;;966      ITStatus bitstatus;
;;;967      uint32_t tmpreg;
;;;968    
;;;969      /* Check the parameters */
;;;970      assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;971    
;;;972      tmpreg = MDR_ADC->ADC1_STATUS;
000310  6a09              LDR      r1,[r1,#0x20]
;;;973      tmpreg &= (tmpreg >> 2) & ADC_IT;
000312  ea000091          AND      r0,r0,r1,LSR #2
000316  4008              ANDS     r0,r0,r1
;;;974    
;;;975      if (tmpreg == 0)
000318  b108              CBZ      r0,|L1.798|
;;;976      {
;;;977        bitstatus = RESET;
;;;978      }
;;;979      else
;;;980      {
;;;981        bitstatus = SET;
00031a  2001              MOVS     r0,#1
;;;982      }
;;;983    
;;;984      return bitstatus;
;;;985    }
00031c  4770              BX       lr
                  |L1.798|
00031e  2000              MOVS     r0,#0                 ;977
000320  4770              BX       lr
;;;986    
                          ENDP

                  ADC2_GetITStatus PROC
;;;994      */
;;;995    ITStatus ADC2_GetITStatus(uint32_t ADC_IT)
000322  4905              LDR      r1,|L1.824|
;;;996    {
;;;997      ITStatus bitstatus;
;;;998      uint32_t tmpreg;
;;;999    
;;;1000     /* Check the parameters */
;;;1001     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1002   
;;;1003     tmpreg = MDR_ADC->ADC2_STATUS;
000324  6a49              LDR      r1,[r1,#0x24]
;;;1004     tmpreg &= (tmpreg >> 2) & ADC_IT;
000326  ea000091          AND      r0,r0,r1,LSR #2
00032a  4008              ANDS     r0,r0,r1
;;;1005   
;;;1006     if (tmpreg == 0)
00032c  b108              CBZ      r0,|L1.818|
;;;1007     {
;;;1008       bitstatus = RESET;
;;;1009     }
;;;1010     else
;;;1011     {
;;;1012       bitstatus = SET;
00032e  2001              MOVS     r0,#1
;;;1013     }
;;;1014   
;;;1015     return bitstatus;
;;;1016   }
000330  4770              BX       lr
                  |L1.818|
000332  2000              MOVS     r0,#0                 ;1008
000334  4770              BX       lr
;;;1017   
                          ENDP

000336  0000              DCW      0x0000
                  |L1.824|
                          DCD      0x40088000
                  |L1.828|
                          DCD      0xf1ff0000
                  |L1.832|
                          DCD      0xf1fb0003

;*** Start embedded assembler ***

#line 1 "..\\Library\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_adc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REVSH|
#line 130
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
