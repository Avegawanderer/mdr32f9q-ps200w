; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list -c --asm --interleave -o.\FLASH\heap_4.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\heap_4.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -I.\src\gui -I.\src\gui\guiCore -I.\src\gui\guiWidgets -I.\src\gui\guiGraphics -I.\src\gui\utils -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\heap_4.crf ..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\MemMang\heap_4.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  prvInsertBlockIntoFreeList PROC
;;;339    
;;;340    static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
000000  b530              PUSH     {r4,r5,lr}
;;;341    {
;;;342    xBlockLink *pxIterator;
;;;343    unsigned char *puc;
;;;344    
;;;345    	/* Iterate through the list until a block is found that has a higher address
;;;346    	than the block being inserted. */
;;;347    	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
000002  4954              LDR      r1,|L1.340|
000004  e000              B        |L1.8|
                  |L1.6|
000006  4611              MOV      r1,r2
                  |L1.8|
000008  680a              LDR      r2,[r1,#0]
00000a  4282              CMP      r2,r0
00000c  d3fb              BCC      |L1.6|
;;;348    	{
;;;349    		/* Nothing to do here, just iterate to the right position. */
;;;350    	}
;;;351    
;;;352    	/* Do the block being inserted, and the block it is being inserted after
;;;353    	make a contiguous block of memory? */	
;;;354    	puc = ( unsigned char * ) pxIterator;
;;;355    	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
00000e  684b              LDR      r3,[r1,#4]
000010  185c              ADDS     r4,r3,r1
000012  4284              CMP      r4,r0
000014  d103              BNE      |L1.30|
;;;356    	{
;;;357    		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
000016  6840              LDR      r0,[r0,#4]
000018  4418              ADD      r0,r0,r3
00001a  6048              STR      r0,[r1,#4]
;;;358    		pxBlockToInsert = pxIterator;
00001c  4608              MOV      r0,r1
                  |L1.30|
;;;359    	}
;;;360    
;;;361    	/* Do the block being inserted, and the block it is being inserted before
;;;362    	make a contiguous block of memory? */
;;;363    	puc = ( unsigned char * ) pxBlockToInsert;
;;;364    	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
00001e  680d              LDR      r5,[r1,#0]
000020  6844              LDR      r4,[r0,#4]
000022  1823              ADDS     r3,r4,r0
000024  42ab              CMP      r3,r5
000026  d10d              BNE      |L1.68|
;;;365    	{
;;;366    		if( pxIterator->pxNextFreeBlock != pxEnd )
000028  4b4a              LDR      r3,|L1.340|
00002a  3b0c              SUBS     r3,r3,#0xc
00002c  681b              LDR      r3,[r3,#0]  ; pxEnd
00002e  429a              CMP      r2,r3
000030  d006              BEQ      |L1.64|
;;;367    		{
;;;368    			/* Form one big block from the two blocks. */
;;;369    			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
000032  6852              LDR      r2,[r2,#4]
000034  4422              ADD      r2,r2,r4
000036  6042              STR      r2,[r0,#4]
;;;370    			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
000038  680a              LDR      r2,[r1,#0]
00003a  6812              LDR      r2,[r2,#0]
00003c  6002              STR      r2,[r0,#0]
00003e  e002              B        |L1.70|
                  |L1.64|
;;;371    		}
;;;372    		else
;;;373    		{
;;;374    			pxBlockToInsert->pxNextFreeBlock = pxEnd;
000040  6003              STR      r3,[r0,#0]
000042  e000              B        |L1.70|
                  |L1.68|
;;;375    		}
;;;376    	}
;;;377    	else
;;;378    	{
;;;379    		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
000044  6002              STR      r2,[r0,#0]
                  |L1.70|
;;;380    	}
;;;381    
;;;382    	/* If the block being inserted plugged a gab, so was merged with the block
;;;383    	before and the block after, then it's pxNextFreeBlock pointer will have
;;;384    	already been set, and should not be set here as that would make it point
;;;385    	to itself. */
;;;386    	if( pxIterator != pxBlockToInsert )
000046  4281              CMP      r1,r0
000048  d000              BEQ      |L1.76|
;;;387    	{
;;;388    		pxIterator->pxNextFreeBlock = pxBlockToInsert;
00004a  6008              STR      r0,[r1,#0]
                  |L1.76|
;;;389    	}
;;;390    }
00004c  bd30              POP      {r4,r5,pc}
;;;391    
                          ENDP

                  prvHeapInit PROC
;;;303    
;;;304    static void prvHeapInit( void )
00004e  4842              LDR      r0,|L1.344|
;;;305    {
;;;306    xBlockLink *pxFirstFreeBlock;
;;;307    unsigned char *pucHeapEnd, *pucAlignedHeap;
;;;308    
;;;309    	/* Ensure the heap starts on a correctly aligned boundary. */
;;;310    	pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
000050  f0200107          BIC      r1,r0,#7
;;;311    
;;;312    	/* xStart is used to hold a pointer to the first item in the list of free
;;;313    	blocks.  The void cast is used to prevent compiler warnings. */
;;;314    	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
000054  483f              LDR      r0,|L1.340|
000056  6001              STR      r1,[r0,#0]  ; xStart
;;;315    	xStart.xBlockSize = ( size_t ) 0;
000058  2300              MOVS     r3,#0
00005a  6043              STR      r3,[r0,#4]  ; xStart
;;;316    
;;;317    	/* pxEnd is used to mark the end of the list of free blocks and is inserted
;;;318    	at the end of the heap space. */
;;;319    	pucHeapEnd = pucAlignedHeap + xTotalHeapSize;
00005c  f24430f8          MOV      r0,#0x43f8
000060  4408              ADD      r0,r0,r1
;;;320    	pucHeapEnd -= heapSTRUCT_SIZE;
000062  3808              SUBS     r0,r0,#8
;;;321    	pxEnd = ( void * ) pucHeapEnd;
000064  4a3b              LDR      r2,|L1.340|
000066  3a0c              SUBS     r2,r2,#0xc
000068  6010              STR      r0,[r2,#0]  ; pxEnd
;;;322    	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
;;;323    	pxEnd->xBlockSize = 0;
00006a  6043              STR      r3,[r0,#4]
;;;324    	pxEnd->pxNextFreeBlock = NULL;
00006c  6003              STR      r3,[r0,#0]
;;;325    
;;;326    	/* To start with there is a single free block that is sized to take up the
;;;327    	entire heap space, minus the space taken by pxEnd. */
;;;328    	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
;;;329    	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
00006e  f24433f0          MOV      r3,#0x43f0
000072  604b              STR      r3,[r1,#4]
;;;330    	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
000074  6008              STR      r0,[r1,#0]
;;;331    
;;;332    	/* The heap now contains pxEnd. */
;;;333    	xFreeBytesRemaining -= heapSTRUCT_SIZE;
000076  6850              LDR      r0,[r2,#4]  ; xFreeBytesRemaining
000078  3808              SUBS     r0,r0,#8
00007a  6050              STR      r0,[r2,#4]  ; xFreeBytesRemaining
;;;334    
;;;335    	/* Work out the position of the top bit in a size_t variable. */
;;;336    	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
00007c  06d8              LSLS     r0,r3,#27
00007e  6090              STR      r0,[r2,#8]  ; xBlockAllocatedBit
;;;337    }
000080  4770              BX       lr
;;;338    /*-----------------------------------------------------------*/
                          ENDP

                  pvPortMalloc PROC
;;;145    
;;;146    void *pvPortMalloc( size_t xWantedSize )
000082  e92d41f0          PUSH     {r4-r8,lr}
;;;147    {
000086  4605              MOV      r5,r0
;;;148    xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
;;;149    void *pvReturn = NULL;
000088  2600              MOVS     r6,#0
;;;150    
;;;151    	vTaskSuspendAll();
00008a  f7fffffe          BL       vTaskSuspendAll
;;;152    	{
;;;153    		/* If this is the first call to malloc then the heap will require
;;;154    		initialisation to setup the list of free blocks. */
;;;155    		if( pxEnd == NULL )
00008e  4f31              LDR      r7,|L1.340|
000090  3f0c              SUBS     r7,r7,#0xc
000092  6838              LDR      r0,[r7,#0]  ; pxEnd
000094  b908              CBNZ     r0,|L1.154|
;;;156    		{
;;;157    			prvHeapInit();
000096  f7fffffe          BL       prvHeapInit
                  |L1.154|
;;;158    		}
;;;159    
;;;160    		/* Check the requested block size is not so large that the top bit is
;;;161    		set.  The top bit of the block size member of the xBlockLink structure 
;;;162    		is used to determine who owns the block - the application or the
;;;163    		kernel, so it must be free. */
;;;164    		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
00009a  68b8              LDR      r0,[r7,#8]  ; xBlockAllocatedBit
00009c  4205              TST      r5,r0
00009e  d131              BNE      |L1.260|
;;;165    		{
;;;166    			/* The wanted size is increased so it can contain a xBlockLink
;;;167    			structure in addition to the requested amount of bytes. */
;;;168    			if( xWantedSize > 0 )
0000a0  b13d              CBZ      r5,|L1.178|
;;;169    			{
;;;170    				xWantedSize += heapSTRUCT_SIZE;
0000a2  3508              ADDS     r5,r5,#8
;;;171    
;;;172    				/* Ensure that blocks are always aligned to the required number 
;;;173    				of bytes. */
;;;174    				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
0000a4  0768              LSLS     r0,r5,#29
0000a6  d004              BEQ      |L1.178|
;;;175    				{
;;;176    					/* Byte alignment required. */
;;;177    					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
0000a8  f0050007          AND      r0,r5,#7
0000ac  f1c00008          RSB      r0,r0,#8
0000b0  4405              ADD      r5,r5,r0
                  |L1.178|
;;;178    				}
;;;179    			}
;;;180    
;;;181    			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
0000b2  b33d              CBZ      r5,|L1.260|
0000b4  6878              LDR      r0,[r7,#4]  ; xFreeBytesRemaining
0000b6  4285              CMP      r5,r0
0000b8  d824              BHI      |L1.260|
;;;182    			{
;;;183    				/* Traverse the list from the start	(lowest address) block until 
;;;184    				one	of adequate size is found. */
;;;185    				pxPreviousBlock = &xStart;
0000ba  4926              LDR      r1,|L1.340|
;;;186    				pxBlock = xStart.pxNextFreeBlock;
0000bc  4608              MOV      r0,r1
0000be  6804              LDR      r4,[r0,#0]  ; xStart
;;;187    				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
0000c0  e001              B        |L1.198|
                  |L1.194|
;;;188    				{
;;;189    					pxPreviousBlock = pxBlock;
0000c2  4621              MOV      r1,r4
;;;190    					pxBlock = pxBlock->pxNextFreeBlock;
0000c4  4604              MOV      r4,r0
                  |L1.198|
0000c6  6860              LDR      r0,[r4,#4]            ;187
0000c8  42a8              CMP      r0,r5                 ;187
0000ca  d202              BCS      |L1.210|
0000cc  6820              LDR      r0,[r4,#0]            ;187
0000ce  2800              CMP      r0,#0                 ;187
0000d0  d1f7              BNE      |L1.194|
                  |L1.210|
;;;191    				}
;;;192    
;;;193    				/* If the end marker was reached then a block of adequate size 
;;;194    				was	not found. */
;;;195    				if( pxBlock != pxEnd )
0000d2  6838              LDR      r0,[r7,#0]  ; pxEnd
0000d4  4284              CMP      r4,r0
0000d6  d015              BEQ      |L1.260|
;;;196    				{
;;;197    					/* Return the memory space pointed to - jumping over the 
;;;198    					xBlockLink structure at its start. */
;;;199    					pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
0000d8  680e              LDR      r6,[r1,#0]
0000da  3608              ADDS     r6,r6,#8
;;;200    
;;;201    					/* This block is being returned for use so must be taken out 
;;;202    					of the list of free blocks. */
;;;203    					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
0000dc  6820              LDR      r0,[r4,#0]
0000de  6008              STR      r0,[r1,#0]
;;;204    
;;;205    					/* If the block is larger than required it can be split into 
;;;206    					two. */
;;;207    					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
0000e0  6860              LDR      r0,[r4,#4]
0000e2  1b41              SUBS     r1,r0,r5
0000e4  2910              CMP      r1,#0x10
0000e6  d904              BLS      |L1.242|
;;;208    					{
;;;209    						/* This block is to be split into two.  Create a new 
;;;210    						block following the number of bytes requested. The void 
;;;211    						cast is used to prevent byte alignment warnings from the 
;;;212    						compiler. */
;;;213    						pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
0000e8  1960              ADDS     r0,r4,r5
;;;214    
;;;215    						/* Calculate the sizes of two blocks split from the 
;;;216    						single block. */
;;;217    						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
0000ea  6041              STR      r1,[r0,#4]
;;;218    						pxBlock->xBlockSize = xWantedSize;
0000ec  6065              STR      r5,[r4,#4]
;;;219    
;;;220    						/* Insert the new block into the list of free blocks. */
;;;221    						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
0000ee  f7fffffe          BL       prvInsertBlockIntoFreeList
                  |L1.242|
;;;222    					}
;;;223    
;;;224    					xFreeBytesRemaining -= pxBlock->xBlockSize;
0000f2  6860              LDR      r0,[r4,#4]
0000f4  6879              LDR      r1,[r7,#4]  ; xFreeBytesRemaining
0000f6  1a09              SUBS     r1,r1,r0
0000f8  6079              STR      r1,[r7,#4]  ; xFreeBytesRemaining
;;;225    
;;;226    					/* The block is being returned - it is allocated and owned
;;;227    					by the application and has no "next" block. */
;;;228    					pxBlock->xBlockSize |= xBlockAllocatedBit;
0000fa  68b9              LDR      r1,[r7,#8]  ; xBlockAllocatedBit
0000fc  4308              ORRS     r0,r0,r1
0000fe  6060              STR      r0,[r4,#4]
;;;229    					pxBlock->pxNextFreeBlock = NULL;
000100  2000              MOVS     r0,#0
000102  6020              STR      r0,[r4,#0]
                  |L1.260|
;;;230    				}
;;;231    			}
;;;232    		}
;;;233    
;;;234    		traceMALLOC( pvReturn, xWantedSize );
;;;235    	}
;;;236    	xTaskResumeAll();
000104  f7fffffe          BL       xTaskResumeAll
;;;237    
;;;238    	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
;;;239    	{
;;;240    		if( pvReturn == NULL )
;;;241    		{
;;;242    			extern void vApplicationMallocFailedHook( void );
;;;243    			vApplicationMallocFailedHook();
;;;244    		}
;;;245    	}
;;;246    	#endif
;;;247    
;;;248    	return pvReturn;
000108  4630              MOV      r0,r6
;;;249    }
00010a  e8bd81f0          POP      {r4-r8,pc}
;;;250    /*-----------------------------------------------------------*/
                          ENDP

                  vPortFree PROC
;;;251    
;;;252    void vPortFree( void *pv )
00010e  b570              PUSH     {r4-r6,lr}
;;;253    {
;;;254    unsigned char *puc = ( unsigned char * ) pv;
;;;255    xBlockLink *pxLink;
;;;256    
;;;257    	if( pv != NULL )
000110  2800              CMP      r0,#0
000112  d019              BEQ      |L1.328|
;;;258    	{
;;;259    		/* The memory being freed will have an xBlockLink structure immediately
;;;260    		before it. */
;;;261    		puc -= heapSTRUCT_SIZE;
000114  3808              SUBS     r0,r0,#8
;;;262    
;;;263    		/* This casting is to keep the compiler from issuing warnings. */
;;;264    		pxLink = ( void * ) puc;
000116  4604              MOV      r4,r0
;;;265    
;;;266    		/* Check the block is actually allocated. */
;;;267    		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
;;;268    		configASSERT( pxLink->pxNextFreeBlock == NULL );
;;;269    		
;;;270    		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
000118  4d0e              LDR      r5,|L1.340|
00011a  6860              LDR      r0,[r4,#4]
00011c  3d0c              SUBS     r5,r5,#0xc
00011e  68a9              LDR      r1,[r5,#8]  ; xBlockAllocatedBit
000120  4208              TST      r0,r1
000122  d011              BEQ      |L1.328|
;;;271    		{
;;;272    			if( pxLink->pxNextFreeBlock == NULL )
000124  6822              LDR      r2,[r4,#0]
000126  2a00              CMP      r2,#0
000128  d10e              BNE      |L1.328|
;;;273    			{
;;;274    				/* The block is being returned to the heap - it is no longer
;;;275    				allocated. */
;;;276    				pxLink->xBlockSize &= ~xBlockAllocatedBit;
00012a  4388              BICS     r0,r0,r1
00012c  6060              STR      r0,[r4,#4]
;;;277    
;;;278    				vTaskSuspendAll();
00012e  f7fffffe          BL       vTaskSuspendAll
;;;279    				{
;;;280    					/* Add this block to the list of free blocks. */
;;;281    					xFreeBytesRemaining += pxLink->xBlockSize;
000132  6860              LDR      r0,[r4,#4]
000134  6869              LDR      r1,[r5,#4]  ; xFreeBytesRemaining
000136  4408              ADD      r0,r0,r1
000138  6068              STR      r0,[r5,#4]  ; xFreeBytesRemaining
;;;282    					prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
00013a  4620              MOV      r0,r4
00013c  f7fffffe          BL       prvInsertBlockIntoFreeList
;;;283    					traceFREE( pv, pxLink->xBlockSize );
;;;284    				}
;;;285    				xTaskResumeAll();
000140  e8bd4070          POP      {r4-r6,lr}
000144  f7ffbffe          B.W      xTaskResumeAll
                  |L1.328|
;;;286    			}
;;;287    		}
;;;288    	}
;;;289    }
000148  bd70              POP      {r4-r6,pc}
;;;290    /*-----------------------------------------------------------*/
                          ENDP

                  xPortGetFreeHeapSize PROC
;;;291    
;;;292    size_t xPortGetFreeHeapSize( void )
00014a  4802              LDR      r0,|L1.340|
;;;293    {
;;;294    	return xFreeBytesRemaining;
00014c  380c              SUBS     r0,r0,#0xc
00014e  6840              LDR      r0,[r0,#4]  ; xFreeBytesRemaining
;;;295    }
000150  4770              BX       lr
;;;296    /*-----------------------------------------------------------*/
                          ENDP

                  vPortInitialiseBlocks PROC
;;;297    
;;;298    void vPortInitialiseBlocks( void )
000152  4770              BX       lr
;;;299    {
;;;300    	/* This just exists to keep the linker quiet. */
;;;301    }
;;;302    /*-----------------------------------------------------------*/
                          ENDP

                  |L1.340|
                          DCD      ||.data||+0xc
                  |L1.344|
                          DCD      ||.bss||+0x8

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucHeap
                          %        17408

                          AREA ||.data||, DATA, ALIGN=2

                  pxEnd
                          DCD      0x00000000
                  xFreeBytesRemaining
                          DCD      0x000043f8
                  xBlockAllocatedBit
                          DCD      0x00000000
                  xStart
                          %        8
