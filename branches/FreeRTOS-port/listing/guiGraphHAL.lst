L 1 "src\gui\guiGraphics\guiGraphHAL.c"
N/**********************************************************
N  Module guiGraphHAL contains low-level LCD routines.
N
N
N
N**********************************************************/
N
N#include <stdint.h>
L 1 "C:\Keil\ARM\RV31\Inc\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 137748 $
N * Checkin $Date: 2008-09-11 17:34:24 +0100 (Thu, 11 Sep 2008) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
L 9 "src\gui\guiGraphics\guiGraphHAL.c" 2
N#include "guiGraphHAL.h"
L 1 "src\gui\guiGraphics\guiGraphHAL.h" 1
N#ifndef __GUI_GRAPH_HAL_
N#define __GUI_GRAPH_HAL_
N
N#include <stdint.h>
N
N
N// Size definitions in points for Nokia 1202 LCD
N#define LCD_XSIZE (2*96)
N#define LCD_YSIZE 68
N
N// Buffer size in bytes
N#define LCD_BUFFER_SIZE (2*96*9)
N
N/*
N// Size definitions in points
N#define LCD_XSIZE (2*128)
N#define LCD_YSIZE 128
N
N// Buffer size in bytes
N#define LCD_BUFFER_SIZE (LCD_XSIZE * 16)
N*/
N
N// LCD functions settings
N//#define SOFT_HORIZ_REVERSED
N
N// counter increments from 0 to LCD_xxx_PERIOD-1
N// if counter < LCD_xxx_COMPARE, pixel is put unchaged
N// if counter >= LCD_xxx_COMPARE, pixel is put inversed
N#define LCD_DOT_PERIOD      4
N#define LCD_DOT_COMPARE     2
N#define LCD_DASH_PERIOD     7
N#define LCD_DASH_COMPARE    5
N
N
N
N
N// Pixel output modes
N#define PIXEL_MODE_REWRITE  0x00
N#define PIXEL_MODE_AND      0x01
N#define PIXEL_MODE_OR       0x02
N#define PIXEL_MODE_XOR      0x03
N
N// Image output modes
N#define IMAGE_MODE_NORMAL    0x01
N#define IMAGE_MODE_INVERSE   0x00
N// Aliases for fill rect
N#define FILL_WITH_BLACK      0x01
N#define FILL_WITH_WHITE      0x00
N
N#define LCD_FillRect(x_pos, y_pos, width, height, mode) \
N    LCD_DrawImage(0, x_pos, y_pos, width, height, mode)
X#define LCD_FillRect(x_pos, y_pos, width, height, mode)     LCD_DrawImage(0, x_pos, y_pos, width, height, mode)
N
N
N// Line drawing mode (not for all functions)
N#define LINE_STYLE_SOLID      0x10
N#define LINE_STYLE_DASHED     0x20
N#define LINE_STYLE_DOTTED     0x30
N
N
N
N
N
Nextern uint8_t lcdBuffer[LCD_BUFFER_SIZE];
Xextern uint8_t lcdBuffer[(2*96*9)];
Nextern uint8_t LCD_lineStyle;
N
Nvoid LCD_SetPixelOutputMode(uint8_t newMode);
Nvoid LCD_SetLineStyle(uint8_t newStyle);
N
Nvoid LCD_FillWholeBuffer(uint8_t pixelValue);
Nvoid LCD_PutPixel (uint8_t x_pos, uint8_t y_pos, uint8_t pixelValue);
Nvoid LCD_DrawHorLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t pixelValue);
Nvoid LCD_DrawVertLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t pixelValue);
N
Nvoid LCD_DrawImage(const uint8_t* img, uint8_t x_pos, uint8_t y_pos, uint8_t width, uint8_t height, uint8_t mode);
N
N
N#endif
L 10 "src\gui\guiGraphics\guiGraphHAL.c" 2
N
N
N// Display buffer
Nuint8_t lcdBuffer[LCD_BUFFER_SIZE];
Xuint8_t lcdBuffer[(2*96*9)];
N
Nuint8_t LCD_lineStyle;
N
Nstatic uint8_t pixel_and_mask;
Nstatic uint8_t pixel_or_mask;
Nstatic uint8_t pixel_xor_mask;
N
N
N
N//-------------------------------------------------------//
N// Sets pixel output mode. Pixels will be processed as follows:
N//
N// REWRITE: data = (data & ~bit_mask) | (pixelValue & bit_mask)
N// AND:     data &= (pixelValue | ~bit_mask)
N// OR:      data |= (pixelValue & bit_mask)
N// XOR:     data ^= (pixelValue & bit_mask)
N//-------------------------------------------------------//
Nvoid LCD_SetPixelOutputMode(uint8_t newMode)
N{
N    switch (newMode)
N    {
N        case PIXEL_MODE_AND:
X        case 0x01:
N            pixel_and_mask = 0x00;
N            pixel_or_mask = 0x00;
N            pixel_xor_mask = 0x00;
N            break;
N        case PIXEL_MODE_OR:
X        case 0x02:
N            pixel_and_mask = 0xFF;
N            pixel_or_mask = 0xFF;
N            pixel_xor_mask = 0x00;
N            break;
N        case PIXEL_MODE_XOR:
X        case 0x03:
N            pixel_and_mask = 0xFF;
N            pixel_or_mask = 0x00;
N            pixel_xor_mask = 0xFF;
N            break;
N        default:    // PIXEL_MODE_REWRITE:
N            pixel_and_mask = 0x00;
N            pixel_or_mask = 0xFF;
N            pixel_xor_mask = 0x00;
N            break;
N    }
N}
N
N
N//-------------------------------------------------------//
N// Sets line style
N//
N//-------------------------------------------------------//
Nvoid LCD_SetLineStyle(uint8_t newStyle)
N{
N    if (newStyle != LCD_lineStyle)
N    {
N        LCD_lineStyle = newStyle;
N    }
N}
N
N
N//-------------------------------------------------------//
N// Fills whole buffer with specified value
N//	Parameters:
N//		uint8_t value - pixel color to fill with (1 or 0)
N// Buffer is filled direct with value specified
N// No pixel output mode is used
N//-------------------------------------------------------//
Nvoid LCD_FillWholeBuffer(uint8_t pixelValue)
N{
N    uint16_t i;
N    if (pixelValue) pixelValue = 0xFF;
N
N    for (i=0;i<LCD_BUFFER_SIZE;i++)
X    for (i=0;i<(2*96*9);i++)
N    {
N        lcdBuffer[i] = pixelValue;
N    }
N}
N
N
N
N//-------------------------------------------------------//
N// Modify single pixel
N//	Parameters:
N//		uint8_t x_pos							- pixel x coordinate
N//		uint8_t y_pos							- pixel y coordinate
N//		uint8_t pixelValue						- new pixel value, 1 or 0
N// Pixel output mode is set by calling LCD_setPixelOutputMode()
N//-------------------------------------------------------//
Nvoid LCD_PutPixel (uint8_t x_pos, uint8_t y_pos, uint8_t pixelValue)
N{
N    int16_t buffer_index;
N    uint8_t data, bit_mask;
N    if (pixelValue) pixelValue = 0xFF;
N    // Get byte index
N    #ifdef SOFT_HORIZ_REVERSED
S        buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + LCD_XSIZE - 1 - x_pos;
N    #else
N        buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + x_pos;
X        buffer_index = ((uint16_t)(y_pos / 8))*(2*96) + x_pos;
N    #endif
N    // Bit mask defines changed pixel
N    bit_mask = 1 << (y_pos % 8);
N    // Modify data byte
N    data = (uint8_t)lcdBuffer[buffer_index];
N    data &= pixelValue | ~bit_mask | pixel_and_mask;
N    data |= pixelValue & bit_mask & pixel_or_mask;
N    data ^= pixelValue & bit_mask & pixel_xor_mask;
N    lcdBuffer[buffer_index] = data;
N}
N
N
N
N//-------------------------------------------------------//
N// Draws horizontal line using LCD_lineStyle
N//	Parameters:
N//		uint8_t x_pos	- pixel x coordinate
N//		uint8_t y_pos	- pixel y coordinate
N//      pixelValue  	- new pixel value, 1 or 0
N// Pixel output mode is set by calling LCD_setPixelOutputMode()
N//-------------------------------------------------------//
Nvoid LCD_DrawHorLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t pixelValue)
N{
N    uint16_t buffer_index;
N    int8_t buffer_increment;
N    uint8_t data, bit_mask;
N    uint8_t pixelInversed;
N    uint8_t dashCompare;
N    uint8_t dashPeriod;
N    uint8_t dashCounter = 0;
N
N    if (pixelValue) pixelValue = 0xFF;
N
N    switch(LCD_lineStyle)
N    {
N        case LINE_STYLE_DASHED:
X        case 0x20:
N            dashPeriod = LCD_DASH_PERIOD;
X            dashPeriod = 7;
N            dashCompare = LCD_DASH_COMPARE;
X            dashCompare = 5;
N            break;
N        case LINE_STYLE_DOTTED:
X        case 0x30:
N            dashPeriod = LCD_DOT_PERIOD;
X            dashPeriod = 4;
N            dashCompare = LCD_DOT_COMPARE;
X            dashCompare = 2;
N            break;
N         default: //LINE_STYLE_SOLID:
N            dashPeriod = 10;
N            dashCompare = 10;   // arbitrary, but >= dashPeriod
N            break;
N    }
N
N    // Get byte index
N    #ifdef SOFT_HORIZ_REVERSED
S        buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + LCD_XSIZE - 1 - x_pos;
S        buffer_increment = -1;
N    #else
N        buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + x_pos;
X        buffer_index = ((uint16_t)(y_pos / 8))*(2*96) + x_pos;
N        buffer_increment = 1;
N    #endif
N    // Bit mask defines changed pixel
N    bit_mask = 1 << (y_pos % 8);
N    while(length)
N    {
N        pixelInversed = (dashCounter < dashCompare) ? pixelValue : ~pixelValue;
N
N        // Modify data byte
N        data = (uint8_t)lcdBuffer[buffer_index];
N        data &= pixelInversed | ~bit_mask | pixel_and_mask;
N        data |= pixelInversed & bit_mask & pixel_or_mask;
N        data ^= pixelInversed & bit_mask & pixel_xor_mask;
N        lcdBuffer[buffer_index] = data;
N        buffer_index += buffer_increment;
N        length--;
N
N        dashCounter++;
N        if (dashCounter == dashPeriod)
N            dashCounter = 0;
N    }
N}
N
N
N//-------------------------------------------------------//
N// Draws vertical line using LCD_lineStyle
N//	Parameters:
N//		uint8_t x_pos	- pixel x coordinate
N//		uint8_t y_pos	- pixel y coordinate
N//      pixelValue  	- new pixel value, 1 or 0
N// Pixel output mode is set by calling LCD_setPixelOutputMode()
N//-------------------------------------------------------//
Nvoid LCD_DrawVertLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t pixelValue)
N{
N    uint8_t dashCompare;
N    uint8_t dashPeriod;
N    uint8_t dashCounter = 0;
N    uint8_t pixelInversed;
N
N    if (pixelValue) pixelValue = 0xFF;
N
N    switch(LCD_lineStyle)
N    {
N        case LINE_STYLE_DASHED:
X        case 0x20:
N            dashPeriod = LCD_DASH_PERIOD;
X            dashPeriod = 7;
N            dashCompare = LCD_DASH_COMPARE;
X            dashCompare = 5;
N            break;
N        case LINE_STYLE_DOTTED:
X        case 0x30:
N            dashPeriod = LCD_DOT_PERIOD;
X            dashPeriod = 4;
N            dashCompare = LCD_DOT_COMPARE;
X            dashCompare = 2;
N            break;
N         default: //LINE_STYLE_SOLID:
N            dashPeriod = 10;
N            dashCompare = 10;   // arbitrary, but >= dashPeriod
N            break;
N    }
N
N    while(length)
N    {
N        pixelInversed = (dashCounter < dashCompare) ? pixelValue : ~pixelValue;
N
N        LCD_PutPixel(x_pos, y_pos, pixelInversed);
N        y_pos++;
N        length--;
N
N        dashCounter++;
N        if (dashCounter == dashPeriod)
N            dashCounter = 0;
N    }
N}
N
N
N
N
N
N
N/*
Nvoid LCD_PutVertLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t mode)
N{
N    uint16_t buffer_index;
N    uint8_t temp;
N    uint8_t counter_inc;
N    uint8_t bit_mask;
N    uint8_t offset = y_pos % 8;
N    uint8_t pixelInversed;
N    uint8_t dashCompare;
N    uint8_t dashPeriod;
N    uint8_t dashCounter = 0;
N
N    if (pixelValue) pixelValue = 0xFF;
N
N    switch(LCD_lineStyle)
N    {
N        case LCD_LINE_DASHED:
N            dashPeriod = LCD_DASH_PERIOD;
N            dashCompare = LCD_DASH_COMPARE;
N            break;
N        case LCD_LINE_DOTTED:
N            dashPeriod = LCD_DOT_PERIOD;
N            dashCompare = LCD_DOT_COMPARE;
N            break;
N         default: //LCD_LINE_SOLID:
N            dashPeriod = 10;
N            dashCompare = 10;   // arbitrary, but >= dashPeriod
N            break;
N    }
N
N    // Get byte index
N    #ifdef SOFT_HORIZ_REVERSED
N        buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + LCD_XSIZE - 1 - x_pos;
N    #else
N        buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + x_pos;
N    #endif
N
N    bit_mask = -(1<<offset);
N    if (offset + length < 8 )
N    {
N        temp = (1<<(offset + length))-1;
N        bit_mask &= temp;
N        counter_inc = length;
N    }
N    else
N    {
N        counter_inc = 8-offset;
N    }
N
N    while(length)
N    {
N        pixelInversed = (dashCounter < dashCompare) ? pixelValue : ~pixelValue;
N
N        //img_shift |= temp << offset;    //
N        img_shift = 0xFF;
N
N
N
N        temp = (uint8_t)lcdBuffer[buffer_index];     // get old value
N        // Modify data byte
N        // Bit mask defines changed pixel
N        temp &= img_shift | ~bit_mask | pixel_and_mask;
N        temp |= img_shift & bit_mask & pixel_or_mask;
N        temp ^= img_shift & bit_mask & pixel_xor_mask;
N        lcdBuffer[buffer_index] = temp;              // write new value back
N
N        //img_shift = img_shift >> 8;						// shift 16-bit register
N        buffer_index += LCD_XSIZE;
N
N        vertical_bits_remain -= counter_inc;
N        if (vertical_bits_remain >= 8)
N            counter_inc = 8;
N        else
N            counter_inc = length;
N        bit_mask = (1 << counter_inc)-1;
N
N        length--;
N
N        dashCounter++;
N        if (dashCounter == dashPeriod)
N            dashCounter = 0;
N    }
N}
N*/
N
N
N
N
N//-------------------------------------------------------//
N// Print an image at specified area
N// This function can be also used for filling rectangles
N// Parameters:
N//		uint8_t* img					- pointer to image
N//          if img = 0, area is filled with color, depending on mode parameter
N//		uint8_t x_pos					- horizontal image position, pixels
N//		uint8_t y_pos					- vertical image position, pixels
N//		uint8_t width					- image width
N//		uint8_t height                  - image height
N//      mode:
N//          IMAGE_MODE_NORMAL - normal image,   if img = 0, image is treated as all 1's
N//          IMAGE_MODE_INVERSE - inversed image, if img = 0, image is treated as all 0's
N//
N// If defined SOFT_HORIZ_REVERSED, function will put image reversed
N// Pixel output mode is set by calling LCD_setPixelOutputMode()
N//-------------------------------------------------------//
Nvoid LCD_DrawImage(const uint8_t* img, uint8_t x_pos, uint8_t y_pos, uint8_t width, uint8_t height, uint8_t mode)
N{
N    uint16_t vertical_bits_remain, counter_inc; // counter_inc - uint8_t ? FIXME
N    uint16_t picture_index, buffer_index;
N    uint16_t start_buffer_index;
N    uint16_t i;
N    uint16_t img_shift;
N    uint8_t bit_mask, temp;
N    uint8_t offset = y_pos % 8;
N    /*
N        img != 0, mode = 1 - print text as black
N            => mode = 0x00
N        img != 0, mode = 0 - print text as white
N            => mode = 0xFF
N        img = 0, mode = 1 - fill with black
N            => mode = 0x00
N        img = 0, mode = 0 - fill with white
N            => mode = 0xFF
N    */
N    mode = (mode) ? 0x00 : 0xFF;
N
N    #ifdef SOFT_HORIZ_REVERSED
S        start_buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + LCD_XSIZE - 1 - x_pos;
N    #else
N        start_buffer_index = ((uint16_t)(y_pos / 8))*LCD_XSIZE + x_pos;
X        start_buffer_index = ((uint16_t)(y_pos / 8))*(2*96) + x_pos;
N    #endif
N
N    //-------------//
N
N    // X-loop
N    for (i=0;i<width;i++)
N    {
N            img_shift = 0;
N            picture_index = i;
N            #ifdef SOFT_HORIZ_REVERSED
S                buffer_index =  start_buffer_index - i;
N            #else
N                buffer_index =  start_buffer_index + i;
N            #endif
N            vertical_bits_remain = height;
N            bit_mask = -(1<<offset);
N
N            if (offset + height < 8 )
N            {
N                temp = (1<<(offset + height))-1;
N                bit_mask &= temp;
N                counter_inc = height;
N            }
N            else
N            {
N                counter_inc = 8-offset;
N            }
N
N            // Y-loop
N            while(vertical_bits_remain)
N            {
N                if (img != 0)
N                    temp = img[picture_index];                  // get image byte
N                else
N                    temp = 0xFF;
N                temp ^= mode;
N                img_shift |= temp << offset;					// add shifted value to the 16-bit accumulator
N
N                temp = (uint8_t)lcdBuffer[buffer_index];     // get old value
N                // Modify data byte
N                // Bit mask defines changed pixel
N                temp &= img_shift | ~bit_mask | pixel_and_mask;
N                temp |= img_shift & bit_mask & pixel_or_mask;
N                temp ^= img_shift & bit_mask & pixel_xor_mask;
N                lcdBuffer[buffer_index] = temp;              // write new value back
N
N                img_shift = img_shift >> 8;						// shift 16-bit register
N                buffer_index += LCD_XSIZE;
X                buffer_index += (2*96);
N                picture_index += width;
N
N                vertical_bits_remain -= counter_inc;
N                if (vertical_bits_remain >= 8)
N                    counter_inc = 8;
N                else
N                    counter_inc = vertical_bits_remain;
N                bit_mask = (1 << counter_inc)-1;
N            }
N    }
N}
N
N
N
N
N
N
N
N
N
