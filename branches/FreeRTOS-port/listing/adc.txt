; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\adc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\adc.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\adc.crf src\adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  vTaskADC PROC
;;;27     
;;;28     void vTaskADC(void *pvParameters) 
000000  b508              PUSH     {r3,lr}
;;;29     {
;;;30     	uint32_t msg;
;;;31     	
;;;32     	// Initialize
;;;33     	xQueueADC = xQueueCreate( 5, sizeof( uint32_t ) );		// Queue can contain 5 elements of type uint32_t
000002  2200              MOVS     r2,#0
000004  2104              MOVS     r1,#4
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       xQueueGenericCreate
00000c  4c59              LDR      r4,|L1.372|
00000e  6120              STR      r0,[r4,#0x10]  ; xQueueADC
;;;34     	if( xQueueADC == 0 )
000010  b180              CBZ      r0,|L1.52|
;;;35     	{
;;;36     		// Queue was not created and must not be used.
;;;37     		while(1);
;;;38     	}
;;;39     	vSemaphoreCreateBinary( xSemaphoreADC );
000012  2203              MOVS     r2,#3
000014  2100              MOVS     r1,#0
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       xQueueGenericCreate
00001c  6160              STR      r0,[r4,#0x14]  ; xSemaphoreADC
00001e  b120              CBZ      r0,|L1.42|
000020  2300              MOVS     r3,#0
000022  461a              MOV      r2,r3
000024  4619              MOV      r1,r3
000026  f7fffffe          BL       xQueueGenericSend
                  |L1.42|
;;;40     	if( xSemaphoreADC == 0 )
00002a  6960              LDR      r0,[r4,#0x14]  ; xSemaphoreADC
00002c  b118              CBZ      r0,|L1.54|
;;;41         {
;;;42             while(1);
;;;43         }
;;;44     	
;;;45     	while(1)
;;;46     	{
;;;47     		xQueueReceive(xQueueADC, &msg, portMAX_DELAY);
;;;48     		switch (msg)
;;;49     		{
;;;50     			case ADC_GET_ALL_NORMAL:
;;;51     				// Send command to low-level task - must be atomic operations
;;;52     				ctrl_ADCProcess = CMD_ADC_START_VOLTAGE | CMD_ADC_START_CURRENT;
;;;53     				
;;;54     				//while(ctrl_ADCProcess)	// TODO - use semaphore
;;;55     					//vTaskDelay(2);
;;;56     				xSemaphoreTake(xSemaphoreADC, portMAX_DELAY);
00002e  f04f35ff          MOV      r5,#0xffffffff
000032  e021              B        |L1.120|
                  |L1.52|
000034  e7fe              B        |L1.52|
                  |L1.54|
000036  e7fe              B        |L1.54|
                  |L1.56|
000038  2003              MOVS     r0,#3                 ;52
00003a  7020              STRB     r0,[r4,#0]            ;52
00003c  2300              MOVS     r3,#0
00003e  462a              MOV      r2,r5
000040  4619              MOV      r1,r3
000042  6960              LDR      r0,[r4,#0x14]  ; xSemaphoreADC
000044  f7fffffe          BL       xQueueGenericReceive
;;;57     			
;;;58     				// Process adc samples
;;;59     				voltage_adc = adc_voltage_counts>>2;
000048  8920              LDRH     r0,[r4,#8]  ; adc_voltage_counts
00004a  0880              LSRS     r0,r0,#2
;;;60     				voltage_adc *= 5;
00004c  eb000080          ADD      r0,r0,r0,LSL #2
000050  b281              UXTH     r1,r0
000052  80a1              STRH     r1,[r4,#4]
;;;61     				
;;;62     				current_adc = adc_current_counts>>2;
000054  8960              LDRH     r0,[r4,#0xa]  ; adc_current_counts
000056  0880              LSRS     r0,r0,#2
000058  80e0              STRH     r0,[r4,#6]
;;;63     				if (regulation_setting_p -> current_limit == CURRENT_LIM_HIGH)
00005a  4a47              LDR      r2,|L1.376|
00005c  6812              LDR      r2,[r2,#0]  ; regulation_setting_p
00005e  7c52              LDRB     r2,[r2,#0x11]
000060  2a01              CMP      r2,#1
000062  d013              BEQ      |L1.140|
;;;64     					current_adc *= 10;
;;;65     				else
;;;66     					current_adc *= 5;
000064  eb000080          ADD      r0,r0,r0,LSL #2
000068  80e0              STRH     r0,[r4,#6]
                  |L1.106|
;;;67     				
;;;68     				power_adc = voltage_adc * current_adc / 1000;
00006a  88e0              LDRH     r0,[r4,#6]  ; current_adc
00006c  4341              MULS     r1,r0,r1
00006e  f44f707a          MOV      r0,#0x3e8
000072  fb91f0f0          SDIV     r0,r1,r0
000076  60e0              STR      r0,[r4,#0xc]  ; power_adc
                  |L1.120|
000078  2300              MOVS     r3,#0                 ;47
00007a  462a              MOV      r2,r5                 ;47
00007c  4669              MOV      r1,sp                 ;47
00007e  6920              LDR      r0,[r4,#0x10]         ;47  ; xQueueADC
000080  f7fffffe          BL       xQueueGenericReceive
000084  9800              LDR      r0,[sp,#0]            ;48
000086  2801              CMP      r0,#1                 ;48
000088  d1f6              BNE      |L1.120|
00008a  e7d5              B        |L1.56|
                  |L1.140|
00008c  eb000080          ADD      r0,r0,r0,LSL #2       ;64
000090  0040              LSLS     r0,r0,#1              ;64
000092  80e0              STRH     r0,[r4,#6]            ;64
000094  e7e9              B        |L1.106|
;;;69     			
;;;70     				break;
;;;71     			
;;;72     			
;;;73     		}
;;;74     		
;;;75     	}
;;;76     	
;;;77     }
;;;78     
                          ENDP

                  Converter_HW_ADCProcess PROC
;;;89     //---------------------------------------------//
;;;90     void Converter_HW_ADCProcess(void)
000096  b570              PUSH     {r4-r6,lr}
;;;91     {
;;;92     	static uint8_t state_ADCProcess = STATE_ADC_IDLE;
;;;93     	static uint8_t adc_cmd;
;;;94     	static uint8_t adc_counter;
;;;95     	
;;;96     	
;;;97     	// Process ADC FSM-based controller
;;;98     	switch (state_ADCProcess)
000098  4c36              LDR      r4,|L1.372|
00009a  2200              MOVS     r2,#0
00009c  4621              MOV      r1,r4
00009e  7860              LDRB     r0,[r4,#1]  ; state_ADCProcess
;;;99     	{
;;;100    		case STATE_ADC_IDLE:
;;;101    			adc_cmd = ctrl_ADCProcess;
;;;102    			if (adc_cmd)
;;;103    				state_ADCProcess = STATE_ADC_DISPATCH;
0000a0  2501              MOVS     r5,#1
;;;104    			break;
;;;105    		case STATE_ADC_DISPATCH:
;;;106    			if ((adc_cmd & (CMD_ADC_START_VOLTAGE | CMD_ADC_START_DISCON)) == CMD_ADC_START_VOLTAGE)
;;;107    			{
;;;108    				// Normal voltage measure 
;;;109    				adc_cmd &= ~(CMD_ADC_START_VOLTAGE | CMD_ADC_START_DISCON);
;;;110    				state_ADCProcess = STATE_ADC_NORMAL_START_U;
;;;111    				adc_voltage_counts = 0;
;;;112    			}
;;;113    			else if (adc_cmd & CMD_ADC_START_CURRENT)
;;;114    			{
;;;115    				// Current measure
;;;116    				adc_cmd &= ~CMD_ADC_START_CURRENT;
;;;117    				state_ADCProcess = STATE_ADC_START_I;
;;;118    				adc_current_counts = 0;
;;;119    			}
;;;120    			else
;;;121    			{
;;;122    				state_ADCProcess = STATE_ADC_IDLE;
;;;123    				ctrl_ADCProcess = 0;						// Can be used as flag
;;;124    				xSemaphoreGiveFromISR( xSemaphoreADC, 0 );	// We dont care for exact timing of ADC task
;;;125    			}
;;;126    			break;
;;;127    		case STATE_ADC_NORMAL_START_U:
;;;128    			// TODO: use DMA for this purpose
;;;129    			ADC1_SetChannel(ADC_CHANNEL_VOLTAGE);
0000a2  2604              MOVS     r6,#4
0000a4  78c9              LDRB     r1,[r1,#3]            ;98
0000a6  2803              CMP      r0,#3                 ;98
0000a8  d038              BEQ      |L1.284|
0000aa  dc05              BGT      |L1.184|
0000ac  b150              CBZ      r0,|L1.196|
0000ae  2801              CMP      r0,#1                 ;98
0000b0  d00e              BEQ      |L1.208|
0000b2  2802              CMP      r0,#2                 ;98
0000b4  d104              BNE      |L1.192|
0000b6  e02a              B        |L1.270|
                  |L1.184|
0000b8  2810              CMP      r0,#0x10              ;98
0000ba  d040              BEQ      |L1.318|
0000bc  2811              CMP      r0,#0x11              ;98
0000be  d045              BEQ      |L1.332|
                  |L1.192|
;;;130    			adc_counter = 4;
;;;131    			state_ADCProcess = STATE_ADC_NORMAL_REPEAT_U;
;;;132    			break;
;;;133    		case STATE_ADC_NORMAL_REPEAT_U:
;;;134    			if (adc_counter < 4)
;;;135    				adc_voltage_counts += ADC1_GetResult();
;;;136    			if (adc_counter != 0)
;;;137    			{
;;;138    				ADC1_Start();
;;;139    				adc_counter--;
;;;140    			}
;;;141    			else
;;;142    			{
;;;143    				state_ADCProcess = STATE_ADC_DISPATCH;
;;;144    			}
;;;145    			break;
;;;146    		case STATE_ADC_START_I:
;;;147    			// TODO: use DMA for this purpose
;;;148    			ADC1_SetChannel(ADC_CHANNEL_CURRENT);
;;;149    			adc_counter = 4;
;;;150    			state_ADCProcess = STATE_ADC_NORMAL_REPEAT_I;
;;;151    			break;
;;;152    		case STATE_ADC_NORMAL_REPEAT_I:
;;;153    			if (adc_counter < 4)
;;;154    				adc_current_counts += ADC1_GetResult();
;;;155    			ADC1_Start();
;;;156    			if (adc_counter != 0)
;;;157    			{
;;;158    				ADC1_Start();
;;;159    				adc_counter--;
;;;160    			}
;;;161    			else
;;;162    			{
;;;163    				state_ADCProcess = STATE_ADC_DISPATCH;
;;;164    			}
;;;165    			break;
;;;166    		default:
;;;167    			state_ADCProcess = STATE_ADC_IDLE;
0000c0  7062              STRB     r2,[r4,#1]
                  |L1.194|
;;;168    			break;
;;;169    	}
;;;170    	
;;;171    	
;;;172    	
;;;173    	/*
;;;174    		//...
;;;175    		
;;;176    		// Disable converter for ADC
;;;177    		cmd_ADC_to_HWProcess = STATE_HW_OFF_BY_ADC;			// Will disallow converter operation
;;;178    		
;;;179    		//...
;;;180    		
;;;181    		// Enable converter for ADC
;;;182    		cmd_ADC_to_HWProcess = CMD_HW_ON_BY_ADC;			// Will allow converter operation
;;;183    	*/
;;;184    	
;;;185    
;;;186    }
0000c2  bd70              POP      {r4-r6,pc}
                  |L1.196|
0000c4  7820              LDRB     r0,[r4,#0]            ;101  ; ctrl_ADCProcess
0000c6  70a0              STRB     r0,[r4,#2]            ;101
0000c8  2800              CMP      r0,#0                 ;102
0000ca  d0fa              BEQ      |L1.194|
0000cc  7065              STRB     r5,[r4,#1]            ;103
0000ce  bd70              POP      {r4-r6,pc}
                  |L1.208|
0000d0  78a0              LDRB     r0,[r4,#2]            ;106  ; adc_cmd
0000d2  f0000105          AND      r1,r0,#5              ;106
0000d6  2901              CMP      r1,#1                 ;106
0000d8  d008              BEQ      |L1.236|
0000da  0781              LSLS     r1,r0,#30             ;113
0000dc  d50d              BPL      |L1.250|
0000de  f0200002          BIC      r0,r0,#2              ;116
0000e2  70a0              STRB     r0,[r4,#2]            ;116
0000e4  2010              MOVS     r0,#0x10              ;117
0000e6  7060              STRB     r0,[r4,#1]            ;117
0000e8  8162              STRH     r2,[r4,#0xa]          ;118
0000ea  bd70              POP      {r4-r6,pc}
                  |L1.236|
0000ec  f0200005          BIC      r0,r0,#5              ;109
0000f0  70a0              STRB     r0,[r4,#2]            ;109
0000f2  2002              MOVS     r0,#2                 ;110
0000f4  7060              STRB     r0,[r4,#1]            ;110
0000f6  8122              STRH     r2,[r4,#8]            ;111
0000f8  bd70              POP      {r4-r6,pc}
                  |L1.250|
0000fa  7062              STRB     r2,[r4,#1]            ;122
0000fc  7022              STRB     r2,[r4,#0]            ;123
0000fe  6960              LDR      r0,[r4,#0x14]         ;124  ; xSemaphoreADC
000100  e8bd4070          POP      {r4-r6,lr}            ;124
000104  2300              MOVS     r3,#0                 ;124
000106  461a              MOV      r2,r3                 ;124
000108  4619              MOV      r1,r3                 ;124
00010a  f7ffbffe          B.W      xQueueGenericSendFromISR
                  |L1.270|
00010e  2004              MOVS     r0,#4                 ;129
000110  f7fffffe          BL       ADC1_SetChannel
000114  70e6              STRB     r6,[r4,#3]            ;130
000116  2003              MOVS     r0,#3                 ;131
000118  7060              STRB     r0,[r4,#1]            ;131
00011a  bd70              POP      {r4-r6,pc}
                  |L1.284|
00011c  2904              CMP      r1,#4                 ;134
00011e  d204              BCS      |L1.298|
000120  f7fffffe          BL       ADC1_GetResult
000124  8921              LDRH     r1,[r4,#8]            ;135  ; adc_voltage_counts
000126  4408              ADD      r0,r0,r1              ;135
000128  8120              STRH     r0,[r4,#8]            ;135
                  |L1.298|
00012a  78e0              LDRB     r0,[r4,#3]            ;136  ; adc_counter
00012c  b128              CBZ      r0,|L1.314|
00012e  f7fffffe          BL       ADC1_Start
000132  78e0              LDRB     r0,[r4,#3]            ;139  ; adc_counter
000134  1e40              SUBS     r0,r0,#1              ;139
000136  70e0              STRB     r0,[r4,#3]            ;139
000138  bd70              POP      {r4-r6,pc}
                  |L1.314|
00013a  7065              STRB     r5,[r4,#1]            ;143
00013c  bd70              POP      {r4-r6,pc}
                  |L1.318|
00013e  2007              MOVS     r0,#7                 ;148
000140  f7fffffe          BL       ADC1_SetChannel
000144  70e6              STRB     r6,[r4,#3]            ;149
000146  2011              MOVS     r0,#0x11              ;150
000148  7060              STRB     r0,[r4,#1]            ;150
00014a  bd70              POP      {r4-r6,pc}
                  |L1.332|
00014c  2904              CMP      r1,#4                 ;153
00014e  d204              BCS      |L1.346|
000150  f7fffffe          BL       ADC1_GetResult
000154  8961              LDRH     r1,[r4,#0xa]          ;154  ; adc_current_counts
000156  4408              ADD      r0,r0,r1              ;154
000158  8160              STRH     r0,[r4,#0xa]          ;154
                  |L1.346|
00015a  f7fffffe          BL       ADC1_Start
00015e  78e0              LDRB     r0,[r4,#3]            ;156  ; adc_counter
000160  b128              CBZ      r0,|L1.366|
000162  f7fffffe          BL       ADC1_Start
000166  78e0              LDRB     r0,[r4,#3]            ;159  ; adc_counter
000168  1e40              SUBS     r0,r0,#1              ;159
00016a  70e0              STRB     r0,[r4,#3]            ;159
00016c  bd70              POP      {r4-r6,pc}
                  |L1.366|
00016e  7065              STRB     r5,[r4,#1]            ;163
000170  bd70              POP      {r4-r6,pc}
;;;187    
                          ENDP

000172  0000              DCW      0x0000
                  |L1.372|
                          DCD      ||.data||
                  |L1.376|
                          DCD      regulation_setting_p

                          AREA ||.data||, DATA, ALIGN=2

                  ctrl_ADCProcess
000000  00                DCB      0x00
                  state_ADCProcess
000001  00                DCB      0x00
                  adc_cmd
000002  00                DCB      0x00
                  adc_counter
000003  00                DCB      0x00
                  voltage_adc
000004  0000              DCB      0x00,0x00
                  current_adc
000006  0000              DCB      0x00,0x00
                  adc_voltage_counts
000008  0000              DCB      0x00,0x00
                  adc_current_counts
00000a  0000              DCB      0x00,0x00
                  power_adc
                          DCD      0x00000000
                  xQueueADC
                          DCD      0x00000000
                  xSemaphoreADC
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "src\\adc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_adc_c_vTaskADC____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_adc_c_vTaskADC____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_adc_c_vTaskADC____REVSH|
#line 130
|__asm___5_adc_c_vTaskADC____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
