L 1 "src\gui\guiCore\guiCore.c"
N/**********************************************************
N    Module guiCore
N
NWidget's event processing function calls:
N
NDirect:
N    guiCore_ProcessMessageQueue
N    guiCore_SetVisibleByTag
N    guiCore_BroadcastEvent
N    guiCore_RedrawAll
N    guiCore_UpdateAll (using guiCore_BroadcastEvent)
N
NThrough message queue:
N    guiCore_PostEventToFocused
N    guiCore_TimerProcess
N    guiCore_Init
N    guiCore_ProcessTouchEvent
N    guiCore_ProcessKeyEvent
N    guiCore_ProcessEncoderEvent
N    guiCore_ProcessTimers (using guiCore_TimerProcess)
N    guiCore_RequestFocusChange
N    guiCore_AcceptFocus
N    guiCore_RequestFocusNextWidget (using guiCore_RequestFocusChange)
N    guiCore_SetFocused (using guiCore_AcceptFocus)
N
N**********************************************************/
N
N#include <stdint.h>
L 1 "C:\Keil\ARM\RV31\Inc\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 137748 $
N * Checkin $Date: 2008-09-11 17:34:24 +0100 (Thu, 11 Sep 2008) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
L 29 "src\gui\guiCore\guiCore.c" 2
N#include "guiConfig.h"
L 1 ".\src\gui\guiConfig.h" 1
N#ifndef __GUI_CONFIG_H_
N#define __GUI_CONFIG_H_
N
N
N#define GUI_CORE_QUEUE_SIZE 20
N
N#define GUI_CFG_USE_TIMERS
N#define GUI_TIMER_COUNT 1
N#define TMR_TIME_UPDATE 0   // timer's name
N
N#define CFG_USE_UPDATE
N
N#define USE_Z_ORDER_REDRAW
N
N//#define ALWAYS_PASS_TOUCH_TO_FOCUSED
N
N//#define USE_TOUCH_SUPPORT
N
N
N
N#endif
L 30 "src\gui\guiCore\guiCore.c" 2
N#include "guiGraphWidgets.h"
L 1 ".\src\gui\guiGraphics\guiGraphWidgets.h" 1
N#ifndef __GUI_GRAPH_WIDGETS_
N#define __GUI_GRAPH_WIDGETS_
N
N#include <stdint.h>
N#include "guiGraphPrimitives.h"
L 1 ".\src\gui\guiGraphics\guiGraphPrimitives.h" 1
N#ifndef __GUI_GRAPH_PRIMITIVES_H_
N#define __GUI_GRAPH_PRIMITIVES_H_
N
N#include <stdint.h>
N#include "guiGraphHAL.h"
L 1 ".\src\gui\guiGraphics\guiGraphHAL.h" 1
N#ifndef __GUI_GRAPH_HAL_
N#define __GUI_GRAPH_HAL_
N
N#include <stdint.h>
N
N
N// Size definitions in points for Nokia 1202 LCD
N#define LCD_XSIZE (2*96)
N#define LCD_YSIZE 68
N
N// Buffer size in bytes
N#define LCD_BUFFER_SIZE (2*96*9)
N
N/*
N// Size definitions in points
N#define LCD_XSIZE (2*128)
N#define LCD_YSIZE 128
N
N// Buffer size in bytes
N#define LCD_BUFFER_SIZE (LCD_XSIZE * 16)
N*/
N
N// LCD functions settings
N//#define SOFT_HORIZ_REVERSED
N
N// counter increments from 0 to LCD_xxx_PERIOD-1
N// if counter < LCD_xxx_COMPARE, pixel is put unchaged
N// if counter >= LCD_xxx_COMPARE, pixel is put inversed
N#define LCD_DOT_PERIOD      4
N#define LCD_DOT_COMPARE     2
N#define LCD_DASH_PERIOD     7
N#define LCD_DASH_COMPARE    5
N
N
N
N
N// Pixel output modes
N#define PIXEL_MODE_REWRITE  0x00
N#define PIXEL_MODE_AND      0x01
N#define PIXEL_MODE_OR       0x02
N#define PIXEL_MODE_XOR      0x03
N
N// Image output modes
N#define IMAGE_MODE_NORMAL    0x01
N#define IMAGE_MODE_INVERSE   0x00
N// Aliases for fill rect
N#define FILL_WITH_BLACK      0x01
N#define FILL_WITH_WHITE      0x00
N
N#define LCD_FillRect(x_pos, y_pos, width, height, mode) \
N    LCD_DrawImage(0, x_pos, y_pos, width, height, mode)
X#define LCD_FillRect(x_pos, y_pos, width, height, mode)     LCD_DrawImage(0, x_pos, y_pos, width, height, mode)
N
N
N// Line drawing mode (not for all functions)
N#define LINE_STYLE_SOLID      0x10
N#define LINE_STYLE_DASHED     0x20
N#define LINE_STYLE_DOTTED     0x30
N
N
N
N
N
Nextern uint8_t lcdBuffer[LCD_BUFFER_SIZE];
Xextern uint8_t lcdBuffer[(2*96*9)];
Nextern uint8_t LCD_lineStyle;
N
Nvoid LCD_SetPixelOutputMode(uint8_t newMode);
Nvoid LCD_SetLineStyle(uint8_t newStyle);
N
Nvoid LCD_FillWholeBuffer(uint8_t pixelValue);
Nvoid LCD_PutPixel (uint8_t x_pos, uint8_t y_pos, uint8_t pixelValue);
Nvoid LCD_DrawHorLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t pixelValue);
Nvoid LCD_DrawVertLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t pixelValue);
N
Nvoid LCD_DrawImage(const uint8_t* img, uint8_t x_pos, uint8_t y_pos, uint8_t width, uint8_t height, uint8_t mode);
N
N
N#endif
L 6 ".\src\gui\guiGraphics\guiGraphPrimitives.h" 2
N#include "guiFonts.h"
L 1 ".\src\gui\guiGraphics\guiFonts.h" 1
N#ifndef __GUI_FONTS_H_
N#define __GUI_FONTS_H_
N
N#include <stdint.h>
N
N/*
N    A font may have all chars present, or only some subset of chars.
N    If a font has contiguous set of chars, starting with some char code,
N    it is indicated by setting charTable to 0 and defining firstCharCode value.
N    Field charCount tells how many chars the font has.
N    Accessing some char with char code c in this case is trivial and looks like this:
N        c -= font.firstCharCode;
N        char_data = font.data[c * font.bytesPerChar];
N    If a font has non-contiguous set of chars, their char codes are specified in codeTable,
N    and offset relative to font.data is specified in offsetTable.
N
N    A font may be monospaced or variable-spaced.
N    If a font is monospaced, widthTable must be set to 0. All chars will have the same width = font.width.
N    If font is variable-spaced, widthTable is used - it contains width for every char.
N
N    If font has non-contiguous set of chars, or font is variable-spaced, font processing routines need to know,
N    where particular char image is located. This information provides offsetTable.
N
N    So, a font can be one of the following:
N        - monospaced, char subset is contiguous:
N            codeTable:      -
N            widthTable:     -
N            offsetTable:    -
N        - monospaced, char subset is non-contiguous:
N            codeTable:      present
N            widthTable:     -
N            offsetTable:    present
N        - variable-spaced, char subset is contiguous:
N            codeTable:      -
N            widthTable:     present
N            offsetTable:    present
N        - variable-spaced, char subset is non-contiguous:
N            codeTable:      present
N            widthTable:     present
N            offsetTable:    present
N
N        Font MUST have valid offsetTable when codeTable or widthTable are used.
N*/
N
N
N//---------------------------------------------//
N// Fonts typedefs
N
Ntypedef struct 
N{
N    uint8_t height;                     // font chars height
N    uint8_t width;                      // actual for monospaced, ignored for variable-width fonts
N    uint8_t charCount;                  // Total number of chars in the font
N    uint8_t spacing;                    // Additional space between chars
N    uint8_t bytesPerChar;               // Actual for monospaced, ignored for variable-length fonts
N    uint8_t firstCharCode;              // Used if there is no charTable - specifies first avaliable char code in the font.
N    const uint8_t *codeTable;           // Used if not all symbols are prensent in the font. Otherwise must be 0.
N    const uint8_t *widthTable;          // Used if font is not monospaced. Otherwise must be 0.
N    const uint16_t *offsetTable;        // Used with codeTable or widthTable
N    const uint8_t *data;                // Font data - contiguous byte array
N} tFont;
N
N
Nextern const tFont font_h11;
Nextern const tFont font_h32;
Nextern const tFont font_h10;
Nextern const tFont font_h10_bold;
Nextern const tFont font_6x8_mono;
Nextern const tFont font_h16;
N
N
N#endif
L 7 ".\src\gui\guiGraphics\guiGraphPrimitives.h" 2
N
N// Align modes - required alignment mode is selected by
N// combining these flags
N#define ALIGN_CENTER    0x00
N#define ALIGN_LEFT      0x01
N#define ALIGN_RIGHT     0x02
N#define ALIGN_TOP       0x04
N#define ALIGN_BOTTOM    0x08
N// Aliases
N#define ALIGN_TOP_LEFT      (ALIGN_TOP | ALIGN_LEFT)
N#define ALIGN_BOTTOM_LEFT   (ALIGN_BOTTOM | ALIGN_LEFT)
N#define ALIGN_TOP_RIGHT     (ALIGN_TOP | ALIGN_RIGHT)
N#define ALIGN_BOTTOM_RIGHT   (ALIGN_BOTTOM | ALIGN_RIGHT)
N
N
Ntypedef struct {
N    uint8_t x1;
N    uint8_t y1;
N    uint8_t x2;
N    uint8_t y2;
N} rect_t;
N
N
Nextern const tFont* LCD_currentFont;
N
Nvoid LCD_SetFont(const tFont *newFont);
N
Nvoid LCD_DrawRect(uint8_t x_pos, uint8_t y_pos, uint8_t width, uint8_t height, uint8_t pixelValue);
Nuint8_t LCD_GetFontItem(const tFont *font, uint8_t code, uint8_t *width, uint16_t *offset);
Nvoid LCD_PrintString(char *str, uint8_t x, uint8_t y, uint8_t mode);
Nvoid LCD_PrintStringAligned(char *str, rect_t *rect, uint8_t alignment, uint8_t mode);
Nvoid LCD_DrawLine(int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint8_t mode);
N
N
N#endif
L 6 ".\src\gui\guiGraphics\guiGraphWidgets.h" 2
N#include "guiWidgets.h"
L 1 ".\src\gui\guiWidgets\guiWidgets.h" 1
N/**********************************************************
N    Module guiWidgets contains widget typedefs and
N  common data
N
N
N
N**********************************************************/
N
N#ifndef __GUI_WIDGETS_H_
N#define __GUI_WIDGETS_H_
N
N#include <stdint.h>
N#include "guiEvents.h"
L 1 ".\src\gui\guiCore\guiEvents.h" 1
N#ifndef __GUI_EVENTS_H_
N#define __GUI_EVENTS_H_
N
N#include <stdint.h>
N
N
N// Event types for widgets
N#define GUI_EVENT_DRAW          0x01
N#define GUI_EVENT_INIT          0x02
N#define GUI_EVENT_UPDATE        0x04
N#define GUI_EVENT_HIDE          0x06
N#define GUI_EVENT_SHOW          0x07
N#define GUI_EVENT_UNFOCUS       0x08
N#define GUI_EVENT_FOCUS         0x09
N#define GUI_EVENT_TOUCH         0x0A
N#define GUI_EVENT_KEY           0x0B
N#define GUI_EVENT_ENCODER       0x0C
N#define GUI_EVENT_TIMER         0x0D
N
N// Event types for callbacks (common widget event handlers)
N#define GUI_ON_FOCUS_CHANGED    0x80
N#define GUI_ON_VISIBLE_CHANGED  0x82
N#define GUI_ON_TOUCH_EVENT      0x83
N
N// Event types, specific for widgets start with 0xC0 and can overlap for different widgets.
N// Those types are declared in widget's header files.
N
N
N// Event struct, common for all GUI elements
Ntypedef struct {
N    uint8_t type;
N    uint8_t spec;
N    uint16_t lparam;
N    uint16_t hparam;
N} guiEvent_t;
N
N
N
N
N// Events are found in guiCore.c
Nextern const guiEvent_t guiEvent_DRAW;
Nextern const guiEvent_t guiEvent_DRAW_ALL;
Nextern const guiEvent_t guiEvent_SELECT;
Nextern const guiEvent_t guiEvent_DESELECT;
Nextern const guiEvent_t guiEvent_UPDATE;
Nextern const guiEvent_t guiEvent_HIDE;
Nextern const guiEvent_t guiEvent_SHOW;
N
N
N
N#endif
L 14 ".\src\gui\guiWidgets\guiWidgets.h" 2
N#include "guiFonts.h"
N
N
N// Widget types
N#define WT_PANEL       0x01
N#define WT_BUTTON      0x02
N#define WT_CHECKBOX    0x03
N#define WT_RADIOBUTTON 0x04
N#define WT_TEXTLABEL   0x05
N#define WT_SPINBOX     0x06
N
N
N
N
N// Event handler record
Ntypedef struct {
N    uint8_t eventType;                                         // Event type
N    uint8_t (*handler)(void *sender, guiEvent_t *event);       // Related callback function pointer
N} guiWidgetHandler_t;
N
N// Event handlers table
Ntypedef struct {
N    uint8_t count;                      // Count of handler records
N    guiWidgetHandler_t *elements;       // Pointer to array of handler records
N} guiHandlerTable_t;
N
N// Widget collection type - used by containers
Ntypedef struct {
N    uint8_t count;
N    uint8_t focusedIndex;
N    uint8_t traverseIndex;              // Required by core for tree traverse
N    void **elements;
N} guiWidgetCollection_t;
N
N
N
N// Basic widget type - all widget types MUST have all fields in their typedef beginning
Ntypedef struct guiGenericWidget_t {
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;     // If set, widget will be sent UPDATE event.
N                                    //   Update mechanism can be used for widget's
N                                    //   internal state processing - cursor blink, etc
N    uint8_t redrawRequired : 1;     // If this flag is set, widget will be sent DRAW event.
N                                    //   Widget should set this flag itself.
N    uint8_t redrawForced : 1;       // This flag is set by GUI core when widget must be redrawn
N                                    //   redrawRequired is set along with redrawForced.
N    uint8_t redrawFocus : 1;        // Flag is set when widget focus must be redrawn.
N                                    //   redrawRequired is set along with redrawFocus.
N    uint8_t showFocus : 1;          // If set, widget will display focus
N    uint8_t keepTouch : 1;          // Flags is set if widget requires all touch events
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N} guiGenericWidget_t;
N
N
N// Basic container type - extends guiGenericWidget_t
Ntypedef struct guiGenericContainer_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    guiWidgetCollection_t widgets;
N
N} guiGenericContainer_t;
N
N
N
Ntypedef struct guiPanel_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    guiWidgetCollection_t widgets;
N    uint8_t focusFallsThrough : 1;
N    uint8_t frame : 3;
N    // uint8_t focusIsKeptOnChilds : 1;      // doesn't let unfocus child widgets when focusFallsThrough is set. CHECKME
N
N} guiPanel_t;
N
N
N
Ntypedef struct guiTextLabel_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    char *text;
N    const tFont *font;
N    uint8_t textAlignment;
N    uint8_t hasFrame : 1;
N    uint8_t redrawText : 1;
N
N} guiTextLabel_t;
N
N
Ntypedef struct guiCheckBox_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    char *text;
N    const tFont *font;
N    uint8_t textAlignment;
N    uint8_t hasFrame : 1;
N    uint8_t isChecked : 1;
N    uint8_t redrawCheckedState : 1;
N
N} guiCheckBox_t;
N
N
Ntypedef struct guiButton_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    char *text;
N    const tFont *font;
N    uint8_t textAlignment;
N    uint8_t redrawPressedState : 1;
N    uint8_t isPressed : 1;
N    uint8_t isToggle : 1;
N    uint8_t isPressOnly : 1;
N
N} guiButton_t;
N
N
N
Ntypedef struct guiRadioButton_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    char *text;
N    const tFont *font;
N    uint8_t textAlignment;
N    uint8_t redrawCheckedState : 1;
N    uint8_t radioIndex;
N    uint8_t isChecked : 1;
N
N
N} guiRadioButton_t;
N
N#define SPINBOX_STRING_LENGTH  12  // long enough to hold INT32_MAX and INT32_MIN + \0
Ntypedef struct guiSpinBox_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    //char text[SPINBOX_STRING_LENGTH];
N    const tFont *font;
N    //uint8_t textAlignment;
N    uint8_t hasFrame : 1;
N    uint8_t redrawValue : 1;
N    uint8_t redrawDigitSelection : 1;
N    uint8_t isActive : 1;
N    uint8_t restoreValueOnEscape : 1;
N    uint8_t newValueAccepted : 1;
N    uint8_t minDigitsToDisplay;
N    uint8_t activeDigit;
N    int8_t dotPosition;
N    int32_t value;
N    int32_t savedValue;
N    int32_t maxValue;
N    int32_t minValue;
N    char text[SPINBOX_STRING_LENGTH];
X    char text[12];
N    uint8_t digitsToDisplay;
N    int8_t textRightOffset;
N    int8_t textTopOffset;
N
N
N
N} guiSpinBox_t;
N
N
N
N
N
N#endif
L 7 ".\src\gui\guiGraphics\guiGraphWidgets.h" 2
N
N
N
N#define FRAME_NONE                      0x00
N#define FRAME3D_RAISED                  0x01
N#define FRAME3D_SUNKEN                  0x02
N#define FRAME_SINGLE                    0x03
N
N
N// Widget Appearance
N
N//---------------------------------------------//
N// Checkbox
N#define CHECKBOX_GRAPH_XSIZE  10
N#define CHECKBOX_GRAPH_YSIZE  10
N#define CHECKBOX_TEXT_MARGIN  6
N#define CHECKBOX_IMG_CHECKED  checkbox_10x10_checked
N#define CHECKBOX_IMG_EMPTY  checkbox_10x10_empty
N
N
N//---------------------------------------------//
N// Textlabel
N#define TEXT_LABEL_TEXT_MARGIN  0
N
N
N//---------------------------------------------//
N// SpinBox
N#define SPINBOX_ACTIVE_UNDERLINE_MARGIN 1
N#define SPINBOX_ACTIVE_UNDERLINE_WIDTH 2
N
N
N
N
Nextern int16_t wx;
Nextern int16_t wy;
N
Nvoid guiGraph_SetBaseXY(int16_t x, int16_t y);
Nvoid guiGraph_OffsetBaseXY(int16_t dx, int16_t dy);
N
N
Nvoid guiGraph_DrawPanel(guiPanel_t *panel);
Nvoid guiGraph_DrawTextLabel(guiTextLabel_t *textLabel);
Nvoid guiGraph_DrawCheckBox(guiCheckBox_t * checkBox);
Nvoid guiGraph_DrawSpinBox(guiSpinBox_t * spinBox);
N
N
N
N#endif
L 31 "src\gui\guiCore\guiCore.c" 2
N#include "guiEvents.h"
N#include "guiWidgets.h"
N#include "guiCore.h"
L 1 "src\gui\guiCore\guiCore.h" 1
N#ifndef __GUI_CORE_H_
N#define __GUI_CORE_H_
N
N#include <stdint.h>
N#include "guiConfig.h"
N#include "guiEvents.h"
N#include "guiWidgets.h"
N
N
Ntypedef struct {
N    guiGenericWidget_t *target;
N    guiEvent_t event;
N} guiMsg_t;
N
Ntypedef struct {
N    uint8_t head;
N    uint8_t tail;
N    uint8_t count;
N    guiMsg_t queue[GUI_CORE_QUEUE_SIZE];
X    guiMsg_t queue[20];
N} guiMsgQueue_t;
N
N
Ntypedef struct {
N    int16_t x1;
N    int16_t y1;
N    int16_t x2;
N    int16_t y2;
N} rect16_t;
N
N
N// Event process function result
N#define GUI_EVENT_DECLINE       0x00
N#define GUI_EVENT_ACCEPTED      0x01
N
N// Set visible by tag mode
N#define ITEMS_IN_RANGE_ARE_VISIBLE          0x01
N#define ITEMS_IN_RANGE_ARE_INVISIBLE        0x02
N#define ITEMS_OUT_OF_RANGE_ARE_VISIBLE      0x04
N#define ITEMS_OUT_OF_RANGE_ARE_INVISIBLE    0x08
N
N// Check tabIndex result
N#define TABINDEX_IS_MAX     2
N#define TABINDEX_IS_MIN     1
N#define TABINDEX_IS_NORM    0
N
N
N
N//-----------------------------------//
N// Keyboard support
N
N// Keyboard codes are design-specific and should be defined in
N// one of top-level modules
N
N// Key event specifications
N#define GUI_KEY_EVENT_DOWN   0x01        // A key has been pressed
N#define GUI_KEY_EVENT_UP     0x02        // A key has been released
N
N// Button codes
N#define GUI_KEY_ESC     0x01
N#define GUI_KEY_OK      0x02
N#define GUI_KEY_LEFT    0x03
N#define GUI_KEY_RIGHT   0x04
N#define GUI_KEY_UP      0x05
N#define GUI_KEY_DOWN    0x06
N#define GUI_KEY_ENCODER 0x07
N
N
N//-----------------------------------//
N// Touch support
N
N// Touch states
N#define TOUCH_PRESS     (1<<0)
N#define TOUCH_RELEASE   (1<<1)
N#define TOUCH_MOVE      (1<<2)
N
N// Decoded touch arguments for a widget
Ntypedef struct {
N    int16_t x;                  // X - coordinate, relative to widget
N    int16_t y;                  // Y - coordinate, relative to widget
N    uint8_t state;              // Touch state
N    uint8_t isInsideWidget;     // Set if touch point lies inside widget
N} widgetTouchState_t;
N
N// Decoded touch arguments for a container
Ntypedef struct {
N    int16_t x;                          // X - coordinate, relative to widget
N    int16_t y;                          // Y - coordinate, relative to widget
N    uint8_t state;                      // Touch state
N    guiGenericWidget_t *widgetAtXY;     // Widget under touch point
N} containerTouchState_t;
N
N
N//-----------------------------------//
N// Timers
N
Ntypedef struct {
N    uint16_t top;
N    uint16_t counter;
N    uint8_t runOnce : 1;
N    uint8_t isEnabled : 1;
N    guiGenericWidget_t *targetWidget;
N    void (*handler)(uint8_t id);
N} guiTimer_t;
N
N
N// Modifying these pointers should be done with care!
Nextern guiGenericWidget_t *rootWidget;         // Root widget must be present
Nextern guiGenericWidget_t *focusedWidget;      // Focused widget gets events from keys/encoder/touch
N
N//===================================================================//
N//                 GUI core message queue functions
N//===================================================================//
Nuint8_t guiCore_AddMessageToQueue(const guiGenericWidget_t *target, const guiEvent_t *event);
Nuint8_t guiCore_GetMessageFromQueue(guiGenericWidget_t **target, guiEvent_t *event);
Nvoid guiCore_ProcessMessageQueue(void);
Nvoid guiCore_PostEventToFocused(guiEvent_t event);
N
N//===================================================================//
N//                      GUI core timers functions
N//===================================================================//
Nvoid guiCore_TimerInit(uint8_t timerID, uint16_t period, uint8_t runOnce, guiGenericWidget_t *target, void (*handler)(uint8_t));
Nvoid guiCore_TimerStart(uint8_t timerID, uint8_t doReset);
Nvoid guiCore_TimerStop(uint8_t timerID, uint8_t doReset);
Nvoid guiCore_TimerProcess(uint8_t timerID);
N
N//===================================================================//
N//                      Top GUI core functions
N//===================================================================//
Nvoid guiCore_Init(guiGenericWidget_t *guiRootWidget);
Nvoid guiCore_RedrawAll(void);
Nvoid guiCore_ProcessTouchEvent(int16_t x, int16_t y, uint8_t touchState);
Nvoid guiCore_ProcessKeyEvent(uint16_t code, uint8_t spec);
Nvoid guiCore_ProcessEncoderEvent(int16_t increment);
Nvoid guiCore_ProcessTimers(void);
Nvoid guiCore_BroadcastEvent(guiEvent_t event, uint8_t(*validator)(guiGenericWidget_t *widget));
Nvoid guiCore_UpdateAll(void);
Nuint8_t guiCore_UpdateValidator(guiGenericWidget_t *widget);
N
N
N//===================================================================//
N//                    Drawing and touch support                      //
N//                       geometry functions                          //
N//===================================================================//
Nvoid guiCore_InvalidateRect(guiGenericWidget_t *widget, int16_t x1, int16_t y1, uint16_t x2, uint16_t y2);
Nuint8_t guiCore_CheckWidgetOvelap(guiGenericWidget_t *widget, rect16_t *rect);
Nvoid guiCore_ConvertToAbsoluteXY(guiGenericWidget_t *widget, int16_t *x, int16_t *y);
Nvoid guiCore_ConvertToRelativeXY(guiGenericWidget_t *widget, int16_t *x, int16_t *y);
NguiGenericWidget_t *guiCore_GetTouchedWidgetAtXY(guiGenericWidget_t *widget, int16_t x, int16_t y);
N
N//===================================================================//
N//                   Widget collections management                   //
N//===================================================================//
Nvoid guiCore_RequestFocusChange(guiGenericWidget_t *newFocusedWidget);
Nvoid guiCore_AcceptFocus(guiGenericWidget_t *widget);
Nvoid guiCore_RequestFocusNextWidget(guiGenericContainer_t *container, int8_t tabDir);
Nuint8_t guiCore_GetWidgetIndex(guiGenericWidget_t *widget);
Nuint8_t guiCore_CheckWidgetTabIndex(guiGenericWidget_t *widget);
N
N//===================================================================//
N//                   General widget API fucntions                    //
N//===================================================================//
Nuint8_t guiCore_SetVisible(guiGenericWidget_t *widget, uint8_t newVisibleState);
Nuint8_t guiCore_SetFocused(guiGenericWidget_t *widget, uint8_t newFocusedState);
Nvoid guiCore_SetVisibleByTag(guiWidgetCollection_t *collection, uint8_t minTag, uint8_t maxTag, uint8_t mode);
Nuint8_t guiCore_CallEventHandler(guiGenericWidget_t *widget, guiEvent_t *event);
Nvoid guiCore_DecodeWidgetTouchEvent(guiGenericWidget_t *widget, guiEvent_t *touchEvent, widgetTouchState_t *decodedTouchState);
Nvoid guiCore_DecodeContainerTouchEvent(guiGenericWidget_t *widget, guiEvent_t *touchEvent, containerTouchState_t *decodedTouchState);
N
N
N
N#endif
L 34 "src\gui\guiCore\guiCore.c" 2
N
N
N// Predefined constant events - saves stack a bit
Nconst guiEvent_t guiEvent_INIT = {GUI_EVENT_INIT, 0, 0, 0};
Xconst guiEvent_t guiEvent_INIT = {0x02, 0, 0, 0};
Nconst guiEvent_t guiEvent_DRAW = {GUI_EVENT_DRAW, 0, 0, 0};
Xconst guiEvent_t guiEvent_DRAW = {0x01, 0, 0, 0};
N#ifdef CFG_USE_UPDATE
Nconst guiEvent_t guiEvent_UPDATE = {GUI_EVENT_UPDATE, 0, 0, 0};
Xconst guiEvent_t guiEvent_UPDATE = {0x04, 0, 0, 0};
N#endif
Nconst guiEvent_t guiEvent_HIDE = {GUI_EVENT_HIDE, 0, 0, 0};
Xconst guiEvent_t guiEvent_HIDE = {0x06, 0, 0, 0};
Nconst guiEvent_t guiEvent_SHOW = {GUI_EVENT_SHOW, 0, 0, 0};
Xconst guiEvent_t guiEvent_SHOW = {0x07, 0, 0, 0};
Nconst guiEvent_t guiEvent_UNFOCUS = {GUI_EVENT_UNFOCUS, 0, 0, 0};
Xconst guiEvent_t guiEvent_UNFOCUS = {0x08, 0, 0, 0};
Nconst guiEvent_t guiEvent_FOCUS = {GUI_EVENT_FOCUS, 0, 0, 0};
Xconst guiEvent_t guiEvent_FOCUS = {0x09, 0, 0, 0};
N
N#ifdef GUI_CFG_USE_TIMERS
N// Total count of timers should be defined in guiConfig.h
NguiTimer_t guiTimers[GUI_TIMER_COUNT];
XguiTimer_t guiTimers[1];
N#endif
N
NguiMsgQueue_t guiMsgQueue;
NguiGenericWidget_t *rootWidget;         // Root widget must be present
NguiGenericWidget_t *focusedWidget;      // Focused widget gets events from keys/encoder/touch
N
N
N
N
N//===================================================================//
N//===================================================================//
N//                                                                   //
N//                 GUI core message queue functions                  //
N//                                                                   //
N//===================================================================//
N
N
N//-------------------------------------------------------//
N//  Adds a message to GUI core message queue
N//
N//  Returns 0 if there is no space left
N//  Returns non-zero if message has been put
N//-------------------------------------------------------//
Nuint8_t guiCore_AddMessageToQueue(const guiGenericWidget_t *target, const guiEvent_t *event)
N{
N    if (guiMsgQueue.count < GUI_CORE_QUEUE_SIZE)
X    if (guiMsgQueue.count < 20)
N    {
N        guiMsgQueue.queue[guiMsgQueue.tail].event = *event;
N        guiMsgQueue.queue[guiMsgQueue.tail].target = (guiGenericWidget_t *)target;
N        guiMsgQueue.count++;
N        guiMsgQueue.tail++;
N        if (guiMsgQueue.tail == GUI_CORE_QUEUE_SIZE)
X        if (guiMsgQueue.tail == 20)
N            guiMsgQueue.tail = 0;
N        return 1;
N     }
N    return 0;
N}
N
N//-------------------------------------------------------//
N//  Reads a message from GUI core message queue
N//
N//  Returns 0 if queue is empty
N//  Returns non-zero if message has been read
N//-------------------------------------------------------//
Nuint8_t guiCore_GetMessageFromQueue(guiGenericWidget_t **target, guiEvent_t *event)
N{
N    if (guiMsgQueue.count > 0)
N    {
N        *target = guiMsgQueue.queue[guiMsgQueue.head].target;
N        *event = guiMsgQueue.queue[guiMsgQueue.head].event;
N        guiMsgQueue.count--;
N        guiMsgQueue.head++;
N        if (guiMsgQueue.head == GUI_CORE_QUEUE_SIZE)
X        if (guiMsgQueue.head == 20)
N            guiMsgQueue.head = 0;
N        return 1;
N    }
N    return 0;
N}
N
N
N//-------------------------------------------------------//
N//  GUI core function for processing message queue
N//
N// Generally, if message target widget cannot process
N// event, message is sent to it's parent and so on
N// until it is accepted or root widget is sent the message
N// If root cannot process this message, it is lost.
N//-------------------------------------------------------//
Nvoid guiCore_ProcessMessageQueue(void)
N{
N    guiGenericWidget_t *target;
N    guiEvent_t targetEvent;
N    uint8_t processResult;
N
N    while(guiCore_GetMessageFromQueue(&target,&targetEvent))
N    {
N        while(1)
N        {
N            if (target == 0)
N                break;
N            processResult = target->processEvent(target, targetEvent);
N            if (processResult == GUI_EVENT_ACCEPTED)
X            if (processResult == 0x01)
N                break;
N            // Focused widget cannot process event - pass event to parent
N            if (target->parent != 0)
N            {
N                target = target->parent;
N            }
N            else
N            {
N                // No widget can process this event - skip it.
N                break;
N            }
N        }
N    }
N}
N
N
N
N//-------------------------------------------------------//
N//  Adds message for focused widget to message queue
N//
N//-------------------------------------------------------//
Nvoid guiCore_PostEventToFocused(guiEvent_t event)
N{
N    if (focusedWidget == 0)
N        return;                 // Should not normally happen ?
N    guiCore_AddMessageToQueue(focusedWidget, &event);
N}
N
N
N
N
N
N//===================================================================//
N//===================================================================//
N//                                                                   //
N//                      GUI core timers functions                    //
N//                                                                   //
N//===================================================================//
N
N
N#ifdef GUI_CFG_USE_TIMERS
N//-------------------------------------------------------//
N//  Initializes GUI core timer
N//  Timer is identified by timerID which is simply index
N//  of element in guiTimers[]
N//
N//-------------------------------------------------------//
Nvoid guiCore_TimerInit(uint8_t timerID, uint16_t period, uint8_t runOnce, guiGenericWidget_t *target, void (*handler)(uint8_t))
N{
N    if (timerID >= GUI_TIMER_COUNT)
X    if (timerID >= 1)
N        return;
N    guiTimers[timerID].top = period;
N    guiTimers[timerID].counter = 0;
N    guiTimers[timerID].runOnce = (runOnce) ? 1 : 0;
N    guiTimers[timerID].isEnabled = 0;
N    guiTimers[timerID].targetWidget = target;
N    guiTimers[timerID].handler = handler;
N}
N
N//-------------------------------------------------------//
N//  Starts GUI core timer
N//  Timer is identified by timerID which is simply index
N//  of element in guiTimers[]
N//
N//  If doReset is non-zero, timer will be set to 0
N//-------------------------------------------------------//
Nvoid guiCore_TimerStart(uint8_t timerID, uint8_t doReset)
N{
N    if (timerID >= GUI_TIMER_COUNT)
X    if (timerID >= 1)
N        return;
N    if (doReset)
N        guiTimers[timerID].counter = 0;
N    guiTimers[timerID].isEnabled = 1;
N}
N
N//-------------------------------------------------------//
N//  Stops GUI core timer
N//  Timer is identified by timerID which is simply index
N//  of element in guiTimers[]
N//
N//  If doReset is non-zero, timer will be set to 0
N//-------------------------------------------------------//
Nvoid guiCore_TimerStop(uint8_t timerID, uint8_t doReset)
N{
N    if (timerID >= GUI_TIMER_COUNT)
X    if (timerID >= 1)
N        return;
N    if (doReset)
N        guiTimers[timerID].counter = 0;
N    guiTimers[timerID].isEnabled = 0;
N}
N
N//-------------------------------------------------------//
N//  Processes GUI core timer
N//  Timer is identified by timerID which is simply index
N//  of element in guiTimers[]
N//
N//  Timer's counter is incremented. If counter has reached
N//  top, in is reset and timer event is sent to the target widget
N//  Additionaly, handler is called (if specified)
N//-------------------------------------------------------//
Nvoid guiCore_TimerProcess(uint8_t timerID)
N{
N    guiEvent_t event = {GUI_EVENT_TIMER, 0, 0, 0};
X    guiEvent_t event = {0x0D, 0, 0, 0};
N    if (timerID >= GUI_TIMER_COUNT)
X    if (timerID >= 1)
N        return;
N    if (guiTimers[timerID].isEnabled)
N    {
N        guiTimers[timerID].counter++;
N        if (guiTimers[timerID].counter >= guiTimers[timerID].top)
N        {
N            guiTimers[timerID].counter = 0;
N            if (guiTimers[timerID].runOnce)
N                guiTimers[timerID].isEnabled = 0;
N            if (guiTimers[timerID].targetWidget != 0)
N            {
N                event.spec = timerID;
N                guiCore_AddMessageToQueue(guiTimers[timerID].targetWidget, &event);
N            }
N            if (guiTimers[timerID].handler != 0)
N                guiTimers[timerID].handler(timerID);
N        }
N    }
N}
N#endif
N
N
N
N
N
N//===================================================================//
N//===================================================================//
N//                                                                   //
N//                      Top GUI core functions                       //
N//                                                                   //
N//===================================================================//
N
N
N
N
N//-------------------------------------------------------//
N//  Top function for GUI core initializing
N//  All components must be already initialized
N//-------------------------------------------------------//
Nvoid guiCore_Init(guiGenericWidget_t *guiRootWidget)
N{
N    uint8_t i;
N    // Init queue
N    guiMsgQueue.count = 0;
N    guiMsgQueue.head = 0;
N    guiMsgQueue.tail = 0;
N
N#ifdef GUI_CFG_USE_TIMERS
N    // Disable all timers
N    for (i=0; i<GUI_TIMER_COUNT; i++)
X    for (i=0; i<1; i++)
N    {
N        guiTimers[i].isEnabled = 0;
N    }
N#endif
N
N    // Set root and focused widget and send initialize event
N    // Root widget must set focus in itself or other widget
N    // depending on design. If focus is not set, no keyboard
N    // and encoder events will get processed.
N    rootWidget = guiRootWidget;
N    focusedWidget = 0;
N    guiCore_AddMessageToQueue(rootWidget, &guiEvent_INIT);
N    guiCore_ProcessMessageQueue();
N}
N
N
N
N//-------------------------------------------------------//
N//  Top function for GUI redrawing
N//
N//-------------------------------------------------------//
Nvoid guiCore_RedrawAll(void)
N{
N    guiGenericWidget_t *widget;
N    guiGenericWidget_t *nextWidget;
N    uint8_t index;
N
N    guiGenericWidget_t *w;
N    uint8_t i;
N    rect16_t inv_rect;
N
N    // Start widget tree traverse from root widget
N    widget = rootWidget;
N    guiGraph_SetBaseXY(widget->x, widget->y);
N
N    while(1)
N    {
N        // Process widget
N        if (widget->redrawRequired)
N        {
N            // The redrawRequired flag is reset by widget after processing DRAW event
N            widget->processEvent(widget, guiEvent_DRAW);
N        }
N        // Check if widget has children
N        if (widget->isContainer)
N        {
N            if (((guiGenericContainer_t *)widget)->widgets.traverseIndex == 0)
N            {
N                // The first time visit
N                // TODO - set graph clipping
N            }
N
N            // If container has unprocessed children
N            if ( ((guiGenericContainer_t *)widget)->widgets.traverseIndex <
N                 ((guiGenericContainer_t *)widget)->widgets.count )
N            {
N                // switch to next one if possible
N                index = ((guiGenericContainer_t *)widget)->widgets.traverseIndex++;
N                nextWidget = ((guiGenericContainer_t *)widget)->widgets.elements[index];
N                // check if widget actually exists and is visible
N                if ((nextWidget == 0) || (nextWidget->isVisible == 0))
N                    continue;
N                // Check if widget must be redrawn forcibly
N                if (widget->redrawForced)
N                {
N                    nextWidget->redrawForced = 1;
N                    nextWidget->redrawRequired = 1;
N                }
N                ///////////////////////////
N#ifdef USE_Z_ORDER_REDRAW
N                if ((widget->redrawForced == 0) &&(nextWidget->redrawRequired))
N                {
N                    // Widget will be redrawn - make overlapping widgets with higher Z index redraw too
N                    inv_rect.x1 = nextWidget->x;
N                    inv_rect.y1 = nextWidget->y;
N                    inv_rect.x2 = nextWidget->x + nextWidget->width - 1;
N                    inv_rect.y2 = nextWidget->y + nextWidget->height - 1;
N                    for (i = index+1; i < ((guiGenericContainer_t *)widget)->widgets.count; i++)
N                    {
N                        w = ((guiGenericContainer_t *)widget)->widgets.elements[i];
N                        if ((w != 0) && (w->isVisible))
N                        {
N                            if (guiCore_CheckWidgetOvelap(w, &inv_rect))
N                            {
N                                w->redrawForced = 1;
N                                w->redrawRequired = 1;
N                            }
N                        }
N                    }
N                }
N#endif
N                ///////////////////////////
N                if ((nextWidget->redrawRequired) || (nextWidget->isContainer))
N                {
N                    widget = nextWidget;
N                    guiGraph_OffsetBaseXY(widget->x, widget->y);
N                }
N            }
N            else
N            {
N                // All container child items are processed. Reset counter of processed items and move up.
N                ((guiGenericContainer_t *)widget)->widgets.traverseIndex = 0;
N                widget->redrawForced = 0;
N                if (widget->parent == 0)    // root widget has no parent
N                    break;
N                else
N                {
N                    guiGraph_OffsetBaseXY(-widget->x, -widget->y);
N                    widget = widget->parent;
N                }
N            }
N        }
N        else
N        {
N            // Widget has no children. Move up.
N            widget->redrawForced = 0;
N            guiGraph_OffsetBaseXY(-widget->x, -widget->y);
N            widget = widget->parent;
N        }
N    }
N}
N
N
N//-------------------------------------------------------//
N//  Top function for touchscreen processing
N//  x and y are absolute coordinates
N//  touchState values are defined in guiCore.h
N//-------------------------------------------------------//
Nvoid guiCore_ProcessTouchEvent(int16_t x, int16_t y, uint8_t touchState)
N{
N    guiEvent_t event;
N    event.type = GUI_EVENT_TOUCH;
X    event.type = 0x0A;
N    event.spec = touchState;
N    event.lparam = (uint16_t)x;
N    event.hparam = (uint16_t)y;
N#ifdef ALWAYS_PASS_TOUCH_TO_FOCUSED
S    guiCore_AddMessageToQueue(focusedWidget, &event);
N#else
N    if ((focusedWidget != 0) && (focusedWidget->keepTouch))
N        guiCore_AddMessageToQueue(focusedWidget, &event);
N    else
N        guiCore_AddMessageToQueue(rootWidget, &event);
N#endif
N    guiCore_ProcessMessageQueue();
N}
N
N//-------------------------------------------------------//
N//  Top function for processing keys
N//  default keys and specificators are defined in guiCore.h
N//-------------------------------------------------------//
Nvoid guiCore_ProcessKeyEvent(uint16_t code, uint8_t spec)
N{
N    guiEvent_t event;
N    event.type = GUI_EVENT_KEY;
X    event.type = 0x0B;
N    event.spec = spec;
N    event.lparam = code;
N    guiCore_AddMessageToQueue(focusedWidget, &event);
N    guiCore_ProcessMessageQueue();
N}
N
N//-------------------------------------------------------//
N//  Top function for processing encoder
N//
N//-------------------------------------------------------//
Nvoid guiCore_ProcessEncoderEvent(int16_t increment)
N{
N    guiEvent_t event;
N    event.type = GUI_EVENT_ENCODER;
X    event.type = 0x0C;
N    event.spec = 0;
N    event.lparam = (uint16_t)increment;
N    guiCore_AddMessageToQueue(focusedWidget, &event);
N    guiCore_ProcessMessageQueue();
N}
N
N//-------------------------------------------------------//
N//  Top function for processing timers
N//
N//-------------------------------------------------------//
Nvoid guiCore_ProcessTimers(void)
N{
N    uint8_t i;
N    for (i=0; i<GUI_TIMER_COUNT; i++)
X    for (i=0; i<1; i++)
N    {
N        guiCore_TimerProcess(i);
N    }
N    guiCore_ProcessMessageQueue();
N}
N
N
N
N//-------------------------------------------------------//
N//  Sends event to all GUI elements for which validator
N//  returns non-zero
N//
N//  guiCore_ProcessMessageQueue() should be called after
N//  this function.
N//  GUI message queue should be long enough - depending
N//  on particular case
N//-------------------------------------------------------//
Nvoid guiCore_BroadcastEvent(guiEvent_t event, uint8_t(*validator)(guiGenericWidget_t *widget))
N{
N    guiGenericWidget_t *widget;
N    guiGenericWidget_t *nextWidget;
N    uint8_t index;
N
N    // Start widget tree traverse from root widget
N    widget = rootWidget;
N
N    while(1)
N    {
N        // Check if widget has children
N        if (widget->isContainer)
N        {
N            if (((guiGenericContainer_t *)widget)->widgets.traverseIndex == 0)
N            {
N                // The first time visit
N                if (validator(widget))
N                {
N                    widget->processEvent(widget, event);
N                }
N            }
N
N            // If container has unprocessed children
N            if ( ((guiGenericContainer_t *)widget)->widgets.traverseIndex <
N                 ((guiGenericContainer_t *)widget)->widgets.count )
N            {
N                // switch to next one if possible
N                index = ((guiGenericContainer_t *)widget)->widgets.traverseIndex++;
N                nextWidget = ((guiGenericContainer_t *)widget)->widgets.elements[index];
N                // check if widget actually exists
N                if ((nextWidget == 0))
N                    continue;
N                widget = nextWidget;
N            }
N            else
N            {
N                // All container child items are processed. Reset counter of processed items and move up.
N                ((guiGenericContainer_t *)widget)->widgets.traverseIndex = 0;
N                if (widget->parent == 0)    // root widget has no parent
N                    break;
N                else
N                    widget = widget->parent;
N            }
N        }
N        else
N        {
N            // Widget has no children. Move up.
N            if (validator(widget))
N            {
N                // The redrawRequired flag is reset by widget after processing DRAW event
N                widget->processEvent(widget, event);
N            }
N            widget = widget->parent;
N        }
N    }
N}
N
N#ifdef CFG_USE_UPDATE
N//-------------------------------------------------------//
N//  Top function for GUI elements update
N//
N//-------------------------------------------------------//
Nvoid guiCore_UpdateAll(void)
N{
N    guiCore_BroadcastEvent(guiEvent_UPDATE, guiCore_UpdateValidator);
N    guiCore_ProcessMessageQueue();
N}
N
N
N//-------------------------------------------------------//
N//  Returns true if widget requires update
N//
N//-------------------------------------------------------//
Nuint8_t guiCore_UpdateValidator(guiGenericWidget_t *widget)
N{
N    if ((widget == 0) || (widget->updateRequired == 0))
N        return 0;
N    else
N        return 1;
N}
N#endif
N
N
N
N
N//===================================================================//
N//===================================================================//
N//                                                                   //
N//                    Drawing and touch support                      //
N//                       geometry functions                          //
N//                                                                   //
N//===================================================================//
N
N
N//-------------------------------------------------------//
N// Makes specified rectangle invalid - it must be redrawn
N// Rectangle coordinates are relative to widget's.
N// When calling this function, widget should set it's
N// redraw flags itself.
N//-------------------------------------------------------//
Nvoid guiCore_InvalidateRect(guiGenericWidget_t *widget, int16_t x1, int16_t y1, uint16_t x2, uint16_t y2)
N{
N    /*
N        Approach 1:
N            Add this rectangle to the list of invalidated rectangles of thew form.
N            Redrawing will be split into two stages:
N                a.  Traverse whole widget tree and find for each container if it intercepts with any of the rectangles.
N                    If there is some interseption, mark the container to fully redraw it and it's content if rectangle is
N                    not an exact widget.
N                    For each widget in the container also check interseption with the rectangles and mark those
N                    who has interception.
N                b.  Add marked widgets and containers to redraw list. Sort list by Z-index and redraw every widget.
N        Approach 2:
N            Check if the rectangle lies on the parent widget completely. If so, mark parent to be redrawn and exit.
N            If rectangle spands over the parent's borders, check the same for parent's parent and so on, until
N            root widget is reached - i.e. propagate up the tree.
N
N        If using Z-order, possibly put all form widgets into single array?
N    */
N
N
N    while (1)
N    {
N        if (widget->parent == 0)    // root widget has no parent
N            break;
N
N        // Convert rectangle into parent's coordinates
N        x1 += widget->x;
N        x2 += widget->x;
N        y1 += widget->y;
N        y2 += widget->y;
N
N        // Move up the tree
N        widget = widget->parent;
N
N        // Make parent widget redraw
N        widget->redrawRequired = 1;
N        widget->redrawForced = 1;
N
N        // Check if rectangle lies inside parent
N        if ( (x1 >= 0) &&
N             (y1 >= 0) &&
N             (x2 < widget->width) &&
N             (y2 < widget->height) )
N        {
N            break;
N        }
N    }
N}
N
N
N
N//-------------------------------------------------------//
N//  Verifies if widget and rectangle are overlapped
N//
N//  Returns true if interseption is not null.
N//-------------------------------------------------------//
Nuint8_t guiCore_CheckWidgetOvelap(guiGenericWidget_t *widget, rect16_t *rect)
N{
N    if ((rect->x2 - rect->x1 <= 0) || (rect->y2 - rect->y1 <= 0))
N        return 0;
N    if ( (rect->x2 < widget->x) ||
N         (rect->y2 < widget->y) ||
N         (rect->x1 > widget->x + widget->width - 1) ||
N         (rect->y1 > widget->y + widget->height - 1) )
N        return 0;
N    else
N        return 1;
N}
N
N
N
N//-------------------------------------------------------//
N//  Converts relative (x,y) for a specified widget to
N//    absolute values (absolute means relative to screen's (0,0))
N//
N//-------------------------------------------------------//
Nvoid guiCore_ConvertToAbsoluteXY(guiGenericWidget_t *widget, int16_t *x, int16_t *y)
N{
N    while(widget != 0)
N    {
N        // Convert XY into parent's coordinates
N        *x += widget->x;
N        *y += widget->y;
N
N        // Move up the tree
N        widget = widget->parent;
N    }
N}
N
N//-------------------------------------------------------//
N//  Converts absolute (x,y) to relative for a specified widget
N//     values (absolute means relative to screen's (0,0))
N//
N//-------------------------------------------------------//
Nvoid guiCore_ConvertToRelativeXY(guiGenericWidget_t *widget, int16_t *x, int16_t *y)
N{
N    while(widget != 0)
N    {
N        // Convert XY into parent's coordinates
N        *x -= widget->x;
N        *y -= widget->y;
N
N        // Move up the tree
N        widget = widget->parent;
N    }
N}
N
N
N//-------------------------------------------------------//
N// Returns widget that has point (x;y) and can be touched -
N//  either one of child widgets or widget itself.
N// If widget is not visible, or not enabled, it is skipped.
N// If no widget is found, 0 is returned
N// X and Y parameters must be relative to container
N//-------------------------------------------------------//
NguiGenericWidget_t *guiCore_GetTouchedWidgetAtXY(guiGenericWidget_t *widget, int16_t x, int16_t y)
N{
N    guiGenericWidget_t *w;
N    uint8_t i;
N
N    // First check if point lies inside widget
N    if ((x < 0) || (x >= widget->width))
N        return 0;
N    if ((y < 0) || (y >= widget->height))
N        return 0;
N
N    if (widget->isContainer)
N    {
N        // Point is inside container or one of it's widgets. Find out which one.
N        i = ((guiGenericContainer_t *)widget)->widgets.count - 1;
N        do
N        {
N            w = ((guiGenericContainer_t *)widget)->widgets.elements[i];
N            if (w == 0)
N                continue;
N            if ((w->acceptTouch) && (w->isVisible))   // TODO - add isEnabled, etc
N            {
N                if ((x >= w->x) && (x < w->x + w->width) &&
N                    (y >= w->y) && (y < w->y + w->height))
N                {
N                    return w;
N                }
N            }
N        } while(i--);
N    }
N    // Not found - return widget itself
N    return widget;
N}
N
N
N
N
N
N
N
N//===================================================================//
N//===================================================================//
N//                                                                   //
N//                   Widget collections management                   //
N//                                                                   //
N//===================================================================//
N
N
N
N
N//-------------------------------------------------------//
N// Adds to queue focus message for newFocusedWidget
N//
N//-------------------------------------------------------//
Nvoid guiCore_RequestFocusChange(guiGenericWidget_t *newFocusedWidget)
N{
N    // Tell new widget to get focus
N    if ((newFocusedWidget != focusedWidget) && (newFocusedWidget != 0))
N    {
N        guiCore_AddMessageToQueue(newFocusedWidget, &guiEvent_FOCUS);
N    }
N}
N
N//-------------------------------------------------------//
N// Sets GUI core focusedWidget pointer to widget
N// This function should be called by a widget when it
N// receives FOCUS message and agrees with it.
N//-------------------------------------------------------//
Nvoid guiCore_AcceptFocus(guiGenericWidget_t *widget)
N{
N    uint8_t index;
N    if ((widget != 0) && (widget != focusedWidget))     // CHECKME
N    {
N        // First tell currently focused widget to loose focus
N        if (focusedWidget != 0)
N        {
N            guiCore_AddMessageToQueue(focusedWidget, &guiEvent_UNFOCUS);
N        }
N        focusedWidget = widget;
N        if ((guiGenericContainer_t *)widget->parent != 0)
N        {
N            // Store index for container
N            index = guiCore_GetWidgetIndex(focusedWidget);
N            ((guiGenericContainer_t *)widget->parent)->widgets.focusedIndex = index;
N        }
N    }
N}
N
N
N//-------------------------------------------------------//
N//  Pass focus to next widget in collection
N//
N//-------------------------------------------------------//
Nvoid guiCore_RequestFocusNextWidget(guiGenericContainer_t *container, int8_t tabDir)
N{
N    uint8_t currentTabIndex;
N    uint8_t i;
N    int16_t minTabIndex = 0x200;   // maximum x2
N    int16_t tmp;
N    uint8_t minWidgetIndex = container->widgets.count;
N    guiGenericWidget_t *widget;
N
N    currentTabIndex = 0;
N
N    // Check if current widget belongs to specified container's collection
N    if (focusedWidget)
N    {
N        if (focusedWidget->parent == (guiGenericWidget_t *)container)
N            currentTabIndex = focusedWidget->tabIndex;
N    }
N
N
N    // Find widget with next tabIndex
N    for (i = 0; i < container->widgets.count; i++)
N    {
N        widget = (guiGenericWidget_t *)container->widgets.elements[i];
N        if (widget == 0)
N            continue;
N        if ((widget->acceptFocusByTab) && (widget->isVisible))
N        {
N            if (tabDir >= 0)
N                tmp = (widget->tabIndex <= currentTabIndex) ? widget->tabIndex + 256 : widget->tabIndex;
N            else
N                tmp = (widget->tabIndex >= currentTabIndex) ? -(widget->tabIndex - 256) : -widget->tabIndex;
N
N            if (tmp < minTabIndex)
N            {
N                minTabIndex = tmp;
N                minWidgetIndex = i;
N            }
N        }
N    }
N
N    if (minWidgetIndex < container->widgets.count)
N    {
N        widget = container->widgets.elements[minWidgetIndex];
N        //container->widgets.focusedIndex = minWidgetIndex;
N        guiCore_RequestFocusChange(widget);
N    }
N}
N
N
N//-------------------------------------------------------//
N// Returns index of a widget in parent's collection
N//
N//-------------------------------------------------------//
Nuint8_t guiCore_GetWidgetIndex(guiGenericWidget_t *widget)
N{
N    uint8_t i;
N    if ((widget == 0) || (widget->parent == 0))
N        return 0;
N    for (i = 0; i < ((guiGenericContainer_t *)widget->parent)->widgets.count; i++)
N    {
N        if (((guiGenericContainer_t *)widget->parent)->widgets.elements[i] == widget)
N            return i;
N    }
N    return 0;   // error - widget is not present in parent's collection
N}
N
N
N//-------------------------------------------------------//
N// Checks widget's tabindex in parent's collection.
N// If current widget is the last in the collection that can be focused,
N//      TABINDEX_IS_MAX is returned.
N// If current widget is the first in the collection that can be focused,
N//      TABINDEX_IS_MIN is returned.
N// Else TABINDEX_IS_NORM is returned.
N//-------------------------------------------------------//
Nuint8_t guiCore_CheckWidgetTabIndex(guiGenericWidget_t *widget)
N{
N    // TODO - add canBeFocused() function
N    uint8_t i;
N    uint8_t currTabIndex;
N    uint8_t maxTabIndex;
N    uint8_t minTabIndex;
N    guiGenericWidget_t *w;
N    if (widget == 0) return 0;
N
N    currTabIndex = widget->tabIndex;
N    maxTabIndex = currTabIndex;
N    minTabIndex = currTabIndex;
N
N    for (i = 0; i < ((guiGenericContainer_t *)widget->parent)->widgets.count; i++)
N    {
N        w = ((guiGenericContainer_t *)widget->parent)->widgets.elements[i];
N        if (w == 0) continue;
N        if ((w->acceptFocusByTab == 0) || (w->isVisible == 0)) continue;    // TODO - add isEnabled
N        if (w->tabIndex > widget->tabIndex)
N            maxTabIndex = w->tabIndex;
N        else if (w->tabIndex < widget->tabIndex)
N            minTabIndex = w->tabIndex;
N    }
N
N    if (currTabIndex == maxTabIndex)
N        return TABINDEX_IS_MAX;
X        return 2;
N    if (currTabIndex == minTabIndex)
N        return TABINDEX_IS_MIN;
X        return 1;
N
N    return TABINDEX_IS_NORM;
X    return 0;
N}
N
N
N
N
N
N//===================================================================//
N//===================================================================//
N//                                                                   //
N//                   General widget API fucntions                    //
N//                                                                   //
N//===================================================================//
N
N
N
N//-------------------------------------------------------//
N//  Shows or hides a widget.
N//  This function should be called by widget as response for
N//      received SHOW or HIDE message
N//
N// This function does not perform any widget state checks
N//      except visible state.
N// Returns 1 if new state was applied. Otherwise returns 0.
N//-------------------------------------------------------//
Nuint8_t guiCore_SetVisible(guiGenericWidget_t *widget, uint8_t newVisibleState)
N{
N    guiEvent_t event;
N    if (widget == 0) return 0;
N    if (newVisibleState)
N    {
N        // Show widget
N        if (widget->isVisible) return 0;
N        widget->isVisible = 1;
N        widget->redrawForced = 1;
N    }
N    else
N    {
N        // Hide widget
N        if (widget->isVisible == 0) return 0;
N        widget->isVisible = 0;
N        guiCore_InvalidateRect(widget, widget->x, widget->y,
N              widget->x + widget->width - 1, widget->y + widget->height - 1);
N    }
N    // Visible state changed - call handler
N    if (widget->handlers.count != 0)
N    {
N        event.type = GUI_ON_VISIBLE_CHANGED;
X        event.type = 0x82;
N        guiCore_CallEventHandler(widget, &event);
N    }
N    return 1;
N}
N
N
N
N//-------------------------------------------------------//
N//  Sets or clears focus on widget.
N//  This function should be called by widget as response for
N//      received FOCUS or UNFOCUS message
N//
N// This function does not perform any widget state checks
N//      except focused state.
N// Returns 1 if new state was applied. Otherwise returns 0.
N//-------------------------------------------------------//
Nuint8_t guiCore_SetFocused(guiGenericWidget_t *widget, uint8_t newFocusedState)
N{
N    guiEvent_t event;
N    if (widget == 0) return 0;
N
N    if (newFocusedState)
N    {
N        // Set focus on widget
N        if (widget->isFocused) return 0;
N        widget->isFocused = 1;
N        guiCore_AcceptFocus(widget);
N    }
N    else
N    {
N        // Focus was removed
N        if (widget->isFocused == 0) return 0;
N        widget->isFocused = 0;
N    }
N    // Focused state changed - call handler
N    //if (widget->showFocus)        // CHECKME
N    //{
N        widget->redrawFocus = 1;
N        widget->redrawRequired = 1;
N    //}
N    // Focus state changed - call handler
N    if (widget->handlers.count != 0)
N    {
N        event.type = GUI_ON_FOCUS_CHANGED;
X        event.type = 0x80;
N        guiCore_CallEventHandler(widget, &event);
N    }
N    return 1;
N}
N
N//-------------------------------------------------------//
N//  Shows or hides widgets in a collection
N//
N//  Affected widgets are sent message directly, bypassing queue.
N//  guiCore_ProcessMessageQueue() should be called after this function
N//  to process posted messages from callbacks or handlers
N//
N//  Widgets are affected using mode paramenter:
N//      ITEMS_IN_RANGE_ARE_VISIBLE
N//      ITEMS_IN_RANGE_ARE_INVISIBLE
N//      ITEMS_OUT_OF_RANGE_ARE_VISIBLE
N//      ITEMS_OUT_OF_RANGE_ARE_INVISIBLE
N//  mode can be any combination of these constants
N//-------------------------------------------------------//
Nvoid guiCore_SetVisibleByTag(guiWidgetCollection_t *collection, uint8_t minTag, uint8_t maxTag, uint8_t mode)
N{
N    uint8_t i;
N    uint8_t tagInRange;
N    guiGenericWidget_t *widget;
N    for(i=0; i<collection->count; i++)
N    {
N        widget = (guiGenericWidget_t *)collection->elements[i];
N        if (widget == 0)
N            continue;
N        tagInRange = ((widget->tag >= minTag) && (widget->tag <= maxTag)) ? mode & 0x3 : mode & 0xC;
N        if ((tagInRange == ITEMS_IN_RANGE_ARE_VISIBLE) || (tagInRange == ITEMS_OUT_OF_RANGE_ARE_VISIBLE))
X        if ((tagInRange == 0x01) || (tagInRange == 0x04))
N        {
N            if (widget->isVisible == 0)
N                widget->processEvent(widget, guiEvent_SHOW);
N                //guiCore_AddMessageToQueue(widget, &guiEvent_SHOW);
N        }
N        else if ((tagInRange == ITEMS_IN_RANGE_ARE_INVISIBLE) || (tagInRange == ITEMS_OUT_OF_RANGE_ARE_INVISIBLE))
X        else if ((tagInRange == 0x02) || (tagInRange == 0x08))
N        {
N            if (widget->isVisible)
N                widget->processEvent(widget, guiEvent_HIDE);
N                //guiCore_AddMessageToQueue(widget, &guiEvent_HIDE);
N        }
N    }
N}
N
N
N//-------------------------------------------------------//
N//  Call widget's handler for an event
N//
N//  Function searches through the widget's handler table
N//  and call handlers for matching event type
N//-------------------------------------------------------//
Nuint8_t guiCore_CallEventHandler(guiGenericWidget_t *widget, guiEvent_t *event)
N{
N    uint8_t i;
N    uint8_t handlerResult = GUI_EVENT_DECLINE;
X    uint8_t handlerResult = 0x00;
N    for(i=0; i<widget->handlers.count; i++)
N    {
N        if (widget->handlers.elements[i].eventType == event->type)
N        {
N            handlerResult = widget->handlers.elements[i].handler(widget, event);
N        }
N    }
N    return handlerResult;
N}
N
N
N
Nvoid guiCore_DecodeWidgetTouchEvent(guiGenericWidget_t *widget, guiEvent_t *touchEvent, widgetTouchState_t *decodedTouchState)
N{
N    // Convert coordinates to widget's relative
N    decodedTouchState->x = (int16_t)touchEvent->lparam;
N    decodedTouchState->y = (int16_t)touchEvent->hparam;
N    guiCore_ConvertToRelativeXY(widget,&decodedTouchState->x, &decodedTouchState->y);
N    decodedTouchState->state = touchEvent->spec;
N    // Determine if touch point lies inside the widget
N    decodedTouchState->isInsideWidget = (guiCore_GetTouchedWidgetAtXY(widget,decodedTouchState->x, decodedTouchState->y)) ? 1 : 0;
N}
N
N
Nvoid guiCore_DecodeContainerTouchEvent(guiGenericWidget_t *widget, guiEvent_t *touchEvent, containerTouchState_t *decodedTouchState)
N{
N    // Convert coordinates to widget's relative
N    decodedTouchState->x = (int16_t)touchEvent->lparam;
N    decodedTouchState->y = (int16_t)touchEvent->hparam;
N    guiCore_ConvertToRelativeXY(widget,&decodedTouchState->x, &decodedTouchState->y);
N    decodedTouchState->state = touchEvent->spec;
N    // Determine if touch point lies inside the widget
N    decodedTouchState->widgetAtXY = guiCore_GetTouchedWidgetAtXY(widget,decodedTouchState->x, decodedTouchState->y);
N}
N
N
N
N
N
N
N
