; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\systemfunc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\systemfunc.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\systemfunc.crf src\systemfunc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Setup_CPU_Clock PROC
;;;43     //-----------------------------------------------------------------//
;;;44     void Setup_CPU_Clock(void)
000000  b510              PUSH     {r4,lr}
;;;45     {
;;;46     	// Enable HSE
;;;47     	RST_CLK_HSEconfig(RST_CLK_HSE_ON);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       RST_CLK_HSEconfig
;;;48     	if (RST_CLK_HSEstatus() != SUCCESS)
000008  f7fffffe          BL       RST_CLK_HSEstatus
00000c  2801              CMP      r0,#1
00000e  d000              BEQ      |L1.18|
                  |L1.16|
;;;49     	{
;;;50     		while (1) {}	// Trap
000010  e7fe              B        |L1.16|
                  |L1.18|
;;;51     	}
;;;52     	
;;;53     	//-------------------------------//
;;;54     	// Setup CPU PLL and CPU_C1_SEL
;;;55     	// CPU_C1 = HSE,	PLL = x8
;;;56     	RST_CLK_CPU_PLLconfig(RST_CLK_CPU_PLLsrcHSEdiv1, RST_CLK_CPU_PLLmul8);
000012  2107              MOVS     r1,#7
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       RST_CLK_CPU_PLLconfig
;;;57     	RST_CLK_CPU_PLLcmd(ENABLE);
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       RST_CLK_CPU_PLLcmd
;;;58     	if (RST_CLK_CPU_PLLstatus() != SUCCESS)
000020  f7fffffe          BL       RST_CLK_CPU_PLLstatus
000024  2801              CMP      r0,#1
000026  d000              BEQ      |L1.42|
                  |L1.40|
;;;59     	{
;;;60     		while (1) {}	// Trap
000028  e7fe              B        |L1.40|
                  |L1.42|
;;;61     	}
;;;62     	// Setup CPU_C2 and CPU_C3
;;;63     	// CPU_C3 = CPU_C2
;;;64     	RST_CLK_CPUclkPrescaler(RST_CLK_CPUclkDIV1);
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       RST_CLK_CPUclkPrescaler
;;;65     	// CPU_C2 = CPU PLL output
;;;66     	RST_CLK_CPU_PLLuse(ENABLE);
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       RST_CLK_CPU_PLLuse
;;;67     	// Switch to CPU_C3
;;;68     	// HCLK = CPU_C3
;;;69     	RST_CLK_CPUclkSelection(RST_CLK_CPUclkCPU_C3);
000036  f44f7080          MOV      r0,#0x100
00003a  f7fffffe          BL       RST_CLK_CPUclkSelection
;;;70     	
;;;71     	//-------------------------------//
;;;72     	// Setup ADC clock
;;;73     	// ADC_C2 = CPU_C1
;;;74     	RST_CLK_ADCclkSelection(RST_CLK_ADCclkCPU_C1);
00003e  2020              MOVS     r0,#0x20
000040  f7fffffe          BL       RST_CLK_ADCclkSelection
;;;75     	// ADC_C3 = ADC_C2
;;;76     	RST_CLK_ADCclkPrescaler(RST_CLK_ADCclkDIV1);
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       RST_CLK_ADCclkPrescaler
;;;77     	// Enable ADC_CLK
;;;78     	RST_CLK_ADCclkEnable(ENABLE);
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       RST_CLK_ADCclkEnable
;;;79     	
;;;80     	// Update system clock variable
;;;81     	SystemCoreClockUpdate();
000050  f7fffffe          BL       SystemCoreClockUpdate
;;;82     	
;;;83     	// Enable clock on all ports (macro are defined in systemfunc.h)
;;;84     	RST_CLK_PCLKcmd(ALL_PORTS_CLK, ENABLE);
000054  2101              MOVS     r1,#1
000056  48fb              LDR      r0,|L1.1092|
000058  f7fffffe          BL       RST_CLK_PCLKcmd
;;;85     	// Enable clock on peripheral blocks used in design
;;;86     	RST_CLK_PCLKcmd(PERIPHERALS_CLK ,ENABLE);
00005c  e8bd4010          POP      {r4,lr}
000060  2101              MOVS     r1,#1
000062  48f9              LDR      r0,|L1.1096|
000064  f7ffbffe          B.W      RST_CLK_PCLKcmd
;;;87     }
;;;88     
                          ENDP

                  HW_PortInit PROC
;;;93     //-----------------------------------------------------------------//
;;;94     void HW_PortInit(void)
000068  e92d4ffe          PUSH     {r1-r11,lr}
;;;95     {
;;;96     	PORT_InitTypeDef PORT_InitStructure;
;;;97       
;;;98     	
;;;99     	PORT_DeInit(MDR_PORTA);
00006c  f8dfb3dc          LDR      r11,|L1.1100|
000070  4658              MOV      r0,r11
000072  f7fffffe          BL       PORT_DeInit
;;;100    	PORT_DeInit(MDR_PORTB);
000076  48f6              LDR      r0,|L1.1104|
000078  f7fffffe          BL       PORT_DeInit
;;;101    	PORT_DeInit(MDR_PORTC);
00007c  48f5              LDR      r0,|L1.1108|
00007e  f7fffffe          BL       PORT_DeInit
;;;102    	PORT_DeInit(MDR_PORTD);
000082  48f5              LDR      r0,|L1.1112|
000084  f7fffffe          BL       PORT_DeInit
;;;103    	PORT_DeInit(MDR_PORTE);
000088  48f4              LDR      r0,|L1.1116|
00008a  f7fffffe          BL       PORT_DeInit
;;;104    	PORT_DeInit(MDR_PORTF);
00008e  48f4              LDR      r0,|L1.1120|
000090  f7fffffe          BL       PORT_DeInit
;;;105    	
;;;106    	// default output value is 0
;;;107    	// Set some outputs the default design values of 1
;;;108    	//PORT_SetBits(MDR_PORTA, (1<<BUZ1) | (1<<BUZ2) );
;;;109    	PORT_SetBits(MDR_PORTB, (1<<LGREEN) | (1<<LRED) );
000094  21c0              MOVS     r1,#0xc0
000096  48ee              LDR      r0,|L1.1104|
000098  f7fffffe          BL       PORT_SetBits
;;;110    	
;;;111    	/*
;;;112    	   Reset PORT initialization structure parameters values 
;;;113      PORT_InitStruct->PORT_Pin        = PORT_Pin_All;
;;;114      PORT_InitStruct->PORT_OE         = PORT_OE_IN;
;;;115      PORT_InitStruct->PORT_PULL_UP    = PORT_PULL_UP_OFF;
;;;116      PORT_InitStruct->PORT_PULL_DOWN  = PORT_PULL_DOWN_OFF;
;;;117      PORT_InitStruct->PORT_PD_SHM     = PORT_PD_SHM_OFF;
;;;118      PORT_InitStruct->PORT_PD         = PORT_PD_DRIVER;
;;;119      PORT_InitStruct->PORT_GFEN       = PORT_GFEN_OFF;
;;;120      PORT_InitStruct->PORT_FUNC       = PORT_FUNC_PORT;
;;;121      PORT_InitStruct->PORT_SPEED      = PORT_OUTPUT_OFF;
;;;122      PORT_InitStruct->PORT_MODE       = PORT_MODE_ANALOG;
;;;123    	*/
;;;124    	
;;;125    	//================= PORTA =================//
;;;126    	PORT_StructInit(&PORT_InitStructure);
00009c  4668              MOV      r0,sp
00009e  f7fffffe          BL       PORT_StructInit
;;;127    	
;;;128    	// Typical digital inputs:
;;;129    	PORT_InitStructure.PORT_Pin   = (1<<OVERLD) | (1<<ENC_BTN);
0000a2  2021              MOVS     r0,#0x21
0000a4  f8ad0000          STRH     r0,[sp,#0]
;;;130    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
0000a8  2401              MOVS     r4,#1
0000aa  f88d400a          STRB     r4,[sp,#0xa]
;;;131    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0000ae  4669              MOV      r1,sp
0000b0  4658              MOV      r0,r11
0000b2  f7fffffe          BL       PORT_Init
;;;132    	
;;;133    	// Digital input with pull-up
;;;134    	PORT_InitStructure.PORT_Pin   = (1<<EEN);
0000b6  f04f0904          MOV      r9,#4
0000ba  f8ad9000          STRH     r9,[sp,#0]
;;;135    	PORT_InitStructure.PORT_PULL_UP  = PORT_PULL_UP_ON;
0000be  f88d4003          STRB     r4,[sp,#3]
;;;136    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0000c2  4669              MOV      r1,sp
0000c4  4658              MOV      r0,r11
0000c6  f7fffffe          BL       PORT_Init
;;;137    	
;;;138    	// Typical digital outputs:
;;;139    	PORT_InitStructure.PORT_Pin   = (1<<CLIM_SEL);
0000ca  2502              MOVS     r5,#2
0000cc  f8ad5000          STRH     r5,[sp,#0]
;;;140    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
0000d0  f88d4002          STRB     r4,[sp,#2]
;;;141    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
0000d4  f88d4009          STRB     r4,[sp,#9]
;;;142    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0000d8  4669              MOV      r1,sp
0000da  4658              MOV      r0,r11
0000dc  f7fffffe          BL       PORT_Init
;;;143    	
;;;144    	// Timer outputs to buzzer (TMR1.CH2, TMR1.CH2N)
;;;145    	PORT_InitStructure.PORT_Pin   = (1<<BUZ1) | (1<<BUZ2);
0000e0  2018              MOVS     r0,#0x18
0000e2  f8ad0000          STRH     r0,[sp,#0]
;;;146    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
0000e6  f88d5008          STRB     r5,[sp,#8]
;;;147    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0000ea  4669              MOV      r1,sp
0000ec  4658              MOV      r0,r11
0000ee  f7fffffe          BL       PORT_Init
;;;148    	
;;;149    	// USART1 pins	
;;;150    	PORT_StructInit(&PORT_InitStructure);
0000f2  4668              MOV      r0,sp
0000f4  f7fffffe          BL       PORT_StructInit
;;;151    	// TX pin
;;;152    	PORT_InitStructure.PORT_Pin   = 1<<TXD1;
0000f8  f04f0a80          MOV      r10,#0x80
0000fc  f8ada000          STRH     r10,[sp,#0]
;;;153    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
000100  f88d400a          STRB     r4,[sp,#0xa]
;;;154    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
000104  f88d5009          STRB     r5,[sp,#9]
;;;155    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_OVERRID;
000108  2603              MOVS     r6,#3
00010a  f88d6008          STRB     r6,[sp,#8]
;;;156    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
00010e  f88d4002          STRB     r4,[sp,#2]
;;;157    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
000112  4669              MOV      r1,sp
000114  4658              MOV      r0,r11
000116  f7fffffe          BL       PORT_Init
;;;158    	// RX pin
;;;159    	PORT_InitStructure.PORT_Pin   = 1<<RXD1;
00011a  2740              MOVS     r7,#0x40
00011c  f8ad7000          STRH     r7,[sp,#0]
;;;160    	PORT_InitStructure.PORT_OE    = PORT_OE_IN;
000120  f04f0800          MOV      r8,#0
000124  f88d8002          STRB     r8,[sp,#2]
;;;161    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
000128  4669              MOV      r1,sp
00012a  4658              MOV      r0,r11
00012c  f7fffffe          BL       PORT_Init
;;;162    	
;;;163    	// debug
;;;164    /*	PORT_StructInit(&PORT_InitStructure);
;;;165    	PORT_InitStructure.PORT_Pin   = (1<<TXD1) | (1<<RXD1);
;;;166    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
;;;167    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
;;;168    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
;;;169    	PORT_Init(MDR_PORTA, &PORT_InitStructure); */
;;;170    
;;;171    	//================= PORTB =================//
;;;172    	PORT_StructInit(&PORT_InitStructure);
000130  4668              MOV      r0,sp
000132  f7fffffe          BL       PORT_StructInit
;;;173    	
;;;174    	// Typical digital inputs: buttons and encoder
;;;175    	PORT_InitStructure.PORT_Pin   = (1<<SB_ESC) | (1<<SB_LEFT) | (1<<SB_RIGHT) | (1<<SB_OK) | (1<<SB_MODE) | (1<<ENCA) | (1<<ENCB) | (1<<PG) ;
000136  f2407037          MOV      r0,#0x737
00013a  f8ad0000          STRH     r0,[sp,#0]
;;;176    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
00013e  f88d400a          STRB     r4,[sp,#0xa]
;;;177    	PORT_Init(MDR_PORTB, &PORT_InitStructure);
000142  4669              MOV      r1,sp
000144  48c2              LDR      r0,|L1.1104|
000146  f7fffffe          BL       PORT_Init
;;;178    	
;;;179    	// Power good 
;;;180    	// TODO: add interrupt
;;;181    	PORT_InitStructure.PORT_Pin   = (1<<PG) ;
00014a  02a0              LSLS     r0,r4,#10
00014c  f8ad0000          STRH     r0,[sp,#0]
;;;182    	PORT_Init(MDR_PORTB, &PORT_InitStructure);
000150  4669              MOV      r1,sp
000152  48bf              LDR      r0,|L1.1104|
000154  f7fffffe          BL       PORT_Init
;;;183    	
;;;184    	// Leds and buttons SB_ON, SB_OFF
;;;185    	PORT_InitStructure.PORT_Pin   = (1<<LGREEN) | (1<<LRED);
000158  20c0              MOVS     r0,#0xc0
00015a  f8ad0000          STRH     r0,[sp,#0]
;;;186    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
00015e  f88d4002          STRB     r4,[sp,#2]
;;;187    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
000162  f88d4009          STRB     r4,[sp,#9]
;;;188    	PORT_Init(MDR_PORTB, &PORT_InitStructure);
000166  4669              MOV      r1,sp
000168  48b9              LDR      r0,|L1.1104|
00016a  f7fffffe          BL       PORT_Init
;;;189    
;;;190    	
;;;191    	//================= PORTC =================//
;;;192    	PORT_StructInit(&PORT_InitStructure);
00016e  4668              MOV      r0,sp
000170  f7fffffe          BL       PORT_StructInit
;;;193    	
;;;194    	// LCD Backlight (TMR3.CH1)
;;;195    	PORT_InitStructure.PORT_Pin   = (1<<LCD_BL);
000174  f8ad9000          STRH     r9,[sp,#0]
;;;196    	PORT_InitStructure.PORT_MODE = PORT_MODE_DIGITAL;
000178  f88d400a          STRB     r4,[sp,#0xa]
;;;197    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
00017c  f88d5008          STRB     r5,[sp,#8]
;;;198    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
000180  f88d4009          STRB     r4,[sp,#9]
;;;199    	PORT_Init(MDR_PORTC, &PORT_InitStructure);
000184  4669              MOV      r1,sp
000186  48b3              LDR      r0,|L1.1108|
000188  f7fffffe          BL       PORT_Init
;;;200    	
;;;201    	// I2C
;;;202    	PORT_InitStructure.PORT_Pin = (1<<SCL) | (1<<SDA);
00018c  f8ad6000          STRH     r6,[sp,#0]
;;;203    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
000190  f88d5009          STRB     r5,[sp,#9]
;;;204    	PORT_Init(MDR_PORTC, &PORT_InitStructure);
000194  4669              MOV      r1,sp
000196  48af              LDR      r0,|L1.1108|
000198  f7fffffe          BL       PORT_Init
;;;205    	
;;;206    	
;;;207    	//================= PORTD =================//
;;;208    	PORT_StructInit(&PORT_InitStructure);
00019c  4668              MOV      r0,sp
00019e  f7fffffe          BL       PORT_StructInit
;;;209    	
;;;210    	// Analog functions
;;;211    	PORT_InitStructure.PORT_Pin   = (1<<VREF_P) | (1<<VREF_N) | (1<<TEMP_IN) | (1<<UADC) | (1<<IADC) ;
0001a2  2097              MOVS     r0,#0x97
0001a4  f8ad0000          STRH     r0,[sp,#0]
;;;212    	PORT_Init(MDR_PORTD, &PORT_InitStructure);
0001a8  4669              MOV      r1,sp
0001aa  48ab              LDR      r0,|L1.1112|
0001ac  f7fffffe          BL       PORT_Init
;;;213    	
;;;214    	// LCD CLK and CS
;;;215    	PORT_InitStructure.PORT_Pin   = (1<<LCD_CLK) | (1<<LCD_CS) ;
0001b0  2028              MOVS     r0,#0x28
0001b2  f8ad0000          STRH     r0,[sp,#0]
;;;216    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
0001b6  f88d400a          STRB     r4,[sp,#0xa]
;;;217    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
0001ba  f88d5008          STRB     r5,[sp,#8]
;;;218    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
0001be  f88d5009          STRB     r5,[sp,#9]
;;;219    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
0001c2  f88d4002          STRB     r4,[sp,#2]
;;;220    	PORT_Init(MDR_PORTD, &PORT_InitStructure);
0001c6  4669              MOV      r1,sp
0001c8  48a3              LDR      r0,|L1.1112|
0001ca  f7fffffe          BL       PORT_Init
;;;221    	
;;;222    	// MOSI 
;;;223    	PORT_InitStructure.PORT_Pin   = (1<<LCD_MOSI);
0001ce  f8ad7000          STRH     r7,[sp,#0]
;;;224    	PORT_InitStructure.PORT_PULL_DOWN = PORT_PULL_DOWN_ON;
0001d2  f88d4004          STRB     r4,[sp,#4]
;;;225    	PORT_Init(MDR_PORTD, &PORT_InitStructure);
0001d6  4669              MOV      r1,sp
0001d8  489f              LDR      r0,|L1.1112|
0001da  f7fffffe          BL       PORT_Init
;;;226    	
;;;227    
;;;228    	
;;;229    	//================= PORTE =================//
;;;230    	PORT_StructInit(&PORT_InitStructure);
0001de  4668              MOV      r0,sp
0001e0  f7fffffe          BL       PORT_StructInit
;;;231    			
;;;232    	// LCD RST and SEL, Load disable output
;;;233    	PORT_InitStructure.PORT_Pin   = (1<<LCD_RST) | (1<<LCD_SEL) | (1<<LDIS);
0001e4  2045              MOVS     r0,#0x45
0001e6  f8ad0000          STRH     r0,[sp,#0]
;;;234    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
0001ea  f88d400a          STRB     r4,[sp,#0xa]
;;;235    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
0001ee  f88d5009          STRB     r5,[sp,#9]
;;;236    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
0001f2  f88d4002          STRB     r4,[sp,#2]
;;;237    	PORT_Init(MDR_PORTE, &PORT_InitStructure);
0001f6  4669              MOV      r1,sp
0001f8  4898              LDR      r0,|L1.1116|
0001fa  f7fffffe          BL       PORT_Init
;;;238    
;;;239    	// cooler PWM output (TMR3.CH3N)
;;;240    	PORT_InitStructure.PORT_Pin   = (1<<CPWM);
0001fe  f8ada000          STRH     r10,[sp,#0]
;;;241    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_OVERRID;
000202  f88d6008          STRB     r6,[sp,#8]
;;;242    	PORT_Init(MDR_PORTE, &PORT_InitStructure);
000206  4669              MOV      r1,sp
000208  4894              LDR      r0,|L1.1116|
00020a  f7fffffe          BL       PORT_Init
;;;243    	
;;;244    	// voltage and current PWM outputs (TMR2.CH1N, TMR2.CH3N)
;;;245    	PORT_InitStructure.PORT_Pin   = (1<<UPWM) | (1<<IPWM);
00020e  200a              MOVS     r0,#0xa
000210  f8ad0000          STRH     r0,[sp,#0]
;;;246    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
000214  f88d5008          STRB     r5,[sp,#8]
;;;247    	PORT_Init(MDR_PORTE, &PORT_InitStructure);
000218  4669              MOV      r1,sp
00021a  4890              LDR      r0,|L1.1116|
00021c  f7fffffe          BL       PORT_Init
;;;248    	
;;;249    	
;;;250    	
;;;251    	//================= PORTF =================//
;;;252    	PORT_StructInit(&PORT_InitStructure);
000220  4668              MOV      r0,sp
000222  f7fffffe          BL       PORT_StructInit
;;;253    	
;;;254    	// Feedback channel select, converter enable
;;;255    	PORT_InitStructure.PORT_Pin   = (1<<EN) | (1<<STAB_SEL) ;
000226  200c              MOVS     r0,#0xc
000228  f8ad0000          STRH     r0,[sp,#0]
;;;256    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
00022c  f88d400a          STRB     r4,[sp,#0xa]
;;;257    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
000230  f88d4009          STRB     r4,[sp,#9]
;;;258    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
000234  f88d4002          STRB     r4,[sp,#2]
;;;259    	PORT_Init(MDR_PORTF, &PORT_InitStructure);
000238  4669              MOV      r1,sp
00023a  4889              LDR      r0,|L1.1120|
00023c  f7fffffe          BL       PORT_Init
;;;260    	
;;;261    	// USART2 functions	
;;;262    	PORT_StructInit(&PORT_InitStructure);
000240  4668              MOV      r0,sp
000242  f7fffffe          BL       PORT_StructInit
;;;263    	// TX pin
;;;264    	PORT_InitStructure.PORT_Pin   = 1<<TXD2;
000246  f8ad5000          STRH     r5,[sp,#0]
;;;265    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
00024a  f88d400a          STRB     r4,[sp,#0xa]
;;;266    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
00024e  f88d5009          STRB     r5,[sp,#9]
;;;267    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_OVERRID;
000252  f88d6008          STRB     r6,[sp,#8]
;;;268    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
000256  f88d4002          STRB     r4,[sp,#2]
;;;269    	PORT_Init(MDR_PORTF, &PORT_InitStructure);
00025a  4669              MOV      r1,sp
00025c  4880              LDR      r0,|L1.1120|
00025e  f7fffffe          BL       PORT_Init
;;;270    	// RX pin
;;;271    	PORT_InitStructure.PORT_Pin   = 1<<RXD2;
000262  f8ad4000          STRH     r4,[sp,#0]
;;;272    	PORT_InitStructure.PORT_OE    = PORT_OE_IN;
000266  f88d8002          STRB     r8,[sp,#2]
;;;273    	PORT_Init(MDR_PORTF, &PORT_InitStructure);
00026a  4669              MOV      r1,sp
00026c  487c              LDR      r0,|L1.1120|
00026e  f7fffffe          BL       PORT_Init
;;;274    }
000272  e8bd8ffe          POP      {r1-r11,pc}
;;;275    
                          ENDP

                  HW_UARTInit PROC
;;;282    //-----------------------------------------------------------------//
;;;283    void HW_UARTInit(void)
000276  e92d47ff          PUSH     {r0-r10,lr}
;;;284    {
;;;285    	BaudRateStatus initStatus;
;;;286    	UART_InitTypeDef sUART;
;;;287    	UART_StructInit(&sUART);
00027a  4668              MOV      r0,sp
00027c  f7fffffe          BL       UART_StructInit
;;;288    	
;;;289    	//--------------- UART2 INIT ---------------//
;;;290    	UART_DeInit(MDR_UART2);
000280  f8df91e0          LDR      r9,|L1.1124|
000284  4648              MOV      r0,r9
000286  f7fffffe          BL       UART_DeInit
;;;291    	
;;;292    	sUART.UART_BaudRate                           = 115200;
00028a  f44f36e1          MOV      r6,#0x1c200
00028e  9600              STR      r6,[sp,#0]
;;;293    	sUART.UART_WordLength                         = UART_WordLength8b;
000290  2760              MOVS     r7,#0x60
000292  f8ad7004          STRH     r7,[sp,#4]
;;;294    	sUART.UART_StopBits                           = UART_StopBits1;
000296  2400              MOVS     r4,#0
000298  f8ad4006          STRH     r4,[sp,#6]
;;;295    	sUART.UART_Parity                             = UART_Parity_No;
00029c  f8ad4008          STRH     r4,[sp,#8]
;;;296    	sUART.UART_FIFOMode                           = UART_FIFO_ON;
0002a0  f04f0810          MOV      r8,#0x10
0002a4  f8ad800a          STRH     r8,[sp,#0xa]
;;;297    	sUART.UART_HardwareFlowControl                = (UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE );
0002a8  00fd              LSLS     r5,r7,#3
0002aa  f8ad500c          STRH     r5,[sp,#0xc]
;;;298    	
;;;299    	UART_BRGInit(MDR_UART2,UART_HCLKdiv1);
0002ae  2100              MOVS     r1,#0
0002b0  4648              MOV      r0,r9
0002b2  f7fffffe          BL       UART_BRGInit
;;;300    	initStatus = UART_Init(MDR_UART2,&sUART);
0002b6  4669              MOV      r1,sp
0002b8  4648              MOV      r0,r9
0002ba  f7fffffe          BL       UART_Init
;;;301    	UART_Cmd(MDR_UART2,ENABLE);
0002be  2101              MOVS     r1,#1
0002c0  4648              MOV      r0,r9
0002c2  f7fffffe          BL       UART_Cmd
;;;302    	
;;;303    	//--------------- UART1 INIT ---------------//
;;;304    	UART_DeInit(MDR_UART1);
0002c6  f8dfa1a0          LDR      r10,|L1.1128|
0002ca  4650              MOV      r0,r10
0002cc  f7fffffe          BL       UART_DeInit
;;;305    	
;;;306    	sUART.UART_BaudRate                           = 115200;
0002d0  9600              STR      r6,[sp,#0]
;;;307    	sUART.UART_WordLength                         = UART_WordLength8b;
0002d2  f8ad7004          STRH     r7,[sp,#4]
;;;308    	sUART.UART_StopBits                           = UART_StopBits1;
0002d6  f8ad4006          STRH     r4,[sp,#6]
;;;309    	sUART.UART_Parity                             = UART_Parity_No;
0002da  f8ad4008          STRH     r4,[sp,#8]
;;;310    	sUART.UART_FIFOMode                           = UART_FIFO_ON;
0002de  f8ad800a          STRH     r8,[sp,#0xa]
;;;311    	sUART.UART_HardwareFlowControl                = (UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE );
0002e2  f8ad500c          STRH     r5,[sp,#0xc]
;;;312    	
;;;313    	UART_BRGInit(MDR_UART1,UART_HCLKdiv1);
0002e6  2100              MOVS     r1,#0
0002e8  4650              MOV      r0,r10
0002ea  f7fffffe          BL       UART_BRGInit
;;;314    	initStatus = UART_Init(MDR_UART1,&sUART);
0002ee  4669              MOV      r1,sp
0002f0  4650              MOV      r0,r10
0002f2  f7fffffe          BL       UART_Init
;;;315    	UART_Cmd(MDR_UART1,ENABLE);
0002f6  2101              MOVS     r1,#1
0002f8  4650              MOV      r0,r10
0002fa  f7fffffe          BL       UART_Cmd
;;;316    	
;;;317    	//------------ UART DMA features------------//
;;;318    	UART_DMAConfig(MDR_UART1,UART_IT_FIFO_LVL_8words,UART_IT_FIFO_LVL_8words);		// ?
0002fe  2202              MOVS     r2,#2
000300  4611              MOV      r1,r2
000302  4650              MOV      r0,r10
000304  f7fffffe          BL       UART_DMAConfig
;;;319    	UART_DMAConfig(MDR_UART2,UART_IT_FIFO_LVL_8words,UART_IT_FIFO_LVL_8words);		//
000308  2202              MOVS     r2,#2
00030a  4611              MOV      r1,r2
00030c  4648              MOV      r0,r9
00030e  f7fffffe          BL       UART_DMAConfig
;;;320    	
;;;321    	/* Enable UART1 DMA Rx and Tx request */
;;;322    //	UART_DMACmd(MDR_UART1,(UART_DMA_RXE | UART_DMA_TXE), ENABLE);
;;;323    	/* Enable UART2 DMA Rx and Tx request */
;;;324    //	UART_DMACmd(MDR_UART2,(UART_DMA_RXE | UART_DMA_TXE), ENABLE);
;;;325    }
000312  e8bd87ff          POP      {r0-r10,pc}
;;;326    
                          ENDP

                  HW_DMAInit PROC
;;;330    //-----------------------------------------------------------------//
;;;331    void HW_DMAInit(void)
000316  b570              PUSH     {r4-r6,lr}
;;;332    {
;;;333    	// Reset all DMA settings
;;;334    	DMA_DeInit();	
000318  f7fffffe          BL       DMA_DeInit
;;;335    	
;;;336    	MDR_DMA->CHNL_REQ_MASK_SET = 0xFFFFFFFF;	// Disable all requests
00031c  4853              LDR      r0,|L1.1132|
00031e  f04f34ff          MOV      r4,#0xffffffff
000322  6204              STR      r4,[r0,#0x20]
;;;337    	MDR_DMA->CHNL_USEBURST_SET = 0xFFFFFFFF;	// disable sreq[]
000324  6184              STR      r4,[r0,#0x18]
;;;338    	
;;;339    	
;;;340    	RST_CLK_PCLKcmd(RST_CLK_PCLK_SSP1 ,ENABLE);
000326  2101              MOVS     r1,#1
000328  1580              ASRS     r0,r0,#22
00032a  f7fffffe          BL       RST_CLK_PCLKcmd
;;;341    	SSP_BRGInit(MDR_SSP1,SSP_HCLKdiv1);		// F_SSPCLK = HCLK / 1
00032e  4d50              LDR      r5,|L1.1136|
000330  2100              MOVS     r1,#0
000332  4628              MOV      r0,r5
000334  f7fffffe          BL       SSP_BRGInit
;;;342    	MDR_SSP1->DMACR = 0;
000338  2100              MOVS     r1,#0
00033a  6269              STR      r1,[r5,#0x24]
;;;343    	MDR_SSP2->DMACR = 0;
00033c  484d              LDR      r0,|L1.1140|
00033e  6241              STR      r1,[r0,#0x24]
;;;344    	
;;;345    	NVIC->ICPR[0] = 0xFFFFFFFF;
000340  484d              LDR      r0,|L1.1144|
000342  f8c041fc          STR      r4,[r0,#0x1fc]
;;;346    	NVIC->ICER[0] = 0xFFFFFFFF;
000346  f8c040fc          STR      r4,[r0,#0xfc]
00034a  f04f0120          MOV      r1,#0x20
00034e  67c1              STR      r1,[r0,#0x7c]
;;;347    	
;;;348    	
;;;349    	
;;;350    	NVIC_EnableIRQ(DMA_IRQn);
;;;351    }
000350  bd70              POP      {r4-r6,pc}
;;;352    
                          ENDP

                  HW_SSPInit PROC
;;;361    //-----------------------------------------------------------------//
;;;362    void HW_SSPInit(void)
000352  b51f              PUSH     {r0-r4,lr}
;;;363    {
;;;364    	SSP_InitTypeDef sSSP;
;;;365    	SSP_StructInit (&sSSP);
000354  4668              MOV      r0,sp
000356  f7fffffe          BL       SSP_StructInit
;;;366    
;;;367    	SSP_BRGInit(MDR_SSP2,SSP_HCLKdiv1);		// F_SSPCLK = HCLK / 1
00035a  4c46              LDR      r4,|L1.1140|
00035c  2100              MOVS     r1,#0
00035e  4620              MOV      r0,r4
000360  f7fffffe          BL       SSP_BRGInit
;;;368    	
;;;369    	sSSP.SSP_SCR  = 0x04;		// 0 to 255
000364  2004              MOVS     r0,#4
000366  f8ad0000          STRH     r0,[sp,#0]
;;;370    	sSSP.SSP_CPSDVSR = 2;		// even 2 to 254
00036a  2202              MOVS     r2,#2
00036c  f8ad2002          STRH     r2,[sp,#2]
;;;371    	sSSP.SSP_Mode = SSP_ModeMaster;
000370  2100              MOVS     r1,#0
000372  f8ad1004          STRH     r1,[sp,#4]
;;;372    	sSSP.SSP_WordLength = SSP_WordLength9b;
000376  2008              MOVS     r0,#8
000378  f8ad0006          STRH     r0,[sp,#6]
;;;373    	sSSP.SSP_SPH = SSP_SPH_1Edge;
00037c  f8ad1008          STRH     r1,[sp,#8]
;;;374    	sSSP.SSP_SPO = SSP_SPO_Low;
000380  f8ad100a          STRH     r1,[sp,#0xa]
;;;375    	sSSP.SSP_FRF = SSP_FRF_SPI_Motorola;
000384  f8ad100c          STRH     r1,[sp,#0xc]
;;;376    	sSSP.SSP_HardwareFlowControl = SSP_HardwareFlowControl_SSE;
000388  f8ad200e          STRH     r2,[sp,#0xe]
;;;377    	SSP_Init (MDR_SSP2,&sSSP);
00038c  4669              MOV      r1,sp
00038e  4620              MOV      r0,r4
000390  f7fffffe          BL       SSP_Init
;;;378    
;;;379    	SSP_Cmd(MDR_SSP2, ENABLE);
000394  2101              MOVS     r1,#1
000396  4620              MOV      r0,r4
000398  f7fffffe          BL       SSP_Cmd
;;;380    }
00039c  bd1f              POP      {r0-r4,pc}
;;;381    
                          ENDP

                  HW_I2CInit PROC
;;;386    //-----------------------------------------------------------------//
;;;387    void HW_I2CInit(void)
00039e  b51c              PUSH     {r2-r4,lr}
;;;388    {
;;;389    	//--------------- I2C INIT ---------------//
;;;390    I2C_InitTypeDef I2C_InitStruct;
;;;391    	
;;;392    	// Enables I2C peripheral
;;;393    	I2C_Cmd(ENABLE);
0003a0  2001              MOVS     r0,#1
0003a2  f7fffffe          BL       I2C_Cmd
;;;394    	
;;;395    	// Initialize I2C_InitStruct
;;;396    	I2C_InitStruct.I2C_ClkDiv = 256;		// 0x0000 to 0xFFFF
0003a6  f44f7080          MOV      r0,#0x100
0003aa  9000              STR      r0,[sp,#0]
;;;397    	I2C_InitStruct.I2C_Speed = I2C_SPEED_UP_TO_400KHz;
0003ac  2000              MOVS     r0,#0
0003ae  9001              STR      r0,[sp,#4]
;;;398    
;;;399    	// Configure I2C parameters
;;;400    	I2C_Init(&I2C_InitStruct);
0003b0  4668              MOV      r0,sp
0003b2  f7fffffe          BL       I2C_Init
;;;401    }
0003b6  bd1c              POP      {r2-r4,pc}
;;;402    
                          ENDP

                  HW_ADCInit PROC
;;;410    //-----------------------------------------------------------------//
;;;411    void HW_ADCInit(void)
0003b8  b530              PUSH     {r4,r5,lr}
;;;412    {
0003ba  b093              SUB      sp,sp,#0x4c
;;;413    	ADC_InitTypeDef sADC;
;;;414    	ADCx_InitTypeDef sADCx;
;;;415    	
;;;416    	// ADC Configuration
;;;417    	// Reset all ADC settings
;;;418    	ADC_DeInit();
0003bc  f7fffffe          BL       ADC_DeInit
;;;419    	ADC_StructInit(&sADC);
0003c0  a80c              ADD      r0,sp,#0x30
0003c2  f7fffffe          BL       ADC_StructInit
;;;420    
;;;421    	sADC.ADC_SynchronousMode      = ADC_SyncMode_Independent;
0003c6  2400              MOVS     r4,#0
0003c8  940c              STR      r4,[sp,#0x30]
;;;422    	sADC.ADC_StartDelay           = 10;
0003ca  200a              MOVS     r0,#0xa
0003cc  900d              STR      r0,[sp,#0x34]
;;;423    	sADC.ADC_TempSensor           = ADC_TEMP_SENSOR_Enable;
0003ce  f44f3000          MOV      r0,#0x20000
0003d2  900e              STR      r0,[sp,#0x38]
;;;424    	sADC.ADC_TempSensorAmplifier  = ADC_TEMP_SENSOR_AMPLIFIER_Enable;
0003d4  0040              LSLS     r0,r0,#1
0003d6  900f              STR      r0,[sp,#0x3c]
;;;425    	sADC.ADC_TempSensorConversion = ADC_TEMP_SENSOR_CONVERSION_Enable;
0003d8  0040              LSLS     r0,r0,#1
0003da  9010              STR      r0,[sp,#0x40]
;;;426    	sADC.ADC_IntVRefConversion    = ADC_VREF_CONVERSION_Enable;
0003dc  0040              LSLS     r0,r0,#1
0003de  9011              STR      r0,[sp,#0x44]
;;;427    	sADC.ADC_IntVRefTrimming      = 1;
0003e0  2501              MOVS     r5,#1
0003e2  9512              STR      r5,[sp,#0x48]
;;;428    	ADC_Init (&sADC);
0003e4  a80c              ADD      r0,sp,#0x30
0003e6  f7fffffe          BL       ADC_Init
;;;429    
;;;430    	// ADC1 Configuration 
;;;431    	ADCx_StructInit (&sADCx);
0003ea  a801              ADD      r0,sp,#4
0003ec  f7fffffe          BL       ADCx_StructInit
;;;432    	sADCx.ADC_ClockSource      = ADC_CLOCK_SOURCE_ADC;
0003f0  2004              MOVS     r0,#4
0003f2  9001              STR      r0,[sp,#4]
;;;433    	sADCx.ADC_SamplingMode     = ADC_SAMPLING_MODE_SINGLE_CONV;
0003f4  9402              STR      r4,[sp,#8]
;;;434    	sADCx.ADC_ChannelSwitching = ADC_CH_SWITCHING_Disable;
0003f6  9403              STR      r4,[sp,#0xc]
;;;435    	sADCx.ADC_ChannelNumber    = ADC_CH_TEMP_SENSOR;		
0003f8  201f              MOVS     r0,#0x1f
0003fa  9004              STR      r0,[sp,#0x10]
;;;436    	sADCx.ADC_Channels         = 0;
0003fc  9405              STR      r4,[sp,#0x14]
;;;437    	sADCx.ADC_LevelControl     = ADC_LEVEL_CONTROL_Disable;
0003fe  9406              STR      r4,[sp,#0x18]
;;;438    	sADCx.ADC_LowLevel         = 0;
000400  f8ad401c          STRH     r4,[sp,#0x1c]
;;;439    	sADCx.ADC_HighLevel        = 0;
000404  f8ad401e          STRH     r4,[sp,#0x1e]
;;;440    	sADCx.ADC_VRefSource       = ADC_VREF_SOURCE_EXTERNAL;
000408  02e8              LSLS     r0,r5,#11
00040a  9008              STR      r0,[sp,#0x20]
;;;441    	sADCx.ADC_IntVRefSource    = ADC_INT_VREF_SOURCE_EXACT;
00040c  9509              STR      r5,[sp,#0x24]
;;;442    	sADCx.ADC_Prescaler        = ADC_CLK_div_128;
00040e  f44f40e0          MOV      r0,#0x7000
000412  900a              STR      r0,[sp,#0x28]
;;;443    	sADCx.ADC_DelayGo          = 0;		// CHECKME
000414  940b              STR      r4,[sp,#0x2c]
;;;444    	ADC1_Init (&sADCx);
000416  a801              ADD      r0,sp,#4
000418  f7fffffe          BL       ADC1_Init
;;;445    	ADC2_Init (&sADCx);
00041c  a801              ADD      r0,sp,#4
00041e  f7fffffe          BL       ADC2_Init
;;;446    
;;;447    	// Disable ADC interupts
;;;448    	ADC1_ITConfig((ADCx_IT_END_OF_CONVERSION  | ADCx_IT_OUT_OF_RANGE), DISABLE);
000422  2100              MOVS     r1,#0
000424  2006              MOVS     r0,#6
000426  f7fffffe          BL       ADC1_ITConfig
;;;449    	ADC2_ITConfig((ADCx_IT_END_OF_CONVERSION  | ADCx_IT_OUT_OF_RANGE), DISABLE);
00042a  2100              MOVS     r1,#0
00042c  2006              MOVS     r0,#6
00042e  f7fffffe          BL       ADC2_ITConfig
;;;450    
;;;451    	// ADC1 enable
;;;452    	ADC1_Cmd (ENABLE);
000432  2001              MOVS     r0,#1
000434  f7fffffe          BL       ADC1_Cmd
;;;453    	ADC2_Cmd (ENABLE);
000438  2001              MOVS     r0,#1
00043a  f7fffffe          BL       ADC2_Cmd
;;;454    	
;;;455    	
;;;456    	//-------------------//
;;;457    /*	ADC1_SetChannel(ADC_CH_TEMP_SENSOR);
;;;458    	ADC1_Start();
;;;459    	while( ADC_GetFlagStatus(ADC1_FLAG_END_OF_CONVERSION)==RESET );
;;;460      temp_adc = ADC1_GetResult();
;;;461    	
;;;462    	ADC1_Start();
;;;463    	while( ADC_GetFlagStatus(ADC1_FLAG_END_OF_CONVERSION)==RESET );
;;;464      temp_adc = ADC1_GetResult();
;;;465    	
;;;466    	temp_adc = temp_adc;
;;;467    	*/
;;;468    	
;;;469    }
00043e  b013              ADD      sp,sp,#0x4c
000440  bd30              POP      {r4,r5,pc}
000442  0000              DCW      0x0000
                  |L1.1092|
                          DCD      0x23e00000
                  |L1.1096|
                          DCD      0x0013c4e0
                  |L1.1100|
                          DCD      0x400a8000
                  |L1.1104|
                          DCD      0x400b0000
                  |L1.1108|
                          DCD      0x400b8000
                  |L1.1112|
                          DCD      0x400c0000
                  |L1.1116|
                          DCD      0x400c8000
                  |L1.1120|
                          DCD      0x400e8000
                  |L1.1124|
                          DCD      0x40038000
                  |L1.1128|
                          DCD      0x40030000
                  |L1.1132|
                          DCD      0x40028000
                  |L1.1136|
                          DCD      0x40040000
                  |L1.1140|
                          DCD      0x400a0000
                  |L1.1144|
                          DCD      0xe000e084
                          ENDP

                  HW_TimersInit PROC
;;;479    //-----------------------------------------------------------------//
;;;480    void HW_TimersInit(void)
00047c  e92d43f0          PUSH     {r4-r9,lr}
;;;481    {
000480  b091              SUB      sp,sp,#0x44
;;;482    	TIMER_CntInitTypeDef sTIM_CntInit;
;;;483    	TIMER_ChnInitTypeDef sTIM_ChnInit;
;;;484    	TIMER_ChnOutInitTypeDef sTIM_ChnOutInit;
;;;485    	
;;;486    	//======================= TIMER1 =======================//
;;;487    	// Timer1		CH2		-> BUZ+
;;;488    	//				CH2N	-> BUZ-
;;;489    	// TIMER_CLK = HCLK
;;;490    	// CLK = 1MHz
;;;491    	// Default buzzer freq = 1 / 500us = 2kHz
;;;492    	
;;;493    	// Initialize timer 1 counter
;;;494    	TIMER_CntStructInit(&sTIM_CntInit);
000482  a80b              ADD      r0,sp,#0x2c
000484  f7fffffe          BL       TIMER_CntStructInit
;;;495    	sTIM_CntInit.TIMER_Prescaler                = 0x1F;		// 32MHz / (31 + 1) = 1MHz
000488  201f              MOVS     r0,#0x1f
00048a  f8ad002e          STRH     r0,[sp,#0x2e]
;;;496    	sTIM_CntInit.TIMER_Period                   = 499;		
00048e  f24010f3          MOV      r0,#0x1f3
000492  f8ad0030          STRH     r0,[sp,#0x30]
;;;497    	TIMER_CntInit (MDR_TIMER1,&sTIM_CntInit);
000496  4eaa              LDR      r6,|L1.1856|
000498  a90b              ADD      r1,sp,#0x2c
00049a  4630              MOV      r0,r6
00049c  f7fffffe          BL       TIMER_CntInit
;;;498    	
;;;499    	// Initialize timer 1 channel 2
;;;500    	TIMER_ChnStructInit(&sTIM_ChnInit);
0004a0  a805              ADD      r0,sp,#0x14
0004a2  f7fffffe          BL       TIMER_ChnStructInit
;;;501    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
0004a6  2400              MOVS     r4,#0
0004a8  f8ad4016          STRH     r4,[sp,#0x16]
;;;502    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format6;
0004ac  f44f6840          MOV      r8,#0xc00
0004b0  f8ad801e          STRH     r8,[sp,#0x1e]
;;;503    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL2;
0004b4  2501              MOVS     r5,#1
0004b6  f8ad5014          STRH     r5,[sp,#0x14]
;;;504    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_On_CNT_eq_0;
0004ba  f04f0908          MOV      r9,#8
0004be  f8ad9026          STRH     r9,[sp,#0x26]
;;;505    	TIMER_ChnInit(MDR_TIMER1, &sTIM_ChnInit);
0004c2  a905              ADD      r1,sp,#0x14
0004c4  4630              MOV      r0,r6
0004c6  f7fffffe          BL       TIMER_ChnInit
;;;506    	
;;;507    	// Initialize timer 1 channel 2 output
;;;508    	TIMER_ChnOutStructInit(&sTIM_ChnOutInit);
0004ca  4668              MOV      r0,sp
0004cc  f7fffffe          BL       TIMER_ChnOutStructInit
;;;509    	sTIM_ChnOutInit.TIMER_CH_DirOut_Polarity          = TIMER_CHOPolarity_NonInverted;
0004d0  f8ad4002          STRH     r4,[sp,#2]
;;;510    	sTIM_ChnOutInit.TIMER_CH_DirOut_Source            = TIMER_CH_OutSrc_Only_1;
0004d4  f8ad5004          STRH     r5,[sp,#4]
;;;511    	sTIM_ChnOutInit.TIMER_CH_DirOut_Mode              = TIMER_CH_OutMode_Output;
0004d8  f8ad5006          STRH     r5,[sp,#6]
;;;512    	sTIM_ChnOutInit.TIMER_CH_NegOut_Polarity          = TIMER_CHOPolarity_NonInverted;
0004dc  f8ad4008          STRH     r4,[sp,#8]
;;;513    	sTIM_ChnOutInit.TIMER_CH_NegOut_Source            = TIMER_CH_OutSrc_Only_1;
0004e0  f8ad500a          STRH     r5,[sp,#0xa]
;;;514    	sTIM_ChnOutInit.TIMER_CH_NegOut_Mode              = TIMER_CH_OutMode_Output;
0004e4  f8ad500c          STRH     r5,[sp,#0xc]
;;;515    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL2;
0004e8  f8ad5000          STRH     r5,[sp,#0]
;;;516    	TIMER_ChnOutInit(MDR_TIMER1, &sTIM_ChnOutInit);
0004ec  4669              MOV      r1,sp
0004ee  4630              MOV      r0,r6
0004f0  f7fffffe          BL       TIMER_ChnOutInit
;;;517    
;;;518    	// Set default buzzer duty
;;;519    	MDR_TIMER1->CCR2 = 249;	
0004f4  20f9              MOVS     r0,#0xf9
0004f6  6170              STR      r0,[r6,#0x14]
;;;520      
;;;521    	// Enable TIMER1 counter clock
;;;522    	TIMER_BRGInit(MDR_TIMER1,TIMER_HCLKdiv1);
0004f8  2100              MOVS     r1,#0
0004fa  4630              MOV      r0,r6
0004fc  f7fffffe          BL       TIMER_BRGInit
;;;523    
;;;524    	// Enable TIMER1
;;;525    	TIMER_Cmd(MDR_TIMER1,ENABLE);
000500  2101              MOVS     r1,#1
000502  4630              MOV      r0,r6
000504  f7fffffe          BL       TIMER_Cmd
;;;526    	
;;;527    	
;;;528    	
;;;529    	//======================= TIMER2 =======================//
;;;530    	// Timer2		CH1N	-> UPWM
;;;531    	//				CH3N	-> IPWM
;;;532    	// 				CH2		-> HW control interrupt generation
;;;533    	// TIMER_CLK = HCLK
;;;534    	// CLK = 16MHz
;;;535    	// PWM frequency = 3906.25 Hz (T = 256us)
;;;536    	// PWM resolution = 12 bit
;;;537    	
;;;538    	// Initialize timer 2 counter
;;;539    	TIMER_CntStructInit(&sTIM_CntInit);
000508  a80b              ADD      r0,sp,#0x2c
00050a  f7fffffe          BL       TIMER_CntStructInit
;;;540    	sTIM_CntInit.TIMER_Prescaler                = 0x1;		// CLK = 16MHz
00050e  f8ad502e          STRH     r5,[sp,#0x2e]
;;;541    	sTIM_CntInit.TIMER_Period                   = 0xFFF;	// 16MHz / 4096 = 3906.25 Hz 
000512  f64070ff          MOV      r0,#0xfff
000516  f8ad0030          STRH     r0,[sp,#0x30]
;;;542    	TIMER_CntInit (MDR_TIMER2,&sTIM_CntInit);
00051a  4f8a              LDR      r7,|L1.1860|
00051c  a90b              ADD      r1,sp,#0x2c
00051e  4638              MOV      r0,r7
000520  f7fffffe          BL       TIMER_CntInit
;;;543    
;;;544    	// Initialize timer 2 channels 1,3
;;;545    	TIMER_ChnStructInit(&sTIM_ChnInit);
000524  a805              ADD      r0,sp,#0x14
000526  f7fffffe          BL       TIMER_ChnStructInit
;;;546    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
00052a  f8ad4016          STRH     r4,[sp,#0x16]
;;;547    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format6;
00052e  f8ad801e          STRH     r8,[sp,#0x1e]
;;;548    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_On_CNT_eq_0;
000532  f8ad9026          STRH     r9,[sp,#0x26]
;;;549    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL1;			// voltage
000536  f8ad4014          STRH     r4,[sp,#0x14]
;;;550    	TIMER_ChnInit(MDR_TIMER2, &sTIM_ChnInit);
00053a  a905              ADD      r1,sp,#0x14
00053c  4638              MOV      r0,r7
00053e  f7fffffe          BL       TIMER_ChnInit
;;;551    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL3;			// curret
000542  2602              MOVS     r6,#2
000544  f8ad6014          STRH     r6,[sp,#0x14]
;;;552    	TIMER_ChnInit(MDR_TIMER2, &sTIM_ChnInit);
000548  a905              ADD      r1,sp,#0x14
00054a  4638              MOV      r0,r7
00054c  f7fffffe          BL       TIMER_ChnInit
;;;553    	
;;;554    	// Initialize timer 2 channel 2 - used for HW control interrupt generation
;;;555    	TIMER_ChnStructInit(&sTIM_ChnInit);
000550  a805              ADD      r0,sp,#0x14
000552  f7fffffe          BL       TIMER_ChnStructInit
;;;556    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
000556  f8ad4016          STRH     r4,[sp,#0x16]
;;;557    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format1;	// REF output = 1 when CNT == CCR
00055a  0268              LSLS     r0,r5,#9
00055c  f8ad001e          STRH     r0,[sp,#0x1e]
;;;558    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL2;
000560  f8ad5014          STRH     r5,[sp,#0x14]
;;;559    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_Immediately;
000564  f8ad4026          STRH     r4,[sp,#0x26]
;;;560    	TIMER_ChnInit(MDR_TIMER2, &sTIM_ChnInit);
000568  a905              ADD      r1,sp,#0x14
00056a  4638              MOV      r0,r7
00056c  f7fffffe          BL       TIMER_ChnInit
;;;561    	
;;;562    	// Initialize timer 2 channels 1,3 output
;;;563    	TIMER_ChnOutStructInit(&sTIM_ChnOutInit);
000570  4668              MOV      r0,sp
000572  f7fffffe          BL       TIMER_ChnOutStructInit
;;;564    	sTIM_ChnOutInit.TIMER_CH_NegOut_Polarity          = TIMER_CHOPolarity_Inverted;
000576  f8ad5008          STRH     r5,[sp,#8]
;;;565    	sTIM_ChnOutInit.TIMER_CH_NegOut_Source            = TIMER_CH_OutSrc_REF;
00057a  f8ad600a          STRH     r6,[sp,#0xa]
;;;566    	sTIM_ChnOutInit.TIMER_CH_NegOut_Mode              = TIMER_CH_OutMode_Output;
00057e  f8ad500c          STRH     r5,[sp,#0xc]
;;;567    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL1;
000582  f8ad4000          STRH     r4,[sp,#0]
;;;568    	TIMER_ChnOutInit(MDR_TIMER2, &sTIM_ChnOutInit);
000586  4669              MOV      r1,sp
000588  4638              MOV      r0,r7
00058a  f7fffffe          BL       TIMER_ChnOutInit
;;;569    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL3;
00058e  f8ad6000          STRH     r6,[sp,#0]
;;;570    	TIMER_ChnOutInit(MDR_TIMER2, &sTIM_ChnOutInit);
000592  4669              MOV      r1,sp
000594  4638              MOV      r0,r7
000596  f7fffffe          BL       TIMER_ChnOutInit
;;;571    	
;;;572    	// Set default voltage PWM duty cycle
;;;573    	MDR_TIMER2->CCR1 = 0;	
00059a  613c              STR      r4,[r7,#0x10]
;;;574    	// Set default current PWM duty cycle
;;;575    	MDR_TIMER2->CCR3 = 0;	
00059c  61bc              STR      r4,[r7,#0x18]
;;;576    	// Set default CCR for interrupt generation
;;;577    	MDR_TIMER2->CCR2 = 0;
00059e  617c              STR      r4,[r7,#0x14]
;;;578    	
;;;579    	// Enable interrupts
;;;580    	TIMER_ITConfig(MDR_TIMER2, TIMER_STATUS_CCR_REF_CH2, ENABLE);
0005a0  2201              MOVS     r2,#1
0005a2  0291              LSLS     r1,r2,#10
0005a4  4638              MOV      r0,r7
0005a6  f7fffffe          BL       TIMER_ITConfig
;;;581    	//TIMER_ITConfig(MDR_TIMER2, TIMER_STATUS_CNT_ZERO, ENABLE);
;;;582    	
;;;583    	// Enable TIMER2 counter clock
;;;584    	TIMER_BRGInit(MDR_TIMER2,TIMER_HCLKdiv1);
0005aa  2100              MOVS     r1,#0
0005ac  4638              MOV      r0,r7
0005ae  f7fffffe          BL       TIMER_BRGInit
;;;585    
;;;586    	// Enable TIMER2
;;;587    	TIMER_Cmd(MDR_TIMER2,ENABLE);
0005b2  2101              MOVS     r1,#1
0005b4  4638              MOV      r0,r7
0005b6  f7fffffe          BL       TIMER_Cmd
;;;588    	
;;;589    	
;;;590    	
;;;591    	//======================= TIMER3 =======================//
;;;592    	// Timer3		CH1 	-> LPWM (LCD backlight PWM) 
;;;593    	//				CH3N	-> CPWM (System cooler PWM)
;;;594    	// TIMER_CLK = HCLK
;;;595    	// CLK = 2MHz
;;;596    	// PWM frequency = 20kHz
;;;597    	// PWM resolution = 100
;;;598    	
;;;599    	// Initialize timer 3 counter
;;;600    	TIMER_CntStructInit(&sTIM_CntInit);
0005ba  a80b              ADD      r0,sp,#0x2c
0005bc  f7fffffe          BL       TIMER_CntStructInit
;;;601    	sTIM_CntInit.TIMER_Prescaler                = 0xF;		// 2MHz at 32MHz core clk
0005c0  200f              MOVS     r0,#0xf
0005c2  f8ad002e          STRH     r0,[sp,#0x2e]
;;;602    	sTIM_CntInit.TIMER_Period                   = 99;			// 20kHz at 2MHz
0005c6  2063              MOVS     r0,#0x63
0005c8  f8ad0030          STRH     r0,[sp,#0x30]
;;;603    	TIMER_CntInit (MDR_TIMER3,&sTIM_CntInit);
0005cc  4f5e              LDR      r7,|L1.1864|
0005ce  a90b              ADD      r1,sp,#0x2c
0005d0  4638              MOV      r0,r7
0005d2  f7fffffe          BL       TIMER_CntInit
;;;604    		
;;;605    	// Initialize timer 3 channel 1
;;;606    	TIMER_ChnStructInit(&sTIM_ChnInit);
0005d6  a805              ADD      r0,sp,#0x14
0005d8  f7fffffe          BL       TIMER_ChnStructInit
;;;607    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL1;
0005dc  f8ad4014          STRH     r4,[sp,#0x14]
;;;608    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
0005e0  f8ad4016          STRH     r4,[sp,#0x16]
;;;609    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format6;
0005e4  f8ad801e          STRH     r8,[sp,#0x1e]
;;;610    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_On_CNT_eq_0;
0005e8  f8ad9026          STRH     r9,[sp,#0x26]
;;;611    	TIMER_ChnInit(MDR_TIMER3, &sTIM_ChnInit);
0005ec  a905              ADD      r1,sp,#0x14
0005ee  4638              MOV      r0,r7
0005f0  f7fffffe          BL       TIMER_ChnInit
;;;612    
;;;613    	// Initialize timer 3 channel 1 output
;;;614    	TIMER_ChnOutStructInit(&sTIM_ChnOutInit);
0005f4  4668              MOV      r0,sp
0005f6  f7fffffe          BL       TIMER_ChnOutStructInit
;;;615    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL1;
0005fa  f8ad4000          STRH     r4,[sp,#0]
;;;616    	sTIM_ChnOutInit.TIMER_CH_DirOut_Source            = TIMER_CH_OutSrc_REF;
0005fe  f8ad6004          STRH     r6,[sp,#4]
;;;617    	sTIM_ChnOutInit.TIMER_CH_DirOut_Polarity          = TIMER_CHOPolarity_NonInverted;
000602  f8ad4002          STRH     r4,[sp,#2]
;;;618    	sTIM_ChnOutInit.TIMER_CH_DirOut_Mode              = TIMER_CH_OutMode_Output;
000606  f8ad5006          STRH     r5,[sp,#6]
;;;619    	TIMER_ChnOutInit(MDR_TIMER3, &sTIM_ChnOutInit);
00060a  4669              MOV      r1,sp
00060c  4638              MOV      r0,r7
00060e  f7fffffe          BL       TIMER_ChnOutInit
;;;620    
;;;621    	// Initialize timer 3 channel 3
;;;622    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL3;
000612  f8ad6014          STRH     r6,[sp,#0x14]
;;;623    	TIMER_ChnInit(MDR_TIMER3, &sTIM_ChnInit);
000616  a905              ADD      r1,sp,#0x14
000618  4638              MOV      r0,r7
00061a  f7fffffe          BL       TIMER_ChnInit
;;;624    	
;;;625    	// Initialize timer 3 channel 3 output
;;;626    	sTIM_ChnOutInit.TIMER_CH_Number           	= TIMER_CHANNEL3;
00061e  f8ad6000          STRH     r6,[sp,#0]
;;;627    	sTIM_ChnOutInit.TIMER_CH_DirOut_Source      = TIMER_CH_OutSrc_Only_0;
000622  f8ad4004          STRH     r4,[sp,#4]
;;;628    	sTIM_ChnOutInit.TIMER_CH_DirOut_Mode        = TIMER_CH_OutMode_Input;
000626  f8ad4006          STRH     r4,[sp,#6]
;;;629    	sTIM_ChnOutInit.TIMER_CH_NegOut_Source     	= TIMER_CH_OutSrc_REF;
00062a  f8ad600a          STRH     r6,[sp,#0xa]
;;;630    	sTIM_ChnOutInit.TIMER_CH_NegOut_Polarity   	= TIMER_CHOPolarity_Inverted;
00062e  f8ad5008          STRH     r5,[sp,#8]
;;;631    	sTIM_ChnOutInit.TIMER_CH_NegOut_Mode       	= TIMER_CH_OutMode_Output;
000632  f8ad500c          STRH     r5,[sp,#0xc]
;;;632    	TIMER_ChnOutInit(MDR_TIMER3, &sTIM_ChnOutInit);
000636  4669              MOV      r1,sp
000638  4638              MOV      r0,r7
00063a  f7fffffe          BL       TIMER_ChnOutInit
;;;633    
;;;634    
;;;635    	// Set default PWM duty cycle for LCD backlight PWM	
;;;636    	MDR_TIMER3->CCR1 = 0;
00063e  613c              STR      r4,[r7,#0x10]
;;;637    	
;;;638    	// Set default PWM duty cycle for system cooler PWM
;;;639    	MDR_TIMER3->CCR3 = 0;
000640  61bc              STR      r4,[r7,#0x18]
;;;640    
;;;641    	// Enable TIMER3 counter clock
;;;642    	TIMER_BRGInit(MDR_TIMER3,TIMER_HCLKdiv1);
000642  2100              MOVS     r1,#0
000644  4638              MOV      r0,r7
000646  f7fffffe          BL       TIMER_BRGInit
;;;643    
;;;644    	// Enable TIMER3
;;;645    	TIMER_Cmd(MDR_TIMER3,ENABLE);
00064a  2101              MOVS     r1,#1
00064c  4638              MOV      r0,r7
00064e  f7fffffe          BL       TIMER_Cmd
;;;646    	
;;;647    
;;;648    
;;;649    }
000652  b011              ADD      sp,sp,#0x44
000654  e8bd83f0          POP      {r4-r9,pc}
;;;650    
                          ENDP

                  SetVoltagePWMPeriod PROC
;;;655    
;;;656    void SetVoltagePWMPeriod(uint16_t new_period)
000658  493a              LDR      r1,|L1.1860|
;;;657    {
;;;658    	MDR_TIMER2->CCR1 = new_period;	
00065a  6108              STR      r0,[r1,#0x10]
;;;659    }
00065c  4770              BX       lr
;;;660    
                          ENDP

                  SetCurrentPWMPeriod PROC
;;;661    void SetCurrentPWMPeriod(uint16_t new_period)
00065e  4939              LDR      r1,|L1.1860|
;;;662    {
;;;663    	MDR_TIMER2->CCR3 = new_period;	
000660  6188              STR      r0,[r1,#0x18]
;;;664    }
000662  4770              BX       lr
;;;665    
                          ENDP

                  SetCoolerSpeed PROC
;;;670    
;;;671    void SetCoolerSpeed(uint16_t speed)
000664  4938              LDR      r1,|L1.1864|
;;;672    {
;;;673    	MDR_TIMER3->CCR3 = speed;
000666  6188              STR      r0,[r1,#0x18]
;;;674    }
000668  4770              BX       lr
;;;675    
                          ENDP

                  LcdSetBacklight PROC
;;;683    //==============================================================//
;;;684    void LcdSetBacklight(uint16_t value)
00066a  2864              CMP      r0,#0x64
;;;685    {
;;;686    	if (value>100) value = 100;
00066c  d900              BLS      |L1.1648|
00066e  2064              MOVS     r0,#0x64
                  |L1.1648|
;;;687    		MDR_TIMER3->CCR1 = value;
000670  4935              LDR      r1,|L1.1864|
000672  6108              STR      r0,[r1,#0x10]
;;;688    }
000674  4770              BX       lr
;;;689    
                          ENDP

                  ProcessPowerOff PROC
;;;691    
;;;692    void ProcessPowerOff(void)
000676  b538              PUSH     {r3-r5,lr}
;;;693    {
;;;694    	uint32_t time_delay;
;;;695    	if (GetACLineStatus() == OFFLINE)
000678  f7fffffe          BL       GetACLineStatus
00067c  2800              CMP      r0,#0
00067e  d15e              BNE      |L1.1854|
;;;696    	{	
;;;697    		__disable_irq();
000680  b672              CPSID    i
;;;698    
;;;699    		SetConverterState(CONVERTER_OFF);		// safe because we're stopping in this function
000682  2000              MOVS     r0,#0
000684  f7fffffe          BL       SetConverterState
;;;700    
;;;701    		//SysTickStop();
;;;702    		//StopBeep();
;;;703    
;;;704    		time_delay = DWT_StartDelayUs(5000);
000688  f2413088          MOV      r0,#0x1388
00068c  f7fffffe          BL       DWT_StartDelayUs
000690  4604              MOV      r4,r0
;;;705    
;;;706    		LcdSetBacklight(0);
000692  2000              MOVS     r0,#0
000694  f7fffffe          BL       LcdSetBacklight
;;;707    		SetCoolerSpeed(0);
000698  2000              MOVS     r0,#0
00069a  f7fffffe          BL       SetCoolerSpeed
;;;708    		SetVoltagePWMPeriod(0);
00069e  2000              MOVS     r0,#0
0006a0  f7fffffe          BL       SetVoltagePWMPeriod
;;;709    		SetCurrentPWMPeriod(0);
0006a4  2000              MOVS     r0,#0
0006a6  f7fffffe          BL       SetCurrentPWMPeriod
;;;710    
;;;711    
;;;712    		// Put message
;;;713    		LcdFillBuffer(lcd0_buffer,0);
0006aa  2100              MOVS     r1,#0
0006ac  4827              LDR      r0,|L1.1868|
0006ae  f7fffffe          BL       LcdFillBuffer
;;;714    		LcdFillBuffer(lcd1_buffer,0);
0006b2  2100              MOVS     r1,#0
0006b4  4826              LDR      r0,|L1.1872|
0006b6  f7fffffe          BL       LcdFillBuffer
;;;715    		LcdPutNormalStr(0,10,"Power OFF",(tNormalFont*)&font_8x12,lcd0_buffer);
0006ba  4824              LDR      r0,|L1.1868|
0006bc  9000              STR      r0,[sp,#0]
0006be  4b25              LDR      r3,|L1.1876|
0006c0  a225              ADR      r2,|L1.1880|
0006c2  210a              MOVS     r1,#0xa
0006c4  2000              MOVS     r0,#0
0006c6  f7fffffe          BL       LcdPutNormalStr
;;;716    		LcdPutNormalStr(0,10,"Power OFF",(tNormalFont*)&font_8x12,lcd1_buffer);
0006ca  4821              LDR      r0,|L1.1872|
0006cc  9000              STR      r0,[sp,#0]
0006ce  4b21              LDR      r3,|L1.1876|
0006d0  a221              ADR      r2,|L1.1880|
0006d2  210a              MOVS     r1,#0xa
0006d4  2000              MOVS     r0,#0
0006d6  f7fffffe          BL       LcdPutNormalStr
                  |L1.1754|
;;;717    
;;;718    
;;;719    
;;;720    		while(DWT_DelayInProgress(time_delay));
0006da  4620              MOV      r0,r4
0006dc  f7fffffe          BL       DWT_DelayInProgress
0006e0  2800              CMP      r0,#0
0006e2  d1fa              BNE      |L1.1754|
;;;721    
;;;722    		SetFeedbackChannel(CHANNEL_12V);
0006e4  f7fffffe          BL       SetFeedbackChannel
;;;723    		SetCurrentLimit(CURRENT_LIM_HIGH); 
0006e8  2001              MOVS     r0,#1
0006ea  f7fffffe          BL       SetCurrentLimit
;;;724    		SetOutputLoad(LOAD_DISABLE); 
0006ee  2001              MOVS     r0,#1
0006f0  f7fffffe          BL       SetOutputLoad
;;;725    
;;;726    		LcdUpdateByCore(LCD0,lcd0_buffer);
0006f4  4915              LDR      r1,|L1.1868|
0006f6  2001              MOVS     r0,#1
0006f8  f7fffffe          BL       LcdUpdateByCore
;;;727    		LcdUpdateByCore(LCD1,lcd1_buffer);
0006fc  4914              LDR      r1,|L1.1872|
0006fe  2002              MOVS     r0,#2
000700  f7fffffe          BL       LcdUpdateByCore
;;;728    
;;;729    
;;;730    
;;;731    		time_delay = DWT_StartDelayUs(1000);
000704  f44f707a          MOV      r0,#0x3e8
000708  f7fffffe          BL       DWT_StartDelayUs
00070c  4604              MOV      r4,r0
                  |L1.1806|
;;;732    		while(DWT_DelayInProgress(time_delay));
00070e  4620              MOV      r0,r4
000710  f7fffffe          BL       DWT_DelayInProgress
000714  2800              CMP      r0,#0
000716  d1fa              BNE      |L1.1806|
;;;733    
;;;734    		PORT_DeInit(MDR_PORTA);
000718  4812              LDR      r0,|L1.1892|
00071a  f7fffffe          BL       PORT_DeInit
;;;735    		PORT_DeInit(MDR_PORTB);
00071e  4812              LDR      r0,|L1.1896|
000720  f7fffffe          BL       PORT_DeInit
;;;736    		PORT_DeInit(MDR_PORTC);
000724  4811              LDR      r0,|L1.1900|
000726  f7fffffe          BL       PORT_DeInit
;;;737    		PORT_DeInit(MDR_PORTD);
00072a  4811              LDR      r0,|L1.1904|
00072c  f7fffffe          BL       PORT_DeInit
;;;738    		PORT_DeInit(MDR_PORTE);
000730  4810              LDR      r0,|L1.1908|
000732  f7fffffe          BL       PORT_DeInit
;;;739    		PORT_DeInit(MDR_PORTF);
000736  4810              LDR      r0,|L1.1912|
000738  f7fffffe          BL       PORT_DeInit
                  |L1.1852|
;;;740    
;;;741    		while(1);
00073c  e7fe              B        |L1.1852|
                  |L1.1854|
;;;742    		 
;;;743    	}
;;;744    }
00073e  bd38              POP      {r3-r5,pc}
;;;745    
                          ENDP

                  |L1.1856|
                          DCD      0x40070000
                  |L1.1860|
                          DCD      0x40078000
                  |L1.1864|
                          DCD      0x40080000
                  |L1.1868|
                          DCD      lcd0_buffer
                  |L1.1872|
                          DCD      lcd1_buffer
                  |L1.1876|
                          DCD      font_8x12
                  |L1.1880|
000758  506f7765          DCB      "Power OFF",0
00075c  72204f46
000760  4600    
000762  00                DCB      0
000763  00                DCB      0
                  |L1.1892|
                          DCD      0x400a8000
                  |L1.1896|
                          DCD      0x400b0000
                  |L1.1900|
                          DCD      0x400b8000
                  |L1.1904|
                          DCD      0x400c0000
                  |L1.1908|
                          DCD      0x400c8000
                  |L1.1912|
                          DCD      0x400e8000

;*** Start embedded assembler ***

#line 1 "src\\systemfunc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_systemfunc_c_b744d595____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_systemfunc_c_b744d595____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_systemfunc_c_b744d595____REVSH|
#line 130
|__asm___12_systemfunc_c_b744d595____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
