; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\systemfunc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\systemfunc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\systemfunc.crf src\systemfunc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Setup_CPU_Clock PROC
;;;42     //-----------------------------------------------------------------//
;;;43     void Setup_CPU_Clock(void)
000000  b510              PUSH     {r4,lr}
;;;44     {
;;;45     	// Enable HSE
;;;46     	RST_CLK_HSEconfig(RST_CLK_HSE_ON);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       RST_CLK_HSEconfig
;;;47     	if (RST_CLK_HSEstatus() != SUCCESS)
000008  f7fffffe          BL       RST_CLK_HSEstatus
00000c  2801              CMP      r0,#1
00000e  d001              BEQ      |L1.20|
;;;48     	{
;;;49     		while (1) {}	// Trap
000010  bf00              NOP      
                  |L1.18|
000012  e7fe              B        |L1.18|
                  |L1.20|
;;;50     	}
;;;51     	
;;;52     	//-------------------------------//
;;;53     	// Setup CPU PLL and CPU_C1_SEL
;;;54     	// CPU_C1 = HSE,	PLL = x8
;;;55     	RST_CLK_CPU_PLLconfig(RST_CLK_CPU_PLLsrcHSEdiv1, RST_CLK_CPU_PLLmul8);
000014  2107              MOVS     r1,#7
000016  2002              MOVS     r0,#2
000018  f7fffffe          BL       RST_CLK_CPU_PLLconfig
;;;56     	RST_CLK_CPU_PLLcmd(ENABLE);
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       RST_CLK_CPU_PLLcmd
;;;57     	if (RST_CLK_CPU_PLLstatus() != SUCCESS)
000022  f7fffffe          BL       RST_CLK_CPU_PLLstatus
000026  2801              CMP      r0,#1
000028  d001              BEQ      |L1.46|
;;;58     	{
;;;59     		while (1) {}	// Trap
00002a  bf00              NOP      
                  |L1.44|
00002c  e7fe              B        |L1.44|
                  |L1.46|
;;;60     	}
;;;61     	// Setup CPU_C2 and CPU_C3
;;;62     	// CPU_C3 = CPU_C2
;;;63     	RST_CLK_CPUclkPrescaler(RST_CLK_CPUclkDIV1);
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       RST_CLK_CPUclkPrescaler
;;;64     	// CPU_C2 = CPU PLL output
;;;65     	RST_CLK_CPU_PLLuse(ENABLE);
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       RST_CLK_CPU_PLLuse
;;;66     	// Switch to CPU_C3
;;;67     	// HCLK = CPU_C3
;;;68     	RST_CLK_CPUclkSelection(RST_CLK_CPUclkCPU_C3);
00003a  f44f7080          MOV      r0,#0x100
00003e  f7fffffe          BL       RST_CLK_CPUclkSelection
;;;69     	
;;;70     	//-------------------------------//
;;;71     	// Setup ADC clock
;;;72     	// ADC_C2 = CPU_C1
;;;73     	RST_CLK_ADCclkSelection(RST_CLK_ADCclkCPU_C1);
000042  2020              MOVS     r0,#0x20
000044  f7fffffe          BL       RST_CLK_ADCclkSelection
;;;74     	// ADC_C3 = ADC_C2
;;;75     	RST_CLK_ADCclkPrescaler(RST_CLK_ADCclkDIV1);
000048  2000              MOVS     r0,#0
00004a  f7fffffe          BL       RST_CLK_ADCclkPrescaler
;;;76     	// Enable ADC_CLK
;;;77     	RST_CLK_ADCclkEnable(ENABLE);
00004e  2001              MOVS     r0,#1
000050  f7fffffe          BL       RST_CLK_ADCclkEnable
;;;78     	
;;;79     	// Update system clock variable
;;;80     	SystemCoreClockUpdate();
000054  f7fffffe          BL       SystemCoreClockUpdate
;;;81     	
;;;82     	// Enable clock on all ports (macro are defined in systemfunc.h)
;;;83     	RST_CLK_PCLKcmd(ALL_PORTS_CLK, ENABLE);
000058  2101              MOVS     r1,#1
00005a  48fe              LDR      r0,|L1.1108|
00005c  f7fffffe          BL       RST_CLK_PCLKcmd
;;;84     	// Enable clock on peripheral blocks used in design
;;;85     	RST_CLK_PCLKcmd(PERIPHERALS_CLK ,ENABLE);
000060  2101              MOVS     r1,#1
000062  48fd              LDR      r0,|L1.1112|
000064  f7fffffe          BL       RST_CLK_PCLKcmd
;;;86     }
000068  bd10              POP      {r4,pc}
;;;87     
                          ENDP

                  HW_PortInit PROC
;;;92     //-----------------------------------------------------------------//
;;;93     void HW_PortInit(void)
00006a  b50e              PUSH     {r1-r3,lr}
;;;94     {
;;;95     	PORT_InitTypeDef PORT_InitStructure;
;;;96       
;;;97     	
;;;98     	PORT_DeInit(MDR_PORTA);
00006c  48fb              LDR      r0,|L1.1116|
00006e  f7fffffe          BL       PORT_DeInit
;;;99     	PORT_DeInit(MDR_PORTB);
000072  48fb              LDR      r0,|L1.1120|
000074  f7fffffe          BL       PORT_DeInit
;;;100    	PORT_DeInit(MDR_PORTC);
000078  48fa              LDR      r0,|L1.1124|
00007a  f7fffffe          BL       PORT_DeInit
;;;101    	PORT_DeInit(MDR_PORTD);
00007e  48fa              LDR      r0,|L1.1128|
000080  f7fffffe          BL       PORT_DeInit
;;;102    	PORT_DeInit(MDR_PORTE);
000084  48f9              LDR      r0,|L1.1132|
000086  f7fffffe          BL       PORT_DeInit
;;;103    	PORT_DeInit(MDR_PORTF);
00008a  48f9              LDR      r0,|L1.1136|
00008c  f7fffffe          BL       PORT_DeInit
;;;104    	
;;;105    	// default output value is 0
;;;106    	// Set some outputs the default design values of 1
;;;107    	//PORT_SetBits(MDR_PORTA, (1<<BUZ1) | (1<<BUZ2) );
;;;108    	PORT_SetBits(MDR_PORTB, (1<<LGREEN) | (1<<LRED) );
000090  21c0              MOVS     r1,#0xc0
000092  48f3              LDR      r0,|L1.1120|
000094  f7fffffe          BL       PORT_SetBits
;;;109    	
;;;110    	/*
;;;111    	   Reset PORT initialization structure parameters values 
;;;112      PORT_InitStruct->PORT_Pin        = PORT_Pin_All;
;;;113      PORT_InitStruct->PORT_OE         = PORT_OE_IN;
;;;114      PORT_InitStruct->PORT_PULL_UP    = PORT_PULL_UP_OFF;
;;;115      PORT_InitStruct->PORT_PULL_DOWN  = PORT_PULL_DOWN_OFF;
;;;116      PORT_InitStruct->PORT_PD_SHM     = PORT_PD_SHM_OFF;
;;;117      PORT_InitStruct->PORT_PD         = PORT_PD_DRIVER;
;;;118      PORT_InitStruct->PORT_GFEN       = PORT_GFEN_OFF;
;;;119      PORT_InitStruct->PORT_FUNC       = PORT_FUNC_PORT;
;;;120      PORT_InitStruct->PORT_SPEED      = PORT_OUTPUT_OFF;
;;;121      PORT_InitStruct->PORT_MODE       = PORT_MODE_ANALOG;
;;;122    	*/
;;;123    	
;;;124    	//================= PORTA =================//
;;;125    	PORT_StructInit(&PORT_InitStructure);
000098  4668              MOV      r0,sp
00009a  f7fffffe          BL       PORT_StructInit
;;;126    	
;;;127    	// Typical digital inputs:
;;;128    	PORT_InitStructure.PORT_Pin   = (1<<OVERLD) | (1<<ENC_BTN);
00009e  2021              MOVS     r0,#0x21
0000a0  f8ad0000          STRH     r0,[sp,#0]
;;;129    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
0000a4  2001              MOVS     r0,#1
0000a6  f88d000a          STRB     r0,[sp,#0xa]
;;;130    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0000aa  4669              MOV      r1,sp
0000ac  48eb              LDR      r0,|L1.1116|
0000ae  f7fffffe          BL       PORT_Init
;;;131    	
;;;132    	// Digital input with pull-up
;;;133    	PORT_InitStructure.PORT_Pin   = (1<<EEN);
0000b2  2004              MOVS     r0,#4
0000b4  f8ad0000          STRH     r0,[sp,#0]
;;;134    	PORT_InitStructure.PORT_PULL_UP  = PORT_PULL_UP_ON;
0000b8  2001              MOVS     r0,#1
0000ba  f88d0003          STRB     r0,[sp,#3]
;;;135    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0000be  4669              MOV      r1,sp
0000c0  48e6              LDR      r0,|L1.1116|
0000c2  f7fffffe          BL       PORT_Init
;;;136    	
;;;137    	// Typical digital outputs:
;;;138    	PORT_InitStructure.PORT_Pin   = (1<<CLIM_SEL);
0000c6  2002              MOVS     r0,#2
0000c8  f8ad0000          STRH     r0,[sp,#0]
;;;139    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
0000cc  2001              MOVS     r0,#1
0000ce  f88d0002          STRB     r0,[sp,#2]
;;;140    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
0000d2  f88d0009          STRB     r0,[sp,#9]
;;;141    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0000d6  4669              MOV      r1,sp
0000d8  48e0              LDR      r0,|L1.1116|
0000da  f7fffffe          BL       PORT_Init
;;;142    	
;;;143    	// Timer outputs to buzzer (TMR1.CH2, TMR1.CH2N)
;;;144    	PORT_InitStructure.PORT_Pin   = (1<<BUZ1) | (1<<BUZ2);
0000de  2018              MOVS     r0,#0x18
0000e0  f8ad0000          STRH     r0,[sp,#0]
;;;145    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
0000e4  2002              MOVS     r0,#2
0000e6  f88d0008          STRB     r0,[sp,#8]
;;;146    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
0000ea  4669              MOV      r1,sp
0000ec  48db              LDR      r0,|L1.1116|
0000ee  f7fffffe          BL       PORT_Init
;;;147    	
;;;148    	// TODO: add USART1 pins
;;;149    	
;;;150    	// debug
;;;151    	PORT_StructInit(&PORT_InitStructure);
0000f2  4668              MOV      r0,sp
0000f4  f7fffffe          BL       PORT_StructInit
;;;152    	PORT_InitStructure.PORT_Pin   = (1<<TXD1) | (1<<RXD1);
0000f8  20c0              MOVS     r0,#0xc0
0000fa  f8ad0000          STRH     r0,[sp,#0]
;;;153    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
0000fe  2001              MOVS     r0,#1
000100  f88d0002          STRB     r0,[sp,#2]
;;;154    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
000104  f88d0009          STRB     r0,[sp,#9]
;;;155    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
000108  f88d000a          STRB     r0,[sp,#0xa]
;;;156    	PORT_Init(MDR_PORTA, &PORT_InitStructure);
00010c  4669              MOV      r1,sp
00010e  48d3              LDR      r0,|L1.1116|
000110  f7fffffe          BL       PORT_Init
;;;157    
;;;158    	//================= PORTB =================//
;;;159    	PORT_StructInit(&PORT_InitStructure);
000114  4668              MOV      r0,sp
000116  f7fffffe          BL       PORT_StructInit
;;;160    	
;;;161    	// Typical digital inputs: buttons and encoder
;;;162    	PORT_InitStructure.PORT_Pin   = (1<<SB_ESC) | (1<<SB_LEFT) | (1<<SB_RIGHT) | (1<<SB_OK) | (1<<SB_MODE) | (1<<ENCA) | (1<<ENCB) | (1<<PG) ;
00011a  f2407037          MOV      r0,#0x737
00011e  f8ad0000          STRH     r0,[sp,#0]
;;;163    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
000122  2001              MOVS     r0,#1
000124  f88d000a          STRB     r0,[sp,#0xa]
;;;164    	PORT_Init(MDR_PORTB, &PORT_InitStructure);
000128  4669              MOV      r1,sp
00012a  48cd              LDR      r0,|L1.1120|
00012c  f7fffffe          BL       PORT_Init
;;;165    	
;;;166    	// Power good 
;;;167    	// TODO: add interrupt
;;;168    	PORT_InitStructure.PORT_Pin   = (1<<PG) ;
000130  f44f6080          MOV      r0,#0x400
000134  f8ad0000          STRH     r0,[sp,#0]
;;;169    	PORT_Init(MDR_PORTB, &PORT_InitStructure);
000138  4669              MOV      r1,sp
00013a  48c9              LDR      r0,|L1.1120|
00013c  f7fffffe          BL       PORT_Init
;;;170    	
;;;171    	// Leds and buttons SB_ON, SB_OFF
;;;172    	PORT_InitStructure.PORT_Pin   = (1<<LGREEN) | (1<<LRED);
000140  20c0              MOVS     r0,#0xc0
000142  f8ad0000          STRH     r0,[sp,#0]
;;;173    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
000146  2001              MOVS     r0,#1
000148  f88d0002          STRB     r0,[sp,#2]
;;;174    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
00014c  f88d0009          STRB     r0,[sp,#9]
;;;175    	PORT_Init(MDR_PORTB, &PORT_InitStructure);
000150  4669              MOV      r1,sp
000152  48c3              LDR      r0,|L1.1120|
000154  f7fffffe          BL       PORT_Init
;;;176    
;;;177    	
;;;178    	//================= PORTC =================//
;;;179    	PORT_StructInit(&PORT_InitStructure);
000158  4668              MOV      r0,sp
00015a  f7fffffe          BL       PORT_StructInit
;;;180    	
;;;181    	// LCD Backlight (TMR3.CH1)
;;;182    	PORT_InitStructure.PORT_Pin   = (1<<LCD_BL);
00015e  2004              MOVS     r0,#4
000160  f8ad0000          STRH     r0,[sp,#0]
;;;183    	PORT_InitStructure.PORT_MODE = PORT_MODE_DIGITAL;
000164  2001              MOVS     r0,#1
000166  f88d000a          STRB     r0,[sp,#0xa]
;;;184    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
00016a  2002              MOVS     r0,#2
00016c  f88d0008          STRB     r0,[sp,#8]
;;;185    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
000170  2001              MOVS     r0,#1
000172  f88d0009          STRB     r0,[sp,#9]
;;;186    	PORT_Init(MDR_PORTC, &PORT_InitStructure);
000176  4669              MOV      r1,sp
000178  48ba              LDR      r0,|L1.1124|
00017a  f7fffffe          BL       PORT_Init
;;;187    	
;;;188    	// I2C
;;;189    	PORT_InitStructure.PORT_Pin = (1<<SCL) | (1<<SDA);
00017e  2003              MOVS     r0,#3
000180  f8ad0000          STRH     r0,[sp,#0]
;;;190    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
000184  2002              MOVS     r0,#2
000186  f88d0009          STRB     r0,[sp,#9]
;;;191    	PORT_Init(MDR_PORTC, &PORT_InitStructure);
00018a  4669              MOV      r1,sp
00018c  48b5              LDR      r0,|L1.1124|
00018e  f7fffffe          BL       PORT_Init
;;;192    	
;;;193    	
;;;194    	//================= PORTD =================//
;;;195    	PORT_StructInit(&PORT_InitStructure);
000192  4668              MOV      r0,sp
000194  f7fffffe          BL       PORT_StructInit
;;;196    	
;;;197    	// Analog functions
;;;198    	PORT_InitStructure.PORT_Pin   = (1<<VREF_P) | (1<<VREF_N) | (1<<TEMP_IN) | (1<<UADC) | (1<<IADC) ;
000198  2097              MOVS     r0,#0x97
00019a  f8ad0000          STRH     r0,[sp,#0]
;;;199    	PORT_Init(MDR_PORTD, &PORT_InitStructure);
00019e  4669              MOV      r1,sp
0001a0  48b1              LDR      r0,|L1.1128|
0001a2  f7fffffe          BL       PORT_Init
;;;200    	
;;;201    	// LCD CLK and CS
;;;202    	PORT_InitStructure.PORT_Pin   = (1<<LCD_CLK) | (1<<LCD_CS) ;
0001a6  2028              MOVS     r0,#0x28
0001a8  f8ad0000          STRH     r0,[sp,#0]
;;;203    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
0001ac  2001              MOVS     r0,#1
0001ae  f88d000a          STRB     r0,[sp,#0xa]
;;;204    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
0001b2  2002              MOVS     r0,#2
0001b4  f88d0008          STRB     r0,[sp,#8]
;;;205    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
0001b8  f88d0009          STRB     r0,[sp,#9]
;;;206    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
0001bc  2001              MOVS     r0,#1
0001be  f88d0002          STRB     r0,[sp,#2]
;;;207    	PORT_Init(MDR_PORTD, &PORT_InitStructure);
0001c2  4669              MOV      r1,sp
0001c4  48a8              LDR      r0,|L1.1128|
0001c6  f7fffffe          BL       PORT_Init
;;;208    	
;;;209    	// MOSI 
;;;210    	PORT_InitStructure.PORT_Pin   = (1<<LCD_MOSI);
0001ca  2040              MOVS     r0,#0x40
0001cc  f8ad0000          STRH     r0,[sp,#0]
;;;211    	PORT_InitStructure.PORT_PULL_DOWN = PORT_PULL_DOWN_ON;
0001d0  2001              MOVS     r0,#1
0001d2  f88d0004          STRB     r0,[sp,#4]
;;;212    	PORT_Init(MDR_PORTD, &PORT_InitStructure);
0001d6  4669              MOV      r1,sp
0001d8  48a3              LDR      r0,|L1.1128|
0001da  f7fffffe          BL       PORT_Init
;;;213    	
;;;214    
;;;215    	
;;;216    	//================= PORTE =================//
;;;217    	PORT_StructInit(&PORT_InitStructure);
0001de  4668              MOV      r0,sp
0001e0  f7fffffe          BL       PORT_StructInit
;;;218    			
;;;219    	// LCD RST and SEL, Load disable output
;;;220    	PORT_InitStructure.PORT_Pin   = (1<<LCD_RST) | (1<<LCD_SEL) | (1<<LDIS);
0001e4  2045              MOVS     r0,#0x45
0001e6  f8ad0000          STRH     r0,[sp,#0]
;;;221    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
0001ea  2001              MOVS     r0,#1
0001ec  f88d000a          STRB     r0,[sp,#0xa]
;;;222    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
0001f0  2002              MOVS     r0,#2
0001f2  f88d0009          STRB     r0,[sp,#9]
;;;223    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
0001f6  2001              MOVS     r0,#1
0001f8  f88d0002          STRB     r0,[sp,#2]
;;;224    	PORT_Init(MDR_PORTE, &PORT_InitStructure);
0001fc  4669              MOV      r1,sp
0001fe  489b              LDR      r0,|L1.1132|
000200  f7fffffe          BL       PORT_Init
;;;225    
;;;226    	// cooler PWM output (TMR3.CH3N)
;;;227    	PORT_InitStructure.PORT_Pin   = (1<<CPWM);
000204  2080              MOVS     r0,#0x80
000206  f8ad0000          STRH     r0,[sp,#0]
;;;228    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_OVERRID;
00020a  2003              MOVS     r0,#3
00020c  f88d0008          STRB     r0,[sp,#8]
;;;229    	PORT_Init(MDR_PORTE, &PORT_InitStructure);
000210  4669              MOV      r1,sp
000212  4896              LDR      r0,|L1.1132|
000214  f7fffffe          BL       PORT_Init
;;;230    	
;;;231    	// voltage and current PWM outputs (TMR2.CH1N, TMR2.CH3N)
;;;232    	PORT_InitStructure.PORT_Pin   = (1<<UPWM) | (1<<IPWM);
000218  200a              MOVS     r0,#0xa
00021a  f8ad0000          STRH     r0,[sp,#0]
;;;233    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_ALTER;
00021e  2002              MOVS     r0,#2
000220  f88d0008          STRB     r0,[sp,#8]
;;;234    	PORT_Init(MDR_PORTE, &PORT_InitStructure);
000224  4669              MOV      r1,sp
000226  4891              LDR      r0,|L1.1132|
000228  f7fffffe          BL       PORT_Init
;;;235    	
;;;236    	
;;;237    	
;;;238    	//================= PORTF =================//
;;;239    	PORT_StructInit(&PORT_InitStructure);
00022c  4668              MOV      r0,sp
00022e  f7fffffe          BL       PORT_StructInit
;;;240    	
;;;241    	// Feedback channel select, converter enable
;;;242    	PORT_InitStructure.PORT_Pin   = (1<<EN) | (1<<STAB_SEL) ;
000232  200c              MOVS     r0,#0xc
000234  f8ad0000          STRH     r0,[sp,#0]
;;;243    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
000238  2001              MOVS     r0,#1
00023a  f88d000a          STRB     r0,[sp,#0xa]
;;;244    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_SLOW;
00023e  f88d0009          STRB     r0,[sp,#9]
;;;245    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
000242  f88d0002          STRB     r0,[sp,#2]
;;;246    	PORT_Init(MDR_PORTF, &PORT_InitStructure);
000246  4669              MOV      r1,sp
000248  4889              LDR      r0,|L1.1136|
00024a  f7fffffe          BL       PORT_Init
;;;247    	
;;;248    	// USART2 functions	
;;;249    	PORT_StructInit(&PORT_InitStructure);
00024e  4668              MOV      r0,sp
000250  f7fffffe          BL       PORT_StructInit
;;;250    	// TX pin
;;;251    	PORT_InitStructure.PORT_Pin   = 1<<TXD2;
000254  2002              MOVS     r0,#2
000256  f8ad0000          STRH     r0,[sp,#0]
;;;252    	PORT_InitStructure.PORT_MODE  = PORT_MODE_DIGITAL;
00025a  2001              MOVS     r0,#1
00025c  f88d000a          STRB     r0,[sp,#0xa]
;;;253    	PORT_InitStructure.PORT_SPEED = PORT_SPEED_FAST;
000260  2002              MOVS     r0,#2
000262  f88d0009          STRB     r0,[sp,#9]
;;;254    	PORT_InitStructure.PORT_FUNC  = PORT_FUNC_OVERRID;
000266  2003              MOVS     r0,#3
000268  f88d0008          STRB     r0,[sp,#8]
;;;255    	PORT_InitStructure.PORT_OE    = PORT_OE_OUT;
00026c  2001              MOVS     r0,#1
00026e  f88d0002          STRB     r0,[sp,#2]
;;;256    	PORT_Init(MDR_PORTF, &PORT_InitStructure);
000272  4669              MOV      r1,sp
000274  487e              LDR      r0,|L1.1136|
000276  f7fffffe          BL       PORT_Init
;;;257    	// RX pin
;;;258    	PORT_InitStructure.PORT_Pin   = 1<<RXD2;
00027a  2001              MOVS     r0,#1
00027c  f8ad0000          STRH     r0,[sp,#0]
;;;259    	PORT_InitStructure.PORT_OE    = PORT_OE_IN;
000280  2000              MOVS     r0,#0
000282  f88d0002          STRB     r0,[sp,#2]
;;;260    	PORT_Init(MDR_PORTF, &PORT_InitStructure);
000286  4669              MOV      r1,sp
000288  4879              LDR      r0,|L1.1136|
00028a  f7fffffe          BL       PORT_Init
;;;261    }
00028e  bd0e              POP      {r1-r3,pc}
;;;262    
                          ENDP

                  HW_UARTInit PROC
;;;269    //-----------------------------------------------------------------//
;;;270    void HW_UARTInit(void)
000290  b51f              PUSH     {r0-r4,lr}
;;;271    {
;;;272    	BaudRateStatus initStatus;
;;;273    	UART_InitTypeDef sUART;
;;;274    	UART_StructInit(&sUART);
000292  4668              MOV      r0,sp
000294  f7fffffe          BL       UART_StructInit
;;;275    
;;;276    	sUART.UART_BaudRate                           = 115200;
000298  f44f30e1          MOV      r0,#0x1c200
00029c  9000              STR      r0,[sp,#0]
;;;277    	sUART.UART_WordLength                         = UART_WordLength8b;
00029e  2060              MOVS     r0,#0x60
0002a0  f8ad0004          STRH     r0,[sp,#4]
;;;278    	sUART.UART_StopBits                           = UART_StopBits1;
0002a4  2000              MOVS     r0,#0
0002a6  f8ad0006          STRH     r0,[sp,#6]
;;;279    	sUART.UART_Parity                             = UART_Parity_No;
0002aa  f8ad0008          STRH     r0,[sp,#8]
;;;280    	sUART.UART_FIFOMode                           = UART_FIFO_ON;
0002ae  2010              MOVS     r0,#0x10
0002b0  f8ad000a          STRH     r0,[sp,#0xa]
;;;281    	sUART.UART_HardwareFlowControl                = (UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE );
0002b4  f44f7040          MOV      r0,#0x300
0002b8  f8ad000c          STRH     r0,[sp,#0xc]
;;;282    	
;;;283    	UART_BRGInit(MDR_UART2,UART_HCLKdiv1);
0002bc  2100              MOVS     r1,#0
0002be  486d              LDR      r0,|L1.1140|
0002c0  f7fffffe          BL       UART_BRGInit
;;;284    	initStatus = UART_Init(MDR_UART2,&sUART);
0002c4  4669              MOV      r1,sp
0002c6  486b              LDR      r0,|L1.1140|
0002c8  f7fffffe          BL       UART_Init
0002cc  4604              MOV      r4,r0
;;;285    	UART_Cmd(MDR_UART2,ENABLE);
0002ce  2101              MOVS     r1,#1
0002d0  4868              LDR      r0,|L1.1140|
0002d2  f7fffffe          BL       UART_Cmd
;;;286    }
0002d6  bd1f              POP      {r0-r4,pc}
;;;287    
                          ENDP

                  HW_SSPInit PROC
;;;295    //-----------------------------------------------------------------//
;;;296    void HW_SSPInit(void)
0002d8  b51f              PUSH     {r0-r4,lr}
;;;297    {
;;;298    	SSP_InitTypeDef sSSP;
;;;299    	SSP_StructInit (&sSSP);
0002da  4668              MOV      r0,sp
0002dc  f7fffffe          BL       SSP_StructInit
;;;300    
;;;301    	SSP_BRGInit(MDR_SSP2,SSP_HCLKdiv1);		// F_SSPCLK = HCLK / 1
0002e0  2100              MOVS     r1,#0
0002e2  4865              LDR      r0,|L1.1144|
0002e4  f7fffffe          BL       SSP_BRGInit
;;;302    	
;;;303    	sSSP.SSP_SCR  = 0x04;		// 0 to 255
0002e8  2004              MOVS     r0,#4
0002ea  f8ad0000          STRH     r0,[sp,#0]
;;;304    	sSSP.SSP_CPSDVSR = 2;		// even 2 to 254
0002ee  2002              MOVS     r0,#2
0002f0  f8ad0002          STRH     r0,[sp,#2]
;;;305    	sSSP.SSP_Mode = SSP_ModeMaster;
0002f4  2000              MOVS     r0,#0
0002f6  f8ad0004          STRH     r0,[sp,#4]
;;;306    	sSSP.SSP_WordLength = SSP_WordLength9b;
0002fa  2008              MOVS     r0,#8
0002fc  f8ad0006          STRH     r0,[sp,#6]
;;;307    	sSSP.SSP_SPH = SSP_SPH_1Edge;
000300  2000              MOVS     r0,#0
000302  f8ad0008          STRH     r0,[sp,#8]
;;;308    	sSSP.SSP_SPO = SSP_SPO_Low;
000306  f8ad000a          STRH     r0,[sp,#0xa]
;;;309    	sSSP.SSP_FRF = SSP_FRF_SPI_Motorola;
00030a  f8ad000c          STRH     r0,[sp,#0xc]
;;;310    	sSSP.SSP_HardwareFlowControl = SSP_HardwareFlowControl_SSE;
00030e  2002              MOVS     r0,#2
000310  f8ad000e          STRH     r0,[sp,#0xe]
;;;311    	SSP_Init (MDR_SSP2,&sSSP);
000314  4669              MOV      r1,sp
000316  4858              LDR      r0,|L1.1144|
000318  f7fffffe          BL       SSP_Init
;;;312    
;;;313    	SSP_Cmd(MDR_SSP2, ENABLE);
00031c  2101              MOVS     r1,#1
00031e  4856              LDR      r0,|L1.1144|
000320  f7fffffe          BL       SSP_Cmd
;;;314    }
000324  bd1f              POP      {r0-r4,pc}
;;;315    
                          ENDP

                  HW_I2CInit PROC
;;;320    //-----------------------------------------------------------------//
;;;321    void HW_I2CInit(void)
000326  b51c              PUSH     {r2-r4,lr}
;;;322    {
;;;323    	//--------------- I2C INIT ---------------//
;;;324    I2C_InitTypeDef I2C_InitStruct;
;;;325    	
;;;326    	// Enables I2C peripheral
;;;327    	I2C_Cmd(ENABLE);
000328  2001              MOVS     r0,#1
00032a  f7fffffe          BL       I2C_Cmd
;;;328    	
;;;329    	// Initialize I2C_InitStruct
;;;330    	I2C_InitStruct.I2C_ClkDiv = 256;		// 0x0000 to 0xFFFF
00032e  f44f7080          MOV      r0,#0x100
000332  9000              STR      r0,[sp,#0]
;;;331    	I2C_InitStruct.I2C_Speed = I2C_SPEED_UP_TO_400KHz;
000334  2000              MOVS     r0,#0
000336  9001              STR      r0,[sp,#4]
;;;332    
;;;333    	// Configure I2C parameters
;;;334    	I2C_Init(&I2C_InitStruct);
000338  4668              MOV      r0,sp
00033a  f7fffffe          BL       I2C_Init
;;;335    }
00033e  bd1c              POP      {r2-r4,pc}
;;;336    
                          ENDP

                  HW_ADCInit PROC
;;;344    //-----------------------------------------------------------------//
;;;345    void HW_ADCInit(void)
000340  b500              PUSH     {lr}
;;;346    {
000342  b093              SUB      sp,sp,#0x4c
;;;347    	ADC_InitTypeDef sADC;
;;;348    	ADCx_InitTypeDef sADCx;
;;;349    	
;;;350    	// ADC Configuration
;;;351    	// Reset all ADC settings
;;;352    	ADC_DeInit();
000344  f7fffffe          BL       ADC_DeInit
;;;353    	ADC_StructInit(&sADC);
000348  a80c              ADD      r0,sp,#0x30
00034a  f7fffffe          BL       ADC_StructInit
;;;354    
;;;355    	sADC.ADC_SynchronousMode      = ADC_SyncMode_Independent;
00034e  2000              MOVS     r0,#0
000350  900c              STR      r0,[sp,#0x30]
;;;356    	sADC.ADC_StartDelay           = 10;
000352  200a              MOVS     r0,#0xa
000354  900d              STR      r0,[sp,#0x34]
;;;357    	sADC.ADC_TempSensor           = ADC_TEMP_SENSOR_Enable;
000356  f44f3000          MOV      r0,#0x20000
00035a  900e              STR      r0,[sp,#0x38]
;;;358    	sADC.ADC_TempSensorAmplifier  = ADC_TEMP_SENSOR_AMPLIFIER_Enable;
00035c  0040              LSLS     r0,r0,#1
00035e  900f              STR      r0,[sp,#0x3c]
;;;359    	sADC.ADC_TempSensorConversion = ADC_TEMP_SENSOR_CONVERSION_Enable;
000360  0040              LSLS     r0,r0,#1
000362  9010              STR      r0,[sp,#0x40]
;;;360    	sADC.ADC_IntVRefConversion    = ADC_VREF_CONVERSION_Enable;
000364  0040              LSLS     r0,r0,#1
000366  9011              STR      r0,[sp,#0x44]
;;;361    	sADC.ADC_IntVRefTrimming      = 1;
000368  2001              MOVS     r0,#1
00036a  9012              STR      r0,[sp,#0x48]
;;;362    	ADC_Init (&sADC);
00036c  a80c              ADD      r0,sp,#0x30
00036e  f7fffffe          BL       ADC_Init
;;;363    
;;;364    	// ADC1 Configuration 
;;;365    	ADCx_StructInit (&sADCx);
000372  a801              ADD      r0,sp,#4
000374  f7fffffe          BL       ADCx_StructInit
;;;366    	sADCx.ADC_ClockSource      = ADC_CLOCK_SOURCE_ADC;
000378  2004              MOVS     r0,#4
00037a  9001              STR      r0,[sp,#4]
;;;367    	sADCx.ADC_SamplingMode     = ADC_SAMPLING_MODE_SINGLE_CONV;
00037c  2000              MOVS     r0,#0
00037e  9002              STR      r0,[sp,#8]
;;;368    	sADCx.ADC_ChannelSwitching = ADC_CH_SWITCHING_Disable;
000380  9003              STR      r0,[sp,#0xc]
;;;369    	sADCx.ADC_ChannelNumber    = ADC_CH_TEMP_SENSOR;		
000382  201f              MOVS     r0,#0x1f
000384  9004              STR      r0,[sp,#0x10]
;;;370    	sADCx.ADC_Channels         = 0;
000386  2000              MOVS     r0,#0
000388  9005              STR      r0,[sp,#0x14]
;;;371    	sADCx.ADC_LevelControl     = ADC_LEVEL_CONTROL_Disable;
00038a  9006              STR      r0,[sp,#0x18]
;;;372    	sADCx.ADC_LowLevel         = 0;
00038c  f8ad001c          STRH     r0,[sp,#0x1c]
;;;373    	sADCx.ADC_HighLevel        = 0;
000390  f8ad001e          STRH     r0,[sp,#0x1e]
;;;374    	sADCx.ADC_VRefSource       = ADC_VREF_SOURCE_EXTERNAL;
000394  f44f6000          MOV      r0,#0x800
000398  9008              STR      r0,[sp,#0x20]
;;;375    	sADCx.ADC_IntVRefSource    = ADC_INT_VREF_SOURCE_EXACT;
00039a  2001              MOVS     r0,#1
00039c  9009              STR      r0,[sp,#0x24]
;;;376    	sADCx.ADC_Prescaler        = ADC_CLK_div_128;
00039e  f44f40e0          MOV      r0,#0x7000
0003a2  900a              STR      r0,[sp,#0x28]
;;;377    	sADCx.ADC_DelayGo          = 0;		// CHECKME
0003a4  2000              MOVS     r0,#0
0003a6  900b              STR      r0,[sp,#0x2c]
;;;378    	ADC1_Init (&sADCx);
0003a8  a801              ADD      r0,sp,#4
0003aa  f7fffffe          BL       ADC1_Init
;;;379    	ADC2_Init (&sADCx);
0003ae  a801              ADD      r0,sp,#4
0003b0  f7fffffe          BL       ADC2_Init
;;;380    
;;;381    	// Disable ADC interupts
;;;382    	ADC1_ITConfig((ADCx_IT_END_OF_CONVERSION  | ADCx_IT_OUT_OF_RANGE), DISABLE);
0003b4  2100              MOVS     r1,#0
0003b6  2006              MOVS     r0,#6
0003b8  f7fffffe          BL       ADC1_ITConfig
;;;383    	ADC2_ITConfig((ADCx_IT_END_OF_CONVERSION  | ADCx_IT_OUT_OF_RANGE), DISABLE);
0003bc  2100              MOVS     r1,#0
0003be  2006              MOVS     r0,#6
0003c0  f7fffffe          BL       ADC2_ITConfig
;;;384    
;;;385    	// ADC1 enable
;;;386    	ADC1_Cmd (ENABLE);
0003c4  2001              MOVS     r0,#1
0003c6  f7fffffe          BL       ADC1_Cmd
;;;387    	ADC2_Cmd (ENABLE);
0003ca  2001              MOVS     r0,#1
0003cc  f7fffffe          BL       ADC2_Cmd
;;;388    	
;;;389    	
;;;390    	//-------------------//
;;;391    /*	ADC1_SetChannel(ADC_CH_TEMP_SENSOR);
;;;392    	ADC1_Start();
;;;393    	while( ADC_GetFlagStatus(ADC1_FLAG_END_OF_CONVERSION)==RESET );
;;;394      temp_adc = ADC1_GetResult();
;;;395    	
;;;396    	ADC1_Start();
;;;397    	while( ADC_GetFlagStatus(ADC1_FLAG_END_OF_CONVERSION)==RESET );
;;;398      temp_adc = ADC1_GetResult();
;;;399    	
;;;400    	temp_adc = temp_adc;
;;;401    	*/
;;;402    	
;;;403    }
0003d0  b013              ADD      sp,sp,#0x4c
0003d2  bd00              POP      {pc}
;;;404    
                          ENDP

                  HW_TimersInit PROC
;;;413    //-----------------------------------------------------------------//
;;;414    void HW_TimersInit(void)
0003d4  b500              PUSH     {lr}
;;;415    {
0003d6  b091              SUB      sp,sp,#0x44
;;;416    	TIMER_CntInitTypeDef sTIM_CntInit;
;;;417    	TIMER_ChnInitTypeDef sTIM_ChnInit;
;;;418    	TIMER_ChnOutInitTypeDef sTIM_ChnOutInit;
;;;419    	
;;;420    	//======================= TIMER1 =======================//
;;;421    	// Timer1		CH2		-> BUZ+
;;;422    	//				CH2N	-> BUZ-
;;;423    	// TIMER_CLK = HCLK
;;;424    	// CLK = 1MHz
;;;425    	// Default buzzer freq = 1 / 500us = 2kHz
;;;426    	
;;;427    	// Initialize timer 1 counter
;;;428    	TIMER_CntStructInit(&sTIM_CntInit);
0003d8  a80b              ADD      r0,sp,#0x2c
0003da  f7fffffe          BL       TIMER_CntStructInit
;;;429    	sTIM_CntInit.TIMER_Prescaler                = 0x1F;		// 32MHz / (31 + 1) = 1MHz
0003de  201f              MOVS     r0,#0x1f
0003e0  f8ad002e          STRH     r0,[sp,#0x2e]
;;;430    	sTIM_CntInit.TIMER_Period                   = 499;		
0003e4  f24010f3          MOV      r0,#0x1f3
0003e8  f8ad0030          STRH     r0,[sp,#0x30]
;;;431    	TIMER_CntInit (MDR_TIMER1,&sTIM_CntInit);
0003ec  a90b              ADD      r1,sp,#0x2c
0003ee  4823              LDR      r0,|L1.1148|
0003f0  f7fffffe          BL       TIMER_CntInit
;;;432    	
;;;433    	// Initialize timer 1 channel 2
;;;434    	TIMER_ChnStructInit(&sTIM_ChnInit);
0003f4  a805              ADD      r0,sp,#0x14
0003f6  f7fffffe          BL       TIMER_ChnStructInit
;;;435    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
0003fa  2000              MOVS     r0,#0
0003fc  f8ad0016          STRH     r0,[sp,#0x16]
;;;436    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format6;
000400  f44f6040          MOV      r0,#0xc00
000404  f8ad001e          STRH     r0,[sp,#0x1e]
;;;437    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL2;
000408  2001              MOVS     r0,#1
00040a  f8ad0014          STRH     r0,[sp,#0x14]
;;;438    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_On_CNT_eq_0;
00040e  2008              MOVS     r0,#8
000410  f8ad0026          STRH     r0,[sp,#0x26]
;;;439    	TIMER_ChnInit(MDR_TIMER1, &sTIM_ChnInit);
000414  a905              ADD      r1,sp,#0x14
000416  4819              LDR      r0,|L1.1148|
000418  f7fffffe          BL       TIMER_ChnInit
;;;440    	
;;;441    	// Initialize timer 1 channel 2 output
;;;442    	TIMER_ChnOutStructInit(&sTIM_ChnOutInit);
00041c  4668              MOV      r0,sp
00041e  f7fffffe          BL       TIMER_ChnOutStructInit
;;;443    	sTIM_ChnOutInit.TIMER_CH_DirOut_Polarity          = TIMER_CHOPolarity_NonInverted;
000422  2000              MOVS     r0,#0
000424  f8ad0002          STRH     r0,[sp,#2]
;;;444    	sTIM_ChnOutInit.TIMER_CH_DirOut_Source            = TIMER_CH_OutSrc_Only_1;
000428  2001              MOVS     r0,#1
00042a  f8ad0004          STRH     r0,[sp,#4]
;;;445    	sTIM_ChnOutInit.TIMER_CH_DirOut_Mode              = TIMER_CH_OutMode_Output;
00042e  f8ad0006          STRH     r0,[sp,#6]
;;;446    	sTIM_ChnOutInit.TIMER_CH_NegOut_Polarity          = TIMER_CHOPolarity_NonInverted;
000432  2000              MOVS     r0,#0
000434  f8ad0008          STRH     r0,[sp,#8]
;;;447    	sTIM_ChnOutInit.TIMER_CH_NegOut_Source            = TIMER_CH_OutSrc_Only_1;
000438  2001              MOVS     r0,#1
00043a  f8ad000a          STRH     r0,[sp,#0xa]
;;;448    	sTIM_ChnOutInit.TIMER_CH_NegOut_Mode              = TIMER_CH_OutMode_Output;
00043e  f8ad000c          STRH     r0,[sp,#0xc]
;;;449    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL2;
000442  f8ad0000          STRH     r0,[sp,#0]
;;;450    	TIMER_ChnOutInit(MDR_TIMER1, &sTIM_ChnOutInit);
000446  4669              MOV      r1,sp
000448  480c              LDR      r0,|L1.1148|
00044a  f7fffffe          BL       TIMER_ChnOutInit
;;;451    
;;;452    	// Set default buzzer duty
;;;453    	MDR_TIMER1->CCR2 = 249;	
00044e  20f9              MOVS     r0,#0xf9
000450  490a              LDR      r1,|L1.1148|
000452  e015              B        |L1.1152|
                  |L1.1108|
                          DCD      0x23e00000
                  |L1.1112|
                          DCD      0x0013c480
                  |L1.1116|
                          DCD      0x400a8000
                  |L1.1120|
                          DCD      0x400b0000
                  |L1.1124|
                          DCD      0x400b8000
                  |L1.1128|
                          DCD      0x400c0000
                  |L1.1132|
                          DCD      0x400c8000
                  |L1.1136|
                          DCD      0x400e8000
                  |L1.1140|
                          DCD      0x40038000
                  |L1.1144|
                          DCD      0x400a0000
                  |L1.1148|
                          DCD      0x40070000
                  |L1.1152|
000480  6148              STR      r0,[r1,#0x14]
;;;454      
;;;455    	// Enable TIMER1 counter clock
;;;456    	TIMER_BRGInit(MDR_TIMER1,TIMER_HCLKdiv1);
000482  2100              MOVS     r1,#0
000484  48a1              LDR      r0,|L1.1804|
000486  f7fffffe          BL       TIMER_BRGInit
;;;457    
;;;458    	// Enable TIMER1
;;;459    	TIMER_Cmd(MDR_TIMER1,ENABLE);
00048a  2101              MOVS     r1,#1
00048c  489f              LDR      r0,|L1.1804|
00048e  f7fffffe          BL       TIMER_Cmd
;;;460    	
;;;461    	
;;;462    	
;;;463    	//======================= TIMER2 =======================//
;;;464    	// Timer2		CH1N	-> UPWM
;;;465    	//				CH3N	-> IPWM
;;;466    	// 				CH2		-> HW control interrupt generation
;;;467    	// TIMER_CLK = HCLK
;;;468    	// CLK = 16MHz
;;;469    	// PWM frequency = 3906.25 Hz (T = 256us)
;;;470    	// PWM resolution = 12 bit
;;;471    	
;;;472    	// Initialize timer 2 counter
;;;473    	TIMER_CntStructInit(&sTIM_CntInit);
000492  a80b              ADD      r0,sp,#0x2c
000494  f7fffffe          BL       TIMER_CntStructInit
;;;474    	sTIM_CntInit.TIMER_Prescaler                = 0x1;		// CLK = 16MHz
000498  2001              MOVS     r0,#1
00049a  f8ad002e          STRH     r0,[sp,#0x2e]
;;;475    	sTIM_CntInit.TIMER_Period                   = 0xFFF;	// 16MHz / 4096 = 3906.25 Hz 
00049e  f64070ff          MOV      r0,#0xfff
0004a2  f8ad0030          STRH     r0,[sp,#0x30]
;;;476    	TIMER_CntInit (MDR_TIMER2,&sTIM_CntInit);
0004a6  a90b              ADD      r1,sp,#0x2c
0004a8  4899              LDR      r0,|L1.1808|
0004aa  f7fffffe          BL       TIMER_CntInit
;;;477    
;;;478    	// Initialize timer 2 channels 1,3
;;;479    	TIMER_ChnStructInit(&sTIM_ChnInit);
0004ae  a805              ADD      r0,sp,#0x14
0004b0  f7fffffe          BL       TIMER_ChnStructInit
;;;480    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
0004b4  2000              MOVS     r0,#0
0004b6  f8ad0016          STRH     r0,[sp,#0x16]
;;;481    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format6;
0004ba  f44f6040          MOV      r0,#0xc00
0004be  f8ad001e          STRH     r0,[sp,#0x1e]
;;;482    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_On_CNT_eq_0;
0004c2  2008              MOVS     r0,#8
0004c4  f8ad0026          STRH     r0,[sp,#0x26]
;;;483    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL1;			// voltage
0004c8  2000              MOVS     r0,#0
0004ca  f8ad0014          STRH     r0,[sp,#0x14]
;;;484    	TIMER_ChnInit(MDR_TIMER2, &sTIM_ChnInit);
0004ce  a905              ADD      r1,sp,#0x14
0004d0  488f              LDR      r0,|L1.1808|
0004d2  f7fffffe          BL       TIMER_ChnInit
;;;485    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL3;			// curret
0004d6  2002              MOVS     r0,#2
0004d8  f8ad0014          STRH     r0,[sp,#0x14]
;;;486    	TIMER_ChnInit(MDR_TIMER2, &sTIM_ChnInit);
0004dc  a905              ADD      r1,sp,#0x14
0004de  488c              LDR      r0,|L1.1808|
0004e0  f7fffffe          BL       TIMER_ChnInit
;;;487    	
;;;488    	// Initialize timer 2 channel 2 - used for HW control interrupt generation
;;;489    	TIMER_ChnStructInit(&sTIM_ChnInit);
0004e4  a805              ADD      r0,sp,#0x14
0004e6  f7fffffe          BL       TIMER_ChnStructInit
;;;490    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
0004ea  2000              MOVS     r0,#0
0004ec  f8ad0016          STRH     r0,[sp,#0x16]
;;;491    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format1;	// REF output = 1 when CNT == CCR
0004f0  f44f7000          MOV      r0,#0x200
0004f4  f8ad001e          STRH     r0,[sp,#0x1e]
;;;492    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL2;
0004f8  2001              MOVS     r0,#1
0004fa  f8ad0014          STRH     r0,[sp,#0x14]
;;;493    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_Immediately;
0004fe  2000              MOVS     r0,#0
000500  f8ad0026          STRH     r0,[sp,#0x26]
;;;494    	TIMER_ChnInit(MDR_TIMER2, &sTIM_ChnInit);
000504  a905              ADD      r1,sp,#0x14
000506  4882              LDR      r0,|L1.1808|
000508  f7fffffe          BL       TIMER_ChnInit
;;;495    	
;;;496    	// Initialize timer 2 channels 1,3 output
;;;497    	TIMER_ChnOutStructInit(&sTIM_ChnOutInit);
00050c  4668              MOV      r0,sp
00050e  f7fffffe          BL       TIMER_ChnOutStructInit
;;;498    	sTIM_ChnOutInit.TIMER_CH_NegOut_Polarity          = TIMER_CHOPolarity_Inverted;
000512  2001              MOVS     r0,#1
000514  f8ad0008          STRH     r0,[sp,#8]
;;;499    	sTIM_ChnOutInit.TIMER_CH_NegOut_Source            = TIMER_CH_OutSrc_REF;
000518  2002              MOVS     r0,#2
00051a  f8ad000a          STRH     r0,[sp,#0xa]
;;;500    	sTIM_ChnOutInit.TIMER_CH_NegOut_Mode              = TIMER_CH_OutMode_Output;
00051e  2001              MOVS     r0,#1
000520  f8ad000c          STRH     r0,[sp,#0xc]
;;;501    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL1;
000524  2000              MOVS     r0,#0
000526  f8ad0000          STRH     r0,[sp,#0]
;;;502    	TIMER_ChnOutInit(MDR_TIMER2, &sTIM_ChnOutInit);
00052a  4669              MOV      r1,sp
00052c  4878              LDR      r0,|L1.1808|
00052e  f7fffffe          BL       TIMER_ChnOutInit
;;;503    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL3;
000532  2002              MOVS     r0,#2
000534  f8ad0000          STRH     r0,[sp,#0]
;;;504    	TIMER_ChnOutInit(MDR_TIMER2, &sTIM_ChnOutInit);
000538  4669              MOV      r1,sp
00053a  4875              LDR      r0,|L1.1808|
00053c  f7fffffe          BL       TIMER_ChnOutInit
;;;505    	
;;;506    	// Set default voltage PWM duty cycle
;;;507    	MDR_TIMER2->CCR1 = 0;	
000540  2000              MOVS     r0,#0
000542  4973              LDR      r1,|L1.1808|
000544  6108              STR      r0,[r1,#0x10]
;;;508    	// Set default current PWM duty cycle
;;;509    	MDR_TIMER2->CCR3 = 0;	
000546  6188              STR      r0,[r1,#0x18]
;;;510    	// Set default CCR for interrupt generation
;;;511    	MDR_TIMER2->CCR2 = 0;
000548  6148              STR      r0,[r1,#0x14]
;;;512    	
;;;513    	// Enable interrupts
;;;514    	TIMER_ITConfig(MDR_TIMER2, TIMER_STATUS_CCR_REF_CH2, ENABLE);
00054a  2201              MOVS     r2,#1
00054c  1509              ASRS     r1,r1,#20
00054e  4870              LDR      r0,|L1.1808|
000550  f7fffffe          BL       TIMER_ITConfig
;;;515    	//TIMER_ITConfig(MDR_TIMER2, TIMER_STATUS_CNT_ZERO, ENABLE);
;;;516    	
;;;517    	// Enable TIMER2 counter clock
;;;518    	TIMER_BRGInit(MDR_TIMER2,TIMER_HCLKdiv1);
000554  2100              MOVS     r1,#0
000556  486e              LDR      r0,|L1.1808|
000558  f7fffffe          BL       TIMER_BRGInit
;;;519    
;;;520    	// Enable TIMER2
;;;521    	TIMER_Cmd(MDR_TIMER2,ENABLE);
00055c  2101              MOVS     r1,#1
00055e  486c              LDR      r0,|L1.1808|
000560  f7fffffe          BL       TIMER_Cmd
;;;522    	
;;;523    	
;;;524    	
;;;525    	//======================= TIMER3 =======================//
;;;526    	// Timer3		CH1 	-> LPWM (LCD backlight PWM) 
;;;527    	//				CH3N	-> CPWM (System cooler PWM)
;;;528    	// TIMER_CLK = HCLK
;;;529    	// CLK = 2MHz
;;;530    	// PWM frequency = 20kHz
;;;531    	// PWM resolution = 100
;;;532    	
;;;533    	// Initialize timer 3 counter
;;;534    	TIMER_CntStructInit(&sTIM_CntInit);
000564  a80b              ADD      r0,sp,#0x2c
000566  f7fffffe          BL       TIMER_CntStructInit
;;;535    	sTIM_CntInit.TIMER_Prescaler                = 0xF;		// 2MHz at 32MHz core clk
00056a  200f              MOVS     r0,#0xf
00056c  f8ad002e          STRH     r0,[sp,#0x2e]
;;;536    	sTIM_CntInit.TIMER_Period                   = 99;			// 20kHz at 2MHz
000570  2063              MOVS     r0,#0x63
000572  f8ad0030          STRH     r0,[sp,#0x30]
;;;537    	TIMER_CntInit (MDR_TIMER3,&sTIM_CntInit);
000576  a90b              ADD      r1,sp,#0x2c
000578  4866              LDR      r0,|L1.1812|
00057a  f7fffffe          BL       TIMER_CntInit
;;;538    		
;;;539    	// Initialize timer 3 channel 1
;;;540    	TIMER_ChnStructInit(&sTIM_ChnInit);
00057e  a805              ADD      r0,sp,#0x14
000580  f7fffffe          BL       TIMER_ChnStructInit
;;;541    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL1;
000584  2000              MOVS     r0,#0
000586  f8ad0014          STRH     r0,[sp,#0x14]
;;;542    	sTIM_ChnInit.TIMER_CH_Mode                = TIMER_CH_MODE_PWM;
00058a  f8ad0016          STRH     r0,[sp,#0x16]
;;;543    	sTIM_ChnInit.TIMER_CH_REF_Format          = TIMER_CH_REF_Format6;
00058e  f44f6040          MOV      r0,#0xc00
000592  f8ad001e          STRH     r0,[sp,#0x1e]
;;;544    	sTIM_ChnInit.TIMER_CH_CCR_UpdateMode      = TIMER_CH_CCR_Update_On_CNT_eq_0;
000596  2008              MOVS     r0,#8
000598  f8ad0026          STRH     r0,[sp,#0x26]
;;;545    	TIMER_ChnInit(MDR_TIMER3, &sTIM_ChnInit);
00059c  a905              ADD      r1,sp,#0x14
00059e  485d              LDR      r0,|L1.1812|
0005a0  f7fffffe          BL       TIMER_ChnInit
;;;546    
;;;547    	// Initialize timer 3 channel 1 output
;;;548    	TIMER_ChnOutStructInit(&sTIM_ChnOutInit);
0005a4  4668              MOV      r0,sp
0005a6  f7fffffe          BL       TIMER_ChnOutStructInit
;;;549    	sTIM_ChnOutInit.TIMER_CH_Number                   = TIMER_CHANNEL1;
0005aa  2000              MOVS     r0,#0
0005ac  f8ad0000          STRH     r0,[sp,#0]
;;;550    	sTIM_ChnOutInit.TIMER_CH_DirOut_Source            = TIMER_CH_OutSrc_REF;
0005b0  2002              MOVS     r0,#2
0005b2  f8ad0004          STRH     r0,[sp,#4]
;;;551    	sTIM_ChnOutInit.TIMER_CH_DirOut_Polarity          = TIMER_CHOPolarity_NonInverted;
0005b6  2000              MOVS     r0,#0
0005b8  f8ad0002          STRH     r0,[sp,#2]
;;;552    	sTIM_ChnOutInit.TIMER_CH_DirOut_Mode              = TIMER_CH_OutMode_Output;
0005bc  2001              MOVS     r0,#1
0005be  f8ad0006          STRH     r0,[sp,#6]
;;;553    	TIMER_ChnOutInit(MDR_TIMER3, &sTIM_ChnOutInit);
0005c2  4669              MOV      r1,sp
0005c4  4853              LDR      r0,|L1.1812|
0005c6  f7fffffe          BL       TIMER_ChnOutInit
;;;554    
;;;555    	// Initialize timer 3 channel 3
;;;556    	sTIM_ChnInit.TIMER_CH_Number              = TIMER_CHANNEL3;
0005ca  2002              MOVS     r0,#2
0005cc  f8ad0014          STRH     r0,[sp,#0x14]
;;;557    	TIMER_ChnInit(MDR_TIMER3, &sTIM_ChnInit);
0005d0  a905              ADD      r1,sp,#0x14
0005d2  4850              LDR      r0,|L1.1812|
0005d4  f7fffffe          BL       TIMER_ChnInit
;;;558    	
;;;559    	// Initialize timer 3 channel 3 output
;;;560    	sTIM_ChnOutInit.TIMER_CH_Number           	= TIMER_CHANNEL3;
0005d8  2002              MOVS     r0,#2
0005da  f8ad0000          STRH     r0,[sp,#0]
;;;561    	sTIM_ChnOutInit.TIMER_CH_DirOut_Source      = TIMER_CH_OutSrc_Only_0;
0005de  2000              MOVS     r0,#0
0005e0  f8ad0004          STRH     r0,[sp,#4]
;;;562    	sTIM_ChnOutInit.TIMER_CH_DirOut_Mode        = TIMER_CH_OutMode_Input;
0005e4  f8ad0006          STRH     r0,[sp,#6]
;;;563    	sTIM_ChnOutInit.TIMER_CH_NegOut_Source     	= TIMER_CH_OutSrc_REF;
0005e8  2002              MOVS     r0,#2
0005ea  f8ad000a          STRH     r0,[sp,#0xa]
;;;564    	sTIM_ChnOutInit.TIMER_CH_NegOut_Polarity   	= TIMER_CHOPolarity_Inverted;
0005ee  2001              MOVS     r0,#1
0005f0  f8ad0008          STRH     r0,[sp,#8]
;;;565    	sTIM_ChnOutInit.TIMER_CH_NegOut_Mode       	= TIMER_CH_OutMode_Output;
0005f4  f8ad000c          STRH     r0,[sp,#0xc]
;;;566    	TIMER_ChnOutInit(MDR_TIMER3, &sTIM_ChnOutInit);
0005f8  4669              MOV      r1,sp
0005fa  4846              LDR      r0,|L1.1812|
0005fc  f7fffffe          BL       TIMER_ChnOutInit
;;;567    
;;;568    
;;;569    	// Set default PWM duty cycle for LCD backlight PWM	
;;;570    	MDR_TIMER3->CCR1 = 0;
000600  2000              MOVS     r0,#0
000602  4944              LDR      r1,|L1.1812|
000604  6108              STR      r0,[r1,#0x10]
;;;571    	
;;;572    	// Set default PWM duty cycle for system cooler PWM
;;;573    	MDR_TIMER3->CCR3 = 0;
000606  6188              STR      r0,[r1,#0x18]
;;;574    
;;;575    	// Enable TIMER3 counter clock
;;;576    	TIMER_BRGInit(MDR_TIMER3,TIMER_HCLKdiv1);
000608  2100              MOVS     r1,#0
00060a  4842              LDR      r0,|L1.1812|
00060c  f7fffffe          BL       TIMER_BRGInit
;;;577    
;;;578    	// Enable TIMER3
;;;579    	TIMER_Cmd(MDR_TIMER3,ENABLE);
000610  2101              MOVS     r1,#1
000612  4840              LDR      r0,|L1.1812|
000614  f7fffffe          BL       TIMER_Cmd
;;;580    	
;;;581    
;;;582    
;;;583    }
000618  b011              ADD      sp,sp,#0x44
00061a  bd00              POP      {pc}
;;;584    
                          ENDP

                  SetVoltagePWMPeriod PROC
;;;590    
;;;591    void SetVoltagePWMPeriod(uint16_t new_period)
00061c  493c              LDR      r1,|L1.1808|
;;;592    {
;;;593    	MDR_TIMER2->CCR1 = new_period;	
00061e  6108              STR      r0,[r1,#0x10]
;;;594    }
000620  4770              BX       lr
;;;595    
                          ENDP

                  SetCurrentPWMPeriod PROC
;;;596    void SetCurrentPWMPeriod(uint16_t new_period)
000622  493b              LDR      r1,|L1.1808|
;;;597    {
;;;598    	MDR_TIMER2->CCR3 = new_period;	
000624  6188              STR      r0,[r1,#0x18]
;;;599    }
000626  4770              BX       lr
;;;600    
                          ENDP

                  SetCoolerSpeed PROC
;;;605    
;;;606    void SetCoolerSpeed(uint16_t speed)
000628  493a              LDR      r1,|L1.1812|
;;;607    {
;;;608    	MDR_TIMER3->CCR3 = speed;
00062a  6188              STR      r0,[r1,#0x18]
;;;609    }
00062c  4770              BX       lr
;;;610    
                          ENDP

                  LcdSetBacklight PROC
;;;618    //==============================================================//
;;;619    void LcdSetBacklight(uint16_t value)
00062e  2864              CMP      r0,#0x64
;;;620    {
;;;621    	if (value>100) value = 100;
000630  dd00              BLE      |L1.1588|
000632  2064              MOVS     r0,#0x64
                  |L1.1588|
;;;622    		MDR_TIMER3->CCR1 = value;
000634  4937              LDR      r1,|L1.1812|
000636  6108              STR      r0,[r1,#0x10]
;;;623    }
000638  4770              BX       lr
;;;624    
                          ENDP

                  ProcessPowerOff PROC
;;;626    
;;;627    void ProcessPowerOff(void)
00063a  b538              PUSH     {r3-r5,lr}
;;;628    {
;;;629    	uint32_t time_delay;
;;;630    	if (GetACLineStatus() == OFFLINE)
00063c  f7fffffe          BL       GetACLineStatus
000640  2800              CMP      r0,#0
000642  d161              BNE      |L1.1800|
;;;631    	{	
;;;632    		__disable_irq();
000644  b672              CPSID    i
;;;633    
;;;634    		SetConverterState(CONVERTER_OFF);		// safe because we're stopping in this function
000646  2000              MOVS     r0,#0
000648  f7fffffe          BL       SetConverterState
;;;635    
;;;636    		//SysTickStop();
;;;637    		//StopBeep();
;;;638    
;;;639    		time_delay = DWT_StartDelayUs(5000);
00064c  f2413088          MOV      r0,#0x1388
000650  f7fffffe          BL       DWT_StartDelayUs
000654  4604              MOV      r4,r0
;;;640    
;;;641    		LcdSetBacklight(0);
000656  2000              MOVS     r0,#0
000658  f7fffffe          BL       LcdSetBacklight
;;;642    		SetCoolerSpeed(0);
00065c  2000              MOVS     r0,#0
00065e  f7fffffe          BL       SetCoolerSpeed
;;;643    		SetVoltagePWMPeriod(0);
000662  2000              MOVS     r0,#0
000664  f7fffffe          BL       SetVoltagePWMPeriod
;;;644    		SetCurrentPWMPeriod(0);
000668  2000              MOVS     r0,#0
00066a  f7fffffe          BL       SetCurrentPWMPeriod
;;;645    
;;;646    
;;;647    		// Put message
;;;648    		LcdFillBuffer(lcd0_buffer,0);
00066e  2100              MOVS     r1,#0
000670  4829              LDR      r0,|L1.1816|
000672  f7fffffe          BL       LcdFillBuffer
;;;649    		LcdFillBuffer(lcd1_buffer,0);
000676  2100              MOVS     r1,#0
000678  4828              LDR      r0,|L1.1820|
00067a  f7fffffe          BL       LcdFillBuffer
;;;650    		LcdPutNormalStr(0,10,"Power OFF",(tNormalFont*)&font_8x12,lcd0_buffer);
00067e  4826              LDR      r0,|L1.1816|
000680  4b27              LDR      r3,|L1.1824|
000682  a228              ADR      r2,|L1.1828|
000684  210a              MOVS     r1,#0xa
000686  9000              STR      r0,[sp,#0]
000688  2000              MOVS     r0,#0
00068a  f7fffffe          BL       LcdPutNormalStr
;;;651    		LcdPutNormalStr(0,10,"Power OFF",(tNormalFont*)&font_8x12,lcd1_buffer);
00068e  4823              LDR      r0,|L1.1820|
000690  4b23              LDR      r3,|L1.1824|
000692  a224              ADR      r2,|L1.1828|
000694  210a              MOVS     r1,#0xa
000696  9000              STR      r0,[sp,#0]
000698  2000              MOVS     r0,#0
00069a  f7fffffe          BL       LcdPutNormalStr
;;;652    
;;;653    
;;;654    
;;;655    		while(DWT_DelayInProgress(time_delay));
00069e  bf00              NOP      
                  |L1.1696|
0006a0  4620              MOV      r0,r4
0006a2  f7fffffe          BL       DWT_DelayInProgress
0006a6  2800              CMP      r0,#0
0006a8  d1fa              BNE      |L1.1696|
;;;656    
;;;657    		SetFeedbackChannel(CHANNEL_12V);
0006aa  f7fffffe          BL       SetFeedbackChannel
;;;658    		SetCurrentLimit(CURRENT_LIM_HIGH); 
0006ae  2001              MOVS     r0,#1
0006b0  f7fffffe          BL       SetCurrentLimit
;;;659    		SetOutputLoad(LOAD_DISABLE); 
0006b4  2001              MOVS     r0,#1
0006b6  f7fffffe          BL       SetOutputLoad
;;;660    
;;;661    		LcdUpdateByCore(LCD0,lcd0_buffer);
0006ba  4917              LDR      r1,|L1.1816|
0006bc  2001              MOVS     r0,#1
0006be  f7fffffe          BL       LcdUpdateByCore
;;;662    		LcdUpdateByCore(LCD1,lcd1_buffer);
0006c2  4916              LDR      r1,|L1.1820|
0006c4  2002              MOVS     r0,#2
0006c6  f7fffffe          BL       LcdUpdateByCore
;;;663    
;;;664    
;;;665    
;;;666    		time_delay = DWT_StartDelayUs(1000);
0006ca  f44f707a          MOV      r0,#0x3e8
0006ce  f7fffffe          BL       DWT_StartDelayUs
0006d2  4604              MOV      r4,r0
;;;667    		while(DWT_DelayInProgress(time_delay));
0006d4  bf00              NOP      
                  |L1.1750|
0006d6  4620              MOV      r0,r4
0006d8  f7fffffe          BL       DWT_DelayInProgress
0006dc  2800              CMP      r0,#0
0006de  d1fa              BNE      |L1.1750|
;;;668    
;;;669    		PORT_DeInit(MDR_PORTA);
0006e0  4813              LDR      r0,|L1.1840|
0006e2  f7fffffe          BL       PORT_DeInit
;;;670    		PORT_DeInit(MDR_PORTB);
0006e6  4813              LDR      r0,|L1.1844|
0006e8  f7fffffe          BL       PORT_DeInit
;;;671    		PORT_DeInit(MDR_PORTC);
0006ec  4812              LDR      r0,|L1.1848|
0006ee  f7fffffe          BL       PORT_DeInit
;;;672    		PORT_DeInit(MDR_PORTD);
0006f2  4812              LDR      r0,|L1.1852|
0006f4  f7fffffe          BL       PORT_DeInit
;;;673    		PORT_DeInit(MDR_PORTE);
0006f8  4811              LDR      r0,|L1.1856|
0006fa  f7fffffe          BL       PORT_DeInit
;;;674    		PORT_DeInit(MDR_PORTF);
0006fe  4811              LDR      r0,|L1.1860|
000700  f7fffffe          BL       PORT_DeInit
;;;675    
;;;676    		while(1);
000704  bf00              NOP      
                  |L1.1798|
000706  e7fe              B        |L1.1798|
                  |L1.1800|
;;;677    		 
;;;678    	}
;;;679    }
000708  bd38              POP      {r3-r5,pc}
;;;680    	
                          ENDP

00070a  0000              DCW      0x0000
                  |L1.1804|
                          DCD      0x40070000
                  |L1.1808|
                          DCD      0x40078000
                  |L1.1812|
                          DCD      0x40080000
                  |L1.1816|
                          DCD      lcd0_buffer
                  |L1.1820|
                          DCD      lcd1_buffer
                  |L1.1824|
                          DCD      font_8x12
                  |L1.1828|
000724  506f7765          DCB      "Power OFF",0
000728  72204f46
00072c  4600    
00072e  00                DCB      0
00072f  00                DCB      0
                  |L1.1840|
                          DCD      0x400a8000
                  |L1.1844|
                          DCD      0x400b0000
                  |L1.1848|
                          DCD      0x400b8000
                  |L1.1852|
                          DCD      0x400c0000
                  |L1.1856|
                          DCD      0x400c8000
                  |L1.1860|
                          DCD      0x400e8000

;*** Start embedded assembler ***

#line 1 "src\\systemfunc.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_systemfunc_c_b744d595____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_systemfunc_c_b744d595____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_systemfunc_c_b744d595____REVSH|
#line 130
|__asm___12_systemfunc_c_b744d595____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
