L 1 "src\gui\guiGraphics\guiGraphWidgets.c"
N/**********************************************************
N  Module guiGraphWidgets contains functions for drawing widgets. (hi, Cap!)
N
N
N
N**********************************************************/
N
N#include <stdint.h>
L 1 "C:\Keil\ARM\RV31\Inc\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 137748 $
N * Checkin $Date: 2008-09-11 17:34:24 +0100 (Thu, 11 Sep 2008) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
L 9 "src\gui\guiGraphics\guiGraphWidgets.c" 2
N#include "guiGraphHAL.h"
L 1 "src\gui\guiGraphics\guiGraphHAL.h" 1
N#ifndef __GUI_GRAPH_HAL_
N#define __GUI_GRAPH_HAL_
N
N#include <stdint.h>
N
N
N// Size definitions in points for Nokia 1202 LCD
N#define LCD_XSIZE (2*96)
N#define LCD_YSIZE 68
N
N// Buffer size in bytes
N#define LCD_BUFFER_SIZE (2*96*9)
N
N/*
N// Size definitions in points
N#define LCD_XSIZE (2*128)
N#define LCD_YSIZE 128
N
N// Buffer size in bytes
N#define LCD_BUFFER_SIZE (LCD_XSIZE * 16)
N*/
N
N// LCD functions settings
N//#define SOFT_HORIZ_REVERSED
N
N// counter increments from 0 to LCD_xxx_PERIOD-1
N// if counter < LCD_xxx_COMPARE, pixel is put unchaged
N// if counter >= LCD_xxx_COMPARE, pixel is put inversed
N#define LCD_DOT_PERIOD      4
N#define LCD_DOT_COMPARE     2
N#define LCD_DASH_PERIOD     7
N#define LCD_DASH_COMPARE    5
N
N
N
N
N// Pixel output modes
N#define PIXEL_MODE_REWRITE  0x00
N#define PIXEL_MODE_AND      0x01
N#define PIXEL_MODE_OR       0x02
N#define PIXEL_MODE_XOR      0x03
N
N// Image output modes
N#define IMAGE_MODE_NORMAL    0x01
N#define IMAGE_MODE_INVERSE   0x00
N// Aliases for fill rect
N#define FILL_WITH_BLACK      0x01
N#define FILL_WITH_WHITE      0x00
N
N#define LCD_FillRect(x_pos, y_pos, width, height, mode) \
N    LCD_DrawImage(0, x_pos, y_pos, width, height, mode)
X#define LCD_FillRect(x_pos, y_pos, width, height, mode)     LCD_DrawImage(0, x_pos, y_pos, width, height, mode)
N
N
N// Line drawing mode (not for all functions)
N#define LINE_STYLE_SOLID      0x10
N#define LINE_STYLE_DASHED     0x20
N#define LINE_STYLE_DOTTED     0x30
N
N
N
N
N
Nextern uint8_t lcdBuffer[LCD_BUFFER_SIZE];
Xextern uint8_t lcdBuffer[(2*96*9)];
Nextern uint8_t LCD_lineStyle;
N
Nvoid LCD_SetPixelOutputMode(uint8_t newMode);
Nvoid LCD_SetLineStyle(uint8_t newStyle);
N
Nvoid LCD_FillWholeBuffer(uint8_t pixelValue);
Nvoid LCD_PutPixel (uint8_t x_pos, uint8_t y_pos, uint8_t pixelValue);
Nvoid LCD_DrawHorLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t pixelValue);
Nvoid LCD_DrawVertLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t pixelValue);
N
Nvoid LCD_DrawImage(const uint8_t* img, uint8_t x_pos, uint8_t y_pos, uint8_t width, uint8_t height, uint8_t mode);
N
N
N#endif
L 10 "src\gui\guiGraphics\guiGraphWidgets.c" 2
N#include "guiGraphPrimitives.h"
L 1 "src\gui\guiGraphics\guiGraphPrimitives.h" 1
N#ifndef __GUI_GRAPH_PRIMITIVES_H_
N#define __GUI_GRAPH_PRIMITIVES_H_
N
N#include <stdint.h>
N#include "guiGraphHAL.h"
N#include "guiFonts.h"
L 1 "src\gui\guiGraphics\guiFonts.h" 1
N#ifndef __GUI_FONTS_H_
N#define __GUI_FONTS_H_
N
N#include <stdint.h>
N
N/*
N    A font may have all chars present, or only some subset of chars.
N    If a font has contiguous set of chars, starting with some char code,
N    it is indicated by setting charTable to 0 and defining firstCharCode value.
N    Field charCount tells how many chars the font has.
N    Accessing some char with char code c in this case is trivial and looks like this:
N        c -= font.firstCharCode;
N        char_data = font.data[c * font.bytesPerChar];
N    If a font has non-contiguous set of chars, their char codes are specified in codeTable,
N    and offset relative to font.data is specified in offsetTable.
N
N    A font may be monospaced or variable-spaced.
N    If a font is monospaced, widthTable must be set to 0. All chars will have the same width = font.width.
N    If font is variable-spaced, widthTable is used - it contains width for every char.
N
N    If font has non-contiguous set of chars, or font is variable-spaced, font processing routines need to know,
N    where particular char image is located. This information provides offsetTable.
N
N    So, a font can be one of the following:
N        - monospaced, char subset is contiguous:
N            codeTable:      -
N            widthTable:     -
N            offsetTable:    -
N        - monospaced, char subset is non-contiguous:
N            codeTable:      present
N            widthTable:     -
N            offsetTable:    present
N        - variable-spaced, char subset is contiguous:
N            codeTable:      -
N            widthTable:     present
N            offsetTable:    present
N        - variable-spaced, char subset is non-contiguous:
N            codeTable:      present
N            widthTable:     present
N            offsetTable:    present
N
N        Font MUST have valid offsetTable when codeTable or widthTable are used.
N*/
N
N
N//---------------------------------------------//
N// Fonts typedefs
N
Ntypedef struct 
N{
N    uint8_t height;                     // font chars height
N    uint8_t width;                      // actual for monospaced, ignored for variable-width fonts
N    uint8_t charCount;                  // Total number of chars in the font
N    uint8_t spacing;                    // Additional space between chars
N    uint8_t bytesPerChar;               // Actual for monospaced, ignored for variable-length fonts
N    uint8_t firstCharCode;              // Used if there is no charTable - specifies first avaliable char code in the font.
N    const uint8_t *codeTable;           // Used if not all symbols are prensent in the font. Otherwise must be 0.
N    const uint8_t *widthTable;          // Used if font is not monospaced. Otherwise must be 0.
N    const uint16_t *offsetTable;        // Used with codeTable or widthTable
N    const uint8_t *data;                // Font data - contiguous byte array
N} tFont;
N
N
Nextern const tFont font_h11;
Nextern const tFont font_h32;
Nextern const tFont font_h10;
Nextern const tFont font_h10_bold;
Nextern const tFont font_6x8_mono;
Nextern const tFont font_h16;
N
N
N#endif
L 7 "src\gui\guiGraphics\guiGraphPrimitives.h" 2
N
N// Align modes - required alignment mode is selected by
N// combining these flags
N#define ALIGN_CENTER    0x00
N#define ALIGN_LEFT      0x01
N#define ALIGN_RIGHT     0x02
N#define ALIGN_TOP       0x04
N#define ALIGN_BOTTOM    0x08
N// Aliases
N#define ALIGN_TOP_LEFT      (ALIGN_TOP | ALIGN_LEFT)
N#define ALIGN_BOTTOM_LEFT   (ALIGN_BOTTOM | ALIGN_LEFT)
N#define ALIGN_TOP_RIGHT     (ALIGN_TOP | ALIGN_RIGHT)
N#define ALIGN_BOTTOM_RIGHT   (ALIGN_BOTTOM | ALIGN_RIGHT)
N
N
Ntypedef struct {
N    uint8_t x1;
N    uint8_t y1;
N    uint8_t x2;
N    uint8_t y2;
N} rect_t;
N
N
Nextern const tFont* LCD_currentFont;
N
Nvoid LCD_SetFont(const tFont *newFont);
N
Nvoid LCD_DrawRect(uint8_t x_pos, uint8_t y_pos, uint8_t width, uint8_t height, uint8_t pixelValue);
Nuint8_t LCD_GetFontItem(const tFont *font, uint8_t code, uint8_t *width, uint16_t *offset);
Nvoid LCD_PrintString(char *str, uint8_t x, uint8_t y, uint8_t mode);
Nvoid LCD_PrintStringAligned(char *str, rect_t *rect, uint8_t alignment, uint8_t mode);
Nvoid LCD_DrawLine(int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint8_t mode);
N
N
N#endif
L 11 "src\gui\guiGraphics\guiGraphWidgets.c" 2
N#include "guiGraphWidgets.h"
L 1 "src\gui\guiGraphics\guiGraphWidgets.h" 1
N#ifndef __GUI_GRAPH_WIDGETS_
N#define __GUI_GRAPH_WIDGETS_
N
N#include <stdint.h>
N#include "guiGraphPrimitives.h"
N#include "guiWidgets.h"
L 1 ".\src\gui\guiWidgets\guiWidgets.h" 1
N/**********************************************************
N    Module guiWidgets contains widget typedefs and
N  common data
N
N
N
N**********************************************************/
N
N#ifndef __GUI_WIDGETS_H_
N#define __GUI_WIDGETS_H_
N
N#include <stdint.h>
N#include "guiEvents.h"
L 1 ".\src\gui\guiCore\guiEvents.h" 1
N#ifndef __GUI_EVENTS_H_
N#define __GUI_EVENTS_H_
N
N#include <stdint.h>
N
N
N// Event types for widgets
N#define GUI_EVENT_DRAW          0x01
N#define GUI_EVENT_INIT          0x02
N#define GUI_EVENT_UPDATE        0x04
N#define GUI_EVENT_HIDE          0x06
N#define GUI_EVENT_SHOW          0x07
N#define GUI_EVENT_UNFOCUS       0x08
N#define GUI_EVENT_FOCUS         0x09
N#define GUI_EVENT_TOUCH         0x0A
N#define GUI_EVENT_KEY           0x0B
N#define GUI_EVENT_ENCODER       0x0C
N#define GUI_EVENT_TIMER         0x0D
N
N// Event types for callbacks (common widget event handlers)
N#define GUI_ON_FOCUS_CHANGED    0x80
N#define GUI_ON_VISIBLE_CHANGED  0x82
N#define GUI_ON_TOUCH_EVENT      0x83
N
N// Event types, specific for widgets start with 0xC0 and can overlap for different widgets.
N// Those types are declared in widget's header files.
N
N
N// Event struct, common for all GUI elements
Ntypedef struct {
N    uint8_t type;
N    uint8_t spec;
N    uint16_t lparam;
N    uint16_t hparam;
N} guiEvent_t;
N
N
N
N
N// Events are found in guiCore.c
Nextern const guiEvent_t guiEvent_DRAW;
Nextern const guiEvent_t guiEvent_DRAW_ALL;
Nextern const guiEvent_t guiEvent_SELECT;
Nextern const guiEvent_t guiEvent_DESELECT;
Nextern const guiEvent_t guiEvent_UPDATE;
Nextern const guiEvent_t guiEvent_HIDE;
Nextern const guiEvent_t guiEvent_SHOW;
N
N
N
N#endif
L 14 ".\src\gui\guiWidgets\guiWidgets.h" 2
N#include "guiFonts.h"
N
N
N// Widget types
N#define WT_PANEL       0x01
N#define WT_BUTTON      0x02
N#define WT_CHECKBOX    0x03
N#define WT_RADIOBUTTON 0x04
N#define WT_TEXTLABEL   0x05
N#define WT_SPINBOX     0x06
N
N
N
N
N// Event handler record
Ntypedef struct {
N    uint8_t eventType;                                         // Event type
N    uint8_t (*handler)(void *sender, guiEvent_t *event);       // Related callback function pointer
N} guiWidgetHandler_t;
N
N// Event handlers table
Ntypedef struct {
N    uint8_t count;                      // Count of handler records
N    guiWidgetHandler_t *elements;       // Pointer to array of handler records
N} guiHandlerTable_t;
N
N// Widget collection type - used by containers
Ntypedef struct {
N    uint8_t count;
N    uint8_t focusedIndex;
N    uint8_t traverseIndex;              // Required by core for tree traverse
N    void **elements;
N} guiWidgetCollection_t;
N
N
N
N// Basic widget type - all widget types MUST have all fields in their typedef beginning
Ntypedef struct guiGenericWidget_t {
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;     // If set, widget will be sent UPDATE event.
N                                    //   Update mechanism can be used for widget's
N                                    //   internal state processing - cursor blink, etc
N    uint8_t redrawRequired : 1;     // If this flag is set, widget will be sent DRAW event.
N                                    //   Widget should set this flag itself.
N    uint8_t redrawForced : 1;       // This flag is set by GUI core when widget must be redrawn
N                                    //   redrawRequired is set along with redrawForced.
N    uint8_t redrawFocus : 1;        // Flag is set when widget focus must be redrawn.
N                                    //   redrawRequired is set along with redrawFocus.
N    uint8_t showFocus : 1;          // If set, widget will display focus
N    uint8_t keepTouch : 1;          // Flags is set if widget requires all touch events
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N} guiGenericWidget_t;
N
N
N// Basic container type - extends guiGenericWidget_t
Ntypedef struct guiGenericContainer_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    guiWidgetCollection_t widgets;
N
N} guiGenericContainer_t;
N
N
N
Ntypedef struct guiPanel_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    guiWidgetCollection_t widgets;
N    uint8_t focusFallsThrough : 1;
N    uint8_t frame : 3;
N    // uint8_t focusIsKeptOnChilds : 1;      // doesn't let unfocus child widgets when focusFallsThrough is set. CHECKME
N
N} guiPanel_t;
N
N
N
Ntypedef struct guiTextLabel_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    char *text;
N    const tFont *font;
N    uint8_t textAlignment;
N    uint8_t hasFrame : 1;
N    uint8_t redrawText : 1;
N
N} guiTextLabel_t;
N
N
Ntypedef struct guiCheckBox_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    char *text;
N    const tFont *font;
N    uint8_t textAlignment;
N    uint8_t hasFrame : 1;
N    uint8_t isChecked : 1;
N    uint8_t redrawCheckedState : 1;
N
N} guiCheckBox_t;
N
N
Ntypedef struct guiButton_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    char *text;
N    const tFont *font;
N    uint8_t textAlignment;
N    uint8_t redrawPressedState : 1;
N    uint8_t isPressed : 1;
N    uint8_t isToggle : 1;
N    uint8_t isPressOnly : 1;
N
N} guiButton_t;
N
N
N
Ntypedef struct guiRadioButton_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    char *text;
N    const tFont *font;
N    uint8_t textAlignment;
N    uint8_t redrawCheckedState : 1;
N    uint8_t radioIndex;
N    uint8_t isChecked : 1;
N
N
N} guiRadioButton_t;
N
N#define SPINBOX_STRING_LENGTH  12  // long enough to hold INT32_MAX and INT32_MIN + \0
Ntypedef struct guiSpinBox_t {
N    //----- Inherited from generic widget -----//
N    // Widget type (starting with WT_)
N    uint8_t type;
N    // Pointer to parent widget
N    struct guiGenericWidget_t *parent;
N    // Bit properties:
N    uint8_t acceptFocusByTab : 1;
N    uint8_t acceptTouch : 1;
N    uint8_t isContainer : 1;
N    // Bit state flags:
N    uint8_t isFocused : 1;
N    uint8_t isVisible : 1;
N    uint8_t updateRequired : 1;
N    uint8_t redrawRequired : 1;
N    uint8_t redrawForced : 1;
N    uint8_t redrawFocus : 1;
N    uint8_t showFocus : 1;
N    uint8_t keepTouch : 1;
N    // Properties
N    uint8_t tag;
N    uint8_t tabIndex;
N    int16_t x;
N    int16_t y;
N    uint16_t width;
N    uint16_t height;
N    // Event processing function
N    uint8_t (*processEvent)(struct guiGenericWidget_t *pWidget, guiEvent_t event);
N    // Handler table
N    guiHandlerTable_t handlers;
N    //-----------------------------------------//
N
N    //char text[SPINBOX_STRING_LENGTH];
N    const tFont *font;
N    //uint8_t textAlignment;
N    uint8_t hasFrame : 1;
N    uint8_t redrawValue : 1;
N    uint8_t redrawDigitSelection : 1;
N    uint8_t isActive : 1;
N    uint8_t restoreValueOnEscape : 1;
N    uint8_t newValueAccepted : 1;
N    uint8_t minDigitsToDisplay;
N    uint8_t activeDigit;
N    int8_t dotPosition;
N    int32_t value;
N    int32_t savedValue;
N    int32_t maxValue;
N    int32_t minValue;
N    char text[SPINBOX_STRING_LENGTH];
X    char text[12];
N    uint8_t digitsToDisplay;
N    int8_t textRightOffset;
N    int8_t textTopOffset;
N
N
N
N} guiSpinBox_t;
N
N
N
N
N
N#endif
L 7 "src\gui\guiGraphics\guiGraphWidgets.h" 2
N
N
N
N#define FRAME_NONE                      0x00
N#define FRAME3D_RAISED                  0x01
N#define FRAME3D_SUNKEN                  0x02
N#define FRAME_SINGLE                    0x03
N
N
N// Widget Appearance
N
N//---------------------------------------------//
N// Checkbox
N#define CHECKBOX_GRAPH_XSIZE  10
N#define CHECKBOX_GRAPH_YSIZE  10
N#define CHECKBOX_TEXT_MARGIN  6
N#define CHECKBOX_IMG_CHECKED  checkbox_10x10_checked
N#define CHECKBOX_IMG_EMPTY  checkbox_10x10_empty
N
N
N//---------------------------------------------//
N// Textlabel
N#define TEXT_LABEL_TEXT_MARGIN  0
N
N
N//---------------------------------------------//
N// SpinBox
N#define SPINBOX_ACTIVE_UNDERLINE_MARGIN 1
N#define SPINBOX_ACTIVE_UNDERLINE_WIDTH 2
N
N
N
N
Nextern int16_t wx;
Nextern int16_t wy;
N
Nvoid guiGraph_SetBaseXY(int16_t x, int16_t y);
Nvoid guiGraph_OffsetBaseXY(int16_t dx, int16_t dy);
N
N
Nvoid guiGraph_DrawPanel(guiPanel_t *panel);
Nvoid guiGraph_DrawTextLabel(guiTextLabel_t *textLabel);
Nvoid guiGraph_DrawCheckBox(guiCheckBox_t * checkBox);
Nvoid guiGraph_DrawSpinBox(guiSpinBox_t * spinBox);
N
N
N
N#endif
L 12 "src\gui\guiGraphics\guiGraphWidgets.c" 2
N#include "guiFonts.h"
N#include "guiImages.h"
L 1 "src\gui\guiGraphics\guiImages.h" 1
N#ifndef __GUI_IMAGES_H_
N#define __GUI_IMAGES_H_
N
N#include <stdint.h>
N
N
N
Nextern uint8_t checkbox_10x10_checked[];
Nextern uint8_t checkbox_10x10_empty[];
Nextern uint8_t selector_tri[];
N
N
N
N#endif
L 14 "src\gui\guiGraphics\guiGraphWidgets.c" 2
N
N#include "guiWidgets.h"
N#include "guiTextLabel.h"
L 1 ".\src\gui\guiWidgets\guiTextLabel.h" 1
N#ifndef __GUI_TEXT_LABEL_H_
N#define __GUI_TEXT_LABEL_H_
N
N#include <stdint.h>
N#include "guiWidgets.h"
N
N
N
N// Widget-specific state checks
N#define TEXTLABEL_ACCEPTS_FOCUS_EVENT(label)  ( (label->isVisible) && (1) )    // TODO - add isEnabled
N
N
Nvoid guiTextLabel_Initialize(guiTextLabel_t *textLabel, guiGenericWidget_t *parent);
Nuint8_t guiTextLabel_ProcessEvent(guiGenericWidget_t *widget, guiEvent_t event);
N
N
N
N#endif
L 17 "src\gui\guiGraphics\guiGraphWidgets.c" 2
N//#include "guiCheckBox.h"
N
N
N
N
Nint16_t wx;
Nint16_t wy;
N
N
N//-------------------------------------------------------//
N// Sets point (0,0) of coordinate system
N// Parameters x and y must be absolute values
N// Widget's geometry is relative to (wx,wy)
N//-------------------------------------------------------//
Nvoid guiGraph_SetBaseXY(int16_t x, int16_t y)
N{
N    wx = x;
N    wy = y;
N}
N
N//-------------------------------------------------------//
N// Sets point (0,0) of coordinate system
N//-------------------------------------------------------//
Nvoid guiGraph_OffsetBaseXY(int16_t dx, int16_t dy)
N{
N    wx += dx;
N    wy += dy;
N}
N
N
N/*
N        There are two sources of widget redraw requests:
N
N        First one is the widget itself - if some widget internal state is changed, it sets "redrawRequired" flag,
N    thus indicating the core it's need to redraw. Widget also sets some internal redraw flags, which are analyzed
N    only in appropriate draw function.
N
N        Second is the GUI core. When GUI core discovers that widget should be redrawn by parent request, or for
N    other reason, the core sets both "redrawRequired" and "redrawForced" flags.
N
N    The "redrawForced" flag is set and cleared by core itself. The "redrawRequired" can be set by
N    both GUI core and widget, but it should be cleared by widget after completing draw procedure and
N    executing callback function.
N
N*/
N
N
N//-------------------------------------------------------//
N// Draw a panel
N//
N//
N//-------------------------------------------------------//
Nvoid guiGraph_DrawPanel(guiPanel_t *panel)
N{
N
N    //-----------------------------------------//
N    // Draw background
N    if (panel->redrawForced)
N    {
N        // Erase rectangle
N        LCD_SetPixelOutputMode(PIXEL_MODE_REWRITE);
X        LCD_SetPixelOutputMode(0x00);
N        LCD_FillRect(wx,wy,panel->width,panel->height,FILL_WITH_WHITE);
X        LCD_DrawImage(0, wx, wy, panel->width, panel->height, 0x00);
N    }
N
N
N    //-----------------------------------------//
N    // Draw focus / frame
N    if (((panel->redrawForced) || (panel->redrawFocus))  &&
N        (panel->showFocus))
N    {
N        LCD_SetPixelOutputMode(PIXEL_MODE_REWRITE);
X        LCD_SetPixelOutputMode(0x00);
N        if (panel->isFocused)
N        {
N            LCD_SetLineStyle(LINE_STYLE_DOTTED);
X            LCD_SetLineStyle(0x30);
N            LCD_DrawRect(wx,wy,panel->width,panel->height,1);
N        }
N        else
N        {
N            LCD_SetLineStyle(LINE_STYLE_SOLID);
X            LCD_SetLineStyle(0x10);
N            if (panel->frame)
N                LCD_DrawRect(wx,wy,panel->width,panel->height,1);
N            else
N                LCD_DrawRect(wx,wy,panel->width,panel->height,0);
N        }
N    }
N}
N
N
N
N//-------------------------------------------------------//
N// Draw a textLabel
N//
N//
N//-------------------------------------------------------//
Nvoid guiGraph_DrawTextLabel(guiTextLabel_t *textLabel)
N{
N    rect_t rect;
N
N    //-----------------------------------------//
N    // Draw background and text
N    if ((textLabel->redrawForced) || (textLabel->redrawText))
N    {
N        // Erase rectangle
N        LCD_SetPixelOutputMode(PIXEL_MODE_REWRITE);
X        LCD_SetPixelOutputMode(0x00);
N        LCD_FillRect(wx,wy,textLabel->width-1,textLabel->height-1,FILL_WITH_WHITE);
X        LCD_DrawImage(0, wx, wy, textLabel->width-1, textLabel->height-1, 0x00);
N
N        // Draw string
N        if (textLabel->text)
N        {
N            LCD_SetPixelOutputMode(PIXEL_MODE_OR);
X            LCD_SetPixelOutputMode(0x02);
N            LCD_SetFont(textLabel->font);
N            rect.x1 = wx + 0 + TEXT_LABEL_TEXT_MARGIN;
X            rect.x1 = wx + 0 + 0;
N            rect.y1 = wy + 0;
N            rect.x2 = wx + textLabel->width - 1 - TEXT_LABEL_TEXT_MARGIN;
X            rect.x2 = wx + textLabel->width - 1 - 0;
N            rect.y2 = wy + textLabel->height - 1;
N            LCD_PrintStringAligned(textLabel->text, &rect, textLabel->textAlignment, IMAGE_MODE_NORMAL);
X            LCD_PrintStringAligned(textLabel->text, &rect, textLabel->textAlignment, 0x01);
N        }
N    }
N
N    //-----------------------------------------//
N    // Draw focus
N    if (((textLabel->redrawForced) || (textLabel->redrawFocus)) &&
N        (textLabel->showFocus))
N    {
N        LCD_SetPixelOutputMode(PIXEL_MODE_REWRITE);
X        LCD_SetPixelOutputMode(0x00);
N        if (textLabel->isFocused)
N        {
N            LCD_SetLineStyle(LINE_STYLE_DOTTED);
X            LCD_SetLineStyle(0x30);
N            LCD_DrawRect(wx,wy,textLabel->width,textLabel->height,1);
N        }
N        else
N        {
N            LCD_SetLineStyle(LINE_STYLE_SOLID);
X            LCD_SetLineStyle(0x10);
N            if (textLabel->hasFrame)
N                LCD_DrawRect(wx,wy,textLabel->width,textLabel->height,1);
N            else
N                LCD_DrawRect(wx,wy,textLabel->width,textLabel->height,0);
N        }
N    }
N}
N
N
N
Nvoid guiGraph_DrawCheckBox(guiCheckBox_t * checkBox)
N{
N    int8_t y_aligned;
N    rect_t rect;
N    uint8_t *img;
N
N    y_aligned = checkBox->height - CHECKBOX_GRAPH_YSIZE;
X    y_aligned = checkBox->height - 10;
N    y_aligned /= 2;
N    y_aligned = wy + y_aligned;
N
N    //-----------------------------------------//
N    // Draw background
N    if (checkBox->redrawForced)
N    {
N        // Erase rectangle
N        LCD_SetPixelOutputMode(PIXEL_MODE_REWRITE);
X        LCD_SetPixelOutputMode(0x00);
N        LCD_FillRect(wx+1,wy+1,checkBox->width-2,checkBox->height-2,FILL_WITH_WHITE);
X        LCD_DrawImage(0, wx+1, wy+1, checkBox->width-2, checkBox->height-2, 0x00);
N
N        // Draw string
N        if (checkBox->text)
N        {
N            LCD_SetPixelOutputMode(PIXEL_MODE_OR);
X            LCD_SetPixelOutputMode(0x02);
N            LCD_SetFont(checkBox->font);
N            rect.x1 = wx + 2 + CHECKBOX_TEXT_MARGIN + CHECKBOX_GRAPH_XSIZE;
X            rect.x1 = wx + 2 + 6 + 10;
N            rect.y1 = wy + 1;
N            rect.x2 = wx + checkBox->width - 2;
N            rect.y2 = wy + checkBox->height - 2;
N            LCD_PrintStringAligned(checkBox->text, &rect, checkBox->textAlignment, IMAGE_MODE_NORMAL);
X            LCD_PrintStringAligned(checkBox->text, &rect, checkBox->textAlignment, 0x01);
N        }
N
N        // Draw rectangle frame
N        //LCD_SetPixelOutputMode(PIXEL_MODE_REWRITE);
N        //LCD_DrawRect(wx + 2,y_aligned,CHECKBOX_GRAPH_XSIZE,CHECKBOX_GRAPH_YSIZE,1);
N    }
N
N
N    //-----------------------------------------//
N    // Draw focus / frame
N    if ((checkBox->redrawForced) || (checkBox->redrawFocus))
N    {
N        LCD_SetPixelOutputMode(PIXEL_MODE_REWRITE);
X        LCD_SetPixelOutputMode(0x00);
N        if (checkBox->isFocused)
N        {
N            LCD_SetLineStyle(LINE_STYLE_DOTTED);
X            LCD_SetLineStyle(0x30);
N            LCD_DrawRect(wx,wy,checkBox->width,checkBox->height,1);
N        }
N        else
N        {
N            LCD_SetLineStyle(LINE_STYLE_SOLID);
X            LCD_SetLineStyle(0x10);
N            if (checkBox->hasFrame)
N                LCD_DrawRect(wx,wy,checkBox->width,checkBox->height,1);
N            else
N                LCD_DrawRect(wx,wy,checkBox->width,checkBox->height,0);
N        }
N    }
N
N
N    //-----------------------------------------//
N    // Draw focus / frame
N    if ((checkBox->redrawForced) || (checkBox->redrawCheckedState))
N    {
N        LCD_SetPixelOutputMode(PIXEL_MODE_REWRITE);
X        LCD_SetPixelOutputMode(0x00);
N        img = (checkBox->isChecked) ? CHECKBOX_IMG_CHECKED :
X        img = (checkBox->isChecked) ? checkbox_10x10_checked :
N                                      CHECKBOX_IMG_EMPTY;
X                                      checkbox_10x10_empty;
N        LCD_DrawImage(img,wx+2,y_aligned,CHECKBOX_GRAPH_XSIZE, CHECKBOX_GRAPH_YSIZE,IMAGE_MODE_NORMAL);
X        LCD_DrawImage(img,wx+2,y_aligned,10, 10,0x01);
N    }
N
N}
N
N
N
N
Nvoid guiGraph_DrawSpinBox(guiSpinBox_t * spinBox)
N{
N    uint8_t frameStyle;
N    uint8_t framePixelValue;
N    uint8_t charIndex;
N    uint8_t charWidth;
N    uint16_t charOffset;
N    int8_t i;
N    int16_t x,y, y_underline;
N    uint8_t numDigits;
N    char c;
N
N    LCD_SetPixelOutputMode(PIXEL_MODE_REWRITE);
X    LCD_SetPixelOutputMode(0x00);
N
N    //-----------------------------------------//
N    // Draw background
N    if ((spinBox->redrawForced) || (spinBox->redrawValue) || (spinBox->redrawDigitSelection))
N    {
N        // Erase rectangle
N        LCD_FillRect(wx+1,wy+1,spinBox->width-2,spinBox->height-2,FILL_WITH_WHITE);
X        LCD_DrawImage(0, wx+1, wy+1, spinBox->width-2, spinBox->height-2, 0x00);
N    }
N
N
N    //-----------------------------------------//
N    // Draw text value
N    if ((spinBox->redrawForced) || (spinBox->redrawValue) || (spinBox->redrawDigitSelection))
N    {
N        x = wx + spinBox->width - 1 + spinBox->textRightOffset;
N        y = wy + spinBox->textTopOffset;
N
N        i = 0;
N        charIndex = 0;
N        // Add one extra digit for minus sign
N        numDigits = (spinBox->value >= 0) ? spinBox->digitsToDisplay : spinBox->digitsToDisplay + 1;
N
N        while(charIndex < numDigits)
N        {
N            c = (i == spinBox->dotPosition) ? '.' : spinBox->text[SPINBOX_STRING_LENGTH - 1 - charIndex++];
X            c = (i == spinBox->dotPosition) ? '.' : spinBox->text[12 - 1 - charIndex++];
N            if (LCD_GetFontItem(spinBox->font, c, &charWidth, &charOffset) == 0)
N                continue;
N            x -= charWidth;
N
N            LCD_DrawImage(&spinBox->font->data[charOffset],x,y,charWidth,spinBox->font->height,IMAGE_MODE_NORMAL);
X            LCD_DrawImage(&spinBox->font->data[charOffset],x,y,charWidth,spinBox->font->height,0x01);
N            if ((charIndex == spinBox->activeDigit+1) && (i != spinBox->dotPosition) && (spinBox->isActive))
N            {
N                LCD_SetLineStyle(LINE_STYLE_SOLID);
X                LCD_SetLineStyle(0x10);
N                for (y_underline = y + spinBox->font->height + SPINBOX_ACTIVE_UNDERLINE_MARGIN;
X                for (y_underline = y + spinBox->font->height + 1;
N                     y_underline < y + spinBox->font->height + SPINBOX_ACTIVE_UNDERLINE_MARGIN + SPINBOX_ACTIVE_UNDERLINE_WIDTH;
X                     y_underline < y + spinBox->font->height + 1 + 2;
N                     y_underline++)
N                    LCD_DrawHorLine(x,y_underline,charWidth,1);
N            }
N          /*  if ((charIndex == spinBox->activeDigit+1) && (i != spinBox->dotPosition) && (spinBox->isActive))
N                LCD_DrawImage(&spinBox->font->data[charOffset],x,y,charWidth,spinBox->font->height,IMAGE_MODE_INVERSE);
N            else
N                LCD_DrawImage(&spinBox->font->data[charOffset],x,y,charWidth,spinBox->font->height,IMAGE_MODE_NORMAL);
N                */
N            i++;
N        }
N    }
N
N    //-----------------------------------------//
N    // Draw focus / frame
N    if ((spinBox->redrawForced) || (spinBox->redrawFocus))
N    {
N        if ((spinBox->hasFrame) || (spinBox->showFocus))
N        {
N            LCD_SetPixelOutputMode(PIXEL_MODE_REWRITE);
X            LCD_SetPixelOutputMode(0x00);
N            frameStyle = ((spinBox->showFocus) && (spinBox->isFocused)) ? LINE_STYLE_DOTTED : LINE_STYLE_SOLID;
X            frameStyle = ((spinBox->showFocus) && (spinBox->isFocused)) ? 0x30 : 0x10;
N            framePixelValue = ((spinBox->showFocus) && (spinBox->isFocused)) ? 1 : 0;
N            framePixelValue |= (spinBox->hasFrame) ? 1 : 0;
N            LCD_SetLineStyle(frameStyle);
N            if (!((spinBox->redrawForced) && (framePixelValue == 0)))
N                LCD_DrawRect(wx,wy,spinBox->width,spinBox->height,framePixelValue);
N        }
N    }
N
N
N}
N
N
