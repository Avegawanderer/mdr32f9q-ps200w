; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\converter.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\converter.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\converter.crf src\converter.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CheckSetVoltageRange PROC
;;;67     
;;;68     static uint16_t CheckSetVoltageRange(int32_t new_set_voltage, uint8_t *err_code)
000000  b510              PUSH     {r4,lr}
;;;69     {
;;;70     	uint8_t error = VCHECK_OK;
000002  2201              MOVS     r2,#1
;;;71     
;;;72     	// First check soft limits
;;;73     	if (regulation_setting_p->soft_voltage_range_enable)
000004  4bfe              LDR      r3,|L1.1024|
000006  695b              LDR      r3,[r3,#0x14]  ; regulation_setting_p
000008  7c1c              LDRB     r4,[r3,#0x10]
00000a  b154              CBZ      r4,|L1.34|
;;;74     	{
;;;75     		if (new_set_voltage <= (int32_t)regulation_setting_p->soft_min_voltage)
00000c  895c              LDRH     r4,[r3,#0xa]
00000e  4284              CMP      r4,r0
000010  db02              BLT      |L1.24|
;;;76     		{
;;;77     			new_set_voltage = (int32_t)regulation_setting_p->soft_min_voltage;
000012  4620              MOV      r0,r4
;;;78     			error = VCHECK_SOFT_MIN;
000014  2205              MOVS     r2,#5
000016  e004              B        |L1.34|
                  |L1.24|
;;;79     		}
;;;80     		else if (new_set_voltage >= (int32_t)regulation_setting_p->soft_max_voltage)
000018  891c              LDRH     r4,[r3,#8]
00001a  4284              CMP      r4,r0
00001c  dc01              BGT      |L1.34|
;;;81     		{
;;;82     			new_set_voltage = (int32_t)regulation_setting_p->soft_max_voltage;
00001e  4620              MOV      r0,r4
;;;83     			error = VCHECK_SOFT_MAX;
000020  2204              MOVS     r2,#4
                  |L1.34|
;;;84     		}
;;;85     	}
;;;86     	
;;;87     	// Check absolute limits
;;;88     	if (new_set_voltage <= (int32_t)regulation_setting_p->MIN_VOLTAGE)
000022  88dc              LDRH     r4,[r3,#6]
000024  4284              CMP      r4,r0
000026  db02              BLT      |L1.46|
;;;89     	{
;;;90     		new_set_voltage = (int32_t)regulation_setting_p->MIN_VOLTAGE;
000028  4620              MOV      r0,r4
;;;91     		error = VCHECK_ABS_MIN;
00002a  2203              MOVS     r2,#3
00002c  e004              B        |L1.56|
                  |L1.46|
;;;92     	}
;;;93     	else if (new_set_voltage >= (int32_t)regulation_setting_p->MAX_VOLTAGE)
00002e  889b              LDRH     r3,[r3,#4]
000030  4283              CMP      r3,r0
000032  dc01              BGT      |L1.56|
;;;94     	{
;;;95     		new_set_voltage = (int32_t)regulation_setting_p->MAX_VOLTAGE;
000034  4618              MOV      r0,r3
;;;96     		error = VCHECK_ABS_MAX;
000036  2202              MOVS     r2,#2
                  |L1.56|
;;;97     	}
;;;98     	
;;;99     	*err_code = error;
000038  700a              STRB     r2,[r1,#0]
;;;100    	return (uint16_t)new_set_voltage;
00003a  b280              UXTH     r0,r0
;;;101    }
00003c  bd10              POP      {r4,pc}
;;;102    
                          ENDP

                  CheckSetCurrentRange PROC
;;;103    
;;;104    static uint16_t CheckSetCurrentRange(int32_t new_set_current, uint8_t *err_code)
00003e  b570              PUSH     {r4-r6,lr}
;;;105    {
;;;106    	int32_t max_current;
;;;107    	int32_t min_current;	
;;;108    	uint8_t error = CCHECK_OK;
000040  2308              MOVS     r3,#8
;;;109    	
;;;110    	if (regulation_setting_p->current_limit == CURRENT_LIM_HIGH)
000042  4aef              LDR      r2,|L1.1024|
000044  6952              LDR      r2,[r2,#0x14]  ; regulation_setting_p
000046  7c54              LDRB     r4,[r2,#0x11]
000048  2c01              CMP      r4,#1
00004a  d00a              BEQ      |L1.98|
;;;111    	{
;;;112    		max_current = regulation_setting_p->HIGH_LIM_MAX_CURRENT;
;;;113    		min_current = regulation_setting_p->HIGH_LIM_MIN_CURRENT;
;;;114    	}
;;;115    	else
;;;116    	{
;;;117    		max_current = regulation_setting_p->LOW_LIM_MAX_CURRENT;
00004c  8a94              LDRH     r4,[r2,#0x14]
;;;118    		min_current = regulation_setting_p->LOW_LIM_MIN_CURRENT;
00004e  8ad5              LDRH     r5,[r2,#0x16]
                  |L1.80|
;;;119    	}
;;;120    	
;;;121    	// First check soft limits
;;;122    	if (regulation_setting_p->soft_current_range_enable)
000050  f8926024          LDRB     r6,[r2,#0x24]
000054  b16e              CBZ      r6,|L1.114|
;;;123    	{
;;;124    		if (new_set_current <= (int32_t)regulation_setting_p->soft_min_current)
000056  8bd6              LDRH     r6,[r2,#0x1e]
000058  4286              CMP      r6,r0
00005a  db05              BLT      |L1.104|
;;;125    		{
;;;126    			new_set_current = (int32_t)regulation_setting_p->soft_min_current;
00005c  4630              MOV      r0,r6
;;;127    			error = CCHECK_SOFT_MIN;
00005e  230c              MOVS     r3,#0xc
000060  e007              B        |L1.114|
                  |L1.98|
000062  8b14              LDRH     r4,[r2,#0x18]         ;112
000064  8b55              LDRH     r5,[r2,#0x1a]         ;113
000066  e7f3              B        |L1.80|
                  |L1.104|
;;;128    		}
;;;129    		else if (new_set_current >= (int32_t)regulation_setting_p->soft_max_current)
000068  8b92              LDRH     r2,[r2,#0x1c]
00006a  4282              CMP      r2,r0
00006c  dc01              BGT      |L1.114|
;;;130    		{
;;;131    			new_set_current = (int32_t)regulation_setting_p->soft_max_current;
00006e  4610              MOV      r0,r2
;;;132    			error = CCHECK_SOFT_MAX;
000070  230b              MOVS     r3,#0xb
                  |L1.114|
;;;133    		}	
;;;134    	}
;;;135    	
;;;136    	// Check absolute limits - this will overwrite possibly incorrect soft limits
;;;137    	// This can happen for exapmle, if soft_min = 35A and current limit is switched to 20A
;;;138    	if (new_set_current <= min_current)
000072  42a8              CMP      r0,r5
000074  dc02              BGT      |L1.124|
;;;139    	{
;;;140    		new_set_current = min_current;
000076  4628              MOV      r0,r5
;;;141    		error = CCHECK_ABS_MIN;
000078  230a              MOVS     r3,#0xa
00007a  e003              B        |L1.132|
                  |L1.124|
;;;142    	}
;;;143    	else if (new_set_current >= max_current)
00007c  42a0              CMP      r0,r4
00007e  db01              BLT      |L1.132|
;;;144    	{
;;;145    		new_set_current = max_current;
000080  4620              MOV      r0,r4
;;;146    		error = CCHECK_ABS_MAX;
000082  2309              MOVS     r3,#9
                  |L1.132|
;;;147    	}
;;;148    	
;;;149    	*err_code = error;
000084  700b              STRB     r3,[r1,#0]
;;;150    	return (uint16_t)new_set_current;
000086  b280              UXTH     r0,r0
;;;151    }
000088  bd70              POP      {r4-r6,pc}
;;;152    
                          ENDP

                  Converter_SetSoftLimit PROC
;;;153    
;;;154    uint8_t Converter_SetSoftLimit(int32_t new_limit, converter_regulation_t *reg_p, uint8_t mode)
00008a  b530              PUSH     {r4,r5,lr}
;;;155    {
;;;156    	uint8_t err_code = SLIM_OK;
00008c  2510              MOVS     r5,#0x10
;;;157    	uint16_t *lim_p;
;;;158    	int32_t minimum;
;;;159    	int32_t maximum;
;;;160    	
;;;161    	switch (mode)
00008e  2a01              CMP      r2,#1
000090  d016              BEQ      |L1.192|
000092  2a03              CMP      r2,#3
000094  d00a              BEQ      |L1.172|
000096  2a04              CMP      r2,#4
000098  d00d              BEQ      |L1.182|
;;;162    	{
;;;163    		case SET_LOW_CURRENT_SOFT_LIMIT:
;;;164    			lim_p = &reg_p->soft_min_current;
;;;165    			minimum = reg_p->SOFT_MIN_CURRENT_LIMIT;
;;;166    			maximum = reg_p->soft_max_current;
;;;167    			break;
;;;168    		case SET_HIGH_CURRENT_SOFT_LIMIT:
;;;169    			lim_p = &reg_p->soft_max_current;
;;;170    			minimum = reg_p->soft_min_current;
;;;171    			maximum = reg_p->SOFT_MAX_CURRENT_LIMIT;
;;;172    			break;
;;;173    		case SET_LOW_VOLTAGE_SOFT_LIMIT:
;;;174    			lim_p = &reg_p->soft_min_voltage;
;;;175    			minimum = reg_p->SOFT_MIN_VOLTAGE_LIMIT;
;;;176    			maximum = reg_p->soft_max_voltage;
;;;177    			break;
;;;178    		default: // SET_HIGH_VOLTAGE_SOFT_LIMIT:
;;;179    			lim_p = &reg_p->soft_max_voltage;
00009a  f1010208          ADD      r2,r1,#8
;;;180    			minimum = reg_p->soft_min_voltage;
00009e  894b              LDRH     r3,[r1,#0xa]
;;;181    			maximum = reg_p->SOFT_MAX_VOLTAGE_LIMIT;
0000a0  898c              LDRH     r4,[r1,#0xc]
                  |L1.162|
;;;182    			break;
;;;183    	}
;;;184    	
;;;185    	if (new_limit < minimum)
0000a2  4298              CMP      r0,r3
0000a4  da11              BGE      |L1.202|
;;;186    	{
;;;187    		new_limit = minimum;
0000a6  4618              MOV      r0,r3
;;;188    		err_code = SLIM_MIN;
0000a8  2511              MOVS     r5,#0x11
0000aa  e012              B        |L1.210|
                  |L1.172|
0000ac  f101021e          ADD      r2,r1,#0x1e           ;164
0000b0  8c4b              LDRH     r3,[r1,#0x22]         ;165
0000b2  8b8c              LDRH     r4,[r1,#0x1c]         ;166
0000b4  e7f5              B        |L1.162|
                  |L1.182|
0000b6  f101021c          ADD      r2,r1,#0x1c           ;169
0000ba  8bcb              LDRH     r3,[r1,#0x1e]         ;170
0000bc  8c0c              LDRH     r4,[r1,#0x20]         ;171
0000be  e7f0              B        |L1.162|
                  |L1.192|
0000c0  f101020a          ADD      r2,r1,#0xa            ;174
0000c4  89cb              LDRH     r3,[r1,#0xe]          ;175
0000c6  890c              LDRH     r4,[r1,#8]            ;176
0000c8  e7eb              B        |L1.162|
                  |L1.202|
;;;189    	}
;;;190    	else if (new_limit > maximum)
0000ca  42a0              CMP      r0,r4
0000cc  dd01              BLE      |L1.210|
;;;191    	{
;;;192    		new_limit = maximum;
0000ce  4620              MOV      r0,r4
;;;193    		err_code = SLIM_MAX;
0000d0  2512              MOVS     r5,#0x12
                  |L1.210|
;;;194    	}
;;;195    	*lim_p = (uint16_t)new_limit;
0000d2  8010              STRH     r0,[r2,#0]
;;;196    	
;;;197    	return err_code;
0000d4  4628              MOV      r0,r5
;;;198    }
0000d6  bd30              POP      {r4,r5,pc}
;;;199    
                          ENDP

                  apply_regulation PROC
;;;200    
;;;201    static void apply_regulation(void)
0000d8  b570              PUSH     {r4-r6,lr}
;;;202    {
;;;203    	uint16_t temp;
;;;204    	
;;;205    	// Apply voltage - same for both 5V and 12V channels
;;;206    	temp = regulation_setting_p -> set_voltage;
0000da  4dc9              LDR      r5,|L1.1024|
0000dc  6968              LDR      r0,[r5,#0x14]  ; regulation_setting_p
0000de  8840              LDRH     r0,[r0,#2]
;;;207    	temp /= 5;
0000e0  2405              MOVS     r4,#5
0000e2  fbb0f0f4          UDIV     r0,r0,r4
;;;208    	SetVoltagePWMPeriod(temp);		// FIXME - we are setting not period but duty
0000e6  f7fffffe          BL       SetVoltagePWMPeriod
;;;209    	
;;;210    	// Apply current different for 20A and 40A limits
;;;211    	temp = regulation_setting_p -> set_current;
0000ea  6969              LDR      r1,[r5,#0x14]  ; regulation_setting_p
0000ec  8a48              LDRH     r0,[r1,#0x12]
;;;212    	temp = (regulation_setting_p -> current_limit == CURRENT_LIM_HIGH) ? temp / 2 : temp;
0000ee  7c49              LDRB     r1,[r1,#0x11]
0000f0  2901              CMP      r1,#1
0000f2  d100              BNE      |L1.246|
0000f4  0840              LSRS     r0,r0,#1
                  |L1.246|
;;;213    	temp /= 5;
0000f6  fbb0f0f4          UDIV     r0,r0,r4
;;;214    	SetCurrentPWMPeriod(temp);		// FIXME - we are setting not period but duty
0000fa  e8bd4070          POP      {r4-r6,lr}
0000fe  f7ffbffe          B.W      SetCurrentPWMPeriod
;;;215    }
;;;216    
                          ENDP

                  Converter_Init PROC
;;;223    
;;;224    void Converter_Init(uint8_t default_channel)
000102  b570              PUSH     {r4-r6,lr}
;;;225    {
;;;226    	// Converter is powered off.
;;;227    	// TODO: add restore from EEPROM
;;;228    	
;;;229    	// Common
;;;230    	channel_5v_setting.CHANNEL = CHANNEL_5V;
000104  49bf              LDR      r1,|L1.1028|
000106  2201              MOVS     r2,#1
000108  700a              STRB     r2,[r1,#0]
;;;231    	channel_5v_setting.load_state = LOAD_ENABLE;							// dummy - load at 5V channel can not be disabled
00010a  2200              MOVS     r2,#0
00010c  704a              STRB     r2,[r1,#1]
;;;232    	// Voltage
;;;233    	channel_5v_setting.set_voltage = 5000;
00010e  f2413388          MOV      r3,#0x1388
000112  804b              STRH     r3,[r1,#2]
;;;234    	channel_5v_setting.MAX_VOLTAGE = CONV_MAX_VOLTAGE_5V_CHANNEL;			// Maximum voltage setting for channel
000114  005b              LSLS     r3,r3,#1
000116  808b              STRH     r3,[r1,#4]
;;;235    	channel_5v_setting.MIN_VOLTAGE = CONV_MIN_VOLTAGE_5V_CHANNEL;			// Minimum voltage setting for channel
000118  80ca              STRH     r2,[r1,#6]
;;;236    	channel_5v_setting.soft_max_voltage = 8000;
00011a  f44f54fa          MOV      r4,#0x1f40
00011e  810c              STRH     r4,[r1,#8]
;;;237    	channel_5v_setting.soft_min_voltage = 3000;
000120  f64034b8          MOV      r4,#0xbb8
000124  814c              STRH     r4,[r1,#0xa]
;;;238    	channel_5v_setting.SOFT_MAX_VOLTAGE_LIMIT = 10000;						// Maximum soft voltage limit
000126  818b              STRH     r3,[r1,#0xc]
;;;239    	channel_5v_setting.SOFT_MIN_VOLTAGE_LIMIT = 0;							// Minimum soft voltage limit
000128  81ca              STRH     r2,[r1,#0xe]
;;;240    	channel_5v_setting.soft_voltage_range_enable = 0;
00012a  740a              STRB     r2,[r1,#0x10]
;;;241    	// Current
;;;242    	channel_5v_setting.current_limit = CURRENT_LIM_LOW;
00012c  744a              STRB     r2,[r1,#0x11]
;;;243    	channel_5v_setting.set_current = 4000;
00012e  f44f637a          MOV      r3,#0xfa0
000132  824b              STRH     r3,[r1,#0x12]
;;;244    	channel_5v_setting.LOW_LIM_MAX_CURRENT = CONV_LOW_LIM_MAX_CURRENT;		// Low limit (20A) maximum current setting
000134  f6446320          MOV      r3,#0x4e20
000138  828b              STRH     r3,[r1,#0x14]
;;;245    	channel_5v_setting.LOW_LIM_MIN_CURRENT = CONV_MIN_CURRENT;				// Low limit (20A) min current setting
00013a  82ca              STRH     r2,[r1,#0x16]
;;;246    	channel_5v_setting.HIGH_LIM_MAX_CURRENT = CONV_HIGH_LIM_MAX_CURRENT;	// High limit (40A) maximum current setting
00013c  005c              LSLS     r4,r3,#1
00013e  830c              STRH     r4,[r1,#0x18]
;;;247    	channel_5v_setting.HIGH_LIM_MIN_CURRENT = CONV_MIN_CURRENT;				// High limit (40A) min current setting
000140  834a              STRH     r2,[r1,#0x1a]
;;;248    	channel_5v_setting.soft_max_current = 37000;
000142  f2490588          MOV      r5,#0x9088
000146  838d              STRH     r5,[r1,#0x1c]
;;;249    	channel_5v_setting.soft_min_current = 30000;
000148  f2475530          MOV      r5,#0x7530
00014c  83cd              STRH     r5,[r1,#0x1e]
;;;250    	channel_5v_setting.SOFT_MAX_CURRENT_LIMIT = 40000;						// Maximum soft current limit
00014e  840c              STRH     r4,[r1,#0x20]
;;;251    	channel_5v_setting.SOFT_MIN_CURRENT_LIMIT = 0;							// Minimum soft current limit
000150  844a              STRH     r2,[r1,#0x22]
;;;252    	channel_5v_setting.soft_current_range_enable = 0;
000152  f8812024          STRB     r2,[r1,#0x24]
;;;253    	
;;;254    	
;;;255    	
;;;256    	// Common
;;;257    	channel_12v_setting.CHANNEL = CHANNEL_12V;
000156  f1010426          ADD      r4,r1,#0x26
00015a  7022              STRB     r2,[r4,#0]
;;;258    	channel_12v_setting.load_state = LOAD_ENABLE;
00015c  7062              STRB     r2,[r4,#1]
;;;259    	// Voltage
;;;260    	channel_12v_setting.set_voltage = 12000;
00015e  f64265e0          MOV      r5,#0x2ee0
000162  8065              STRH     r5,[r4,#2]
;;;261    	channel_12v_setting.MAX_VOLTAGE = CONV_MAX_VOLTAGE_12V_CHANNEL;			// Maximum voltage setting for channel
000164  80a3              STRH     r3,[r4,#4]
;;;262    	channel_12v_setting.MIN_VOLTAGE = CONV_MIN_VOLTAGE_12V_CHANNEL;			// Minimum voltage setting for channel
000166  80e2              STRH     r2,[r4,#6]
;;;263    	channel_12v_setting.soft_max_voltage = 16000;
000168  f44f557a          MOV      r5,#0x3e80
00016c  8125              STRH     r5,[r4,#8]
;;;264    	channel_12v_setting.soft_min_voltage = 1500;
00016e  f24055dc          MOV      r5,#0x5dc
000172  8165              STRH     r5,[r4,#0xa]
;;;265    	channel_12v_setting.SOFT_MAX_VOLTAGE_LIMIT = 20000;						// Maximum soft voltage limit
000174  81a3              STRH     r3,[r4,#0xc]
;;;266    	channel_12v_setting.SOFT_MIN_VOLTAGE_LIMIT = 0;							// Minimum soft voltage limit
000176  81e2              STRH     r2,[r4,#0xe]
;;;267    	channel_12v_setting.soft_voltage_range_enable = 0;
000178  7422              STRB     r2,[r4,#0x10]
;;;268    	// Current
;;;269    	channel_12v_setting.current_limit = CURRENT_LIM_LOW;
00017a  7462              STRB     r2,[r4,#0x11]
;;;270    	channel_12v_setting.set_current = 2000;
00017c  f44f65fa          MOV      r5,#0x7d0
000180  8265              STRH     r5,[r4,#0x12]
;;;271    	channel_12v_setting.LOW_LIM_MAX_CURRENT = CONV_LOW_LIM_MAX_CURRENT;		// Low limit (20A) maximum current setting
000182  82a3              STRH     r3,[r4,#0x14]
;;;272    	channel_12v_setting.LOW_LIM_MIN_CURRENT = CONV_MIN_CURRENT;				// Low limit (20A) min current setting
000184  82e2              STRH     r2,[r4,#0x16]
;;;273    	channel_12v_setting.HIGH_LIM_MAX_CURRENT = CONV_LOW_LIM_MAX_CURRENT;	// High limit (40A) maximum current setting
000186  8323              STRH     r3,[r4,#0x18]
;;;274    	channel_12v_setting.HIGH_LIM_MIN_CURRENT = CONV_MIN_CURRENT;			// High limit (40A) min current setting
000188  8362              STRH     r2,[r4,#0x1a]
;;;275    	channel_12v_setting.soft_max_current = 18000;
00018a  f2446550          MOV      r5,#0x4650
00018e  83a5              STRH     r5,[r4,#0x1c]
;;;276    	channel_12v_setting.soft_min_current = 6000;
000190  f2417570          MOV      r5,#0x1770
000194  83e5              STRH     r5,[r4,#0x1e]
;;;277    	channel_12v_setting.SOFT_MAX_CURRENT_LIMIT = 20000;						// Maximum soft current limit
000196  8423              STRH     r3,[r4,#0x20]
;;;278    	channel_12v_setting.SOFT_MIN_CURRENT_LIMIT = 0;							// Minimum soft current limit
000198  8462              STRH     r2,[r4,#0x22]
;;;279    	channel_12v_setting.soft_current_range_enable = 0;
00019a  f8842024          STRB     r2,[r4,#0x24]
;;;280    	
;;;281    	// 
;;;282    	if (default_channel == CHANNEL_12V)
;;;283    		regulation_setting_p = &channel_12v_setting;
00019e  4d98              LDR      r5,|L1.1024|
0001a0  b168              CBZ      r0,|L1.446|
;;;284    	else
;;;285    		regulation_setting_p = &channel_5v_setting;
0001a2  6169              STR      r1,[r5,#0x14]  ; regulation_setting_p
                  |L1.420|
;;;286    	
;;;287    	
;;;288    	// Apply controls
;;;289    	//__disable_irq();
;;;290    	SetFeedbackChannel(regulation_setting_p->CHANNEL);		// PORTF can be accessed from ISR
0001a4  6968              LDR      r0,[r5,#0x14]  ; regulation_setting_p
0001a6  7800              LDRB     r0,[r0,#0]
0001a8  f7fffffe          BL       SetFeedbackChannel
;;;291    	//__enable_irq();
;;;292    	SetCurrentLimit(regulation_setting_p->current_limit);
0001ac  6968              LDR      r0,[r5,#0x14]  ; regulation_setting_p
0001ae  7c40              LDRB     r0,[r0,#0x11]
0001b0  f7fffffe          BL       SetCurrentLimit
;;;293    	SetOutputLoad(channel_12v_setting.load_state);
0001b4  7860              LDRB     r0,[r4,#1]  ; channel_12v_setting
0001b6  e8bd4070          POP      {r4-r6,lr}
0001ba  f7ffbffe          B.W      SetOutputLoad
                  |L1.446|
0001be  616c              STR      r4,[r5,#0x14]         ;283  ; regulation_setting_p
0001c0  e7f0              B        |L1.420|
;;;294    }
;;;295    
                          ENDP

                  analyzeAndResetHWErrorState PROC
;;;299    
;;;300    static uint32_t analyzeAndResetHWErrorState(void)
0001c2  488f              LDR      r0,|L1.1024|
;;;301    {
;;;302    	uint32_t state_flags;
;;;303    	if (state_HWProcess & STATE_HW_OVERLOADED)		
0001c4  7801              LDRB     r1,[r0,#0]  ; state_HWProcess
0001c6  0749              LSLS     r1,r1,#29
0001c8  d506              BPL      |L1.472|
;;;304    	{
;;;305    		ctrl_HWProcess = CMD_HW_RESET_OVERLOAD;		
0001ca  2104              MOVS     r1,#4
0001cc  7041              STRB     r1,[r0,#1]
                  |L1.462|
;;;306    		while(ctrl_HWProcess);
0001ce  7841              LDRB     r1,[r0,#1]  ; ctrl_HWProcess
0001d0  2900              CMP      r1,#0
0001d2  d1fc              BNE      |L1.462|
;;;307    		state_flags = CONV_OVERLOAD;	
0001d4  2010              MOVS     r0,#0x10
;;;308    	}
;;;309    	// Add more if necessary
;;;310    	else
;;;311    	{
;;;312    		state_flags = 0;
;;;313    	}
;;;314    	return state_flags;
;;;315    }
0001d6  4770              BX       lr
                  |L1.472|
0001d8  2000              MOVS     r0,#0                 ;312
0001da  4770              BX       lr
;;;316    
                          ENDP

                  disableConverterAndCheckHWState PROC
;;;317    static uint32_t disableConverterAndCheckHWState(void)
0001dc  4888              LDR      r0,|L1.1024|
;;;318    {
;;;319    	uint32_t new_state;
;;;320    	
;;;321    #if CMD_HAS_PRIORITY == 1
;;;322    	// If error status is generated simultaneously with OFF command,
;;;323    	// converter will be turned off and no error status will be shown
;;;324    	ctrl_HWProcess = CMD_HW_OFF | CMD_HW_RESET_OVERLOAD;	// Turn off converter and suppress error status (if any)
0001de  2106              MOVS     r1,#6
0001e0  7041              STRB     r1,[r0,#1]
                  |L1.482|
;;;325    	while(ctrl_HWProcess);
0001e2  7841              LDRB     r1,[r0,#1]  ; ctrl_HWProcess
0001e4  2900              CMP      r1,#0
0001e6  d1fc              BNE      |L1.482|
;;;326    	new_state = CONV_OFF;		
0001e8  2001              MOVS     r0,#1
;;;327    	
;;;328    #elif ERROR_HAS_PRIORITY == 1
;;;329    	// If error status is generated simultaneously with OFF command,
;;;330    	// converter will be turned off, but error status will be indicated
;;;331    	ctrl_HWProcess = CMD_HW_OFF;					// Turn converter off
;;;332    	while(ctrl_HWProcess);
;;;333    	new_state = CONV_OFF;	
;;;334    	new_state |= analyzeAndResetHWErrorState();	
;;;335    						
;;;336    #endif
;;;337    	return new_state;
;;;338    }
0001ea  4770              BX       lr
;;;339    
                          ENDP

                  vTaskConverter PROC
;;;345    //---------------------------------------------//
;;;346    void vTaskConverter(void *pvParameters) 
0001ec  b086              SUB      sp,sp,#0x18
;;;347    {
;;;348    	conveter_message_t msg;
;;;349    	
;;;350    	uint8_t err_code;
;;;351    	uint32_t adc_msg;
;;;352    	uint32_t sound_msg;
;;;353    	
;;;354    	// Initialize
;;;355    	xQueueConverter = xQueueCreate( 5, sizeof( conveter_message_t ) );		// Queue can contain 5 elements of type conveter_message_t
0001ee  2200              MOVS     r2,#0
0001f0  210c              MOVS     r1,#0xc
0001f2  2005              MOVS     r0,#5
0001f4  f7fffffe          BL       xQueueGenericCreate
0001f8  4c81              LDR      r4,|L1.1024|
0001fa  61a0              STR      r0,[r4,#0x18]  ; xQueueConverter
;;;356    	if( xQueueConverter == 0 )
0001fc  b160              CBZ      r0,|L1.536|
;;;357    	{
;;;358    		// Queue was not created and must not be used.
;;;359    		while(1);
;;;360    	}
;;;361    	
;;;362    	
;;;363    	
;;;364    	while(1)
;;;365    	{
;;;366    		xQueueReceive(xQueueConverter, &msg, portMAX_DELAY);
;;;367    		
;;;368    
;;;369    		switch (msg.type)
;;;370    		{
;;;371    			case CONVERTER_SET_VOLTAGE:
;;;372    				regulation_setting_p->set_voltage = CheckSetVoltageRange(msg.data_a, &err_code);
;;;373    				if ((err_code == VCHECK_ABS_MAX) || (err_code == VCHECK_ABS_MIN))
;;;374    					sound_msg = SND_CONV_SETTING_ILLEGAL;
;;;375    				else if ((err_code == VCHECK_SOFT_MAX) || (err_code == VCHECK_SOFT_MIN))
;;;376    					sound_msg = SND_CONV_SETTING_ILLEGAL;
;;;377    				else
;;;378    					sound_msg = SND_CONV_SETTING_OK;
;;;379    				sound_msg |= SND_CONVERTER_PRIORITY_NORMAL;
;;;380    				xQueueSendToBack(xQueueSound, &sound_msg, 0);
;;;381    				break;
;;;382    			case CONVERTER_SET_CURRENT:
;;;383    				regulation_setting_p->set_current = CheckSetCurrentRange(msg.data_a, &err_code);
;;;384    				if ((err_code == CCHECK_ABS_MAX) || (err_code == CCHECK_ABS_MIN))
;;;385    					sound_msg = SND_CONV_SETTING_ILLEGAL;
;;;386    				else if ((err_code == CCHECK_SOFT_MAX) || (err_code == CCHECK_SOFT_MIN))
;;;387    					sound_msg = SND_CONV_SETTING_ILLEGAL;
;;;388    				else
;;;389    					sound_msg = SND_CONV_SETTING_OK;
;;;390    				sound_msg |= SND_CONVERTER_PRIORITY_NORMAL;
;;;391    				xQueueSendToBack(xQueueSound, &sound_msg, 0);
;;;392    				break;
;;;393    		}
;;;394    		
;;;395    
;;;396    		
;;;397    		switch(conv_state & CONV_STATE_MASK)
;;;398    		{
;;;399    			case CONV_OFF:
;;;400    				if (msg.type == CONVERTER_SWITCH_TO_5VCH)
;;;401    				{
;;;402    					regulation_setting_p = &channel_5v_setting;
0001fe  f8df8204          LDR      r8,|L1.1028|
;;;403    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
000202  2508              MOVS     r5,#8
000204  f44f3700          MOV      r7,#0x20000           ;374
000208  f44f3b80          MOV      r11,#0x10000          ;378
00020c  f8df91f8          LDR      r9,|L1.1032|
;;;404    					while(ctrl_HWProcess);
;;;405    					break;
;;;406    				}
;;;407    				if (msg.type == CONVERTER_SWITCH_TO_12VCH)
;;;408    				{
;;;409    					regulation_setting_p = &channel_12v_setting;
;;;410    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
;;;411    					while(ctrl_HWProcess);
;;;412    					break;
;;;413    				}
;;;414    				if (msg.type == SET_CURRENT_LIMIT_20A)
;;;415    				{
;;;416    					regulation_setting_p -> current_limit = CURRENT_LIM_LOW;
;;;417    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
;;;418    					while(ctrl_HWProcess);
;;;419    					break;
;;;420    				}
;;;421    				if (msg.type == SET_CURRENT_LIMIT_40A)
;;;422    				{
;;;423    					regulation_setting_p -> current_limit = CURRENT_LIM_HIGH;
000210  2601              MOVS     r6,#1
000212  f1080a26          ADD      r10,r8,#0x26          ;409
000216  e103              B        |L1.1056|
                  |L1.536|
000218  e7fe              B        |L1.536|
                  |L1.538|
00021a  2808              CMP      r0,#8                 ;369
00021c  d13f              BNE      |L1.670|
00021e  e021              B        |L1.612|
                  |L1.544|
000220  a902              ADD      r1,sp,#8              ;372
000222  9804              LDR      r0,[sp,#0x10]         ;372
000224  f7fffffe          BL       CheckSetVoltageRange
000228  6961              LDR      r1,[r4,#0x14]         ;372  ; regulation_setting_p
00022a  8048              STRH     r0,[r1,#2]            ;372
00022c  f89d0008          LDRB     r0,[sp,#8]            ;373
000230  2802              CMP      r0,#2                 ;373
000232  d013              BEQ      |L1.604|
000234  2803              CMP      r0,#3                 ;373
000236  d011              BEQ      |L1.604|
000238  2804              CMP      r0,#4                 ;375
00023a  d011              BEQ      |L1.608|
00023c  2805              CMP      r0,#5                 ;375
00023e  d00f              BEQ      |L1.608|
000240  f8cdb000          STR      r11,[sp,#0]           ;378
                  |L1.580|
000244  9800              LDR      r0,[sp,#0]            ;379
000246  f0400032          ORR      r0,r0,#0x32           ;379
00024a  9000              STR      r0,[sp,#0]            ;379
00024c  2300              MOVS     r3,#0                 ;380
00024e  461a              MOV      r2,r3                 ;380
000250  4669              MOV      r1,sp                 ;380
000252  f8d90000          LDR      r0,[r9,#0]            ;380  ; xQueueSound
000256  f7fffffe          BL       xQueueGenericSend
00025a  e020              B        |L1.670|
                  |L1.604|
00025c  9700              STR      r7,[sp,#0]            ;374
00025e  e7f1              B        |L1.580|
                  |L1.608|
000260  9700              STR      r7,[sp,#0]            ;376
000262  e7ef              B        |L1.580|
                  |L1.612|
000264  a902              ADD      r1,sp,#8              ;383
000266  9804              LDR      r0,[sp,#0x10]         ;383
000268  f7fffffe          BL       CheckSetCurrentRange
00026c  6961              LDR      r1,[r4,#0x14]         ;383  ; regulation_setting_p
00026e  8248              STRH     r0,[r1,#0x12]         ;383
000270  f89d0008          LDRB     r0,[sp,#8]            ;384
000274  2809              CMP      r0,#9                 ;384
000276  d01a              BEQ      |L1.686|
000278  280a              CMP      r0,#0xa               ;384
00027a  d018              BEQ      |L1.686|
00027c  280b              CMP      r0,#0xb               ;386
00027e  d018              BEQ      |L1.690|
000280  280c              CMP      r0,#0xc               ;386
000282  d016              BEQ      |L1.690|
000284  f8cdb000          STR      r11,[sp,#0]           ;389
                  |L1.648|
000288  9800              LDR      r0,[sp,#0]            ;390
00028a  f0400032          ORR      r0,r0,#0x32           ;390
00028e  9000              STR      r0,[sp,#0]            ;390
000290  2300              MOVS     r3,#0                 ;391
000292  461a              MOV      r2,r3                 ;391
000294  4669              MOV      r1,sp                 ;391
000296  f8d90000          LDR      r0,[r9,#0]            ;391  ; xQueueSound
00029a  f7fffffe          BL       xQueueGenericSend
                  |L1.670|
00029e  6920              LDR      r0,[r4,#0x10]         ;397  ; conv_state
0002a0  f000000f          AND      r0,r0,#0xf            ;397
0002a4  2801              CMP      r0,#1                 ;397
0002a6  d006              BEQ      |L1.694|
0002a8  2802              CMP      r0,#2                 ;397
0002aa  d116              BNE      |L1.730|
0002ac  e042              B        |L1.820|
                  |L1.686|
0002ae  9700              STR      r7,[sp,#0]            ;385
0002b0  e7ea              B        |L1.648|
                  |L1.690|
0002b2  9700              STR      r7,[sp,#0]            ;387
0002b4  e7e8              B        |L1.648|
                  |L1.694|
0002b6  9803              LDR      r0,[sp,#0xc]          ;400
0002b8  2803              CMP      r0,#3                 ;400
0002ba  d00f              BEQ      |L1.732|
0002bc  9803              LDR      r0,[sp,#0xc]          ;407
0002be  2804              CMP      r0,#4                 ;407
0002c0  d013              BEQ      |L1.746|
0002c2  9803              LDR      r0,[sp,#0xc]          ;414
0002c4  2805              CMP      r0,#5                 ;414
0002c6  d017              BEQ      |L1.760|
0002c8  9803              LDR      r0,[sp,#0xc]          ;421
0002ca  2806              CMP      r0,#6                 ;421
0002cc  d01c              BEQ      |L1.776|
;;;424    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
;;;425    					while(ctrl_HWProcess);
;;;426    					break;
;;;427    				}
;;;428    				if (msg.type == CONVERTER_TURN_OFF)
0002ce  9803              LDR      r0,[sp,#0xc]
0002d0  2802              CMP      r0,#2
0002d2  d020              BEQ      |L1.790|
;;;429    				{
;;;430    					conv_state = CONV_OFF;			// Reset overload flag
;;;431    					break;
;;;432    				}
;;;433    				if (msg.type == CONVERTER_TURN_ON)
0002d4  9803              LDR      r0,[sp,#0xc]
0002d6  2801              CMP      r0,#1
0002d8  d01f              BEQ      |L1.794|
                  |L1.730|
0002da  e06d              B        |L1.952|
                  |L1.732|
0002dc  f8c48014          STR      r8,[r4,#0x14]         ;402  ; regulation_setting_p
0002e0  7065              STRB     r5,[r4,#1]            ;403
                  |L1.738|
0002e2  7860              LDRB     r0,[r4,#1]            ;404  ; ctrl_HWProcess
0002e4  2800              CMP      r0,#0                 ;404
0002e6  d1fc              BNE      |L1.738|
0002e8  e066              B        |L1.952|
                  |L1.746|
0002ea  f8c4a014          STR      r10,[r4,#0x14]        ;409  ; regulation_setting_p
0002ee  7065              STRB     r5,[r4,#1]            ;410
                  |L1.752|
0002f0  7860              LDRB     r0,[r4,#1]            ;411  ; ctrl_HWProcess
0002f2  2800              CMP      r0,#0                 ;411
0002f4  d1fc              BNE      |L1.752|
0002f6  e05f              B        |L1.952|
                  |L1.760|
0002f8  6961              LDR      r1,[r4,#0x14]         ;416  ; regulation_setting_p
0002fa  2000              MOVS     r0,#0                 ;416
0002fc  7448              STRB     r0,[r1,#0x11]         ;416
0002fe  7065              STRB     r5,[r4,#1]            ;417
                  |L1.768|
000300  7860              LDRB     r0,[r4,#1]            ;418  ; ctrl_HWProcess
000302  2800              CMP      r0,#0                 ;418
000304  d1fc              BNE      |L1.768|
000306  e057              B        |L1.952|
                  |L1.776|
000308  6960              LDR      r0,[r4,#0x14]         ;423  ; regulation_setting_p
00030a  7446              STRB     r6,[r0,#0x11]         ;423
00030c  7065              STRB     r5,[r4,#1]            ;424
                  |L1.782|
00030e  7860              LDRB     r0,[r4,#1]            ;425  ; ctrl_HWProcess
000310  2800              CMP      r0,#0                 ;425
000312  d1fc              BNE      |L1.782|
000314  e050              B        |L1.952|
                  |L1.790|
000316  6126              STR      r6,[r4,#0x10]         ;430  ; conv_state
000318  e04e              B        |L1.952|
                  |L1.794|
;;;434    				{
;;;435    					// Message to turn on converter is received
;;;436    					if ((state_HWProcess & STATE_HW_TIMER_NOT_EXPIRED) || (!(state_HWProcess & STATE_HW_USER_TIMER_EXPIRED)))
00031a  7820              LDRB     r0,[r4,#0]  ; state_HWProcess
00031c  06c0              LSLS     r0,r0,#27
00031e  d44b              BMI      |L1.952|
000320  7820              LDRB     r0,[r4,#0]  ; state_HWProcess
000322  0680              LSLS     r0,r0,#26
000324  d548              BPL      |L1.952|
;;;437    					{
;;;438    						// Safe timeout is not expired
;;;439    						break;
;;;440    					}
;;;441    					ctrl_HWProcess = CMD_HW_ON;
000326  7066              STRB     r6,[r4,#1]
                  |L1.808|
;;;442    					while(ctrl_HWProcess);
000328  7860              LDRB     r0,[r4,#1]  ; ctrl_HWProcess
00032a  2800              CMP      r0,#0
00032c  d1fc              BNE      |L1.808|
;;;443    					conv_state = CONV_ON;			// Switch to new state and reset overload flag
00032e  2002              MOVS     r0,#2
000330  6120              STR      r0,[r4,#0x10]  ; conv_state
;;;444    					break;
000332  e041              B        |L1.952|
                  |L1.820|
;;;445    				}
;;;446    				break;
;;;447    			case CONV_ON:
;;;448    				if (msg.type == CONVERTER_TURN_OFF)
000334  9803              LDR      r0,[sp,#0xc]
000336  2802              CMP      r0,#2
000338  d003              BEQ      |L1.834|
;;;449    				{
;;;450    					conv_state = disableConverterAndCheckHWState();
;;;451    					break;
;;;452    				}
;;;453    				if ( (msg.type == CONVERTER_SWITCH_TO_5VCH) && (regulation_setting_p != &channel_5v_setting) )
00033a  9803              LDR      r0,[sp,#0xc]
00033c  2803              CMP      r0,#3
00033e  d004              BEQ      |L1.842|
000340  e013              B        |L1.874|
                  |L1.834|
000342  f7fffffe          BL       disableConverterAndCheckHWState
000346  6120              STR      r0,[r4,#0x10]         ;450  ; conv_state
000348  e036              B        |L1.952|
                  |L1.842|
00034a  6960              LDR      r0,[r4,#0x14]  ; regulation_setting_p
00034c  4540              CMP      r0,r8
00034e  d00c              BEQ      |L1.874|
;;;454    				{
;;;455    					conv_state = disableConverterAndCheckHWState();
000350  f7fffffe          BL       disableConverterAndCheckHWState
000354  6120              STR      r0,[r4,#0x10]  ; conv_state
;;;456    					vTaskDelay(4);
000356  2004              MOVS     r0,#4
000358  f7fffffe          BL       vTaskDelay
;;;457    					regulation_setting_p = &channel_5v_setting;
00035c  f8c48014          STR      r8,[r4,#0x14]  ; regulation_setting_p
;;;458    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
000360  7065              STRB     r5,[r4,#1]
                  |L1.866|
;;;459    					while(ctrl_HWProcess);
000362  7860              LDRB     r0,[r4,#1]  ; ctrl_HWProcess
000364  2800              CMP      r0,#0
000366  d1fc              BNE      |L1.866|
000368  e026              B        |L1.952|
                  |L1.874|
;;;460    					break;
;;;461    				}
;;;462    				if ( (msg.type == CONVERTER_SWITCH_TO_12VCH) && (regulation_setting_p != &channel_12v_setting) )
00036a  9803              LDR      r0,[sp,#0xc]
00036c  2804              CMP      r0,#4
00036e  d10f              BNE      |L1.912|
000370  6960              LDR      r0,[r4,#0x14]  ; regulation_setting_p
000372  4550              CMP      r0,r10
000374  d00c              BEQ      |L1.912|
;;;463    				{
;;;464    					conv_state = disableConverterAndCheckHWState();
000376  f7fffffe          BL       disableConverterAndCheckHWState
00037a  6120              STR      r0,[r4,#0x10]  ; conv_state
;;;465    					vTaskDelay(4);
00037c  2004              MOVS     r0,#4
00037e  f7fffffe          BL       vTaskDelay
;;;466    					regulation_setting_p = &channel_5v_setting;
000382  f8c48014          STR      r8,[r4,#0x14]  ; regulation_setting_p
;;;467    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
000386  7065              STRB     r5,[r4,#1]
                  |L1.904|
;;;468    					while(ctrl_HWProcess);
000388  7860              LDRB     r0,[r4,#1]  ; ctrl_HWProcess
00038a  2800              CMP      r0,#0
00038c  d1fc              BNE      |L1.904|
00038e  e013              B        |L1.952|
                  |L1.912|
;;;469    					break;
;;;470    				}
;;;471    				if (state_HWProcess & STATE_HW_OFF)
000390  7820              LDRB     r0,[r4,#0]  ; state_HWProcess
000392  0780              LSLS     r0,r0,#30
000394  d510              BPL      |L1.952|
;;;472    				{
;;;473    					// Some hardware error has happened and converter had been switched off
;;;474    					conv_state = CONV_OFF;
000396  6126              STR      r6,[r4,#0x10]  ; conv_state
;;;475    					conv_state |= analyzeAndResetHWErrorState();
000398  f7fffffe          BL       analyzeAndResetHWErrorState
00039c  6921              LDR      r1,[r4,#0x10]  ; conv_state
00039e  4308              ORRS     r0,r0,r1
0003a0  6120              STR      r0,[r4,#0x10]  ; conv_state
;;;476    					if (conv_state & CONV_OVERLOAD)
0003a2  06c0              LSLS     r0,r0,#27
0003a4  d508              BPL      |L1.952|
;;;477    					{
;;;478    						// Send message to sound driver
;;;479    						// TODO: send this message in other cases (when overload is detected simultaneously with button)
;;;480    						sound_msg = SND_CONV_OVERLOADED | SND_CONVERTER_PRIORITY_HIGHEST;
0003a6  4819              LDR      r0,|L1.1036|
0003a8  9000              STR      r0,[sp,#0]
;;;481    						xQueueSendToBack(xQueueSound, &sound_msg, 0);
0003aa  2300              MOVS     r3,#0
0003ac  461a              MOV      r2,r3
0003ae  4669              MOV      r1,sp
0003b0  f8d90000          LDR      r0,[r9,#0]  ; xQueueSound
0003b4  f7fffffe          BL       xQueueGenericSend
                  |L1.952|
;;;482    					}
;;;483    					break;
;;;484    				}
;;;485    				break;
;;;486    		}
;;;487    		
;;;488    		
;;;489    		// Will be special for charging mode - TODO
;;;490    		if (msg.type == CONVERTER_TICK)
0003b8  9803              LDR      r0,[sp,#0xc]
0003ba  28ff              CMP      r0,#0xff
0003bc  d107              BNE      |L1.974|
;;;491    		{
;;;492    			// ADC task is responsible for sampling and filtering voltage and current
;;;493    			adc_msg = ADC_GET_ALL_NORMAL;
0003be  9601              STR      r6,[sp,#4]
;;;494    			xQueueSendToBack(xQueueADC, &adc_msg, 0);
0003c0  4813              LDR      r0,|L1.1040|
0003c2  2300              MOVS     r3,#0
0003c4  461a              MOV      r2,r3
0003c6  a901              ADD      r1,sp,#4
0003c8  6800              LDR      r0,[r0,#0]  ; xQueueADC
0003ca  f7fffffe          BL       xQueueGenericSend
                  |L1.974|
;;;495    		}			
;;;496    		
;;;497    		// Apply controls
;;;498    		__disable_irq();
0003ce  b672              CPSID    i
;;;499    		SetFeedbackChannel(regulation_setting_p->CHANNEL);		// PORTF can be accessed from ISR
0003d0  6960              LDR      r0,[r4,#0x14]  ; regulation_setting_p
0003d2  7800              LDRB     r0,[r0,#0]
0003d4  f7fffffe          BL       SetFeedbackChannel
;;;500    		__enable_irq();
0003d8  b662              CPSIE    i
;;;501    		SetCurrentLimit(regulation_setting_p->current_limit);
0003da  6960              LDR      r0,[r4,#0x14]  ; regulation_setting_p
0003dc  7c40              LDRB     r0,[r0,#0x11]
0003de  f7fffffe          BL       SetCurrentLimit
;;;502    		SetOutputLoad(channel_12v_setting.load_state);
0003e2  f89a0001          LDRB     r0,[r10,#1]  ; channel_12v_setting
0003e6  f7fffffe          BL       SetOutputLoad
;;;503    	
;;;504    		// Always make sure settings are within allowed range
;;;505    		regulation_setting_p->set_current = CheckSetCurrentRange((int32_t)regulation_setting_p->set_current, &err_code);
0003ea  6960              LDR      r0,[r4,#0x14]  ; regulation_setting_p
0003ec  a902              ADD      r1,sp,#8
0003ee  8a40              LDRH     r0,[r0,#0x12]
0003f0  f7fffffe          BL       CheckSetCurrentRange
0003f4  6961              LDR      r1,[r4,#0x14]  ; regulation_setting_p
0003f6  8248              STRH     r0,[r1,#0x12]
;;;506    		regulation_setting_p->set_voltage = CheckSetVoltageRange((int32_t)regulation_setting_p->set_voltage, &err_code);
0003f8  8848              LDRH     r0,[r1,#2]
0003fa  a902              ADD      r1,sp,#8
0003fc  e00a              B        |L1.1044|
0003fe  0000              DCW      0x0000
                  |L1.1024|
                          DCD      ||.data||
                  |L1.1028|
                          DCD      ||.bss||
                  |L1.1032|
                          DCD      xQueueSound
                  |L1.1036|
                          DCD      0x00030034
                  |L1.1040|
                          DCD      xQueueADC
                  |L1.1044|
000414  f7fffffe          BL       CheckSetVoltageRange
000418  6961              LDR      r1,[r4,#0x14]  ; regulation_setting_p
00041a  8048              STRH     r0,[r1,#2]
;;;507    
;;;508    		// Apply voltage and current settings
;;;509    		apply_regulation();		
00041c  f7fffffe          BL       apply_regulation
                  |L1.1056|
000420  2300              MOVS     r3,#0                 ;366
000422  1e5a              SUBS     r2,r3,#1              ;366
000424  a903              ADD      r1,sp,#0xc            ;366
000426  69a0              LDR      r0,[r4,#0x18]         ;366  ; xQueueConverter
000428  f7fffffe          BL       xQueueGenericReceive
00042c  9803              LDR      r0,[sp,#0xc]          ;369
00042e  2807              CMP      r0,#7                 ;369
000430  f43faef6          BEQ      |L1.544|
000434  e6f1              B        |L1.538|
;;;510    		
;;;511    	
;;;512    		// LED indication
;;;513    
;;;514    	}
;;;515    	
;;;516    }
;;;517    
                          ENDP

                  Converter_HWProcess PROC
;;;537    //---------------------------------------------//
;;;538    void Converter_HWProcess(void) 
000436  e92d41f0          PUSH     {r4-r8,lr}
;;;539    {
;;;540    	static uint16_t overload_ignore_counter;
;;;541    	static uint16_t overload_counter;
;;;542    	static uint16_t safe_counter = 0;
;;;543    	static uint16_t user_counter = 0;
;;;544    	static uint16_t led_blink_counter = 0;
;;;545    	static uint16_t overload_warning_counter = 0;
;;;546    	uint8_t overload_check_enable;
;;;547    	uint8_t raw_overload_flag;
;;;548    	uint8_t led_state;
;;;549    
;;;550    	//-------------------------------//
;;;551    	// Get converter status and process overload timers
;;;552    	
;;;553    	// Due to hardware specialty overload input is active when converter is powered off
;;;554    	// Overload timeout counter reaches 0 when converter has been enabled for OVERLOAD_IGNORE_TIMEOUT ticks
;;;555    	overload_check_enable = 0;
00043a  2000              MOVS     r0,#0
;;;556    	if (state_HWProcess & (STATE_HW_OFF | STATE_HW_OFF_BY_ADC))
00043c  4d60              LDR      r5,|L1.1472|
00043e  7829              LDRB     r1,[r5,#0]  ; state_HWProcess
;;;557    		overload_ignore_counter = OVERLOAD_IGNORE_TIMEOUT;
000440  f44f76fa          MOV      r6,#0x1f4
000444  f0110f0a          TST      r1,#0xa               ;556
000448  d001              BEQ      |L1.1102|
00044a  80ae              STRH     r6,[r5,#4]
00044c  e005              B        |L1.1114|
                  |L1.1102|
;;;558    	else if (overload_ignore_counter != 0)
00044e  88a9              LDRH     r1,[r5,#4]  ; overload_ignore_counter
000450  b111              CBZ      r1,|L1.1112|
;;;559    		overload_ignore_counter--;
000452  1e49              SUBS     r1,r1,#1
000454  80a9              STRH     r1,[r5,#4]
000456  e000              B        |L1.1114|
                  |L1.1112|
;;;560    	else
;;;561    		overload_check_enable = 1;
000458  2001              MOVS     r0,#1
                  |L1.1114|
;;;562    	
;;;563    	// Apply top-level overload check control
;;;564    	//if (__overload_functions_disabled__)
;;;565    	//	overload_check_enable = 0;
;;;566    	
;;;567    	if (overload_check_enable)
00045a  b118              CBZ      r0,|L1.1124|
;;;568    		raw_overload_flag = GetOverloadStatus();
00045c  f7fffffe          BL       GetOverloadStatus
000460  4604              MOV      r4,r0
000462  e000              B        |L1.1126|
                  |L1.1124|
;;;569    	else
;;;570    		raw_overload_flag = NORMAL;
000464  2400              MOVS     r4,#0
                  |L1.1126|
;;;571    	
;;;572    	if (raw_overload_flag == NORMAL)
000466  b13c              CBZ      r4,|L1.1144|
;;;573    		overload_counter = OVERLOAD_TIMEOUT;
;;;574    	else if (overload_counter != 0)
000468  88e8              LDRH     r0,[r5,#6]  ; overload_counter
00046a  b108              CBZ      r0,|L1.1136|
;;;575    		overload_counter--;
00046c  1e40              SUBS     r0,r0,#1
00046e  80e8              STRH     r0,[r5,#6]
                  |L1.1136|
;;;576    	
;;;577    
;;;578    	//-------------------------------//
;;;579    	// Check overload 	
;;;580    	if (overload_counter == 0)
000470  88e8              LDRH     r0,[r5,#6]  ; overload_counter
;;;581    	{
;;;582    		// Converter is overloaded
;;;583    		state_HWProcess &= ~STATE_HW_ON;
;;;584    		state_HWProcess |= STATE_HW_OFF | STATE_HW_OVERLOADED;	// Set status for itself and top-level software
;;;585    		safe_counter = MINIMAL_OFF_TIME;						// Start timer to provide minimal OFF timeout
000472  27c8              MOVS     r7,#0xc8
000474  b118              CBZ      r0,|L1.1150|
000476  e011              B        |L1.1180|
                  |L1.1144|
000478  2005              MOVS     r0,#5                 ;573
00047a  80e8              STRH     r0,[r5,#6]            ;573
00047c  e7f8              B        |L1.1136|
                  |L1.1150|
00047e  7828              LDRB     r0,[r5,#0]            ;583  ; state_HWProcess
000480  f0200001          BIC      r0,r0,#1              ;583
000484  7028              STRB     r0,[r5,#0]            ;583
000486  7828              LDRB     r0,[r5,#0]            ;584  ; state_HWProcess
000488  f0400006          ORR      r0,r0,#6              ;584
00048c  7028              STRB     r0,[r5,#0]            ;584
00048e  812f              STRH     r7,[r5,#8]
;;;586    		xQueueSendToFrontFromISR(xQueueConverter, &converter_update_message, 0);	// No need for exact timing
000490  2301              MOVS     r3,#1
000492  2200              MOVS     r2,#0
000494  494b              LDR      r1,|L1.1476|
000496  69a8              LDR      r0,[r5,#0x18]  ; xQueueConverter
000498  f7fffffe          BL       xQueueGenericSendFromISR
                  |L1.1180|
;;;587    	}
;;;588    	
;;;589    	//-------------------------------//
;;;590    	// Process commands from top-level converter controller
;;;591    	if (ctrl_HWProcess & CMD_HW_RESET_OVERLOAD)
00049c  7868              LDRB     r0,[r5,#1]  ; ctrl_HWProcess
00049e  0740              LSLS     r0,r0,#29
0004a0  d503              BPL      |L1.1194|
;;;592    	{
;;;593    		state_HWProcess &= ~STATE_HW_OVERLOADED;
0004a2  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
0004a4  f0200004          BIC      r0,r0,#4
0004a8  7028              STRB     r0,[r5,#0]
                  |L1.1194|
;;;594    	}
;;;595    	if ( (ctrl_HWProcess & CMD_HW_OFF) && (!(state_HWProcess & STATE_HW_OFF)) )
0004aa  7868              LDRB     r0,[r5,#1]  ; ctrl_HWProcess
0004ac  0780              LSLS     r0,r0,#30
0004ae  d50c              BPL      |L1.1226|
0004b0  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
0004b2  0780              LSLS     r0,r0,#30
0004b4  d409              BMI      |L1.1226|
;;;596    	{
;;;597    		state_HWProcess &= ~STATE_HW_ON;
0004b6  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
0004b8  f0200001          BIC      r0,r0,#1
0004bc  7028              STRB     r0,[r5,#0]
;;;598    		state_HWProcess |= STATE_HW_OFF;		
0004be  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
0004c0  f0400002          ORR      r0,r0,#2
0004c4  7028              STRB     r0,[r5,#0]
;;;599    		safe_counter = MINIMAL_OFF_TIME;						// Start timer to provide minimal OFF timeout
0004c6  812f              STRH     r7,[r5,#8]
0004c8  e00d              B        |L1.1254|
                  |L1.1226|
;;;600    	}
;;;601    	else if ( (ctrl_HWProcess & CMD_HW_ON) && (!(state_HWProcess & STATE_HW_ON)) )
0004ca  7868              LDRB     r0,[r5,#1]  ; ctrl_HWProcess
0004cc  07c0              LSLS     r0,r0,#31
0004ce  d00a              BEQ      |L1.1254|
0004d0  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
0004d2  07c0              LSLS     r0,r0,#31
0004d4  d107              BNE      |L1.1254|
;;;602    	{
;;;603    		state_HWProcess &= ~STATE_HW_OFF;
0004d6  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
0004d8  f0200002          BIC      r0,r0,#2
0004dc  7028              STRB     r0,[r5,#0]
;;;604    		state_HWProcess |= STATE_HW_ON;								
0004de  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
0004e0  f0400001          ORR      r0,r0,#1
0004e4  7028              STRB     r0,[r5,#0]
                  |L1.1254|
;;;605    	}
;;;606    	if (ctrl_HWProcess & CMD_HW_RESTART_USER_TIMER)
0004e6  7868              LDRB     r0,[r5,#1]  ; ctrl_HWProcess
0004e8  0700              LSLS     r0,r0,#28
0004ea  d501              BPL      |L1.1264|
;;;607    	{
;;;608    		user_counter = USER_TIMEOUT;
0004ec  2064              MOVS     r0,#0x64
0004ee  8168              STRH     r0,[r5,#0xa]
                  |L1.1264|
;;;609    	}
;;;610    	if (ctrl_HWProcess & CMD_HW_RESTART_LED_BLINK_TIMER)
0004f0  7868              LDRB     r0,[r5,#1]  ; ctrl_HWProcess
0004f2  06c0              LSLS     r0,r0,#27
0004f4  d500              BPL      |L1.1272|
;;;611    	{
;;;612    		user_counter = LED_BLINK_TIMEOUT;
0004f6  816e              STRH     r6,[r5,#0xa]
                  |L1.1272|
;;;613    	}
;;;614    	
;;;615    	//-------------------------------//
;;;616    	// Process commands from top-level ADC controller
;;;617    	if (cmd_ADC_to_HWProcess & CMD_HW_OFF_BY_ADC)
0004f8  78a8              LDRB     r0,[r5,#2]  ; cmd_ADC_to_HWProcess
0004fa  07c0              LSLS     r0,r0,#31
0004fc  d004              BEQ      |L1.1288|
;;;618    	{
;;;619    		state_HWProcess |= STATE_HW_OFF_BY_ADC;
0004fe  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
000500  f0400008          ORR      r0,r0,#8
000504  7028              STRB     r0,[r5,#0]
000506  e006              B        |L1.1302|
                  |L1.1288|
;;;620    	}
;;;621    	else if (cmd_ADC_to_HWProcess & CMD_HW_ON_BY_ADC)
000508  78a8              LDRB     r0,[r5,#2]  ; cmd_ADC_to_HWProcess
00050a  0780              LSLS     r0,r0,#30
00050c  d503              BPL      |L1.1302|
;;;622    	{
;;;623    		state_HWProcess &= ~STATE_HW_OFF_BY_ADC;
00050e  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
000510  f0200008          BIC      r0,r0,#8
000514  7028              STRB     r0,[r5,#0]
                  |L1.1302|
;;;624    	}
;;;625    	
;;;626    	// Reset commands
;;;627    	ctrl_HWProcess = 0;
000516  2000              MOVS     r0,#0
000518  7068              STRB     r0,[r5,#1]
;;;628    	cmd_ADC_to_HWProcess = 0;
00051a  70a8              STRB     r0,[r5,#2]
;;;629    
;;;630    	//-------------------------------//
;;;631    	// Apply converter state
;;;632    	// TODO - check IRQ disable while accessing converter control port (MDR_PORTF) for write
;;;633    	if (state_HWProcess & (STATE_HW_OFF | STATE_HW_OFF_BY_ADC))
00051c  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
00051e  f0100f0a          TST      r0,#0xa
000522  d003              BEQ      |L1.1324|
;;;634    		SetConverterState(CONVERTER_OFF);
000524  2000              MOVS     r0,#0
000526  f7fffffe          BL       SetConverterState
00052a  e005              B        |L1.1336|
                  |L1.1324|
;;;635    	else if (state_HWProcess & STATE_HW_ON)
00052c  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
00052e  07c0              LSLS     r0,r0,#31
000530  d002              BEQ      |L1.1336|
;;;636    		SetConverterState(CONVERTER_ON);
000532  2001              MOVS     r0,#1
000534  f7fffffe          BL       SetConverterState
                  |L1.1336|
;;;637    		
;;;638    	//-------------------------------//
;;;639    	// LED indication
;;;640    	// Uses raw converter state and top-level conveter status
;;;641    	// TODO - check IRQ disable while accessing LED port (MDR_PORTB) for write
;;;642    	led_state = 0;
000538  2000              MOVS     r0,#0
;;;643    	if ((state_HWProcess & STATE_HW_ON) && (led_blink_counter == 0))
00053a  7829              LDRB     r1,[r5,#0]  ; state_HWProcess
00053c  07c9              LSLS     r1,r1,#31
00053e  d002              BEQ      |L1.1350|
000540  89a9              LDRH     r1,[r5,#0xc]  ; led_blink_counter
000542  b901              CBNZ     r1,|L1.1350|
;;;644    		led_state |= LED_GREEN;
000544  2001              MOVS     r0,#1
                  |L1.1350|
;;;645    	if ((raw_overload_flag == OVERLOAD) || (conv_state & CONV_OVERLOAD))
000546  2c01              CMP      r4,#1
000548  d002              BEQ      |L1.1360|
00054a  6929              LDR      r1,[r5,#0x10]  ; conv_state
00054c  06c9              LSLS     r1,r1,#27
00054e  d501              BPL      |L1.1364|
                  |L1.1360|
;;;646    		led_state |= LED_RED;
000550  f0400002          ORR      r0,r0,#2
                  |L1.1364|
;;;647    	UpdateLEDs(led_state);
000554  f7fffffe          BL       UpdateLEDs
;;;648    	
;;;649    	//-------------------------------//
;;;650    	// Overload sound warning
;;;651    	if ((raw_overload_flag == OVERLOAD) && (overload_warning_counter == 0))
000558  2c01              CMP      r4,#1
00055a  d10b              BNE      |L1.1396|
00055c  89e8              LDRH     r0,[r5,#0xe]  ; overload_warning_counter
00055e  b948              CBNZ     r0,|L1.1396|
;;;652    	{
;;;653    		xQueueSendToFrontFromISR(xQueueSound, &sound_instant_overload_msg, 0);	// No need for exact timing
000560  481a              LDR      r0,|L1.1484|
000562  2301              MOVS     r3,#1
000564  2200              MOVS     r2,#0
000566  4918              LDR      r1,|L1.1480|
000568  6800              LDR      r0,[r0,#0]  ; xQueueSound
00056a  f7fffffe          BL       xQueueGenericSendFromISR
;;;654    		overload_warning_counter = OVERLOAD_WARNING_TIMEOUT;
00056e  f44f707a          MOV      r0,#0x3e8
000572  81e8              STRH     r0,[r5,#0xe]
                  |L1.1396|
;;;655    	}
;;;656    	
;;;657    	//-------------------------------//
;;;658    	// Process timers
;;;659    	
;;;660    	// Process safe timer - used by top-level controller to provide a safe minimal OFF timeout
;;;661    	if (safe_counter != 0)
000574  8928              LDRH     r0,[r5,#8]  ; safe_counter
000576  b130              CBZ      r0,|L1.1414|
;;;662    	{
;;;663    		safe_counter--;
000578  1e40              SUBS     r0,r0,#1
00057a  8128              STRH     r0,[r5,#8]
;;;664    		state_HWProcess |= STATE_HW_TIMER_NOT_EXPIRED;
00057c  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
00057e  f0400010          ORR      r0,r0,#0x10
000582  7028              STRB     r0,[r5,#0]
000584  e003              B        |L1.1422|
                  |L1.1414|
;;;665    	}
;;;666    	else
;;;667    	{
;;;668    		state_HWProcess &= ~STATE_HW_TIMER_NOT_EXPIRED;
000586  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
000588  f0200010          BIC      r0,r0,#0x10
00058c  7028              STRB     r0,[r5,#0]
                  |L1.1422|
;;;669    	}
;;;670    	
;;;671    	// Process user timer - used by top-level controller to provide a safe interval after switching channels
;;;672    	if (user_counter != 0)
00058e  8968              LDRH     r0,[r5,#0xa]  ; user_counter
000590  b130              CBZ      r0,|L1.1440|
;;;673    	{
;;;674    		user_counter--;
000592  1e40              SUBS     r0,r0,#1
000594  8168              STRH     r0,[r5,#0xa]
;;;675    		state_HWProcess &= ~STATE_HW_USER_TIMER_EXPIRED;
000596  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
000598  f0200020          BIC      r0,r0,#0x20
00059c  7028              STRB     r0,[r5,#0]
00059e  e003              B        |L1.1448|
                  |L1.1440|
;;;676    	}
;;;677    	else
;;;678    	{
;;;679    		state_HWProcess |= STATE_HW_USER_TIMER_EXPIRED;
0005a0  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
0005a2  f0400020          ORR      r0,r0,#0x20
0005a6  7028              STRB     r0,[r5,#0]
                  |L1.1448|
;;;680    	}
;;;681    	
;;;682    	// Process LED blink timer
;;;683    	if (led_blink_counter != 0)
0005a8  89a8              LDRH     r0,[r5,#0xc]  ; led_blink_counter
0005aa  b108              CBZ      r0,|L1.1456|
;;;684    	{
;;;685    		led_blink_counter--;
0005ac  1e40              SUBS     r0,r0,#1
0005ae  81a8              STRH     r0,[r5,#0xc]
                  |L1.1456|
;;;686    	}
;;;687    	
;;;688    	// Process overload sound warning timer
;;;689    	if (overload_warning_counter != 0)
0005b0  89e8              LDRH     r0,[r5,#0xe]  ; overload_warning_counter
0005b2  2800              CMP      r0,#0
0005b4  d001              BEQ      |L1.1466|
;;;690    	{
;;;691    		overload_warning_counter--;
0005b6  1e40              SUBS     r0,r0,#1
0005b8  81e8              STRH     r0,[r5,#0xe]
                  |L1.1466|
;;;692    	}
;;;693    }
0005ba  e8bd81f0          POP      {r4-r8,pc}
;;;694    
                          ENDP

0005be  0000              DCW      0x0000
                  |L1.1472|
                          DCD      ||.data||
                  |L1.1476|
                          DCD      ||area_number.6||
                  |L1.1480|
                          DCD      sound_instant_overload_msg
                  |L1.1484|
                          DCD      xQueueSound

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  channel_5v_setting
                          %        38
                  channel_12v_setting
                          %        38

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  converter_tick_message
                          DCD      0x000000ff
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||area_number.6||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.constdata||
                  converter_update_message
                          DCD      0x000000fe
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=2

                  state_HWProcess
000000  02                DCB      0x02
                  ctrl_HWProcess
000001  00                DCB      0x00
                  cmd_ADC_to_HWProcess
000002  0000              DCB      0x00,0x00
                  overload_ignore_counter
000004  0000              DCB      0x00,0x00
                  overload_counter
000006  0000              DCB      0x00,0x00
                  safe_counter
000008  0000              DCW      0x0000
                  user_counter
00000a  0000              DCW      0x0000
                  led_blink_counter
00000c  0000              DCW      0x0000
                  overload_warning_counter
00000e  0000              DCW      0x0000
                  conv_state
                          DCD      0x00000001
                  regulation_setting_p
                          DCD      0x00000000
                  xQueueConverter
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "src\\converter.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_converter_c_40e17437____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_converter_c_40e17437____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_converter_c_40e17437____REVSH|
#line 130
|__asm___11_converter_c_40e17437____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
