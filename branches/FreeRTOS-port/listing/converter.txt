; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\converter.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\converter.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -I.\src\gui -I.\src\gui\guiCore -I.\src\gui\guiWidgets -I.\src\gui\guiGraphics -I.\src\gui\utils -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\converter.crf src\converter.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CheckSetVoltageRange PROC
;;;73     
;;;74     static uint16_t CheckSetVoltageRange(int32_t new_set_voltage, uint8_t *err_code)
000000  b530              PUSH     {r4,r5,lr}
;;;75     {
;;;76     	uint8_t error = VCHECK_OK;
000002  2201              MOVS     r2,#1
;;;77     
;;;78     	// First check soft limits
;;;79     	if ((regulation_setting_p->voltage.enable_low_limit) && 
000004  4bfa              LDR      r3,|L1.1008|
000006  699b              LDR      r3,[r3,#0x18]  ; regulation_setting_p
000008  7c1d              LDRB     r5,[r3,#0x10]
00000a  07ec              LSLS     r4,r5,#31
00000c  d004              BEQ      |L1.24|
;;;80     		(new_set_voltage <= (int32_t)regulation_setting_p->voltage.limit_low))
00000e  891c              LDRH     r4,[r3,#8]
000010  4284              CMP      r4,r0
000012  db01              BLT      |L1.24|
;;;81     	{
;;;82     		new_set_voltage = (int32_t)regulation_setting_p->voltage.limit_low;
000014  4620              MOV      r0,r4
;;;83     		error = VCHECK_SOFT_MIN;
000016  2205              MOVS     r2,#5
                  |L1.24|
;;;84     	}
;;;85     	
;;;86     	if ((regulation_setting_p->voltage.enable_high_limit) && 
000018  07ac              LSLS     r4,r5,#30
00001a  d504              BPL      |L1.38|
;;;87     		(new_set_voltage >= (int32_t)regulation_setting_p->voltage.limit_high))
00001c  895c              LDRH     r4,[r3,#0xa]
00001e  4284              CMP      r4,r0
000020  dc01              BGT      |L1.38|
;;;88     	{
;;;89     			new_set_voltage = (int32_t)regulation_setting_p->voltage.limit_high;
000022  4620              MOV      r0,r4
;;;90     			error = VCHECK_SOFT_MAX;
000024  2204              MOVS     r2,#4
                  |L1.38|
;;;91     	}
;;;92     	
;;;93     	// Check absolute limits
;;;94     	if (new_set_voltage <= (int32_t)regulation_setting_p->voltage.MINIMUM)
000026  889c              LDRH     r4,[r3,#4]
000028  4284              CMP      r4,r0
00002a  db02              BLT      |L1.50|
;;;95     	{
;;;96     		new_set_voltage = (int32_t)regulation_setting_p->voltage.MINIMUM;
00002c  4620              MOV      r0,r4
;;;97     		error = VCHECK_ABS_MIN;
00002e  2203              MOVS     r2,#3
000030  e004              B        |L1.60|
                  |L1.50|
;;;98     	}
;;;99     	else if (new_set_voltage >= (int32_t)regulation_setting_p->voltage.MAXIMUM)
000032  88db              LDRH     r3,[r3,#6]
000034  4283              CMP      r3,r0
000036  dc01              BGT      |L1.60|
;;;100    	{
;;;101    		new_set_voltage = (int32_t)regulation_setting_p->voltage.MAXIMUM;
000038  4618              MOV      r0,r3
;;;102    		error = VCHECK_ABS_MAX;
00003a  2202              MOVS     r2,#2
                  |L1.60|
;;;103    	}
;;;104    	
;;;105    	if (err_code)
00003c  b101              CBZ      r1,|L1.64|
;;;106    		*err_code = error;
00003e  700a              STRB     r2,[r1,#0]
                  |L1.64|
;;;107    	return (uint16_t)new_set_voltage;
000040  b280              UXTH     r0,r0
;;;108    }
000042  bd30              POP      {r4,r5,pc}
;;;109    
                          ENDP

                  CheckSetCurrentRange PROC
;;;110    
;;;111    static uint16_t CheckSetCurrentRange(int32_t new_set_current, uint8_t *err_code)
000044  b530              PUSH     {r4,r5,lr}
;;;112    {
;;;113    	uint8_t error = CCHECK_OK;
000046  2208              MOVS     r2,#8
;;;114    	
;;;115    	// First check soft limits
;;;116    	if ((regulation_setting_p->current->enable_low_limit) && 
000048  4be9              LDR      r3,|L1.1008|
00004a  699b              LDR      r3,[r3,#0x18]  ; regulation_setting_p
00004c  6b5b              LDR      r3,[r3,#0x34]
00004e  7b9d              LDRB     r5,[r3,#0xe]
000050  07ec              LSLS     r4,r5,#31
000052  d004              BEQ      |L1.94|
;;;117    		(new_set_current <= (int32_t)regulation_setting_p->current->limit_low))
000054  88dc              LDRH     r4,[r3,#6]
000056  4284              CMP      r4,r0
000058  db01              BLT      |L1.94|
;;;118    	{
;;;119    		new_set_current = (int32_t)regulation_setting_p->current->limit_low;
00005a  4620              MOV      r0,r4
;;;120    		error = CCHECK_SOFT_MIN;
00005c  220c              MOVS     r2,#0xc
                  |L1.94|
;;;121    	}
;;;122    	
;;;123    	if ((regulation_setting_p->current->enable_high_limit) && 
00005e  07ac              LSLS     r4,r5,#30
000060  d504              BPL      |L1.108|
;;;124    		(new_set_current >= (int32_t)regulation_setting_p->current->limit_high))
000062  891c              LDRH     r4,[r3,#8]
000064  4284              CMP      r4,r0
000066  dc01              BGT      |L1.108|
;;;125    	{
;;;126    		new_set_current = (int32_t)regulation_setting_p->current->limit_high;
000068  4620              MOV      r0,r4
;;;127    		error = CCHECK_SOFT_MAX;
00006a  220b              MOVS     r2,#0xb
                  |L1.108|
;;;128    	}
;;;129    	
;;;130    	// Check absolute limits
;;;131    	if (new_set_current <= (int32_t)regulation_setting_p->current->MINIMUM)
00006c  885c              LDRH     r4,[r3,#2]
00006e  4284              CMP      r4,r0
000070  db02              BLT      |L1.120|
;;;132    	{
;;;133    		new_set_current = (int32_t)regulation_setting_p->current->MINIMUM;
000072  4620              MOV      r0,r4
;;;134    		error = CCHECK_ABS_MIN;
000074  220a              MOVS     r2,#0xa
000076  e004              B        |L1.130|
                  |L1.120|
;;;135    	}
;;;136    	else if (new_set_current >= (int32_t)regulation_setting_p->current->MAXIMUM)
000078  889b              LDRH     r3,[r3,#4]
00007a  4283              CMP      r3,r0
00007c  dc01              BGT      |L1.130|
;;;137    	{
;;;138    		new_set_current = (int32_t)regulation_setting_p->current->MAXIMUM;
00007e  4618              MOV      r0,r3
;;;139    		error = CCHECK_ABS_MAX;
000080  2209              MOVS     r2,#9
                  |L1.130|
;;;140    	}
;;;141    	
;;;142    	
;;;143    	
;;;144    	if (err_code)
000082  b101              CBZ      r1,|L1.134|
;;;145    		*err_code = error;
000084  700a              STRB     r2,[r1,#0]
                  |L1.134|
;;;146    	return (uint16_t)new_set_current;
000086  b280              UXTH     r0,r0
;;;147    }
000088  bd30              POP      {r4,r5,pc}
;;;148    
                          ENDP

                  Converter_SetVoltageLimit PROC
;;;152    
;;;153    uint8_t Converter_SetVoltageLimit(uint8_t type, int32_t value, uint8_t enable)
00008a  b530              PUSH     {r4,r5,lr}
;;;154    {
00008c  4605              MOV      r5,r0
;;;155    	uint8_t error = 0;
00008e  2000              MOVS     r0,#0
;;;156    	
;;;157    	// Bound limit
;;;158    	if (value <= regulation_setting_p->voltage.LIMIT_MIN)
000090  4bd7              LDR      r3,|L1.1008|
000092  699b              LDR      r3,[r3,#0x18]  ; regulation_setting_p
000094  899c              LDRH     r4,[r3,#0xc]
000096  428c              CMP      r4,r1
000098  db01              BLT      |L1.158|
;;;159    	{
;;;160    		value = regulation_setting_p->voltage.LIMIT_MIN;
00009a  4621              MOV      r1,r4
;;;161    		error = 1;
00009c  2001              MOVS     r0,#1
                  |L1.158|
;;;162    	}
;;;163    	if (value >= regulation_setting_p->voltage.LIMIT_MAX)
00009e  89dc              LDRH     r4,[r3,#0xe]
0000a0  428c              CMP      r4,r1
0000a2  dc01              BGT      |L1.168|
;;;164    	{
;;;165    		value = regulation_setting_p->voltage.LIMIT_MAX;
0000a4  4621              MOV      r1,r4
;;;166    		error = 1;
0000a6  2001              MOVS     r0,#1
                  |L1.168|
0000a8  4cd1              LDR      r4,|L1.1008|
0000aa  69a4              LDR      r4,[r4,#0x18]         ;158
;;;167    	}
;;;168    	
;;;169    	if (type == 0)
;;;170    	{
;;;171    		// Low limit
;;;172    		regulation_setting_p->voltage.limit_low = (uint16_t) value;
;;;173    		regulation_setting_p->voltage.enable_low_limit = enable;
0000ac  7c24              LDRB     r4,[r4,#0x10]
0000ae  b125              CBZ      r5,|L1.186|
;;;174    	}
;;;175    	else
;;;176    	{
;;;177    		// High limit
;;;178    		regulation_setting_p->voltage.limit_high = (uint16_t) value;
0000b0  8159              STRH     r1,[r3,#0xa]
;;;179    		regulation_setting_p->voltage.enable_high_limit = enable;
0000b2  f3620441          BFI      r4,r2,#1,#1
0000b6  741c              STRB     r4,[r3,#0x10]
;;;180    	}
;;;181    	return error;
;;;182    }
0000b8  bd30              POP      {r4,r5,pc}
                  |L1.186|
0000ba  8119              STRH     r1,[r3,#8]            ;172
0000bc  f3620400          BFI      r4,r2,#0,#1           ;173
0000c0  741c              STRB     r4,[r3,#0x10]         ;173
0000c2  bd30              POP      {r4,r5,pc}
;;;183    
                          ENDP

                  apply_regulation PROC
;;;232    
;;;233    static void apply_regulation(void)
0000c4  b570              PUSH     {r4-r6,lr}
;;;234    {
;;;235    	uint16_t temp;
;;;236    	
;;;237    	// Apply voltage - same for both 5V and 12V channels
;;;238    	temp = regulation_setting_p->voltage.setting;
0000c6  4dca              LDR      r5,|L1.1008|
0000c8  69a8              LDR      r0,[r5,#0x18]  ; regulation_setting_p
0000ca  8840              LDRH     r0,[r0,#2]
;;;239    	temp /= 5;
0000cc  2405              MOVS     r4,#5
0000ce  fbb0f0f4          UDIV     r0,r0,r4
;;;240    	SetVoltagePWMPeriod(temp);		// FIXME - we are setting not period but duty
0000d2  f7fffffe          BL       SetVoltagePWMPeriod
;;;241    	
;;;242    	// Apply current different for 20A and 40A limits
;;;243    	temp = regulation_setting_p->current->setting;
0000d6  69a8              LDR      r0,[r5,#0x18]  ; regulation_setting_p
0000d8  6b41              LDR      r1,[r0,#0x34]
0000da  8808              LDRH     r0,[r1,#0]
;;;244    	temp = (regulation_setting_p->current->RANGE == CURRENT_RANGE_HIGH) ? temp / 2 : temp;
0000dc  7b89              LDRB     r1,[r1,#0xe]
0000de  0749              LSLS     r1,r1,#29
0000e0  d500              BPL      |L1.228|
0000e2  0840              LSRS     r0,r0,#1
                  |L1.228|
;;;245    	temp /= 5;
0000e4  fbb0f0f4          UDIV     r0,r0,r4
;;;246    	SetCurrentPWMPeriod(temp);		// FIXME - we are setting not period but duty
0000e8  e8bd4070          POP      {r4-r6,lr}
0000ec  f7ffbffe          B.W      SetCurrentPWMPeriod
;;;247    }
;;;248    
                          ENDP

                  Converter_Init PROC
;;;254    
;;;255    void Converter_Init(uint8_t default_channel)
0000f0  e92d41f0          PUSH     {r4-r8,lr}
;;;256    {
;;;257    	// Converter is powered off.
;;;258    	// TODO: add restore from EEPROM
;;;259    	
;;;260    	//---------- Channel 5V ------------//
;;;261    	
;;;262    	// Common
;;;263    	channel_5v.CHANNEL = CHANNEL_5V;
0000f4  49bf              LDR      r1,|L1.1012|
0000f6  780a              LDRB     r2,[r1,#0]  ; channel_5v
0000f8  f0420201          ORR      r2,r2,#1
;;;264    	channel_5v.load_state = LOAD_ENABLE;										// dummy - load at 5V channel can not be disabled
0000fc  f0220202          BIC      r2,r2,#2
;;;265    	channel_5v.overload_protection_enable = 1;									// TODO: EEPROM
000100  f0420204          ORR      r2,r2,#4
000104  700a              STRB     r2,[r1,#0]
;;;266    	channel_5v.overload_timeout = 1;											// TODO: EEPROM
000106  2701              MOVS     r7,#1
000108  704f              STRB     r7,[r1,#1]
;;;267    	
;;;268    	// Voltage
;;;269    	channel_5v.voltage.setting = 5000;											// TODO: EEPROM
00010a  f2413288          MOV      r2,#0x1388
00010e  804a              STRH     r2,[r1,#2]
;;;270    	channel_5v.voltage.MINIMUM = CONV_MIN_VOLTAGE_5V_CHANNEL;					// Minimum voltage setting for channel
000110  2300              MOVS     r3,#0
000112  808b              STRH     r3,[r1,#4]
;;;271    	channel_5v.voltage.MAXIMUM = CONV_MAX_VOLTAGE_5V_CHANNEL;					// Maximum voltage setting for channel
000114  0052              LSLS     r2,r2,#1
000116  80ca              STRH     r2,[r1,#6]
;;;272    	channel_5v.voltage.limit_low = CONV_MIN_VOLTAGE_5V_CHANNEL;					// TODO: EEPROM
000118  810b              STRH     r3,[r1,#8]
;;;273    	channel_5v.voltage.limit_high = CONV_MAX_VOLTAGE_5V_CHANNEL;				// TODO: EEPROM
00011a  814a              STRH     r2,[r1,#0xa]
;;;274    	channel_5v.voltage.LIMIT_MIN = CONV_MIN_VOLTAGE_5V_CHANNEL;					// Minimum voltage limit setting
00011c  818b              STRH     r3,[r1,#0xc]
;;;275    	channel_5v.voltage.LIMIT_MAX = CONV_MAX_VOLTAGE_5V_CHANNEL;					// Maximum voltage limit setting
00011e  81ca              STRH     r2,[r1,#0xe]
;;;276    	channel_5v.voltage.enable_low_limit = 0;									// TODO: EEPROM
000120  7c0a              LDRB     r2,[r1,#0x10]  ; channel_5v
000122  f0220201          BIC      r2,r2,#1
;;;277    	channel_5v.voltage.enable_high_limit = 0;									// TODO: EEPROM
000126  f0220202          BIC      r2,r2,#2
00012a  740a              STRB     r2,[r1,#0x10]
;;;278    	
;;;279    	// Current
;;;280    	channel_5v.current_low_range.RANGE = 0;										// LOW current range
00012c  f8912020          LDRB     r2,[r1,#0x20]  ; channel_5v
000130  f0220204          BIC      r2,r2,#4
;;;281    	channel_5v.current_low_range.setting = 4000;								// TODO: EEPROM
000134  f44f657a          MOV      r5,#0xfa0
000138  824d              STRH     r5,[r1,#0x12]
;;;282    	channel_5v.current_low_range.MINIMUM = CONV_LOW_CURRENT_RANGE_MIN;			// Minimum current setting for specified current range
00013a  828b              STRH     r3,[r1,#0x14]
;;;283    	channel_5v.current_low_range.MAXIMUM = CONV_LOW_CURRENT_RANGE_MAX;			// Maximum current setting for specified current range
00013c  f6446420          MOV      r4,#0x4e20
000140  82cc              STRH     r4,[r1,#0x16]
;;;284    	channel_5v.current_low_range.limit_low = CONV_LOW_CURRENT_RANGE_MIN;		// TODO: EEPROM
000142  830b              STRH     r3,[r1,#0x18]
;;;285    	channel_5v.current_low_range.limit_high = CONV_LOW_CURRENT_RANGE_MAX;		// TODO: EEPROM
000144  834c              STRH     r4,[r1,#0x1a]
;;;286    	channel_5v.current_low_range.LIMIT_MIN = CONV_LOW_CURRENT_RANGE_MIN;		// Minimum current limit setting
000146  838b              STRH     r3,[r1,#0x1c]
;;;287    	channel_5v.current_low_range.LIMIT_MAX = CONV_LOW_CURRENT_RANGE_MAX;		// Maximum current limit setting
000148  83cc              STRH     r4,[r1,#0x1e]
;;;288    	channel_5v.current_low_range.enable_low_limit = 0;							// TODO: EEPROM
00014a  f0220201          BIC      r2,r2,#1
;;;289    	channel_5v.current_low_range.enable_high_limit = 0;							// TODO: EEPROM
00014e  f0220202          BIC      r2,r2,#2
000152  f8812020          STRB     r2,[r1,#0x20]
;;;290    	
;;;291    	channel_5v.current_high_range.RANGE = 1;									// HIGH current range
000156  f8912030          LDRB     r2,[r1,#0x30]  ; channel_5v
00015a  f0420604          ORR      r6,r2,#4
;;;292    	channel_5v.current_high_range.setting = 4000;								// TODO: EEPROM
00015e  844d              STRH     r5,[r1,#0x22]
;;;293    	channel_5v.current_high_range.MINIMUM = CONV_HIGH_CURRENT_RANGE_MIN;		// Minimum current setting for specified current range
000160  848b              STRH     r3,[r1,#0x24]
;;;294    	channel_5v.current_high_range.MAXIMUM = CONV_HIGH_CURRENT_RANGE_MAX;		// Maximum current setting for specified current range
000162  0062              LSLS     r2,r4,#1
000164  84ca              STRH     r2,[r1,#0x26]
;;;295    	channel_5v.current_high_range.limit_low = CONV_HIGH_CURRENT_RANGE_MIN;		// TODO: EEPROM
000166  850b              STRH     r3,[r1,#0x28]
;;;296    	channel_5v.current_high_range.limit_high = CONV_HIGH_CURRENT_RANGE_MAX;		// TODO: EEPROM
000168  854a              STRH     r2,[r1,#0x2a]
;;;297    	channel_5v.current_high_range.LIMIT_MIN = CONV_HIGH_CURRENT_RANGE_MIN;		// Minimum current limit setting
00016a  858b              STRH     r3,[r1,#0x2c]
;;;298    	channel_5v.current_high_range.LIMIT_MAX = CONV_HIGH_CURRENT_RANGE_MAX;		// Maximum current limit setting
00016c  85ca              STRH     r2,[r1,#0x2e]
;;;299    	channel_5v.current_high_range.enable_low_limit = 0;							// TODO: EEPROM
00016e  f0260201          BIC      r2,r6,#1
;;;300    	channel_5v.current_high_range.enable_high_limit = 0;						// TODO: EEPROM
000172  f0220202          BIC      r2,r2,#2
000176  f8812030          STRB     r2,[r1,#0x30]
;;;301    
;;;302    	channel_5v.current = &channel_5v.current_low_range;
00017a  f1010212          ADD      r2,r1,#0x12
00017e  634a              STR      r2,[r1,#0x34]  ; channel_5v
;;;303    	
;;;304    	//---------- Channel 12V -----------//
;;;305    	
;;;306    	// Common
;;;307    	channel_12v.CHANNEL = CHANNEL_12V;
000180  3226              ADDS     r2,r2,#0x26
000182  7816              LDRB     r6,[r2,#0]  ; channel_12v
000184  f0260601          BIC      r6,r6,#1
;;;308    	channel_12v.load_state = LOAD_ENABLE;										
000188  f0260602          BIC      r6,r6,#2
;;;309    	channel_12v.overload_protection_enable = 1;									// TODO: EEPROM
00018c  f0460604          ORR      r6,r6,#4
000190  7016              STRB     r6,[r2,#0]
;;;310    	channel_12v.overload_timeout = 1;											// TODO: EEPROM
000192  7057              STRB     r7,[r2,#1]
;;;311    	
;;;312    	// Voltage
;;;313    	channel_12v.voltage.setting = 12000;										// TODO: EEPROM
000194  f64266e0          MOV      r6,#0x2ee0
000198  8056              STRH     r6,[r2,#2]
;;;314    	channel_12v.voltage.MINIMUM = CONV_MIN_VOLTAGE_12V_CHANNEL;					// Minimum voltage setting for channel
00019a  8093              STRH     r3,[r2,#4]
;;;315    	channel_12v.voltage.MAXIMUM = CONV_MAX_VOLTAGE_12V_CHANNEL;					// Maximum voltage setting for channel
00019c  80d4              STRH     r4,[r2,#6]
;;;316    	channel_12v.voltage.limit_low = CONV_MIN_VOLTAGE_12V_CHANNEL;				// TODO: EEPROM
00019e  8113              STRH     r3,[r2,#8]
;;;317    	channel_12v.voltage.limit_high = CONV_MAX_VOLTAGE_12V_CHANNEL;				// TODO: EEPROM
0001a0  8154              STRH     r4,[r2,#0xa]
;;;318    	channel_12v.voltage.LIMIT_MIN = CONV_MIN_VOLTAGE_12V_CHANNEL;				// Minimum voltage limit setting
0001a2  8193              STRH     r3,[r2,#0xc]
;;;319    	channel_12v.voltage.LIMIT_MAX = CONV_MAX_VOLTAGE_12V_CHANNEL;				// Maximum voltage limit setting
0001a4  81d4              STRH     r4,[r2,#0xe]
;;;320    	channel_12v.voltage.enable_low_limit = 0;									// TODO: EEPROM
0001a6  7c16              LDRB     r6,[r2,#0x10]  ; channel_12v
0001a8  f0260601          BIC      r6,r6,#1
;;;321    	channel_12v.voltage.enable_high_limit = 0;									// TODO: EEPROM
0001ac  f0260602          BIC      r6,r6,#2
0001b0  7416              STRB     r6,[r2,#0x10]
;;;322    	
;;;323    	// Current
;;;324    	channel_12v.current_low_range.RANGE = 0;									// LOW current range
0001b2  f8926020          LDRB     r6,[r2,#0x20]  ; channel_12v
0001b6  f0260604          BIC      r6,r6,#4
;;;325    	channel_12v.current_low_range.setting = 2000;								// TODO: EEPROM
0001ba  106f              ASRS     r7,r5,#1
0001bc  8257              STRH     r7,[r2,#0x12]
;;;326    	channel_12v.current_low_range.MINIMUM = CONV_LOW_CURRENT_RANGE_MIN;			// Minimum current setting for specified current range
0001be  8293              STRH     r3,[r2,#0x14]
;;;327    	channel_12v.current_low_range.MAXIMUM = CONV_LOW_CURRENT_RANGE_MAX;			// Maximum current setting for specified current range
0001c0  82d4              STRH     r4,[r2,#0x16]
;;;328    	channel_12v.current_low_range.limit_low = CONV_LOW_CURRENT_RANGE_MIN;		// TODO: EEPROM
0001c2  8313              STRH     r3,[r2,#0x18]
;;;329    	channel_12v.current_low_range.limit_high = CONV_LOW_CURRENT_RANGE_MAX;		// TODO: EEPROM
0001c4  8354              STRH     r4,[r2,#0x1a]
;;;330    	channel_12v.current_low_range.LIMIT_MIN = CONV_LOW_CURRENT_RANGE_MIN;		// Minimum current limit setting
0001c6  8393              STRH     r3,[r2,#0x1c]
;;;331    	channel_12v.current_low_range.LIMIT_MAX = CONV_LOW_CURRENT_RANGE_MAX;		// Maximum current limit setting
0001c8  83d4              STRH     r4,[r2,#0x1e]
;;;332    	channel_12v.current_low_range.enable_low_limit = 0;							// TODO: EEPROM
0001ca  f0260601          BIC      r6,r6,#1
;;;333    	channel_12v.current_low_range.enable_high_limit = 0;						// TODO: EEPROM
0001ce  f0260602          BIC      r6,r6,#2
0001d2  f8826020          STRB     r6,[r2,#0x20]
;;;334    	
;;;335    	// 12V channel cannot provide currents > 20A (low range)
;;;336    	channel_12v.current_high_range.RANGE = 1;									// HIGH current range
0001d6  f8926030          LDRB     r6,[r2,#0x30]  ; channel_12v
0001da  f0460604          ORR      r6,r6,#4
;;;337    	channel_12v.current_high_range.setting = 4000;								// TODO: EEPROM
0001de  8455              STRH     r5,[r2,#0x22]
;;;338    	channel_12v.current_high_range.MINIMUM = CONV_LOW_CURRENT_RANGE_MIN;		// Minimum current setting for specified current range
0001e0  8493              STRH     r3,[r2,#0x24]
;;;339    	channel_12v.current_high_range.MAXIMUM = CONV_LOW_CURRENT_RANGE_MAX;		// Maximum current setting for specified current range
0001e2  84d4              STRH     r4,[r2,#0x26]
;;;340    	channel_12v.current_high_range.limit_low = CONV_LOW_CURRENT_RANGE_MIN;		// TODO: EEPROM
0001e4  8513              STRH     r3,[r2,#0x28]
;;;341    	channel_12v.current_high_range.limit_high = CONV_LOW_CURRENT_RANGE_MAX;		// TODO: EEPROM
0001e6  8554              STRH     r4,[r2,#0x2a]
;;;342    	channel_12v.current_high_range.LIMIT_MIN = CONV_LOW_CURRENT_RANGE_MIN;		// Minimum current limit setting
0001e8  8593              STRH     r3,[r2,#0x2c]
;;;343    	channel_12v.current_high_range.LIMIT_MAX = CONV_LOW_CURRENT_RANGE_MAX;		// Maximum current limit setting
0001ea  85d4              STRH     r4,[r2,#0x2e]
;;;344    	channel_12v.current_high_range.enable_low_limit = 0;						// TODO: EEPROM
0001ec  f0260301          BIC      r3,r6,#1
;;;345    	channel_12v.current_high_range.enable_high_limit = 0;						// TODO: EEPROM
0001f0  f0230302          BIC      r3,r3,#2
0001f4  f8823030          STRB     r3,[r2,#0x30]
;;;346    
;;;347    	channel_12v.current = &channel_12v.current_low_range;
0001f8  f101034a          ADD      r3,r1,#0x4a
0001fc  6353              STR      r3,[r2,#0x34]  ; channel_12v
;;;348    	
;;;349    	
;;;350    	// Select default channel
;;;351    	if (default_channel == CHANNEL_12V)
;;;352    		regulation_setting_p = &channel_12v;
0001fe  4c7c              LDR      r4,|L1.1008|
000200  b1c0              CBZ      r0,|L1.564|
;;;353    	else
;;;354    		regulation_setting_p = &channel_5v;
000202  61a1              STR      r1,[r4,#0x18]  ; regulation_setting_p
                  |L1.516|
;;;355    	
;;;356    	
;;;357    	// Apply controls
;;;358    	__disable_irq();
000204  b672              CPSID    i
;;;359    	SetFeedbackChannel(regulation_setting_p->CHANNEL);		// PORTF can be accessed from ISR
000206  69a0              LDR      r0,[r4,#0x18]  ; regulation_setting_p
000208  7800              LDRB     r0,[r0,#0]
00020a  f3c00000          UBFX     r0,r0,#0,#1
00020e  f7fffffe          BL       SetFeedbackChannel
;;;360    	__enable_irq();
000212  b662              CPSIE    i
;;;361    	SetCurrentRange(regulation_setting_p->current->RANGE);
000214  69a0              LDR      r0,[r4,#0x18]  ; regulation_setting_p
000216  6b40              LDR      r0,[r0,#0x34]
000218  7b80              LDRB     r0,[r0,#0xe]
00021a  f3c00080          UBFX     r0,r0,#2,#1
00021e  f7fffffe          BL       SetCurrentRange
;;;362    	SetOutputLoad(regulation_setting_p->load_state);
000222  69a0              LDR      r0,[r4,#0x18]  ; regulation_setting_p
000224  7800              LDRB     r0,[r0,#0]
000226  f3c00040          UBFX     r0,r0,#1,#1
00022a  f7fffffe          BL       SetOutputLoad
;;;363    	apply_regulation();										// Apply voltage and current settings
00022e  e8bd41f0          POP      {r4-r8,lr}
000232  e7fe              B        apply_regulation
                  |L1.564|
000234  61a2              STR      r2,[r4,#0x18]         ;352  ; regulation_setting_p
000236  e7e5              B        |L1.516|
;;;364    }
;;;365    
                          ENDP

                  analyzeAndResetHWErrorState PROC
;;;444    
;;;445    static uint32_t analyzeAndResetHWErrorState(void)
000238  486d              LDR      r0,|L1.1008|
;;;446    {
;;;447    	uint32_t state_flags;
;;;448    	if (state_HWProcess & STATE_HW_OVERLOADED)		
00023a  7801              LDRB     r1,[r0,#0]  ; state_HWProcess
00023c  0749              LSLS     r1,r1,#29
00023e  d506              BPL      |L1.590|
;;;449    	{
;;;450    		ctrl_HWProcess = CMD_HW_RESET_OVERLOAD;		
000240  2104              MOVS     r1,#4
000242  7041              STRB     r1,[r0,#1]
                  |L1.580|
;;;451    		while(ctrl_HWProcess);
000244  7841              LDRB     r1,[r0,#1]  ; ctrl_HWProcess
000246  2900              CMP      r1,#0
000248  d1fc              BNE      |L1.580|
;;;452    		state_flags = CONV_OVERLOAD;	
00024a  2010              MOVS     r0,#0x10
;;;453    	}
;;;454    	// Add more if necessary
;;;455    	else
;;;456    	{
;;;457    		state_flags = 0;
;;;458    	}
;;;459    	return state_flags;
;;;460    }
00024c  4770              BX       lr
                  |L1.590|
00024e  2000              MOVS     r0,#0                 ;457
000250  4770              BX       lr
;;;461    
                          ENDP

                  disableConverterAndCheckHWState PROC
;;;462    static uint32_t disableConverterAndCheckHWState(void)
000252  4867              LDR      r0,|L1.1008|
;;;463    {
;;;464    	uint32_t new_state;
;;;465    	
;;;466    #if CMD_HAS_PRIORITY == 1
;;;467    	// If error status is generated simultaneously with OFF command,
;;;468    	// converter will be turned off and no error status will be shown
;;;469    	ctrl_HWProcess = CMD_HW_OFF | CMD_HW_RESET_OVERLOAD;	// Turn off converter and suppress error status (if any)
000254  2106              MOVS     r1,#6
000256  7041              STRB     r1,[r0,#1]
                  |L1.600|
;;;470    	while(ctrl_HWProcess);
000258  7841              LDRB     r1,[r0,#1]  ; ctrl_HWProcess
00025a  2900              CMP      r1,#0
00025c  d1fc              BNE      |L1.600|
;;;471    	new_state = CONV_OFF;		
00025e  2001              MOVS     r0,#1
;;;472    	
;;;473    #elif ERROR_HAS_PRIORITY == 1
;;;474    	// If error status is generated simultaneously with OFF command,
;;;475    	// converter will be turned off, but error status will be indicated
;;;476    	ctrl_HWProcess = CMD_HW_OFF;					// Turn converter off
;;;477    	while(ctrl_HWProcess);
;;;478    	new_state = CONV_OFF;	
;;;479    	new_state |= analyzeAndResetHWErrorState();	
;;;480    						
;;;481    #endif
;;;482    	return new_state;
;;;483    }
000260  4770              BX       lr
;;;484    
                          ENDP

                  vTaskConverter PROC
;;;491    //---------------------------------------------//
;;;492    void vTaskConverter(void *pvParameters) 
000262  b086              SUB      sp,sp,#0x18
;;;493    {
;;;494    	conveter_message_t msg;
;;;495    	
;;;496    	uint8_t err_code;
;;;497    	uint32_t adc_msg;
;;;498    	uint32_t sound_msg;
;;;499    	
;;;500    	// Initialize
;;;501    	xQueueConverter = xQueueCreate( 5, sizeof( conveter_message_t ) );		// Queue can contain 5 elements of type conveter_message_t
000264  2200              MOVS     r2,#0
000266  210c              MOVS     r1,#0xc
000268  2005              MOVS     r0,#5
00026a  f7fffffe          BL       xQueueGenericCreate
00026e  4c60              LDR      r4,|L1.1008|
000270  61e0              STR      r0,[r4,#0x1c]  ; xQueueConverter
;;;502    	if( xQueueConverter == 0 )
000272  b918              CBNZ     r0,|L1.636|
                  |L1.628|
;;;503    	{
;;;504    		// Queue was not created and must not be used.
;;;505    		while(1);
000274  e7fe              B        |L1.628|
                  |L1.630|
;;;506    	}
;;;507    	
;;;508    	// Wait until task is started by dispatcher
;;;509    	//vTaskSuspend(vTaskConverter);			
;;;510    	
;;;511    	while (taskConverter_Enable == 0)
;;;512    		vTaskDelay(5);
000276  2005              MOVS     r0,#5
000278  f7fffffe          BL       vTaskDelay
                  |L1.636|
00027c  78e0              LDRB     r0,[r4,#3]            ;511  ; taskConverter_Enable
00027e  2800              CMP      r0,#0                 ;511
000280  d0f9              BEQ      |L1.630|
;;;513    	
;;;514    	xQueueReset(xQueueConverter);
000282  2100              MOVS     r1,#0
000284  69e0              LDR      r0,[r4,#0x1c]  ; xQueueConverter
000286  f7fffffe          BL       xQueueGenericReset
;;;515    	
;;;516    	
;;;517    	while(1)
;;;518    	{
;;;519    		xQueueReceive(xQueueConverter, &msg, portMAX_DELAY);
;;;520    	
;;;521    		// CHECKME - Possibly need to add a mechanism to protect against illegal messages ?
;;;522    		// For example, GUI sends message to set new voltage, but converter has switched channel by comand from UART.
;;;523    		// In this case, command from GUI is old and bad and should be ignored somehow.
;;;524    
;;;525    		switch (msg.type)
;;;526    		{
;;;527    			case CONVERTER_SET_VOLTAGE:
;;;528    				regulation_setting_p->voltage.setting = CheckSetVoltageRange(msg.data.a, &err_code);
;;;529    				//----- Send notification to GUI -----//
;;;530    				gui_msg = GUI_TASK_UPDATE_VOLTAGE_SETTING;
;;;531    				xQueueSendToFront(xQueueGUI, &gui_msg, 0);
00028a  4d5b              LDR      r5,|L1.1016|
;;;532    				//------------------------------------//
;;;533    				if ((err_code == VCHECK_ABS_MAX) || (err_code == VCHECK_ABS_MIN))
;;;534    					sound_msg = SND_CONV_SETTING_ILLEGAL;
;;;535    				else if ((err_code == VCHECK_SOFT_MAX) || (err_code == VCHECK_SOFT_MIN))
;;;536    					sound_msg = SND_CONV_SETTING_ILLEGAL;
;;;537    				else
;;;538    					sound_msg = SND_CONV_SETTING_OK;
;;;539    				sound_msg |= SND_CONVERTER_PRIORITY_NORMAL;
;;;540    				xQueueSendToBack(xQueueSound, &sound_msg, 0);
00028c  f8df916c          LDR      r9,|L1.1020|
000290  f44f3700          MOV      r7,#0x20000           ;534
000294  2608              MOVS     r6,#8                 ;525
000296  f04f0809          MOV      r8,#9                 ;525
00029a  f04f0a01          MOV      r10,#1                ;531
                  |L1.670|
00029e  2300              MOVS     r3,#0                 ;519
0002a0  1e5a              SUBS     r2,r3,#1              ;519
0002a2  a903              ADD      r1,sp,#0xc            ;519
0002a4  69e0              LDR      r0,[r4,#0x1c]         ;519  ; xQueueConverter
0002a6  f7fffffe          BL       xQueueGenericReceive
0002aa  9803              LDR      r0,[sp,#0xc]          ;525
0002ac  2807              CMP      r0,#7                 ;525
0002ae  d004              BEQ      |L1.698|
0002b0  2808              CMP      r0,#8                 ;525
0002b2  d05b              BEQ      |L1.876|
0002b4  2809              CMP      r0,#9                 ;525
0002b6  d127              BNE      |L1.776|
0002b8  e02b              B        |L1.786|
                  |L1.698|
0002ba  a902              ADD      r1,sp,#8              ;528
0002bc  9804              LDR      r0,[sp,#0x10]         ;528
0002be  f7fffffe          BL       CheckSetVoltageRange
0002c2  69a1              LDR      r1,[r4,#0x18]         ;528  ; regulation_setting_p
0002c4  8048              STRH     r0,[r1,#2]            ;528
0002c6  2006              MOVS     r0,#6                 ;530
0002c8  6160              STR      r0,[r4,#0x14]         ;530  ; gui_msg
0002ca  4949              LDR      r1,|L1.1008|
0002cc  2301              MOVS     r3,#1                 ;531
0002ce  2200              MOVS     r2,#0                 ;531
0002d0  3114              ADDS     r1,r1,#0x14           ;531
0002d2  6828              LDR      r0,[r5,#0]            ;531  ; xQueueGUI
0002d4  f7fffffe          BL       xQueueGenericSend
0002d8  f89d0008          LDRB     r0,[sp,#8]            ;533
0002dc  2802              CMP      r0,#2                 ;533
0002de  d014              BEQ      |L1.778|
0002e0  2803              CMP      r0,#3                 ;533
0002e2  d012              BEQ      |L1.778|
0002e4  2804              CMP      r0,#4                 ;535
0002e6  d012              BEQ      |L1.782|
0002e8  2805              CMP      r0,#5                 ;535
0002ea  d010              BEQ      |L1.782|
0002ec  f44f3080          MOV      r0,#0x10000           ;538
0002f0  9000              STR      r0,[sp,#0]            ;538
                  |L1.754|
0002f2  9800              LDR      r0,[sp,#0]            ;539
0002f4  f0400032          ORR      r0,r0,#0x32           ;539
0002f8  9000              STR      r0,[sp,#0]            ;539
0002fa  2300              MOVS     r3,#0
0002fc  461a              MOV      r2,r3
0002fe  4669              MOV      r1,sp
000300  f8d90000          LDR      r0,[r9,#0]  ; xQueueSound
000304  f7fffffe          BL       xQueueGenericSend
                  |L1.776|
;;;541    				break;
000308  e069              B        |L1.990|
                  |L1.778|
00030a  9700              STR      r7,[sp,#0]            ;534
00030c  e7f1              B        |L1.754|
                  |L1.782|
00030e  9700              STR      r7,[sp,#0]            ;536
000310  e7ef              B        |L1.754|
                  |L1.786|
;;;542    			case CONVERTER_SET_CURRENT:
;;;543    				regulation_setting_p->current->setting = CheckSetCurrentRange(msg.data.a, &err_code);
000312  a902              ADD      r1,sp,#8
000314  9804              LDR      r0,[sp,#0x10]
000316  f7fffffe          BL       CheckSetCurrentRange
00031a  69a1              LDR      r1,[r4,#0x18]  ; regulation_setting_p
00031c  6b49              LDR      r1,[r1,#0x34]
00031e  8008              STRH     r0,[r1,#0]
;;;544    				//----- Send notification to GUI -----//
;;;545    				gui_msg = GUI_TASK_UPDATE_CURRENT_SETTING;
000320  2007              MOVS     r0,#7
000322  6160              STR      r0,[r4,#0x14]  ; gui_msg
;;;546    				xQueueSendToFront(xQueueGUI, &gui_msg, 0);
000324  4932              LDR      r1,|L1.1008|
000326  2301              MOVS     r3,#1
000328  2200              MOVS     r2,#0
00032a  3114              ADDS     r1,r1,#0x14
00032c  6828              LDR      r0,[r5,#0]  ; xQueueGUI
00032e  f7fffffe          BL       xQueueGenericSend
;;;547    				//------------------------------------//
;;;548    				if ((err_code == CCHECK_ABS_MAX) || (err_code == CCHECK_ABS_MIN))
000332  f89d0008          LDRB     r0,[sp,#8]
000336  2809              CMP      r0,#9
000338  d014              BEQ      |L1.868|
00033a  280a              CMP      r0,#0xa
00033c  d012              BEQ      |L1.868|
;;;549    					sound_msg = SND_CONV_SETTING_ILLEGAL;
;;;550    				else if ((err_code == CCHECK_SOFT_MAX) || (err_code == CCHECK_SOFT_MIN))
00033e  280b              CMP      r0,#0xb
000340  d012              BEQ      |L1.872|
000342  280c              CMP      r0,#0xc
000344  d010              BEQ      |L1.872|
;;;551    					sound_msg = SND_CONV_SETTING_ILLEGAL;
;;;552    				else
;;;553    					sound_msg = SND_CONV_SETTING_OK;
000346  f44f3080          MOV      r0,#0x10000
00034a  9000              STR      r0,[sp,#0]
                  |L1.844|
;;;554    				sound_msg |= SND_CONVERTER_PRIORITY_NORMAL;
00034c  9800              LDR      r0,[sp,#0]
00034e  f0400032          ORR      r0,r0,#0x32
000352  9000              STR      r0,[sp,#0]
;;;555    				xQueueSendToBack(xQueueSound, &sound_msg, 0);
000354  2300              MOVS     r3,#0
000356  461a              MOV      r2,r3
000358  4669              MOV      r1,sp
00035a  f8d90000          LDR      r0,[r9,#0]  ; xQueueSound
00035e  f7fffffe          BL       xQueueGenericSend
;;;556    				break;
000362  e03c              B        |L1.990|
                  |L1.868|
000364  9700              STR      r7,[sp,#0]            ;549
000366  e7f1              B        |L1.844|
                  |L1.872|
000368  9700              STR      r7,[sp,#0]            ;551
00036a  e7ef              B        |L1.844|
                  |L1.876|
;;;557    			case CONVERTER_SET_VOLTAGE_LIMIT:
;;;558    				// Apply new voltage limit
;;;559    				
;;;560    				//msg.voltage_limit_setting.mode
;;;561    				//msg.voltage_limit_setting.enable
;;;562    				//msg.voltage_limit_setting.value
;;;563    				
;;;564    				err_code =  Converter_SetVoltageLimit( msg.voltage_limit_setting.mode, 
00036c  f8bd0012          LDRH     r0,[sp,#0x12]
000370  9905              LDR      r1,[sp,#0x14]
000372  b2c2              UXTB     r2,r0
000374  f8bd0010          LDRH     r0,[sp,#0x10]
000378  b2c0              UXTB     r0,r0
00037a  f7fffffe          BL       Converter_SetVoltageLimit
00037e  9002              STR      r0,[sp,#8]
;;;565    													  (int32_t)msg.voltage_limit_setting.value, 
;;;566    												      msg.voltage_limit_setting.enable);
;;;567    				
;;;568    		
;;;569    				/*
;;;570    				errCode = Converter_SetSoftLimit((int32_t)msg.data.b, regulation_setting_p, (uint8_t)msg.data.a);
;;;571    				if (msg.data.a & 0x80000000)	// if limit enabled
;;;572    				{
;;;573    					regulation_setting_p.soft_voltage_limits_enable |= ((uint8_t)msg.data.a == 0x00) ? ENABLE_LOW_LIMIT : ENABLE_HIGH_LIMIT;
;;;574    				}
;;;575    				else
;;;576    				{
;;;577    					regulation_setting_p.soft_voltage_limits_enable &= ~((uint8_t)msg.data.a == 0x00) ? ENABLE_LOW_LIMIT : ENABLE_HIGH_LIMIT;
;;;578    				} */
;;;579    				//----- Send notification to GUI -----//
;;;580    				gui_msg = GUI_TASK_UPDATE_SOFT_LIMIT_SETTINGS;
000380  200b              MOVS     r0,#0xb
000382  6160              STR      r0,[r4,#0x14]  ; gui_msg
;;;581    				xQueueSendToFront(xQueueGUI, &gui_msg, 0);
000384  491a              LDR      r1,|L1.1008|
000386  2301              MOVS     r3,#1
000388  2200              MOVS     r2,#0
00038a  3114              ADDS     r1,r1,#0x14
00038c  6828              LDR      r0,[r5,#0]  ; xQueueGUI
00038e  f7fffffe          BL       xQueueGenericSend
;;;582    				//------------------------------------//
;;;583    				
;;;584    				// Apply limit settings to voltage
;;;585    				regulation_setting_p->voltage.setting = CheckSetVoltageRange(regulation_setting_p->voltage.setting, 0);
000392  69a0              LDR      r0,[r4,#0x18]  ; regulation_setting_p
000394  2100              MOVS     r1,#0
000396  8840              LDRH     r0,[r0,#2]
000398  f7fffffe          BL       CheckSetVoltageRange
00039c  69a1              LDR      r1,[r4,#0x18]  ; regulation_setting_p
00039e  8048              STRH     r0,[r1,#2]
;;;586    				//----- Send notification to GUI -----//
;;;587    				gui_msg = GUI_TASK_UPDATE_VOLTAGE_SETTING;
0003a0  2006              MOVS     r0,#6
0003a2  6160              STR      r0,[r4,#0x14]  ; gui_msg
;;;588    				xQueueSendToFront(xQueueGUI, &gui_msg, 0);
0003a4  4912              LDR      r1,|L1.1008|
0003a6  2301              MOVS     r3,#1
0003a8  2200              MOVS     r2,#0
0003aa  3114              ADDS     r1,r1,#0x14
0003ac  6828              LDR      r0,[r5,#0]  ; xQueueGUI
0003ae  f7fffffe          BL       xQueueGenericSend
;;;589    				//------------------------------------//
;;;590    				
;;;591    				// Apply voltage and current settings
;;;592    				apply_regulation();		
0003b2  f7fffffe          BL       apply_regulation
;;;593    				
;;;594    				if ((err_code == SLIM_MAX) || (err_code == SLIM_MIN))
0003b6  f89d0008          LDRB     r0,[sp,#8]
0003ba  2812              CMP      r0,#0x12
0003bc  d020              BEQ      |L1.1024|
0003be  2811              CMP      r0,#0x11
0003c0  d01e              BEQ      |L1.1024|
;;;595    					sound_msg = SND_CONV_SETTING_ILLEGAL;
;;;596    				else
;;;597    					sound_msg = SND_CONV_SETTING_OK;
0003c2  f44f3080          MOV      r0,#0x10000
0003c6  9000              STR      r0,[sp,#0]
                  |L1.968|
;;;598    				sound_msg |= SND_CONVERTER_PRIORITY_NORMAL;
0003c8  9800              LDR      r0,[sp,#0]
0003ca  f0400032          ORR      r0,r0,#0x32
0003ce  9000              STR      r0,[sp,#0]
;;;599    				xQueueSendToBack(xQueueSound, &sound_msg, 0);
0003d0  2300              MOVS     r3,#0
0003d2  461a              MOV      r2,r3
0003d4  4669              MOV      r1,sp
0003d6  f8d90000          LDR      r0,[r9,#0]  ; xQueueSound
0003da  f7fffffe          BL       xQueueGenericSend
                  |L1.990|
;;;600    				break;
;;;601    		}
;;;602    		
;;;603    
;;;604    		
;;;605    		switch(conv_state & CONV_STATE_MASK)
0003de  6920              LDR      r0,[r4,#0x10]  ; conv_state
0003e0  f000000f          AND      r0,r0,#0xf
0003e4  2801              CMP      r0,#1
0003e6  d00d              BEQ      |L1.1028|
0003e8  2802              CMP      r0,#2
0003ea  d11a              BNE      |L1.1058|
0003ec  e062              B        |L1.1204|
0003ee  0000              DCW      0x0000
                  |L1.1008|
                          DCD      ||.data||
                  |L1.1012|
                          DCD      ||.bss||
                  |L1.1016|
                          DCD      xQueueGUI
                  |L1.1020|
                          DCD      xQueueSound
                  |L1.1024|
000400  9700              STR      r7,[sp,#0]            ;595
000402  e7e1              B        |L1.968|
                  |L1.1028|
;;;606    		{
;;;607    			case CONV_OFF:
;;;608    				if (msg.type == CONVERTER_SWITCH_TO_5VCH)
000404  9803              LDR      r0,[sp,#0xc]
000406  2804              CMP      r0,#4
000408  d00c              BEQ      |L1.1060|
;;;609    				{
;;;610    					regulation_setting_p = &channel_5v;
;;;611    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
;;;612    					//----- Send notification to GUI -----//
;;;613    					gui_msg = GUI_TASK_UPDATE_FEEDBACK_CHANNEL;
;;;614    					xQueueSendToFront(xQueueGUI, &gui_msg, 0);
;;;615    					//------------------------------------//
;;;616    					while(ctrl_HWProcess);
;;;617    					break;
;;;618    				}
;;;619    				if (msg.type == CONVERTER_SWITCH_TO_12VCH)
00040a  9803              LDR      r0,[sp,#0xc]
00040c  2805              CMP      r0,#5
00040e  d018              BEQ      |L1.1090|
;;;620    				{
;;;621    					regulation_setting_p = &channel_12v;
;;;622    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
;;;623    					//----- Send notification to GUI -----//
;;;624    					gui_msg = GUI_TASK_UPDATE_FEEDBACK_CHANNEL;
;;;625    					xQueueSendToFront(xQueueGUI, &gui_msg, 0);
;;;626    					//------------------------------------//
;;;627    					while(ctrl_HWProcess);
;;;628    					break;
;;;629    				}
;;;630    				if (msg.type == CONVERTER_SET_CURRENT_RANGE)
000410  9803              LDR      r0,[sp,#0xc]
000412  2806              CMP      r0,#6
000414  d025              BEQ      |L1.1122|
;;;631    				{
;;;632    					if (msg.data.a == CURRENT_RANGE_HIGH)
;;;633    						regulation_setting_p->current = &regulation_setting_p->current_high_range;
;;;634    					else
;;;635    						regulation_setting_p->current = &regulation_setting_p->current_low_range;
;;;636    					
;;;637    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
;;;638    					//----- Send notification to GUI -----//
;;;639    					gui_msg = GUI_TASK_UPDATE_CURRENT_LIMIT;
;;;640    					xQueueSendToFront(xQueueGUI, &gui_msg, 0);
;;;641    					//------------------------------------//
;;;642    					while(ctrl_HWProcess);
;;;643    					break;
;;;644    				}
;;;645    
;;;646    				if (msg.type == CONVERTER_TURN_OFF)
000416  9803              LDR      r0,[sp,#0xc]
000418  2803              CMP      r0,#3
00041a  d03a              BEQ      |L1.1170|
;;;647    				{
;;;648    					conv_state = CONV_OFF;			// Reset overload flag
;;;649    					break;
;;;650    				}
;;;651    				if (msg.type == CONVERTER_TURN_ON)
00041c  9803              LDR      r0,[sp,#0xc]
00041e  2802              CMP      r0,#2
000420  d03a              BEQ      |L1.1176|
                  |L1.1058|
000422  e0a0              B        |L1.1382|
                  |L1.1060|
000424  48cc              LDR      r0,|L1.1880|
000426  61a0              STR      r0,[r4,#0x18]         ;610  ; regulation_setting_p
000428  7066              STRB     r6,[r4,#1]            ;611
00042a  f8c48014          STR      r8,[r4,#0x14]         ;613  ; gui_msg
00042e  2301              MOVS     r3,#1                 ;614
000430  2200              MOVS     r2,#0                 ;614
000432  49ca              LDR      r1,|L1.1884|
000434  6828              LDR      r0,[r5,#0]            ;614  ; xQueueGUI
000436  f7fffffe          BL       xQueueGenericSend
                  |L1.1082|
00043a  7860              LDRB     r0,[r4,#1]            ;616  ; ctrl_HWProcess
00043c  2800              CMP      r0,#0                 ;616
00043e  d1fc              BNE      |L1.1082|
000440  e091              B        |L1.1382|
                  |L1.1090|
000442  48c5              LDR      r0,|L1.1880|
000444  3038              ADDS     r0,r0,#0x38           ;621
000446  61a0              STR      r0,[r4,#0x18]         ;621  ; regulation_setting_p
000448  7066              STRB     r6,[r4,#1]            ;622
00044a  f8c48014          STR      r8,[r4,#0x14]         ;624  ; gui_msg
00044e  2301              MOVS     r3,#1                 ;625
000450  2200              MOVS     r2,#0                 ;625
000452  49c2              LDR      r1,|L1.1884|
000454  6828              LDR      r0,[r5,#0]            ;625  ; xQueueGUI
000456  f7fffffe          BL       xQueueGenericSend
                  |L1.1114|
00045a  7860              LDRB     r0,[r4,#1]            ;627  ; ctrl_HWProcess
00045c  2800              CMP      r0,#0                 ;627
00045e  d1fc              BNE      |L1.1114|
000460  e081              B        |L1.1382|
                  |L1.1122|
000462  9804              LDR      r0,[sp,#0x10]         ;632
000464  2801              CMP      r0,#1                 ;632
000466  d00f              BEQ      |L1.1160|
000468  69a0              LDR      r0,[r4,#0x18]         ;635  ; regulation_setting_p
00046a  f1000112          ADD      r1,r0,#0x12           ;635
00046e  6341              STR      r1,[r0,#0x34]         ;635
                  |L1.1136|
000470  7066              STRB     r6,[r4,#1]            ;637
000472  6166              STR      r6,[r4,#0x14]         ;639  ; gui_msg
000474  2301              MOVS     r3,#1                 ;640
000476  2200              MOVS     r2,#0                 ;640
000478  49b8              LDR      r1,|L1.1884|
00047a  6828              LDR      r0,[r5,#0]            ;640  ; xQueueGUI
00047c  f7fffffe          BL       xQueueGenericSend
                  |L1.1152|
000480  7860              LDRB     r0,[r4,#1]            ;642  ; ctrl_HWProcess
000482  2800              CMP      r0,#0                 ;642
000484  d1fc              BNE      |L1.1152|
000486  e06e              B        |L1.1382|
                  |L1.1160|
000488  69a0              LDR      r0,[r4,#0x18]         ;633  ; regulation_setting_p
00048a  f1000122          ADD      r1,r0,#0x22           ;633
00048e  6341              STR      r1,[r0,#0x34]         ;633
000490  e7ee              B        |L1.1136|
                  |L1.1170|
000492  f8c4a010          STR      r10,[r4,#0x10]        ;648  ; conv_state
000496  e066              B        |L1.1382|
                  |L1.1176|
;;;652    				{
;;;653    					// Message to turn on converter is received
;;;654    					if ((state_HWProcess & STATE_HW_TIMER_NOT_EXPIRED) || (!(state_HWProcess & STATE_HW_USER_TIMER_EXPIRED)))
000498  7820              LDRB     r0,[r4,#0]  ; state_HWProcess
00049a  06c0              LSLS     r0,r0,#27
00049c  d463              BMI      |L1.1382|
00049e  7820              LDRB     r0,[r4,#0]  ; state_HWProcess
0004a0  0680              LSLS     r0,r0,#26
0004a2  d560              BPL      |L1.1382|
;;;655    					{
;;;656    						// Safe timeout is not expired
;;;657    						break;
;;;658    					}
;;;659    					ctrl_HWProcess = CMD_HW_ON;
0004a4  f884a001          STRB     r10,[r4,#1]
                  |L1.1192|
;;;660    					while(ctrl_HWProcess);
0004a8  7860              LDRB     r0,[r4,#1]  ; ctrl_HWProcess
0004aa  2800              CMP      r0,#0
0004ac  d1fc              BNE      |L1.1192|
;;;661    					conv_state = CONV_ON;			// Switch to new state and reset overload flag
0004ae  2002              MOVS     r0,#2
0004b0  6120              STR      r0,[r4,#0x10]  ; conv_state
;;;662    					break;
0004b2  e058              B        |L1.1382|
                  |L1.1204|
;;;663    				}
;;;664    				break;
;;;665    			case CONV_ON:
;;;666    				if (msg.type == CONVERTER_TURN_OFF)
0004b4  9803              LDR      r0,[sp,#0xc]
0004b6  2803              CMP      r0,#3
0004b8  d003              BEQ      |L1.1218|
;;;667    				{
;;;668    					conv_state = disableConverterAndCheckHWState();
;;;669    					break;
;;;670    				}
;;;671    				if ( (msg.type == CONVERTER_SWITCH_TO_5VCH) && (regulation_setting_p != &channel_5v) )
0004ba  9803              LDR      r0,[sp,#0xc]
0004bc  2804              CMP      r0,#4
0004be  d004              BEQ      |L1.1226|
0004c0  e01d              B        |L1.1278|
                  |L1.1218|
0004c2  f7fffffe          BL       disableConverterAndCheckHWState
0004c6  6120              STR      r0,[r4,#0x10]         ;668  ; conv_state
0004c8  e04d              B        |L1.1382|
                  |L1.1226|
0004ca  f8dfb28c          LDR      r11,|L1.1880|
0004ce  69a0              LDR      r0,[r4,#0x18]  ; regulation_setting_p
0004d0  4558              CMP      r0,r11
0004d2  d014              BEQ      |L1.1278|
;;;672    				{
;;;673    					conv_state = disableConverterAndCheckHWState();
0004d4  f7fffffe          BL       disableConverterAndCheckHWState
0004d8  6120              STR      r0,[r4,#0x10]  ; conv_state
;;;674    					vTaskDelay(4);
0004da  2004              MOVS     r0,#4
0004dc  f7fffffe          BL       vTaskDelay
;;;675    					regulation_setting_p = &channel_5v;
0004e0  f8c4b018          STR      r11,[r4,#0x18]  ; regulation_setting_p
;;;676    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
0004e4  7066              STRB     r6,[r4,#1]
;;;677    					//----- Send notification to GUI -----//
;;;678    					gui_msg = GUI_TASK_UPDATE_FEEDBACK_CHANNEL;
0004e6  f8c48014          STR      r8,[r4,#0x14]  ; gui_msg
;;;679    					xQueueSendToFront(xQueueGUI, &gui_msg, 0);
0004ea  2301              MOVS     r3,#1
0004ec  2200              MOVS     r2,#0
0004ee  499b              LDR      r1,|L1.1884|
0004f0  6828              LDR      r0,[r5,#0]  ; xQueueGUI
0004f2  f7fffffe          BL       xQueueGenericSend
                  |L1.1270|
;;;680    					//------------------------------------//
;;;681    					while(ctrl_HWProcess);
0004f6  7860              LDRB     r0,[r4,#1]  ; ctrl_HWProcess
0004f8  2800              CMP      r0,#0
0004fa  d1fc              BNE      |L1.1270|
0004fc  e033              B        |L1.1382|
                  |L1.1278|
;;;682    					break;
;;;683    				}
;;;684    				if ( (msg.type == CONVERTER_SWITCH_TO_12VCH) && (regulation_setting_p != &channel_12v) )
0004fe  9803              LDR      r0,[sp,#0xc]
000500  2805              CMP      r0,#5
000502  d11b              BNE      |L1.1340|
000504  f8dfb250          LDR      r11,|L1.1880|
000508  69a0              LDR      r0,[r4,#0x18]  ; regulation_setting_p
00050a  f10b0b38          ADD      r11,r11,#0x38
00050e  4558              CMP      r0,r11
000510  d014              BEQ      |L1.1340|
;;;685    				{
;;;686    					conv_state = disableConverterAndCheckHWState();
000512  f7fffffe          BL       disableConverterAndCheckHWState
000516  6120              STR      r0,[r4,#0x10]  ; conv_state
;;;687    					vTaskDelay(4);
000518  2004              MOVS     r0,#4
00051a  f7fffffe          BL       vTaskDelay
;;;688    					regulation_setting_p = &channel_12v;
00051e  f8c4b018          STR      r11,[r4,#0x18]  ; regulation_setting_p
;;;689    					ctrl_HWProcess = CMD_HW_RESTART_USER_TIMER;
000522  7066              STRB     r6,[r4,#1]
;;;690    					//----- Send notification to GUI -----//
;;;691    					gui_msg = GUI_TASK_UPDATE_FEEDBACK_CHANNEL;
000524  f8c48014          STR      r8,[r4,#0x14]  ; gui_msg
;;;692    					xQueueSendToFront(xQueueGUI, &gui_msg, 0);
000528  2301              MOVS     r3,#1
00052a  2200              MOVS     r2,#0
00052c  498b              LDR      r1,|L1.1884|
00052e  6828              LDR      r0,[r5,#0]  ; xQueueGUI
000530  f7fffffe          BL       xQueueGenericSend
                  |L1.1332|
;;;693    					//------------------------------------//
;;;694    					while(ctrl_HWProcess);
000534  7860              LDRB     r0,[r4,#1]  ; ctrl_HWProcess
000536  2800              CMP      r0,#0
000538  d1fc              BNE      |L1.1332|
00053a  e014              B        |L1.1382|
                  |L1.1340|
;;;695    					break;
;;;696    				}
;;;697    				if (state_HWProcess & STATE_HW_OFF)
00053c  7820              LDRB     r0,[r4,#0]  ; state_HWProcess
00053e  0780              LSLS     r0,r0,#30
000540  d511              BPL      |L1.1382|
;;;698    				{
;;;699    					// Some hardware error has happened and converter had been switched off
;;;700    					conv_state = CONV_OFF;
000542  f8c4a010          STR      r10,[r4,#0x10]  ; conv_state
;;;701    					conv_state |= analyzeAndResetHWErrorState();
000546  f7fffffe          BL       analyzeAndResetHWErrorState
00054a  6921              LDR      r1,[r4,#0x10]  ; conv_state
00054c  4308              ORRS     r0,r0,r1
00054e  6120              STR      r0,[r4,#0x10]  ; conv_state
;;;702    					if (conv_state & CONV_OVERLOAD)
000550  06c0              LSLS     r0,r0,#27
000552  d508              BPL      |L1.1382|
;;;703    					{
;;;704    						// Send message to sound driver
;;;705    						// TODO: send this message in other cases (when overload is detected simultaneously with button)
;;;706    						sound_msg = SND_CONV_OVERLOADED | SND_CONVERTER_PRIORITY_HIGHEST;
000554  4882              LDR      r0,|L1.1888|
000556  9000              STR      r0,[sp,#0]
;;;707    						xQueueSendToBack(xQueueSound, &sound_msg, 0);
000558  2300              MOVS     r3,#0
00055a  461a              MOV      r2,r3
00055c  4669              MOV      r1,sp
00055e  f8d90000          LDR      r0,[r9,#0]  ; xQueueSound
000562  f7fffffe          BL       xQueueGenericSend
                  |L1.1382|
;;;708    					}
;;;709    					break;
;;;710    				}
;;;711    				break;
;;;712    		}
;;;713    		
;;;714    		
;;;715    		// Will be special for charging mode - TODO
;;;716    		if (msg.type == CONVERTER_TICK)
000566  9803              LDR      r0,[sp,#0xc]
000568  b940              CBNZ     r0,|L1.1404|
;;;717    		{
;;;718    			// ADC task is responsible for sampling and filtering voltage and current
;;;719    			adc_msg = ADC_GET_ALL_NORMAL;
00056a  f8cda004          STR      r10,[sp,#4]
;;;720    			xQueueSendToBack(xQueueADC, &adc_msg, 0);
00056e  487d              LDR      r0,|L1.1892|
000570  2300              MOVS     r3,#0
000572  461a              MOV      r2,r3
000574  a901              ADD      r1,sp,#4
000576  6800              LDR      r0,[r0,#0]  ; xQueueADC
000578  f7fffffe          BL       xQueueGenericSend
                  |L1.1404|
;;;721    		}			
;;;722    		
;;;723    		// Apply controls
;;;724    		__disable_irq();
00057c  b672              CPSID    i
;;;725    		SetFeedbackChannel(regulation_setting_p->CHANNEL);		// PORTF can be accessed from ISR
00057e  69a0              LDR      r0,[r4,#0x18]  ; regulation_setting_p
000580  7800              LDRB     r0,[r0,#0]
000582  f3c00000          UBFX     r0,r0,#0,#1
000586  f7fffffe          BL       SetFeedbackChannel
;;;726    		__enable_irq();
00058a  b662              CPSIE    i
;;;727    		SetCurrentRange(regulation_setting_p->current->RANGE);
00058c  69a0              LDR      r0,[r4,#0x18]  ; regulation_setting_p
00058e  6b40              LDR      r0,[r0,#0x34]
000590  7b80              LDRB     r0,[r0,#0xe]
000592  f3c00080          UBFX     r0,r0,#2,#1
000596  f7fffffe          BL       SetCurrentRange
;;;728    		SetOutputLoad(channel_12v.load_state);
00059a  486f              LDR      r0,|L1.1880|
00059c  3038              ADDS     r0,r0,#0x38
00059e  7800              LDRB     r0,[r0,#0]  ; channel_12v
0005a0  f3c00040          UBFX     r0,r0,#1,#1
0005a4  f7fffffe          BL       SetOutputLoad
;;;729    	
;;;730    		// Always make sure settings are within allowed range
;;;731    		regulation_setting_p->current->setting = CheckSetCurrentRange((int32_t)regulation_setting_p->current->setting, &err_code);
0005a8  69a0              LDR      r0,[r4,#0x18]  ; regulation_setting_p
0005aa  a902              ADD      r1,sp,#8
0005ac  6b40              LDR      r0,[r0,#0x34]
0005ae  8800              LDRH     r0,[r0,#0]
0005b0  f7fffffe          BL       CheckSetCurrentRange
0005b4  69a1              LDR      r1,[r4,#0x18]  ; regulation_setting_p
0005b6  6b49              LDR      r1,[r1,#0x34]
0005b8  8008              STRH     r0,[r1,#0]
;;;732    		regulation_setting_p->voltage.setting = CheckSetVoltageRange((int32_t)regulation_setting_p->voltage.setting, &err_code);
0005ba  69a0              LDR      r0,[r4,#0x18]  ; regulation_setting_p
0005bc  a902              ADD      r1,sp,#8
0005be  8840              LDRH     r0,[r0,#2]
0005c0  f7fffffe          BL       CheckSetVoltageRange
0005c4  69a1              LDR      r1,[r4,#0x18]  ; regulation_setting_p
0005c6  8048              STRH     r0,[r1,#2]
;;;733    
;;;734    		// Apply voltage and current settings
;;;735    		apply_regulation();		
0005c8  f7fffffe          BL       apply_regulation
0005cc  e667              B        |L1.670|
;;;736    		
;;;737    	
;;;738    		// LED indication
;;;739    
;;;740    	}
;;;741    	
;;;742    }
;;;743    
                          ENDP

                  Converter_HWProcess PROC
;;;763    //---------------------------------------------//
;;;764    void Converter_HWProcess(void) 
0005ce  e92d41f0          PUSH     {r4-r8,lr}
;;;765    {
;;;766    	static uint16_t overload_ignore_counter;
;;;767    	static uint16_t overload_counter;
;;;768    	static uint16_t safe_counter = 0;
;;;769    	static uint16_t user_counter = 0;
;;;770    	static uint16_t led_blink_counter = 0;
;;;771    	static uint16_t overload_warning_counter = 0;
;;;772    	uint8_t overload_check_enable;
;;;773    	uint8_t raw_overload_flag;
;;;774    	uint8_t led_state;
;;;775    
;;;776    	//-------------------------------//
;;;777    	// Get converter status and process overload timers
;;;778    	
;;;779    	// Due to hardware specialty overload input is active when converter is powered off
;;;780    	// Overload timeout counter reaches 0 when converter has been enabled for OVERLOAD_IGNORE_TIMEOUT ticks
;;;781    	overload_check_enable = 0;
0005d2  2000              MOVS     r0,#0
;;;782    	if (state_HWProcess & (STATE_HW_OFF | STATE_HW_OFF_BY_ADC))
0005d4  4d61              LDR      r5,|L1.1884|
0005d6  3d14              SUBS     r5,r5,#0x14
0005d8  7829              LDRB     r1,[r5,#0]  ; state_HWProcess
;;;783    		overload_ignore_counter = OVERLOAD_IGNORE_TIMEOUT;
0005da  f44f76fa          MOV      r6,#0x1f4
0005de  f0110f0a          TST      r1,#0xa               ;782
0005e2  d001              BEQ      |L1.1512|
0005e4  80ae              STRH     r6,[r5,#4]
0005e6  e005              B        |L1.1524|
                  |L1.1512|
;;;784    	else if (overload_ignore_counter != 0)
0005e8  88a9              LDRH     r1,[r5,#4]  ; overload_ignore_counter
0005ea  b111              CBZ      r1,|L1.1522|
;;;785    		overload_ignore_counter--;
0005ec  1e49              SUBS     r1,r1,#1
0005ee  80a9              STRH     r1,[r5,#4]
0005f0  e000              B        |L1.1524|
                  |L1.1522|
;;;786    	else
;;;787    		overload_check_enable = 1;
0005f2  2001              MOVS     r0,#1
                  |L1.1524|
;;;788    	
;;;789    	// Apply top-level overload check control
;;;790    	//if (__overload_functions_disabled__)
;;;791    	//	overload_check_enable = 0;
;;;792    	
;;;793    	if (overload_check_enable)
0005f4  b118              CBZ      r0,|L1.1534|
;;;794    		raw_overload_flag = GetOverloadStatus();
0005f6  f7fffffe          BL       GetOverloadStatus
0005fa  4604              MOV      r4,r0
0005fc  e000              B        |L1.1536|
                  |L1.1534|
;;;795    	else
;;;796    		raw_overload_flag = NORMAL;
0005fe  2400              MOVS     r4,#0
                  |L1.1536|
;;;797    	
;;;798    	if (raw_overload_flag == NORMAL)
000600  b13c              CBZ      r4,|L1.1554|
;;;799    		overload_counter = OVERLOAD_TIMEOUT;
;;;800    	else if (overload_counter != 0)
000602  88e8              LDRH     r0,[r5,#6]  ; overload_counter
000604  b108              CBZ      r0,|L1.1546|
;;;801    		overload_counter--;
000606  1e40              SUBS     r0,r0,#1
000608  80e8              STRH     r0,[r5,#6]
                  |L1.1546|
;;;802    	
;;;803    
;;;804    	//-------------------------------//
;;;805    	// Check overload 	
;;;806    	if (overload_counter == 0)
00060a  88e8              LDRH     r0,[r5,#6]  ; overload_counter
;;;807    	{
;;;808    		// Converter is overloaded
;;;809    		state_HWProcess &= ~STATE_HW_ON;
;;;810    		state_HWProcess |= STATE_HW_OFF | STATE_HW_OVERLOADED;	// Set status for itself and top-level software
;;;811    		safe_counter = MINIMAL_OFF_TIME;						// Start timer to provide minimal OFF timeout
00060c  27c8              MOVS     r7,#0xc8
00060e  b118              CBZ      r0,|L1.1560|
000610  e011              B        |L1.1590|
                  |L1.1554|
000612  2005              MOVS     r0,#5                 ;799
000614  80e8              STRH     r0,[r5,#6]            ;799
000616  e7f8              B        |L1.1546|
                  |L1.1560|
000618  7828              LDRB     r0,[r5,#0]            ;809  ; state_HWProcess
00061a  f0200001          BIC      r0,r0,#1              ;809
00061e  7028              STRB     r0,[r5,#0]            ;809
000620  7828              LDRB     r0,[r5,#0]            ;810  ; state_HWProcess
000622  f0400006          ORR      r0,r0,#6              ;810
000626  7028              STRB     r0,[r5,#0]            ;810
000628  812f              STRH     r7,[r5,#8]
;;;812    		xQueueSendToFrontFromISR(xQueueConverter, &converter_update_message, 0);	// No need for exact timing
00062a  2301              MOVS     r3,#1
00062c  2200              MOVS     r2,#0
00062e  494e              LDR      r1,|L1.1896|
000630  69e8              LDR      r0,[r5,#0x1c]  ; xQueueConverter
000632  f7fffffe          BL       xQueueGenericSendFromISR
                  |L1.1590|
;;;813    	}
;;;814    	
;;;815    	//-------------------------------//
;;;816    	// Process commands from top-level converter controller
;;;817    	if (ctrl_HWProcess & CMD_HW_RESET_OVERLOAD)
000636  7868              LDRB     r0,[r5,#1]  ; ctrl_HWProcess
000638  0740              LSLS     r0,r0,#29
00063a  d503              BPL      |L1.1604|
;;;818    	{
;;;819    		state_HWProcess &= ~STATE_HW_OVERLOADED;
00063c  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
00063e  f0200004          BIC      r0,r0,#4
000642  7028              STRB     r0,[r5,#0]
                  |L1.1604|
;;;820    	}
;;;821    	if ( (ctrl_HWProcess & CMD_HW_OFF) && (!(state_HWProcess & STATE_HW_OFF)) )
000644  7868              LDRB     r0,[r5,#1]  ; ctrl_HWProcess
000646  0780              LSLS     r0,r0,#30
000648  d50c              BPL      |L1.1636|
00064a  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
00064c  0780              LSLS     r0,r0,#30
00064e  d409              BMI      |L1.1636|
;;;822    	{
;;;823    		state_HWProcess &= ~STATE_HW_ON;
000650  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
000652  f0200001          BIC      r0,r0,#1
000656  7028              STRB     r0,[r5,#0]
;;;824    		state_HWProcess |= STATE_HW_OFF;		
000658  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
00065a  f0400002          ORR      r0,r0,#2
00065e  7028              STRB     r0,[r5,#0]
;;;825    		safe_counter = MINIMAL_OFF_TIME;						// Start timer to provide minimal OFF timeout
000660  812f              STRH     r7,[r5,#8]
000662  e00d              B        |L1.1664|
                  |L1.1636|
;;;826    	}
;;;827    	else if ( (ctrl_HWProcess & CMD_HW_ON) && (!(state_HWProcess & STATE_HW_ON)) )
000664  7868              LDRB     r0,[r5,#1]  ; ctrl_HWProcess
000666  07c0              LSLS     r0,r0,#31
000668  d00a              BEQ      |L1.1664|
00066a  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
00066c  07c0              LSLS     r0,r0,#31
00066e  d107              BNE      |L1.1664|
;;;828    	{
;;;829    		state_HWProcess &= ~STATE_HW_OFF;
000670  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
000672  f0200002          BIC      r0,r0,#2
000676  7028              STRB     r0,[r5,#0]
;;;830    		state_HWProcess |= STATE_HW_ON;								
000678  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
00067a  f0400001          ORR      r0,r0,#1
00067e  7028              STRB     r0,[r5,#0]
                  |L1.1664|
;;;831    	}
;;;832    	if (ctrl_HWProcess & CMD_HW_RESTART_USER_TIMER)
000680  7868              LDRB     r0,[r5,#1]  ; ctrl_HWProcess
000682  0700              LSLS     r0,r0,#28
000684  d501              BPL      |L1.1674|
;;;833    	{
;;;834    		user_counter = USER_TIMEOUT;
000686  2064              MOVS     r0,#0x64
000688  8168              STRH     r0,[r5,#0xa]
                  |L1.1674|
;;;835    	}
;;;836    	if (ctrl_HWProcess & CMD_HW_RESTART_LED_BLINK_TIMER)
00068a  7868              LDRB     r0,[r5,#1]  ; ctrl_HWProcess
00068c  06c0              LSLS     r0,r0,#27
00068e  d500              BPL      |L1.1682|
;;;837    	{
;;;838    		user_counter = LED_BLINK_TIMEOUT;
000690  816e              STRH     r6,[r5,#0xa]
                  |L1.1682|
;;;839    	}
;;;840    	
;;;841    	//-------------------------------//
;;;842    	// Process commands from top-level ADC controller
;;;843    	if (cmd_ADC_to_HWProcess & CMD_HW_OFF_BY_ADC)
000692  78a8              LDRB     r0,[r5,#2]  ; cmd_ADC_to_HWProcess
000694  07c0              LSLS     r0,r0,#31
000696  d004              BEQ      |L1.1698|
;;;844    	{
;;;845    		state_HWProcess |= STATE_HW_OFF_BY_ADC;
000698  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
00069a  f0400008          ORR      r0,r0,#8
00069e  7028              STRB     r0,[r5,#0]
0006a0  e006              B        |L1.1712|
                  |L1.1698|
;;;846    	}
;;;847    	else if (cmd_ADC_to_HWProcess & CMD_HW_ON_BY_ADC)
0006a2  78a8              LDRB     r0,[r5,#2]  ; cmd_ADC_to_HWProcess
0006a4  0780              LSLS     r0,r0,#30
0006a6  d503              BPL      |L1.1712|
;;;848    	{
;;;849    		state_HWProcess &= ~STATE_HW_OFF_BY_ADC;
0006a8  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
0006aa  f0200008          BIC      r0,r0,#8
0006ae  7028              STRB     r0,[r5,#0]
                  |L1.1712|
;;;850    	}
;;;851    	
;;;852    	// Reset commands
;;;853    	ctrl_HWProcess = 0;
0006b0  2000              MOVS     r0,#0
0006b2  7068              STRB     r0,[r5,#1]
;;;854    	cmd_ADC_to_HWProcess = 0;
0006b4  70a8              STRB     r0,[r5,#2]
;;;855    
;;;856    	//-------------------------------//
;;;857    	// Apply converter state
;;;858    	// TODO - check IRQ disable while accessing converter control port (MDR_PORTF) for write
;;;859    	if (state_HWProcess & (STATE_HW_OFF | STATE_HW_OFF_BY_ADC))
0006b6  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
0006b8  f0100f0a          TST      r0,#0xa
0006bc  d003              BEQ      |L1.1734|
;;;860    		SetConverterState(CONVERTER_OFF);
0006be  2000              MOVS     r0,#0
0006c0  f7fffffe          BL       SetConverterState
0006c4  e005              B        |L1.1746|
                  |L1.1734|
;;;861    	else if (state_HWProcess & STATE_HW_ON)
0006c6  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
0006c8  07c0              LSLS     r0,r0,#31
0006ca  d002              BEQ      |L1.1746|
;;;862    		SetConverterState(CONVERTER_ON);
0006cc  2001              MOVS     r0,#1
0006ce  f7fffffe          BL       SetConverterState
                  |L1.1746|
;;;863    		
;;;864    	//-------------------------------//
;;;865    	// LED indication
;;;866    	// Uses raw converter state and top-level conveter status
;;;867    	// TODO - check IRQ disable while accessing LED port (MDR_PORTB) for write
;;;868    	led_state = 0;
0006d2  2000              MOVS     r0,#0
;;;869    	if ((state_HWProcess & STATE_HW_ON) && (led_blink_counter == 0))
0006d4  7829              LDRB     r1,[r5,#0]  ; state_HWProcess
0006d6  07c9              LSLS     r1,r1,#31
0006d8  d002              BEQ      |L1.1760|
0006da  89a9              LDRH     r1,[r5,#0xc]  ; led_blink_counter
0006dc  b901              CBNZ     r1,|L1.1760|
;;;870    		led_state |= LED_GREEN;
0006de  2001              MOVS     r0,#1
                  |L1.1760|
;;;871    	if ((raw_overload_flag == OVERLOAD) || (conv_state & CONV_OVERLOAD))
0006e0  2c01              CMP      r4,#1
0006e2  d002              BEQ      |L1.1770|
0006e4  6929              LDR      r1,[r5,#0x10]  ; conv_state
0006e6  06c9              LSLS     r1,r1,#27
0006e8  d501              BPL      |L1.1774|
                  |L1.1770|
;;;872    		led_state |= LED_RED;
0006ea  f0400002          ORR      r0,r0,#2
                  |L1.1774|
;;;873    	UpdateLEDs(led_state);
0006ee  f7fffffe          BL       UpdateLEDs
;;;874    	
;;;875    	//-------------------------------//
;;;876    	// Overload sound warning
;;;877    	if ((raw_overload_flag == OVERLOAD) && (overload_warning_counter == 0))
0006f2  2c01              CMP      r4,#1
0006f4  d10b              BNE      |L1.1806|
0006f6  89e8              LDRH     r0,[r5,#0xe]  ; overload_warning_counter
0006f8  b948              CBNZ     r0,|L1.1806|
;;;878    	{
;;;879    		xQueueSendToFrontFromISR(xQueueSound, &sound_instant_overload_msg, 0);	// No need for exact timing
0006fa  481d              LDR      r0,|L1.1904|
0006fc  2301              MOVS     r3,#1
0006fe  2200              MOVS     r2,#0
000700  491a              LDR      r1,|L1.1900|
000702  6800              LDR      r0,[r0,#0]  ; xQueueSound
000704  f7fffffe          BL       xQueueGenericSendFromISR
;;;880    		overload_warning_counter = OVERLOAD_WARNING_TIMEOUT;
000708  f44f707a          MOV      r0,#0x3e8
00070c  81e8              STRH     r0,[r5,#0xe]
                  |L1.1806|
;;;881    	}
;;;882    	
;;;883    	//-------------------------------//
;;;884    	// Process timers
;;;885    	
;;;886    	// Process safe timer - used by top-level controller to provide a safe minimal OFF timeout
;;;887    	if (safe_counter != 0)
00070e  8928              LDRH     r0,[r5,#8]  ; safe_counter
000710  b130              CBZ      r0,|L1.1824|
;;;888    	{
;;;889    		safe_counter--;
000712  1e40              SUBS     r0,r0,#1
000714  8128              STRH     r0,[r5,#8]
;;;890    		state_HWProcess |= STATE_HW_TIMER_NOT_EXPIRED;
000716  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
000718  f0400010          ORR      r0,r0,#0x10
00071c  7028              STRB     r0,[r5,#0]
00071e  e003              B        |L1.1832|
                  |L1.1824|
;;;891    	}
;;;892    	else
;;;893    	{
;;;894    		state_HWProcess &= ~STATE_HW_TIMER_NOT_EXPIRED;
000720  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
000722  f0200010          BIC      r0,r0,#0x10
000726  7028              STRB     r0,[r5,#0]
                  |L1.1832|
;;;895    	}
;;;896    	
;;;897    	// Process user timer - used by top-level controller to provide a safe interval after switching channels
;;;898    	if (user_counter != 0)
000728  8968              LDRH     r0,[r5,#0xa]  ; user_counter
00072a  b130              CBZ      r0,|L1.1850|
;;;899    	{
;;;900    		user_counter--;
00072c  1e40              SUBS     r0,r0,#1
00072e  8168              STRH     r0,[r5,#0xa]
;;;901    		state_HWProcess &= ~STATE_HW_USER_TIMER_EXPIRED;
000730  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
000732  f0200020          BIC      r0,r0,#0x20
000736  7028              STRB     r0,[r5,#0]
000738  e003              B        |L1.1858|
                  |L1.1850|
;;;902    	}
;;;903    	else
;;;904    	{
;;;905    		state_HWProcess |= STATE_HW_USER_TIMER_EXPIRED;
00073a  7828              LDRB     r0,[r5,#0]  ; state_HWProcess
00073c  f0400020          ORR      r0,r0,#0x20
000740  7028              STRB     r0,[r5,#0]
                  |L1.1858|
;;;906    	}
;;;907    	
;;;908    	// Process LED blink timer
;;;909    	if (led_blink_counter != 0)
000742  89a8              LDRH     r0,[r5,#0xc]  ; led_blink_counter
000744  b108              CBZ      r0,|L1.1866|
;;;910    	{
;;;911    		led_blink_counter--;
000746  1e40              SUBS     r0,r0,#1
000748  81a8              STRH     r0,[r5,#0xc]
                  |L1.1866|
;;;912    	}
;;;913    	
;;;914    	// Process overload sound warning timer
;;;915    	if (overload_warning_counter != 0)
00074a  89e8              LDRH     r0,[r5,#0xe]  ; overload_warning_counter
00074c  2800              CMP      r0,#0
00074e  d001              BEQ      |L1.1876|
;;;916    	{
;;;917    		overload_warning_counter--;
000750  1e40              SUBS     r0,r0,#1
000752  81e8              STRH     r0,[r5,#0xe]
                  |L1.1876|
;;;918    	}
;;;919    }
000754  e8bd81f0          POP      {r4-r8,pc}
;;;920    
                          ENDP

                  |L1.1880|
                          DCD      ||.bss||
                  |L1.1884|
                          DCD      ||.data||+0x14
                  |L1.1888|
                          DCD      0x00030034
                  |L1.1892|
                          DCD      xQueueADC
                  |L1.1896|
                          DCD      ||area_number.6||
                  |L1.1900|
                          DCD      sound_instant_overload_msg
                  |L1.1904|
                          DCD      xQueueSound

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  channel_5v
                          %        56
                  channel_12v
                          %        56

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  converter_tick_message
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||area_number.6||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.constdata||
                  converter_update_message
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=2

                  state_HWProcess
000000  02                DCB      0x02
                  ctrl_HWProcess
000001  00                DCB      0x00
                  cmd_ADC_to_HWProcess
000002  00                DCB      0x00
                  taskConverter_Enable
000003  00                DCB      0x00
                  overload_ignore_counter
000004  0000              DCB      0x00,0x00
                  overload_counter
000006  0000              DCB      0x00,0x00
                  safe_counter
000008  0000              DCW      0x0000
                  user_counter
00000a  0000              DCW      0x0000
                  led_blink_counter
00000c  0000              DCW      0x0000
                  overload_warning_counter
00000e  0000              DCW      0x0000
                  conv_state
                          DCD      0x00000001
                  gui_msg
                          DCD      0x00000000
                  regulation_setting_p
                          DCD      0x00000000
                  xQueueConverter
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "src\\converter.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_converter_c_40e17437____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_converter_c_40e17437____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_converter_c_40e17437____REVSH|
#line 130
|__asm___11_converter_c_40e17437____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
