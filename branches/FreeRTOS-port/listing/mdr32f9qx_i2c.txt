; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\mdr32f9qx_i2c.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\mdr32f9qx_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\mdr32f9qx_i2c.crf ..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_i2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;45       */
;;;46     void I2C_DeInit(void)
000000  4841              LDR      r0,|L1.264|
;;;47     {
;;;48       MDR_I2C_TypeDef *I2Cx;
;;;49     
;;;50       I2Cx = MDR_I2C;
;;;51     
;;;52       I2Cx->CTR = 0;
000002  2100              MOVS     r1,#0
000004  6081              STR      r1,[r0,#8]
;;;53       I2Cx->STA = 0;
000006  6101              STR      r1,[r0,#0x10]
;;;54       I2Cx->CMD = I2C_CMD_CLRINT;
000008  2101              MOVS     r1,#1
00000a  6181              STR      r1,[r0,#0x18]
;;;55       I2Cx->PRL = 0;
00000c  2100              MOVS     r1,#0
00000e  6001              STR      r1,[r0,#0]
;;;56       I2Cx->PRH = 0;
000010  6041              STR      r1,[r0,#4]
;;;57     }
000012  4770              BX       lr
;;;58     
                          ENDP

                  I2C_Init PROC
;;;65       */
;;;66     void I2C_Init(const I2C_InitTypeDef* I2C_InitStruct)
000014  b510              PUSH     {r4,lr}
;;;67     {
000016  4601              MOV      r1,r0
;;;68       MDR_I2C_TypeDef *I2Cx;
;;;69       uint32_t tmpreg_CTR;
;;;70       uint32_t tmpreg_PR;
;;;71     
;;;72       /* Check the parameters */
;;;73       assert_param(IS_I2C_SPEED(I2C_InitStruct->I2C_Speed));
;;;74       assert_param(IS_I2C_CLKDIV(I2C_InitStruct->I2C_ClkDiv));
;;;75     
;;;76       I2Cx = MDR_I2C;
000018  483b              LDR      r0,|L1.264|
;;;77     
;;;78       /* Form new values */
;;;79       tmpreg_CTR = I2Cx->CTR;
00001a  6882              LDR      r2,[r0,#8]
;;;80     
;;;81       if ((I2C_InitStruct->I2C_Speed & I2C_SPEED_Msk) != I2C_SPEED_UP_TO_400KHz)
00001c  684c              LDR      r4,[r1,#4]
00001e  f0140f20          TST      r4,#0x20
000022  d002              BEQ      |L1.42|
;;;82       {
;;;83         tmpreg_CTR |= I2C_CTR_S_I2C;
000024  f0420220          ORR      r2,r2,#0x20
000028  e001              B        |L1.46|
                  |L1.42|
;;;84       }
;;;85       else
;;;86       {
;;;87         tmpreg_CTR &= ~I2C_CTR_S_I2C;
00002a  f0220220          BIC      r2,r2,#0x20
                  |L1.46|
;;;88       }
;;;89     
;;;90       /* Configure I2C registers with new values */
;;;91       I2Cx->CTR = tmpreg_CTR;
00002e  6082              STR      r2,[r0,#8]
;;;92     
;;;93       tmpreg_PR = I2C_InitStruct->I2C_ClkDiv;
000030  680b              LDR      r3,[r1,#0]
;;;94       I2Cx->PRL = tmpreg_PR;
000032  6003              STR      r3,[r0,#0]
;;;95       I2Cx->PRH = tmpreg_PR >> 8;
000034  0a1c              LSRS     r4,r3,#8
000036  6044              STR      r4,[r0,#4]
;;;96     }
000038  bd10              POP      {r4,pc}
;;;97     
                          ENDP

                  I2C_StructInit PROC
;;;103      */
;;;104    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
00003a  2100              MOVS     r1,#0
;;;105    {
;;;106      /* Reset I2C initialization structure parameters values */
;;;107      I2C_InitStruct->I2C_Speed  = I2C_SPEED_UP_TO_400KHz;
00003c  6041              STR      r1,[r0,#4]
;;;108      I2C_InitStruct->I2C_ClkDiv = 1;
00003e  2101              MOVS     r1,#1
000040  6001              STR      r1,[r0,#0]
;;;109    }
000042  4770              BX       lr
;;;110    
                          ENDP

                  I2C_Cmd PROC
;;;116      */
;;;117    void I2C_Cmd(FunctionalState NewState)
000044  4601              MOV      r1,r0
;;;118    {
;;;119      MDR_I2C_TypeDef *I2Cx;
;;;120      uint32_t tmpreg_CTR;
;;;121    
;;;122      /* Check the parameters */
;;;123      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;124    
;;;125      I2Cx = MDR_I2C;
000046  4a30              LDR      r2,|L1.264|
;;;126    
;;;127      tmpreg_CTR = I2Cx->CTR;
000048  6890              LDR      r0,[r2,#8]
;;;128    
;;;129      /* Form new value */
;;;130      if (NewState != DISABLE)
00004a  b111              CBZ      r1,|L1.82|
;;;131      {
;;;132        /* Enable I2C by setting the EN_I2C bit in the CTR register */
;;;133        tmpreg_CTR |= I2C_CTR_EN_I2C;
00004c  f0400080          ORR      r0,r0,#0x80
000050  e001              B        |L1.86|
                  |L1.82|
;;;134      }
;;;135      else
;;;136      {
;;;137        /* Disable I2C by resetting the EN_I2C bit in the CTR register */
;;;138        tmpreg_CTR &= ~I2C_CTR_EN_I2C;
000052  f0200080          BIC      r0,r0,#0x80
                  |L1.86|
;;;139      }
;;;140    
;;;141      /* Configure CTR register with new value */
;;;142      I2Cx->CTR = tmpreg_CTR;
000056  6090              STR      r0,[r2,#8]
;;;143    }
000058  4770              BX       lr
;;;144    
                          ENDP

                  I2C_ITConfig PROC
;;;150      */
;;;151    void I2C_ITConfig(FunctionalState NewState)
00005a  4601              MOV      r1,r0
;;;152    {
;;;153      MDR_I2C_TypeDef *I2Cx;
;;;154      uint32_t tmpreg_CTR;
;;;155    
;;;156      /* Check the parameters */
;;;157      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;158    
;;;159      I2Cx = MDR_I2C;
00005c  4a2a              LDR      r2,|L1.264|
;;;160    
;;;161      tmpreg_CTR = I2Cx->CTR;
00005e  6890              LDR      r0,[r2,#8]
;;;162    
;;;163      /* Form new value */
;;;164      if (NewState != DISABLE)
000060  b111              CBZ      r1,|L1.104|
;;;165      {
;;;166        /* Enable the I2C interrupts by setting the EN_INT bit in the CTR register */
;;;167        tmpreg_CTR |= I2C_CTR_EN_INT;
000062  f0400040          ORR      r0,r0,#0x40
000066  e001              B        |L1.108|
                  |L1.104|
;;;168      }
;;;169      else
;;;170      {
;;;171        /* Disable the I2C interrupts by resetting the EN_INT bit in the CTR register */
;;;172        tmpreg_CTR &= ~I2C_CTR_EN_INT;
000068  f0200040          BIC      r0,r0,#0x40
                  |L1.108|
;;;173      }
;;;174    
;;;175      /* Configure CTR register with new value */
;;;176      I2Cx->CTR = tmpreg_CTR;
00006c  6090              STR      r0,[r2,#8]
;;;177    }
00006e  4770              BX       lr
;;;178    
                          ENDP

                  I2C_GetITStatus PROC
;;;183      */
;;;184    ITStatus I2C_GetITStatus(void)
000070  4925              LDR      r1,|L1.264|
;;;185    {
;;;186      MDR_I2C_TypeDef *I2Cx;
;;;187      ITStatus bitstatus;
;;;188    
;;;189      I2Cx = MDR_I2C;
;;;190    
;;;191      if ((I2Cx->STA & I2C_STA_INT) == I2C_STA_INT)
000072  690a              LDR      r2,[r1,#0x10]
000074  f0020201          AND      r2,r2,#1
000078  2a01              CMP      r2,#1
00007a  d101              BNE      |L1.128|
;;;192      {
;;;193        bitstatus = SET;
00007c  2001              MOVS     r0,#1
00007e  e000              B        |L1.130|
                  |L1.128|
;;;194      }
;;;195      else
;;;196      {
;;;197        bitstatus = RESET;
000080  2000              MOVS     r0,#0
                  |L1.130|
;;;198      }
;;;199    
;;;200      return bitstatus;
;;;201    }
000082  4770              BX       lr
;;;202    
                          ENDP

                  I2C_ClearITPendingBit PROC
;;;207      */
;;;208    void I2C_ClearITPendingBit(void)
000084  4820              LDR      r0,|L1.264|
;;;209    {
;;;210      MDR_I2C_TypeDef *I2Cx;
;;;211    
;;;212      I2Cx = MDR_I2C;
;;;213    
;;;214      I2Cx->CMD |= I2C_CMD_CLRINT;
000086  6981              LDR      r1,[r0,#0x18]
000088  f0410101          ORR      r1,r1,#1
00008c  6181              STR      r1,[r0,#0x18]
;;;215    }
00008e  4770              BX       lr
;;;216    
                          ENDP

                  I2C_Send7bitAddress PROC
;;;228      */
;;;229    void I2C_Send7bitAddress(uint8_t Address, uint32_t Direction)
000090  4a1d              LDR      r2,|L1.264|
;;;230    {
;;;231      MDR_I2C_TypeDef *I2Cx;
;;;232    
;;;233      assert_param(IS_I2C_DIRECTION(Direction));
;;;234    
;;;235      I2Cx = MDR_I2C;
;;;236    
;;;237      I2Cx->TXD = (Address & ~I2C_Direction_Msk) | Direction;
000092  f0200301          BIC      r3,r0,#1
000096  430b              ORRS     r3,r3,r1
000098  6153              STR      r3,[r2,#0x14]
;;;238      I2Cx->CMD = I2C_CMD_START | I2C_CMD_WR;
00009a  2390              MOVS     r3,#0x90
00009c  6193              STR      r3,[r2,#0x18]
;;;239    }
00009e  4770              BX       lr
;;;240    
                          ENDP

                  I2C_SendByte PROC
;;;245      */
;;;246    void I2C_SendByte(uint8_t ByteToSend)
0000a0  4601              MOV      r1,r0
;;;247    {
;;;248      MDR_I2C_TypeDef *I2Cx;
;;;249    
;;;250      I2Cx = MDR_I2C;
0000a2  4819              LDR      r0,|L1.264|
;;;251    
;;;252      I2Cx->TXD = ByteToSend;
0000a4  6141              STR      r1,[r0,#0x14]
;;;253      I2Cx->CMD = I2C_CMD_WR;
0000a6  2210              MOVS     r2,#0x10
0000a8  6182              STR      r2,[r0,#0x18]
;;;254    }
0000aa  4770              BX       lr
;;;255    
                          ENDP

                  I2C_SendSTOP PROC
;;;260      */
;;;261    void I2C_SendSTOP(void)
0000ac  4816              LDR      r0,|L1.264|
;;;262    {
;;;263      MDR_I2C_TypeDef *I2Cx;
;;;264    
;;;265      I2Cx = MDR_I2C;
;;;266    
;;;267      I2Cx->CMD = I2C_CMD_STOP;
0000ae  2140              MOVS     r1,#0x40
0000b0  6181              STR      r1,[r0,#0x18]
;;;268    }
0000b2  4770              BX       lr
;;;269    
                          ENDP

                  I2C_StartReceiveData PROC
;;;278      */
;;;279    void I2C_StartReceiveData(uint32_t Acknowlage)
0000b4  4914              LDR      r1,|L1.264|
;;;280    {
;;;281      MDR_I2C_TypeDef *I2Cx;
;;;282    
;;;283      assert_param(IS_I2C_SEND_ACKNOWLAGE(Acknowlage));
;;;284    
;;;285      I2Cx = MDR_I2C;
;;;286    
;;;287      I2Cx->CMD = I2C_CMD_RD | Acknowlage;
0000b6  f0400220          ORR      r2,r0,#0x20
0000ba  618a              STR      r2,[r1,#0x18]
;;;288    }
0000bc  4770              BX       lr
;;;289    
                          ENDP

                  I2C_GetReceivedData PROC
;;;294      */
;;;295    uint8_t I2C_GetReceivedData(void)
0000be  4912              LDR      r1,|L1.264|
;;;296    {
;;;297      MDR_I2C_TypeDef *I2Cx;
;;;298    
;;;299      I2Cx = MDR_I2C;
;;;300    
;;;301      return I2Cx->RXD;
0000c0  68c8              LDR      r0,[r1,#0xc]
0000c2  b2c0              UXTB     r0,r0
;;;302    }
0000c4  4770              BX       lr
;;;303    
                          ENDP

                  I2C_GetLastEvent PROC
;;;344      */
;;;345    uint32_t I2C_GetLastEvent(void)
0000c6  4910              LDR      r1,|L1.264|
;;;346    {
;;;347      MDR_I2C_TypeDef *I2Cx;
;;;348      uint32_t event;
;;;349    
;;;350      I2Cx = MDR_I2C;
;;;351    
;;;352      event = I2Cx->CMD | (I2Cx->STA << 8);
0000c8  698a              LDR      r2,[r1,#0x18]
0000ca  690b              LDR      r3,[r1,#0x10]
0000cc  ea422003          ORR      r0,r2,r3,LSL #8
;;;353      event |= ~event << 16;
0000d0  43c2              MVNS     r2,r0
0000d2  ea404002          ORR      r0,r0,r2,LSL #16
;;;354    
;;;355      return event;
;;;356    }
0000d6  4770              BX       lr
;;;357    
                          ENDP

                  I2C_CheckEvent PROC
;;;318      */
;;;319    ErrorStatus I2C_CheckEvent(uint32_t Event)
0000d8  b530              PUSH     {r4,r5,lr}
;;;320    {
0000da  4604              MOV      r4,r0
;;;321      ErrorStatus errstatus;
;;;322    
;;;323      assert_param(IS_I2C_FLAGS(Event));
;;;324    
;;;325      if ((I2C_GetLastEvent() & Event) == Event)
0000dc  f7fffffe          BL       I2C_GetLastEvent
0000e0  4020              ANDS     r0,r0,r4
0000e2  42a0              CMP      r0,r4
0000e4  d101              BNE      |L1.234|
;;;326      {
;;;327        errstatus = SUCCESS;
0000e6  2501              MOVS     r5,#1
0000e8  e000              B        |L1.236|
                  |L1.234|
;;;328      }
;;;329      else
;;;330      {
;;;331        errstatus = ERROR;
0000ea  2500              MOVS     r5,#0
                  |L1.236|
;;;332      }
;;;333    
;;;334      return errstatus;
0000ec  4628              MOV      r0,r5
;;;335    }
0000ee  bd30              POP      {r4,r5,pc}
;;;336    
                          ENDP

                  I2C_GetFlagStatus PROC
;;;383      */
;;;384    FlagStatus I2C_GetFlagStatus(uint32_t Flag)
0000f0  b530              PUSH     {r4,r5,lr}
;;;385    {
0000f2  4605              MOV      r5,r0
;;;386      FlagStatus bitstatus;
;;;387    
;;;388      assert_param(IS_I2C_FLAG(Flag));
;;;389    
;;;390      if ((I2C_GetLastEvent() & Flag) != 0)
0000f4  f7fffffe          BL       I2C_GetLastEvent
0000f8  4228              TST      r0,r5
0000fa  d001              BEQ      |L1.256|
;;;391      {
;;;392        bitstatus = SET;
0000fc  2401              MOVS     r4,#1
0000fe  e000              B        |L1.258|
                  |L1.256|
;;;393      }
;;;394      else
;;;395      {
;;;396        bitstatus = RESET;
000100  2400              MOVS     r4,#0
                  |L1.258|
;;;397      }
;;;398    
;;;399      return bitstatus;
000102  4620              MOV      r0,r4
;;;400    }
000104  bd30              POP      {r4,r5,pc}
;;;401    
                          ENDP

000106  0000              DCW      0x0000
                  |L1.264|
                          DCD      0x40050000

;*** Start embedded assembler ***

#line 1 "..\\Library\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_i2c.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_i2c_c_7174d409____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_MDR32F9Qx_i2c_c_7174d409____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_i2c_c_7174d409____REVSH|
#line 130
|__asm___15_MDR32F9Qx_i2c_c_7174d409____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
