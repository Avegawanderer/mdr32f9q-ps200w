; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\mdr32f9qx_timer.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\mdr32f9qx_timer.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\mdr32f9qx_timer.crf ..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_timer.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIMER_DeInit PROC
;;;45       */
;;;46     void TIMER_DeInit(MDR_TIMER_TypeDef* TIMERx)
000000  2100              MOVS     r1,#0
;;;47     {
;;;48       /* Check the parameters */
;;;49       assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;50     
;;;51       TIMERx->CNTRL = 0;
000002  60c1              STR      r1,[r0,#0xc]
;;;52       TIMERx->CNT = 0;
000004  6001              STR      r1,[r0,#0]
;;;53       TIMERx->PSG = 0;
000006  6041              STR      r1,[r0,#4]
;;;54       TIMERx->ARR = 0;
000008  6081              STR      r1,[r0,#8]
;;;55     
;;;56       TIMERx->CH1_CNTRL = 0;
00000a  6201              STR      r1,[r0,#0x20]
;;;57       TIMERx->CH2_CNTRL = 0;
00000c  6241              STR      r1,[r0,#0x24]
;;;58       TIMERx->CH3_CNTRL = 0;
00000e  6281              STR      r1,[r0,#0x28]
;;;59       TIMERx->CH4_CNTRL = 0;
000010  62c1              STR      r1,[r0,#0x2c]
;;;60       TIMERx->CH1_CNTRL1 = 0;
000012  6301              STR      r1,[r0,#0x30]
;;;61       TIMERx->CH2_CNTRL1 = 0;
000014  6341              STR      r1,[r0,#0x34]
;;;62       TIMERx->CH3_CNTRL1 = 0;
000016  6381              STR      r1,[r0,#0x38]
;;;63       TIMERx->CH4_CNTRL1 = 0;
000018  63c1              STR      r1,[r0,#0x3c]
;;;64       TIMERx->CH1_CNTRL2 = 0;
00001a  6601              STR      r1,[r0,#0x60]
;;;65       TIMERx->CH2_CNTRL2 = 0;
00001c  6641              STR      r1,[r0,#0x64]
;;;66       TIMERx->CH3_CNTRL2 = 0;
00001e  6681              STR      r1,[r0,#0x68]
;;;67       TIMERx->CH4_CNTRL2 = 0;
000020  66c1              STR      r1,[r0,#0x6c]
;;;68     
;;;69       TIMERx->CCR1 = 0;
000022  6101              STR      r1,[r0,#0x10]
;;;70       TIMERx->CCR2 = 0;
000024  6141              STR      r1,[r0,#0x14]
;;;71       TIMERx->CCR3 = 0;
000026  6181              STR      r1,[r0,#0x18]
;;;72       TIMERx->CCR4 = 0;
000028  61c1              STR      r1,[r0,#0x1c]
;;;73       TIMERx->CCR11 = 0;
00002a  6701              STR      r1,[r0,#0x70]
;;;74       TIMERx->CCR21 = 0;
00002c  6741              STR      r1,[r0,#0x74]
;;;75       TIMERx->CCR31 = 0;
00002e  6781              STR      r1,[r0,#0x78]
;;;76       TIMERx->CCR41 = 0;
000030  67c1              STR      r1,[r0,#0x7c]
;;;77       TIMERx->CH1_DTG = 0;
000032  6401              STR      r1,[r0,#0x40]
;;;78       TIMERx->CH2_DTG = 0;
000034  6441              STR      r1,[r0,#0x44]
;;;79       TIMERx->CH3_DTG = 0;
000036  6481              STR      r1,[r0,#0x48]
;;;80       TIMERx->CH4_DTG = 0;
000038  64c1              STR      r1,[r0,#0x4c]
;;;81       TIMERx->BRKETR_CNTRL = 0;
00003a  6501              STR      r1,[r0,#0x50]
;;;82       TIMERx->STATUS = 0;
00003c  6541              STR      r1,[r0,#0x54]
;;;83       TIMERx->IE = 0;
00003e  6581              STR      r1,[r0,#0x58]
;;;84       TIMERx->DMA_RE = 0;
000040  65c1              STR      r1,[r0,#0x5c]
;;;85     }
000042  4770              BX       lr
;;;86     
                          ENDP

                  TIMER_CntInit PROC
;;;95       */
;;;96     void TIMER_CntInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_CntInitTypeDef* TIMER_CntInitStruct)
000044  b510              PUSH     {r4,lr}
;;;97     {
;;;98       uint32_t tmpreg_CNTRL;
;;;99       uint32_t tmpreg_BRKETR_CNTRL;
;;;100    
;;;101      /* Check the parameters */
;;;102      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;103      assert_param(IS_TIMER_COUNTER_MODE(TIMER_CntInitStruct->TIMER_CounterMode));
;;;104      assert_param(IS_TIMER_COUNTER_DIR(TIMER_CntInitStruct->TIMER_CounterDirection));
;;;105      assert_param(IS_TIMER_EVENT_SOURCE(TIMER_CntInitStruct->TIMER_EventSource));
;;;106      assert_param(IS_TIMER_FILTER_SAMPLING(TIMER_CntInitStruct->TIMER_FilterSampling));
;;;107      assert_param(IS_TIMER_ARR_UPDATE_MODE(TIMER_CntInitStruct->TIMER_ARR_UpdateMode));
;;;108      assert_param(IS_TIMER_FILTER_CONF(TIMER_CntInitStruct->TIMER_ETR_FilterConf));
;;;109      assert_param(IS_TIMER_ETR_PRESCALER(TIMER_CntInitStruct->TIMER_ETR_Prescaler));
;;;110      assert_param(IS_TIMER_ETR_POLARITY(TIMER_CntInitStruct->TIMER_ETR_Polarity));
;;;111      assert_param(IS_TIMER_BRK_POLARITY(TIMER_CntInitStruct->TIMER_BRK_Polarity));
;;;112    
;;;113      TIMERx->CNT = TIMER_CntInitStruct->TIMER_IniCounter;
000046  880a              LDRH     r2,[r1,#0]
000048  6002              STR      r2,[r0,#0]
;;;114      TIMERx->PSG = TIMER_CntInitStruct->TIMER_Prescaler;
00004a  884a              LDRH     r2,[r1,#2]
00004c  6042              STR      r2,[r0,#4]
;;;115      TIMERx->ARR = TIMER_CntInitStruct->TIMER_Period;
00004e  888a              LDRH     r2,[r1,#4]
000050  6082              STR      r2,[r0,#8]
;;;116    
;;;117      /* Form new value for the TIMERx_CNTRL register */
;;;118      tmpreg_CNTRL = TIMER_CntInitStruct->TIMER_CounterMode
000052  88ca              LDRH     r2,[r1,#6]
000054  890b              LDRH     r3,[r1,#8]
000056  898c              LDRH     r4,[r1,#0xc]
000058  441a              ADD      r2,r2,r3
00005a  894b              LDRH     r3,[r1,#0xa]
00005c  4423              ADD      r3,r3,r4
00005e  441a              ADD      r2,r2,r3
000060  89cb              LDRH     r3,[r1,#0xe]
000062  441a              ADD      r2,r2,r3
;;;119                   + TIMER_CntInitStruct->TIMER_CounterDirection
;;;120                   + TIMER_CntInitStruct->TIMER_EventSource
;;;121                   + TIMER_CntInitStruct->TIMER_FilterSampling
;;;122                   + TIMER_CntInitStruct->TIMER_ARR_UpdateMode;
;;;123    
;;;124      /* Configure TIMERx_CNTRL register with new value */
;;;125      TIMERx->CNTRL = tmpreg_CNTRL;
000064  60c2              STR      r2,[r0,#0xc]
;;;126    
;;;127      /* Form new value for the TIMERx_BRKETR_CNTRL register */
;;;128      tmpreg_BRKETR_CNTRL = (TIMER_CntInitStruct->TIMER_ETR_FilterConf << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos)
000066  8a4a              LDRH     r2,[r1,#0x12]
000068  8a8b              LDRH     r3,[r1,#0x14]
00006a  441a              ADD      r2,r2,r3
00006c  8acb              LDRH     r3,[r1,#0x16]
00006e  8a09              LDRH     r1,[r1,#0x10]
000070  eb031101          ADD      r1,r3,r1,LSL #4
000074  4411              ADD      r1,r1,r2
;;;129                          + TIMER_CntInitStruct->TIMER_ETR_Prescaler
;;;130                          + TIMER_CntInitStruct->TIMER_ETR_Polarity
;;;131                          + TIMER_CntInitStruct->TIMER_BRK_Polarity;
;;;132    
;;;133      /* Configure TIMERx_BRKETR_CNTRL register with new value */
;;;134      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000076  6501              STR      r1,[r0,#0x50]
;;;135    }
000078  bd10              POP      {r4,pc}
;;;136    
                          ENDP

                  TIMER_CntStructInit PROC
;;;142      */
;;;143    void TIMER_CntStructInit(TIMER_CntInitTypeDef* TIMER_CntInitStruct)
00007a  2100              MOVS     r1,#0
;;;144    {
;;;145      TIMER_CntInitStruct->TIMER_IniCounter = 0;
00007c  8001              STRH     r1,[r0,#0]
;;;146      TIMER_CntInitStruct->TIMER_Prescaler  = 0;
00007e  8041              STRH     r1,[r0,#2]
;;;147      TIMER_CntInitStruct->TIMER_Period     = 0;
000080  8081              STRH     r1,[r0,#4]
;;;148      TIMER_CntInitStruct->TIMER_CounterMode      = TIMER_CntMode_ClkFixedDir;
000082  80c1              STRH     r1,[r0,#6]
;;;149      TIMER_CntInitStruct->TIMER_CounterDirection = TIMER_CntDir_Up;
000084  8101              STRH     r1,[r0,#8]
;;;150      TIMER_CntInitStruct->TIMER_EventSource      = TIMER_EvSrc_None;
000086  8141              STRH     r1,[r0,#0xa]
;;;151      TIMER_CntInitStruct->TIMER_FilterSampling   = TIMER_FDTS_TIMER_CLK_div_1;
000088  8181              STRH     r1,[r0,#0xc]
;;;152      TIMER_CntInitStruct->TIMER_ARR_UpdateMode   = TIMER_ARR_Update_Immediately;
00008a  81c1              STRH     r1,[r0,#0xe]
;;;153      TIMER_CntInitStruct->TIMER_ETR_FilterConf   = TIMER_Filter_1FF_at_TIMER_CLK;
00008c  8201              STRH     r1,[r0,#0x10]
;;;154      TIMER_CntInitStruct->TIMER_ETR_Prescaler    = TIMER_ETR_Prescaler_None;
00008e  8241              STRH     r1,[r0,#0x12]
;;;155      TIMER_CntInitStruct->TIMER_ETR_Polarity     = TIMER_ETRPolarity_NonInverted;
000090  8281              STRH     r1,[r0,#0x14]
;;;156      TIMER_CntInitStruct->TIMER_BRK_Polarity     = TIMER_BRKPolarity_NonInverted;
000092  82c1              STRH     r1,[r0,#0x16]
;;;157    }
000094  4770              BX       lr
;;;158    
                          ENDP

                  TIMER_Cmd PROC
;;;165      */
;;;166    void TIMER_Cmd(MDR_TIMER_TypeDef* TIMERx, FunctionalState NewState)
000096  68c2              LDR      r2,[r0,#0xc]
;;;167    {
;;;168      uint32_t tmpreg_CNTRL;
;;;169    
;;;170      /* Check the parameters */
;;;171      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;172      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;173    
;;;174      tmpreg_CNTRL = TIMERx->CNTRL;
;;;175    
;;;176      /* Form new value */
;;;177      if (NewState != DISABLE)
000098  b111              CBZ      r1,|L1.160|
;;;178      {
;;;179        /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
;;;180        tmpreg_CNTRL |= TIMER_CNTRL_CNT_EN;
00009a  f0420101          ORR      r1,r2,#1
00009e  e001              B        |L1.164|
                  |L1.160|
;;;181      }
;;;182      else
;;;183      {
;;;184        /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
;;;185        tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_EN;
0000a0  f0220101          BIC      r1,r2,#1
                  |L1.164|
;;;186      }
;;;187    
;;;188      /* Configure CNTRL register with new value */
;;;189      TIMERx->CNTRL = tmpreg_CNTRL;
0000a4  60c1              STR      r1,[r0,#0xc]
;;;190    }
0000a6  4770              BX       lr
;;;191    
                          ENDP

                  TIMER_SetCounter PROC
;;;197      */
;;;198    void TIMER_SetCounter(MDR_TIMER_TypeDef* TIMERx, uint16_t Counter)
0000a8  6001              STR      r1,[r0,#0]
;;;199    {
;;;200      /* Check the parameters */
;;;201      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;202    
;;;203      TIMERx->CNT = Counter;
;;;204    }
0000aa  4770              BX       lr
;;;205    
                          ENDP

                  TIMER_SetCntPrescaler PROC
;;;211      */
;;;212    void TIMER_SetCntPrescaler(MDR_TIMER_TypeDef* TIMERx, uint16_t Prescaler)
0000ac  6041              STR      r1,[r0,#4]
;;;213    {
;;;214      /* Check the parameters */
;;;215      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;216    
;;;217      TIMERx->PSG = Prescaler;
;;;218    }
0000ae  4770              BX       lr
;;;219    
                          ENDP

                  TIMER_SetCntAutoreload PROC
;;;225      */
;;;226    void TIMER_SetCntAutoreload(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload)
0000b0  6081              STR      r1,[r0,#8]
;;;227    {
;;;228      /* Check the parameters */
;;;229      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;230    
;;;231      TIMERx->ARR = Autoreload;
;;;232    }
0000b2  4770              BX       lr
;;;233    
                          ENDP

                  TIMER_CntAutoreloadConfig PROC
;;;243      */
;;;244    void TIMER_CntAutoreloadConfig(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload, uint32_t UpdateMode)
0000b4  68c3              LDR      r3,[r0,#0xc]
;;;245    {
;;;246      uint32_t tmpreg_CNTRL;
;;;247    
;;;248      /* Check the parameters */
;;;249      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;250      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;251    
;;;252      tmpreg_CNTRL = TIMERx->CNTRL;
;;;253      tmpreg_CNTRL &= ~TIMER_CNTRL_ARRB_EN;
0000b6  f0230302          BIC      r3,r3,#2
;;;254      tmpreg_CNTRL += UpdateMode;
0000ba  441a              ADD      r2,r2,r3
;;;255      TIMERx->CNTRL = tmpreg_CNTRL;
0000bc  60c2              STR      r2,[r0,#0xc]
;;;256    
;;;257      TIMERx->ARR = Autoreload;
0000be  6081              STR      r1,[r0,#8]
;;;258    }
0000c0  4770              BX       lr
;;;259    
                          ENDP

                  TIMER_GetCounter PROC
;;;264      */
;;;265    uint16_t TIMER_GetCounter(MDR_TIMER_TypeDef* TIMERx)
0000c2  6800              LDR      r0,[r0,#0]
;;;266    {
;;;267      /* Check the parameters */
;;;268      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;269    
;;;270      return TIMERx->CNT;
0000c4  b280              UXTH     r0,r0
;;;271    }
0000c6  4770              BX       lr
;;;272    
                          ENDP

                  TIMER_CntEventSourceConfig PROC
;;;288      */
;;;289    void TIMER_CntEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t EventSource)
0000c8  68c2              LDR      r2,[r0,#0xc]
;;;290    {
;;;291      uint32_t tmpreg_CNTRL;
;;;292    
;;;293      /* Check the parameters */
;;;294      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;295      assert_param(IS_TIMER_EVENT_SOURCE(EventSource));
;;;296    
;;;297      tmpreg_CNTRL = TIMERx->CNTRL;
;;;298      tmpreg_CNTRL &= ~TIMER_CNTRL_EVENT_SEL_Msk;
0000ca  f4226270          BIC      r2,r2,#0xf00
;;;299      tmpreg_CNTRL += EventSource;
0000ce  4411              ADD      r1,r1,r2
;;;300      TIMERx->CNTRL = tmpreg_CNTRL;
0000d0  60c1              STR      r1,[r0,#0xc]
;;;301    }
0000d2  4770              BX       lr
;;;302    
                          ENDP

                  TIMER_FilterSamplingConfig PROC
;;;313      */
;;;314    void TIMER_FilterSamplingConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
0000d4  68c2              LDR      r2,[r0,#0xc]
;;;315    {
;;;316      uint32_t tmpreg_CNTRL;
;;;317    
;;;318      /* Check the parameters */
;;;319      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;320      assert_param(IS_TIMER_FILTER_SAMPLING(Prescaler));
;;;321    
;;;322      tmpreg_CNTRL = TIMERx->CNTRL;
;;;323      tmpreg_CNTRL &= ~TIMER_CNTRL_FDTS_Msk;
0000d6  f0220230          BIC      r2,r2,#0x30
;;;324      tmpreg_CNTRL += Prescaler;
0000da  4411              ADD      r1,r1,r2
;;;325      TIMERx->CNTRL = tmpreg_CNTRL;
0000dc  60c1              STR      r1,[r0,#0xc]
;;;326    }
0000de  4770              BX       lr
;;;327    
                          ENDP

                  TIMER_CounterModeConfig PROC
;;;338      */
;;;339    void TIMER_CounterModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Mode)
0000e0  68c2              LDR      r2,[r0,#0xc]
;;;340    {
;;;341      uint32_t tmpreg_CNTRL;
;;;342    
;;;343      /* Check the parameters */
;;;344      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;345      assert_param(IS_TIMER_COUNTER_MODE(Mode));
;;;346    
;;;347      tmpreg_CNTRL = TIMERx->CNTRL;
;;;348      tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_MODE_Msk;
0000e2  f02202c0          BIC      r2,r2,#0xc0
;;;349      tmpreg_CNTRL += Mode;
0000e6  4411              ADD      r1,r1,r2
;;;350      TIMERx->CNTRL = tmpreg_CNTRL;
0000e8  60c1              STR      r1,[r0,#0xc]
;;;351    }
0000ea  4770              BX       lr
;;;352    
                          ENDP

                  TIMER_SetCounterDirection PROC
;;;361      */
;;;362    void TIMER_SetCounterDirection(MDR_TIMER_TypeDef* TIMERx, uint32_t Direction)
0000ec  68c2              LDR      r2,[r0,#0xc]
;;;363    {
;;;364      uint32_t tmpreg_CNTRL;
;;;365    
;;;366      /* Check the parameters */
;;;367      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;368      assert_param(IS_TIMER_COUNTER_DIR(Direction));
;;;369    
;;;370      tmpreg_CNTRL = TIMERx->CNTRL;
;;;371      tmpreg_CNTRL &= ~TIMER_CNTRL_DIR;
0000ee  f0220208          BIC      r2,r2,#8
;;;372      tmpreg_CNTRL += Direction;
0000f2  4411              ADD      r1,r1,r2
;;;373      TIMERx->CNTRL = tmpreg_CNTRL;
0000f4  60c1              STR      r1,[r0,#0xc]
;;;374    }
0000f6  4770              BX       lr
;;;375    
                          ENDP

                  TIMER_ETRInputConfig PROC
;;;408      */
;;;409    void TIMER_ETRInputConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler, uint32_t Polarity, uint32_t Filter)
0000f8  b510              PUSH     {r4,lr}
;;;410    {
;;;411      uint32_t tmpreg_BRKETR_CNTRL;
;;;412    
;;;413      /* Check the parameters */
;;;414      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;415      assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
;;;416      assert_param(IS_TIMER_ETR_POLARITY(Polarity));
;;;417      assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;418    
;;;419      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
0000fa  6d04              LDR      r4,[r0,#0x50]
;;;420      tmpreg_BRKETR_CNTRL &= ~(TIMER_BRKETR_CNTRL_ETR_PSC_Msk + TIMER_BRKETR_CNTRL_ETR_INV + TIMER_BRKETR_CNTRL_ETR_FILTER_Msk);
0000fc  f02404fe          BIC      r4,r4,#0xfe
;;;421      tmpreg_BRKETR_CNTRL += Prescaler + Polarity + (Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos);
000100  4411              ADD      r1,r1,r2
000102  eb011103          ADD      r1,r1,r3,LSL #4
000106  4421              ADD      r1,r1,r4
;;;422      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000108  6501              STR      r1,[r0,#0x50]
;;;423    }
00010a  bd10              POP      {r4,pc}
;;;424    
                          ENDP

                  TIMER_ETRFilterConfig PROC
;;;447      */
;;;448    void TIMER_ETRFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Filter)
00010c  6d02              LDR      r2,[r0,#0x50]
;;;449    {
;;;450      uint32_t tmpreg_BRKETR_CNTRL;
;;;451    
;;;452      /* Check the parameters */
;;;453      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;454      assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;455    
;;;456      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
;;;457      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_FILTER_Msk;
00010e  f02202f0          BIC      r2,r2,#0xf0
;;;458      tmpreg_BRKETR_CNTRL += Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos;
000112  eb021101          ADD      r1,r2,r1,LSL #4
;;;459      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000116  6501              STR      r1,[r0,#0x50]
;;;460    }
000118  4770              BX       lr
;;;461    
                          ENDP

                  TIMER_ETRPrescalerConfig PROC
;;;472      */
;;;473    void TIMER_ETRPrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
00011a  6d02              LDR      r2,[r0,#0x50]
;;;474    {
;;;475      uint32_t tmpreg_BRKETR_CNTRL;
;;;476    
;;;477      /* Check the parameters */
;;;478      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;479      assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
;;;480    
;;;481      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
;;;482      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_PSC_Msk;
00011c  f022020c          BIC      r2,r2,#0xc
;;;483      tmpreg_BRKETR_CNTRL += Prescaler;
000120  4411              ADD      r1,r1,r2
;;;484      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000122  6501              STR      r1,[r0,#0x50]
;;;485    }
000124  4770              BX       lr
;;;486    
                          ENDP

                  TIMER_ETRPolarityConfig PROC
;;;495      */
;;;496    void TIMER_ETRPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
000126  6d02              LDR      r2,[r0,#0x50]
;;;497    {
;;;498      uint32_t tmpreg_BRKETR_CNTRL;
;;;499    
;;;500      /* Check the parameters */
;;;501      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;502      assert_param(IS_TIMER_ETR_POLARITY(Polarity));
;;;503    
;;;504      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
;;;505      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_INV;
000128  f0220202          BIC      r2,r2,#2
;;;506      tmpreg_BRKETR_CNTRL += Polarity;
00012c  4411              ADD      r1,r1,r2
;;;507      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00012e  6501              STR      r1,[r0,#0x50]
;;;508    }
000130  4770              BX       lr
;;;509    
                          ENDP

                  TIMER_BRKPolarityConfig PROC
;;;518      */
;;;519    void TIMER_BRKPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
000132  6d02              LDR      r2,[r0,#0x50]
;;;520    {
;;;521      uint32_t tmpreg_BRKETR_CNTRL;
;;;522    
;;;523      /* Check the parameters */
;;;524      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;525      assert_param(IS_TIMER_BRK_POLARITY(Polarity));
;;;526    
;;;527      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
;;;528      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_BRK_INV;
000134  f0220201          BIC      r2,r2,#1
;;;529      tmpreg_BRKETR_CNTRL += Polarity;
000138  4411              ADD      r1,r1,r2
;;;530      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00013a  6501              STR      r1,[r0,#0x50]
;;;531    }
00013c  4770              BX       lr
;;;532    
                          ENDP

                  TIMER_GetCounterDirection PROC
;;;537      */
;;;538    uint32_t TIMER_GetCounterDirection(MDR_TIMER_TypeDef* TIMERx)
00013e  68c0              LDR      r0,[r0,#0xc]
;;;539    {
;;;540      uint32_t bitstatus;
;;;541    
;;;542      /* Check the parameters */
;;;543      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;544    
;;;545      if ((TIMERx->CNTRL & TIMER_CNTRL_DIR) == 0)
000140  0700              LSLS     r0,r0,#28
000142  d401              BMI      |L1.328|
;;;546      {
;;;547        bitstatus = TIMER_CntDir_Up;
000144  2000              MOVS     r0,#0
;;;548      }
;;;549      else
;;;550      {
;;;551        bitstatus = TIMER_CntDir_Dn;
;;;552      }
;;;553    
;;;554      return bitstatus;
;;;555    }
000146  4770              BX       lr
                  |L1.328|
000148  2008              MOVS     r0,#8                 ;551
00014a  4770              BX       lr
;;;556    
                          ENDP

                  TIMER_GetCntWriteComplete PROC
;;;561      */
;;;562    FlagStatus TIMER_GetCntWriteComplete(MDR_TIMER_TypeDef* TIMERx)
00014c  68c0              LDR      r0,[r0,#0xc]
;;;563    {
;;;564      FlagStatus bitstatus;
;;;565    
;;;566      /* Check the parameters */
;;;567      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;568    
;;;569      if ((TIMERx->CNTRL & TIMER_CNTRL_WR_CMPL) == 0)
00014e  0740              LSLS     r0,r0,#29
000150  d401              BMI      |L1.342|
;;;570      {
;;;571        bitstatus = RESET;
000152  2000              MOVS     r0,#0
;;;572      }
;;;573      else
;;;574      {
;;;575        bitstatus = SET;
;;;576      }
;;;577    
;;;578      return bitstatus;
;;;579    }
000154  4770              BX       lr
                  |L1.342|
000156  2001              MOVS     r0,#1                 ;575
000158  4770              BX       lr
;;;580    
                          ENDP

                  TIMER_ChnInit PROC
;;;589      */
;;;590    void TIMER_ChnInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
00015a  b510              PUSH     {r4,lr}
;;;591    {
;;;592      uint32_t tmpreg_CH_Number;
;;;593      uint32_t tmpreg_CH_CNTRL;
;;;594      uint32_t tmpreg_CH_CNTRL2;
;;;595    
;;;596      /* Check the parameters */
;;;597      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;598      assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnInitStruct->TIMER_CH_Number));
;;;599      assert_param(IS_TIMER_CHANNEL_MODE(TIMER_ChnInitStruct->TIMER_CH_Mode));
;;;600      assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_ETR_Ena));
;;;601      assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_ETR_Reset));
;;;602      assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_BRK_Reset));
;;;603      assert_param(IS_TIMER_CHANNEL_REF_FORMAT(TIMER_ChnInitStruct->TIMER_CH_REF_Format));
;;;604      assert_param(IS_TIMER_CHANNEL_PRESCALER(TIMER_ChnInitStruct->TIMER_CH_Prescaler));
;;;605      assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_EventSource));
;;;606      assert_param(IS_TIMER_FILTER_CONF(TIMER_ChnInitStruct->TIMER_CH_FilterConf));
;;;607      assert_param(IS_TIMER_CHANNEL_CCR_UPDATE_MODE(TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode));
;;;608      assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena));
;;;609      assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource));
;;;610    
;;;611      tmpreg_CH_CNTRL = TIMER_ChnInitStruct->TIMER_CH_Mode
00015c  884a              LDRH     r2,[r1,#2]
00015e  88cb              LDRH     r3,[r1,#6]
000160  894c              LDRH     r4,[r1,#0xa]
000162  441a              ADD      r2,r2,r3
000164  890b              LDRH     r3,[r1,#8]
000166  4423              ADD      r3,r3,r4
000168  441a              ADD      r2,r2,r3
00016a  898b              LDRH     r3,[r1,#0xc]
00016c  eb021283          ADD      r2,r2,r3,LSL #6
000170  89cb              LDRH     r3,[r1,#0xe]
000172  441a              ADD      r2,r2,r3
000174  8a0b              LDRH     r3,[r1,#0x10]
000176  441a              ADD      r2,r2,r3
;;;612                      + TIMER_ChnInitStruct->TIMER_CH_ETR_Reset
;;;613                      + TIMER_ChnInitStruct->TIMER_CH_BRK_Reset
;;;614                      + TIMER_ChnInitStruct->TIMER_CH_REF_Format
;;;615                      + (TIMER_ChnInitStruct->TIMER_CH_Prescaler << TIMER_CH_CNTRL_CHPSC_Pos)
;;;616                      + TIMER_ChnInitStruct->TIMER_CH_EventSource
;;;617                      + (TIMER_ChnInitStruct->TIMER_CH_FilterConf << TIMER_CH_CNTRL_CHFLTR_Pos);
;;;618    
;;;619      if (TIMER_ChnInitStruct->TIMER_CH_ETR_Ena != DISABLE)
000178  888b              LDRH     r3,[r1,#4]
00017a  b10b              CBZ      r3,|L1.384|
;;;620      {
;;;621        tmpreg_CH_CNTRL += TIMER_CH_CNTRL_ETREN;
00017c  f5025200          ADD      r2,r2,#0x2000
                  |L1.384|
;;;622      }
;;;623    
;;;624      tmpreg_CH_Number = TIMER_ChnInitStruct->TIMER_CH_Number;
000180  880b              LDRH     r3,[r1,#0]
;;;625    
;;;626      *(&TIMERx->CH1_CNTRL + tmpreg_CH_Number) = tmpreg_CH_CNTRL;
000182  eb000383          ADD      r3,r0,r3,LSL #2
000186  621a              STR      r2,[r3,#0x20]
;;;627    
;;;628      tmpreg_CH_CNTRL2 = TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode
000188  8a48              LDRH     r0,[r1,#0x12]
00018a  8aca              LDRH     r2,[r1,#0x16]
00018c  4410              ADD      r0,r0,r2
;;;629                       + TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource;
;;;630    
;;;631      if (TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena != DISABLE)
00018e  8a89              LDRH     r1,[r1,#0x14]
000190  b101              CBZ      r1,|L1.404|
;;;632      {
;;;633        tmpreg_CH_CNTRL2 += TIMER_CH_CNTRL2_CCR1_EN;
000192  1d00              ADDS     r0,r0,#4
                  |L1.404|
;;;634      }
;;;635    
;;;636      *(&TIMERx->CH1_CNTRL2 + tmpreg_CH_Number) = tmpreg_CH_CNTRL2;
000194  6618              STR      r0,[r3,#0x60]
;;;637    }
000196  bd10              POP      {r4,pc}
;;;638    
                          ENDP

                  TIMER_ChnStructInit PROC
;;;644      */
;;;645    void TIMER_ChnStructInit(TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
000198  2100              MOVS     r1,#0
;;;646    {
;;;647      TIMER_ChnInitStruct->TIMER_CH_Number           = TIMER_CHANNEL1;
00019a  8001              STRH     r1,[r0,#0]
;;;648      TIMER_ChnInitStruct->TIMER_CH_Mode             = TIMER_CH_MODE_PWM;
00019c  8041              STRH     r1,[r0,#2]
;;;649      TIMER_ChnInitStruct->TIMER_CH_ETR_Ena          = DISABLE;
00019e  8081              STRH     r1,[r0,#4]
;;;650      TIMER_ChnInitStruct->TIMER_CH_ETR_Reset        = TIMER_CH_ETR_RESET_Disable;
0001a0  80c1              STRH     r1,[r0,#6]
;;;651      TIMER_ChnInitStruct->TIMER_CH_BRK_Reset        = TIMER_CH_BRK_RESET_Disable;
0001a2  8101              STRH     r1,[r0,#8]
;;;652      TIMER_ChnInitStruct->TIMER_CH_REF_Format       = TIMER_CH_REF_Format0;
0001a4  8141              STRH     r1,[r0,#0xa]
;;;653      TIMER_ChnInitStruct->TIMER_CH_Prescaler        = TIMER_CH_Prescaler_None;
0001a6  8181              STRH     r1,[r0,#0xc]
;;;654      TIMER_ChnInitStruct->TIMER_CH_EventSource      = TIMER_CH_EvSrc_PE;
0001a8  81c1              STRH     r1,[r0,#0xe]
;;;655      TIMER_ChnInitStruct->TIMER_CH_FilterConf       = TIMER_Filter_1FF_at_TIMER_CLK;
0001aa  8201              STRH     r1,[r0,#0x10]
;;;656      TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode   = TIMER_CH_CCR_Update_Immediately;
0001ac  8241              STRH     r1,[r0,#0x12]
;;;657      TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena         = DISABLE;
0001ae  8281              STRH     r1,[r0,#0x14]
;;;658      TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource = TIMER_CH_CCR1EvSrc_PE;
0001b0  82c1              STRH     r1,[r0,#0x16]
;;;659    }
0001b2  4770              BX       lr
;;;660    
                          ENDP

                  TIMER_SetChnCompare PROC
;;;672      */
;;;673    void TIMER_SetChnCompare(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
0001b4  eb000081          ADD      r0,r0,r1,LSL #2
;;;674    {
;;;675      __IO uint32_t *tmpreg_CCRx;
;;;676    
;;;677      /* Check the parameters */
;;;678      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;679      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;680    
;;;681      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
;;;682      *tmpreg_CCRx = Compare;
0001b8  6102              STR      r2,[r0,#0x10]
;;;683    }
0001ba  4770              BX       lr
;;;684    
                          ENDP

                  TIMER_SetChnCompare1 PROC
;;;696      */
;;;697    void TIMER_SetChnCompare1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
0001bc  eb000081          ADD      r0,r0,r1,LSL #2
;;;698    {
;;;699      __IO uint32_t *tmpreg_CCR1x;
;;;700    
;;;701      /* Check the parameters */
;;;702      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;703      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;704    
;;;705      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
;;;706      *tmpreg_CCR1x = Compare;
0001c0  6702              STR      r2,[r0,#0x70]
;;;707    }
0001c2  4770              BX       lr
;;;708    
                          ENDP

                  TIMER_ChnCompareConfig PROC
;;;724      */
;;;725    void TIMER_ChnCompareConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
0001c4  b510              PUSH     {r4,lr}
;;;726    {
;;;727      __IO uint32_t *tmpreg_CNTRL2x;
;;;728      __IO uint32_t *tmpreg_CCRx;
;;;729      uint32_t tmpreg_CNTRL2;
;;;730    
;;;731      /* Check the parameters */
;;;732      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;733      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;734      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;735    
;;;736      tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
0001c6  eb000081          ADD      r0,r0,r1,LSL #2
0001ca  4601              MOV      r1,r0
;;;737    
;;;738      tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
0001cc  6e04              LDR      r4,[r0,#0x60]
;;;739      tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
0001ce  f0240408          BIC      r4,r4,#8
;;;740      tmpreg_CNTRL2 += UpdateMode;
0001d2  4423              ADD      r3,r3,r4
;;;741      *tmpreg_CNTRL2x = tmpreg_CNTRL2;
0001d4  6603              STR      r3,[r0,#0x60]
;;;742    
;;;743      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
0001d6  4608              MOV      r0,r1
;;;744    
;;;745      *tmpreg_CCRx = Compare;
0001d8  6102              STR      r2,[r0,#0x10]
;;;746    }
0001da  bd10              POP      {r4,pc}
;;;747    
                          ENDP

                  TIMER_ChnCompare1Config PROC
;;;763      */
;;;764    void TIMER_ChnCompare1Config(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
0001dc  b510              PUSH     {r4,lr}
;;;765    {
;;;766      __IO uint32_t *tmpreg_CNTRL2x;
;;;767      __IO uint32_t *tmpreg_CCR1x;
;;;768      uint32_t tmpreg_CNTRL2;
;;;769    
;;;770      /* Check the parameters */
;;;771      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;772      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;773      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;774    
;;;775      tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
0001de  eb000081          ADD      r0,r0,r1,LSL #2
0001e2  4601              MOV      r1,r0
;;;776    
;;;777      tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
0001e4  6e04              LDR      r4,[r0,#0x60]
;;;778      tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
0001e6  f0240408          BIC      r4,r4,#8
;;;779      tmpreg_CNTRL2 += UpdateMode;
0001ea  4423              ADD      r3,r3,r4
;;;780      *tmpreg_CNTRL2x = tmpreg_CNTRL2;
0001ec  6603              STR      r3,[r0,#0x60]
;;;781    
;;;782      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
0001ee  4608              MOV      r0,r1
;;;783    
;;;784      *tmpreg_CCR1x = Compare;
0001f0  6702              STR      r2,[r0,#0x70]
;;;785    }
0001f2  bd10              POP      {r4,pc}
;;;786    
                          ENDP

                  TIMER_GetChnCapture PROC
;;;797      */
;;;798    uint16_t TIMER_GetChnCapture(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
0001f4  eb000081          ADD      r0,r0,r1,LSL #2
;;;799    {
;;;800      __IO uint32_t *tmpreg_CCRx;
;;;801      uint32_t tmpreg;
;;;802    
;;;803      /* Check the parameters */
;;;804      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;805      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;806    
;;;807      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
;;;808      tmpreg = *tmpreg_CCRx;
0001f8  6900              LDR      r0,[r0,#0x10]
;;;809    
;;;810      return tmpreg;
0001fa  b280              UXTH     r0,r0
;;;811    }
0001fc  4770              BX       lr
;;;812    
                          ENDP

                  TIMER_GetChnCapture1 PROC
;;;823      */
;;;824    uint16_t TIMER_GetChnCapture1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
0001fe  eb000081          ADD      r0,r0,r1,LSL #2
;;;825    {
;;;826      __IO uint32_t *tmpreg_CCR1x;
;;;827      uint32_t tmpreg;
;;;828    
;;;829      /* Check the parameters */
;;;830      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;831      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;832    
;;;833      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
;;;834      tmpreg = *tmpreg_CCR1x;
000202  6f00              LDR      r0,[r0,#0x70]
;;;835    
;;;836      return tmpreg;
000204  b280              UXTH     r0,r0
;;;837    }
000206  4770              BX       lr
;;;838    
                          ENDP

                  TIMER_ChnETR_Cmd PROC
;;;851      */
;;;852    void TIMER_ChnETR_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
000208  eb000081          ADD      r0,r0,r1,LSL #2
;;;853    {
;;;854      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;855      uint32_t tmpreg_CH_CNTRL;
;;;856    
;;;857      /* Check the parameters */
;;;858      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;859      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;860      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;861    
;;;862      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
00020c  3020              ADDS     r0,r0,#0x20
;;;863    
;;;864      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00020e  6801              LDR      r1,[r0,#0]
;;;865    
;;;866      /* Form new value */
;;;867      if (NewState != DISABLE)
000210  b112              CBZ      r2,|L1.536|
;;;868      {
;;;869        /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
;;;870        tmpreg_CH_CNTRL |= TIMER_CH_CNTRL_OCCE;
000212  f4417180          ORR      r1,r1,#0x100
000216  e001              B        |L1.540|
                  |L1.536|
;;;871      }
;;;872      else
;;;873      {
;;;874        /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
;;;875        tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCE;
000218  f4217180          BIC      r1,r1,#0x100
                  |L1.540|
;;;876      }
;;;877    
;;;878      /* Configure CNTRL register with new value */
;;;879      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
00021c  6001              STR      r1,[r0,#0]
;;;880    }
00021e  4770              BX       lr
;;;881    
                          ENDP

                  TIMER_ChnETRResetConfig PROC
;;;896      */
;;;897    void TIMER_ChnETRResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
000220  eb000081          ADD      r0,r0,r1,LSL #2
;;;898    {
;;;899      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;900      uint32_t tmpreg_CH_CNTRL;
;;;901    
;;;902      /* Check the parameters */
;;;903      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;904      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;905      assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(NewState));
;;;906    
;;;907      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;908    
;;;909      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
000224  6a01              LDR      r1,[r0,#0x20]
;;;910      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_ETREN;
000226  f4215100          BIC      r1,r1,#0x2000
;;;911      tmpreg_CH_CNTRL += NewState;
00022a  4411              ADD      r1,r1,r2
;;;912      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
00022c  6201              STR      r1,[r0,#0x20]
;;;913    }
00022e  4770              BX       lr
;;;914    
                          ENDP

                  TIMER_ChnBRKResetConfig PROC
;;;929      */
;;;930    void TIMER_ChnBRKResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
000230  eb000081          ADD      r0,r0,r1,LSL #2
;;;931    {
;;;932      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;933      uint32_t tmpreg_CH_CNTRL;
;;;934    
;;;935      /* Check the parameters */
;;;936      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;937      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;938      assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(NewState));
;;;939    
;;;940      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;941    
;;;942      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
000234  6a01              LDR      r1,[r0,#0x20]
;;;943      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_BRKEN;
000236  f4215180          BIC      r1,r1,#0x1000
;;;944      tmpreg_CH_CNTRL += NewState;
00023a  4411              ADD      r1,r1,r2
;;;945      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
00023c  6201              STR      r1,[r0,#0x20]
;;;946    }
00023e  4770              BX       lr
;;;947    
                          ENDP

                  TIMER_ChnREFFormatConfig PROC
;;;960      */
;;;961    void TIMER_ChnREFFormatConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Format)
000240  eb000081          ADD      r0,r0,r1,LSL #2
;;;962    {
;;;963      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;964      uint32_t tmpreg_CH_CNTRL;
;;;965    
;;;966      /* Check the parameters */
;;;967      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;968      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;969      assert_param(IS_TIMER_CHANNEL_REF_FORMAT(Format));
;;;970    
;;;971      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;972    
;;;973      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
000244  6a01              LDR      r1,[r0,#0x20]
;;;974      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCM_Msk;
000246  f4216160          BIC      r1,r1,#0xe00
;;;975      tmpreg_CH_CNTRL += Format;
00024a  4411              ADD      r1,r1,r2
;;;976      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
00024c  6201              STR      r1,[r0,#0x20]
;;;977    }
00024e  4770              BX       lr
;;;978    
                          ENDP

                  TIMER_ChnCapturePrescalerConfig PROC
;;;995      */
;;;996    void TIMER_ChnCapturePrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Prescaler)
000250  eb000081          ADD      r0,r0,r1,LSL #2
;;;997    {
;;;998      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;999      uint32_t tmpreg_CH_CNTRL;
;;;1000   
;;;1001     /* Check the parameters */
;;;1002     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1003     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1004     assert_param(IS_TIMER_CHANNEL_PRESCALER(Prescaler));
;;;1005   
;;;1006     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;1007   
;;;1008     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
000254  6a01              LDR      r1,[r0,#0x20]
;;;1009     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHPSC_Msk;
000256  f02101c0          BIC      r1,r1,#0xc0
;;;1010     tmpreg_CH_CNTRL += Prescaler << TIMER_CH_CNTRL_CHPSC_Pos;
00025a  eb011182          ADD      r1,r1,r2,LSL #6
;;;1011     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
00025e  6201              STR      r1,[r0,#0x20]
;;;1012   }
000260  4770              BX       lr
;;;1013   
                          ENDP

                  TIMER_ChnEventSourceConfig PROC
;;;1030     */
;;;1031   void TIMER_ChnEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
000262  eb000081          ADD      r0,r0,r1,LSL #2
;;;1032   {
;;;1033     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1034     uint32_t tmpreg_CH_CNTRL;
;;;1035   
;;;1036     /* Check the parameters */
;;;1037     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1038     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1039     assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(EventSource));
;;;1040   
;;;1041     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;1042   
;;;1043     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
000266  6a01              LDR      r1,[r0,#0x20]
;;;1044     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHSEL_Msk;
000268  f0210130          BIC      r1,r1,#0x30
;;;1045     tmpreg_CH_CNTRL += EventSource;
00026c  4411              ADD      r1,r1,r2
;;;1046     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
00026e  6201              STR      r1,[r0,#0x20]
;;;1047   }
000270  4770              BX       lr
;;;1048   
                          ENDP

                  TIMER_ChnFilterConfig PROC
;;;1077     */
;;;1078   void TIMER_ChnFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Filter)
000272  eb000081          ADD      r0,r0,r1,LSL #2
;;;1079   {
;;;1080     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1081     uint32_t tmpreg_CH_CNTRL;
;;;1082   
;;;1083     /* Check the parameters */
;;;1084     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1085     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1086     assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;1087   
;;;1088     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;1089   
;;;1090     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
000276  6a01              LDR      r1,[r0,#0x20]
;;;1091     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHFLTR_Msk;
000278  f021010f          BIC      r1,r1,#0xf
;;;1092     tmpreg_CH_CNTRL += Filter << TIMER_CH_CNTRL_CHFLTR_Pos;
00027c  4411              ADD      r1,r1,r2
;;;1093     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
00027e  6201              STR      r1,[r0,#0x20]
;;;1094   }
000280  4770              BX       lr
;;;1095   
                          ENDP

                  TIMER_GetChnWriteComplete PROC
;;;1106     */
;;;1107   FlagStatus TIMER_GetChnWriteComplete(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
000282  eb000081          ADD      r0,r0,r1,LSL #2
;;;1108   {
;;;1109     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1110     FlagStatus bitstatus;
;;;1111   
;;;1112     /* Check the parameters */
;;;1113     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1114     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1115   
;;;1116     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
;;;1117   
;;;1118     if ((*tmpreg_CH_CNTRLx & TIMER_CH_CNTRL_WR_CMPL) == 0)
000286  6a00              LDR      r0,[r0,#0x20]
000288  0440              LSLS     r0,r0,#17
00028a  d401              BMI      |L1.656|
;;;1119     {
;;;1120       bitstatus = RESET;
00028c  2000              MOVS     r0,#0
;;;1121     }
;;;1122     else
;;;1123     {
;;;1124       bitstatus = SET;
;;;1125     }
;;;1126   
;;;1127     return bitstatus;
;;;1128   }
00028e  4770              BX       lr
                  |L1.656|
000290  2001              MOVS     r0,#1                 ;1124
000292  4770              BX       lr
;;;1129   
                          ENDP

                  TIMER_ChnCCR1_EventSourceConfig PROC
;;;1146     */
;;;1147   void TIMER_ChnCCR1_EventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
000294  eb000081          ADD      r0,r0,r1,LSL #2
;;;1148   {
;;;1149     __IO uint32_t *tmpreg_CH_CNTRL2x;
;;;1150     uint32_t tmpreg_CH_CNTRL2;
;;;1151   
;;;1152     /* Check the parameters */
;;;1153     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1154     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1155     assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(EventSource));
;;;1156   
;;;1157     tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
;;;1158   
;;;1159     tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
000298  6e01              LDR      r1,[r0,#0x60]
;;;1160     tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CHSEL1_Msk;
00029a  f0210103          BIC      r1,r1,#3
;;;1161     tmpreg_CH_CNTRL2 += EventSource;
00029e  4411              ADD      r1,r1,r2
;;;1162     *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
0002a0  6601              STR      r1,[r0,#0x60]
;;;1163   }
0002a2  4770              BX       lr
;;;1164   
                          ENDP

                  TIMER_ChnCCR1_Cmd PROC
;;;1177     */
;;;1178   void TIMER_ChnCCR1_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
0002a4  eb000081          ADD      r0,r0,r1,LSL #2
;;;1179   {
;;;1180     __IO uint32_t *tmpreg_CH_CNTRL2x;
;;;1181     uint32_t tmpreg_CH_CNTRL2;
;;;1182   
;;;1183     /* Check the parameters */
;;;1184     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1185     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1186     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1187   
;;;1188     tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
0002a8  3060              ADDS     r0,r0,#0x60
;;;1189   
;;;1190     tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
0002aa  6801              LDR      r1,[r0,#0]
;;;1191   
;;;1192     /* Form new value */
;;;1193     if (NewState != DISABLE)
0002ac  b112              CBZ      r2,|L1.692|
;;;1194     {
;;;1195       /* Enable TIMERx by setting the CCR1_EN bit in the CNTRL2 register */
;;;1196       tmpreg_CH_CNTRL2 |= TIMER_CH_CNTRL2_CCR1_EN;
0002ae  f0410104          ORR      r1,r1,#4
0002b2  e001              B        |L1.696|
                  |L1.692|
;;;1197     }
;;;1198     else
;;;1199     {
;;;1200       /* Disable TIMERx by resetting the CCR1_EN bit in the CNTRL2 register */
;;;1201       tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CCR1_EN;
0002b4  f0210104          BIC      r1,r1,#4
                  |L1.696|
;;;1202     }
;;;1203   
;;;1204     /* Configure CNTRL register with new value */
;;;1205     *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
0002b8  6001              STR      r1,[r0,#0]
;;;1206   }
0002ba  4770              BX       lr
;;;1207   
                          ENDP

                  TIMER_ChnOutInit PROC
;;;1216     */
;;;1217   void TIMER_ChnOutInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
0002bc  b510              PUSH     {r4,lr}
;;;1218   {
;;;1219     uint32_t tmpreg_CH_Number;
;;;1220     uint32_t tmpreg_CH_CNTRL1;
;;;1221     uint32_t tmpreg_CH_DTG;
;;;1222   
;;;1223     /* Check the parameters */
;;;1224     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1225     assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnOutInitStruct->TIMER_CH_Number));
;;;1226     assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity));
;;;1227     assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source));
;;;1228     assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode));
;;;1229     assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity));
;;;1230     assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source));
;;;1231     assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode));
;;;1232     assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler));
;;;1233     assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler));
;;;1234     assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource));
;;;1235   
;;;1236     tmpreg_CH_CNTRL1 = (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity << TIMER_CH_CNTRL1_INV_Pos)
0002be  88ca              LDRH     r2,[r1,#6]
0002c0  884b              LDRH     r3,[r1,#2]
0002c2  890c              LDRH     r4,[r1,#8]
0002c4  eb021203          ADD      r2,r2,r3,LSL #4
0002c8  888b              LDRH     r3,[r1,#4]
0002ca  009b              LSLS     r3,r3,#2
0002cc  eb033304          ADD      r3,r3,r4,LSL #12
0002d0  441a              ADD      r2,r2,r3
0002d2  894b              LDRH     r3,[r1,#0xa]
0002d4  eb022283          ADD      r2,r2,r3,LSL #10
0002d8  898b              LDRH     r3,[r1,#0xc]
0002da  eb022203          ADD      r2,r2,r3,LSL #8
;;;1237                      + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source   << TIMER_CH_CNTRL1_SELO_Pos)
;;;1238                      + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode     << TIMER_CH_CNTRL1_SELOE_Pos)
;;;1239                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity << TIMER_CH_CNTRL1_NINV_Pos)
;;;1240                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source   << TIMER_CH_CNTRL1_NSELO_Pos)
;;;1241                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode     << TIMER_CH_CNTRL1_NSELOE_Pos);
;;;1242   
;;;1243     tmpreg_CH_Number = TIMER_ChnOutInitStruct->TIMER_CH_Number;
0002de  880b              LDRH     r3,[r1,#0]
;;;1244   
;;;1245     *(&TIMERx->CH1_CNTRL1 + tmpreg_CH_Number) = tmpreg_CH_CNTRL1;
0002e0  eb000083          ADD      r0,r0,r3,LSL #2
0002e4  6302              STR      r2,[r0,#0x30]
;;;1246   
;;;1247     tmpreg_CH_DTG = (TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler << TIMER_CH_DTG_Pos)
0002e6  8a0a              LDRH     r2,[r1,#0x10]
0002e8  8a4b              LDRH     r3,[r1,#0x12]
0002ea  89c9              LDRH     r1,[r1,#0xe]
0002ec  441a              ADD      r2,r2,r3
0002ee  eb022101          ADD      r1,r2,r1,LSL #8
;;;1248                   + (TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  << TIMER_CH_DTGX_Pos)
;;;1249                   + TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource;
;;;1250   
;;;1251     *(&TIMERx->CH1_DTG + tmpreg_CH_Number) = tmpreg_CH_DTG;
0002f2  6401              STR      r1,[r0,#0x40]
;;;1252   }
0002f4  bd10              POP      {r4,pc}
;;;1253   
                          ENDP

                  TIMER_ChnOutStructInit PROC
;;;1259     */
;;;1260   void TIMER_ChnOutStructInit(TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
0002f6  2100              MOVS     r1,#0
;;;1261   {
;;;1262     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity   = TIMER_CHOPolarity_NonInverted;
0002f8  8041              STRH     r1,[r0,#2]
;;;1263     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source     = TIMER_CH_OutSrc_Only_0;
0002fa  8081              STRH     r1,[r0,#4]
;;;1264     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode       = TIMER_CH_OutMode_Input;
0002fc  80c1              STRH     r1,[r0,#6]
;;;1265     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity   = TIMER_CHOPolarity_NonInverted;
0002fe  8101              STRH     r1,[r0,#8]
;;;1266     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source     = TIMER_CH_OutSrc_Only_0;
000300  8141              STRH     r1,[r0,#0xa]
;;;1267     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode       = TIMER_CH_OutMode_Input;
000302  8181              STRH     r1,[r0,#0xc]
;;;1268     TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler = 0;
000304  81c1              STRH     r1,[r0,#0xe]
;;;1269     TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  = 0;
000306  8201              STRH     r1,[r0,#0x10]
;;;1270     TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource   = TIMER_CH_DTG_ClkSrc_TIMER_CLK;
000308  8241              STRH     r1,[r0,#0x12]
;;;1271   }
00030a  4770              BX       lr
;;;1272   
                          ENDP

                  TIMER_ChnOutConfig PROC
;;;1299     */
;;;1300   void TIMER_ChnOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
00030c  b510              PUSH     {r4,lr}
;;;1301   {
00030e  9c02              LDR      r4,[sp,#8]
;;;1302     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1303     uint32_t tmpreg_CH_CNTRL1;
;;;1304   
;;;1305     /* Check the parameters */
;;;1306     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1307     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1308     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1309     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1310     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1311   
;;;1312     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000310  eb000081          ADD      r0,r0,r1,LSL #2
;;;1313   
;;;1314     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000314  6b01              LDR      r1,[r0,#0x30]
;;;1315     tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_INV + TIMER_CH_CNTRL1_SELO_Msk + TIMER_CH_CNTRL1_SELOE_Msk);
000316  f021011f          BIC      r1,r1,#0x1f
;;;1316     tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_INV_Pos)
00031a  0124              LSLS     r4,r4,#4
00031c  eb040282          ADD      r2,r4,r2,LSL #2
000320  441a              ADD      r2,r2,r3
000322  4411              ADD      r1,r1,r2
;;;1317                       + (OutSource << TIMER_CH_CNTRL1_SELO_Pos)
;;;1318                       + (Mode      << TIMER_CH_CNTRL1_SELOE_Pos);
;;;1319     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000324  6301              STR      r1,[r0,#0x30]
;;;1320   }
000326  bd10              POP      {r4,pc}
;;;1321   
                          ENDP

                  TIMER_ChnOutSourceConfig PROC
;;;1338     */
;;;1339   void TIMER_ChnOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
000328  eb000081          ADD      r0,r0,r1,LSL #2
;;;1340   {
;;;1341     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1342     uint32_t tmpreg_CH_CNTRL1;
;;;1343   
;;;1344     /* Check the parameters */
;;;1345     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1346     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1347     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1348   
;;;1349     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
;;;1350   
;;;1351     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00032c  6b01              LDR      r1,[r0,#0x30]
;;;1352     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELO_Msk;
00032e  f021010c          BIC      r1,r1,#0xc
;;;1353     tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_SELO_Pos;
000332  eb010182          ADD      r1,r1,r2,LSL #2
;;;1354     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000336  6301              STR      r1,[r0,#0x30]
;;;1355   }
000338  4770              BX       lr
;;;1356   
                          ENDP

                  TIMER_ChnOutModeConfig PROC
;;;1373     */
;;;1374   void TIMER_ChnOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
00033a  eb000081          ADD      r0,r0,r1,LSL #2
;;;1375   {
;;;1376     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1377     uint32_t tmpreg_CH_CNTRL1;
;;;1378   
;;;1379     /* Check the parameters */
;;;1380     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1381     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1382     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1383   
;;;1384     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
;;;1385   
;;;1386     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00033e  6b01              LDR      r1,[r0,#0x30]
;;;1387     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELOE_Msk;
000340  f0210103          BIC      r1,r1,#3
;;;1388     tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_SELOE_Pos;
000344  4411              ADD      r1,r1,r2
;;;1389     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000346  6301              STR      r1,[r0,#0x30]
;;;1390   }
000348  4770              BX       lr
;;;1391   
                          ENDP

                  TIMER_ChnOutPolarityConfig PROC
;;;1406     */
;;;1407   void TIMER_ChnOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
00034a  eb000081          ADD      r0,r0,r1,LSL #2
;;;1408   {
;;;1409     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1410     uint32_t tmpreg_CH_CNTRL1;
;;;1411   
;;;1412     /* Check the parameters */
;;;1413     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1414     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1415     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1416   
;;;1417     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
;;;1418   
;;;1419     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00034e  6b01              LDR      r1,[r0,#0x30]
;;;1420     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_INV;
000350  f0210110          BIC      r1,r1,#0x10
;;;1421     tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_INV_Pos;
000354  eb011102          ADD      r1,r1,r2,LSL #4
;;;1422     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000358  6301              STR      r1,[r0,#0x30]
;;;1423   }
00035a  4770              BX       lr
;;;1424   
                          ENDP

                  TIMER_ChnNOutConfig PROC
;;;1451     */
;;;1452   void TIMER_ChnNOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
00035c  b510              PUSH     {r4,lr}
;;;1453   {
00035e  9c02              LDR      r4,[sp,#8]
;;;1454     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1455     uint32_t tmpreg_CH_CNTRL1;
;;;1456   
;;;1457     /* Check the parameters */
;;;1458     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1459     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1460     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1461     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1462     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1463   
;;;1464     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000360  eb000081          ADD      r0,r0,r1,LSL #2
;;;1465   
;;;1466     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000364  6b01              LDR      r1,[r0,#0x30]
;;;1467     tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_NINV + TIMER_CH_CNTRL1_NSELO_Msk + TIMER_CH_CNTRL1_NSELOE_Msk);
000366  f42151f8          BIC      r1,r1,#0x1f00
;;;1468     tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_NINV_Pos)
00036a  0324              LSLS     r4,r4,#12
00036c  eb042282          ADD      r2,r4,r2,LSL #10
000370  eb022203          ADD      r2,r2,r3,LSL #8
000374  4411              ADD      r1,r1,r2
;;;1469                       + (OutSource << TIMER_CH_CNTRL1_NSELO_Pos)
;;;1470                       + (Mode      << TIMER_CH_CNTRL1_NSELOE_Pos);
;;;1471     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000376  6301              STR      r1,[r0,#0x30]
;;;1472   }
000378  bd10              POP      {r4,pc}
;;;1473   
                          ENDP

                  TIMER_ChnNOutSourceConfig PROC
;;;1490     */
;;;1491   void TIMER_ChnNOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
00037a  eb000081          ADD      r0,r0,r1,LSL #2
;;;1492   {
;;;1493     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1494     uint32_t tmpreg_CH_CNTRL1;
;;;1495   
;;;1496     /* Check the parameters */
;;;1497     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1498     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1499     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1500   
;;;1501     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
;;;1502   
;;;1503     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00037e  6b01              LDR      r1,[r0,#0x30]
;;;1504     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELO_Msk;
000380  f4216140          BIC      r1,r1,#0xc00
;;;1505     tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_NSELO_Pos;
000384  eb012182          ADD      r1,r1,r2,LSL #10
;;;1506     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000388  6301              STR      r1,[r0,#0x30]
;;;1507   }
00038a  4770              BX       lr
;;;1508   
                          ENDP

                  TIMER_ChnNOutModeConfig PROC
;;;1525     */
;;;1526   void TIMER_ChnNOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
00038c  eb000081          ADD      r0,r0,r1,LSL #2
;;;1527   {
;;;1528     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1529     uint32_t tmpreg_CH_CNTRL1;
;;;1530   
;;;1531     /* Check the parameters */
;;;1532     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1533     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1534     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1535   
;;;1536     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
;;;1537   
;;;1538     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000390  6b01              LDR      r1,[r0,#0x30]
;;;1539     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELOE_Msk;
000392  f4217140          BIC      r1,r1,#0x300
;;;1540     tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_NSELOE_Pos;
000396  eb012102          ADD      r1,r1,r2,LSL #8
;;;1541     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
00039a  6301              STR      r1,[r0,#0x30]
;;;1542   }
00039c  4770              BX       lr
;;;1543   
                          ENDP

                  TIMER_ChnNOutPolarityConfig PROC
;;;1558     */
;;;1559   void TIMER_ChnNOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
00039e  eb000081          ADD      r0,r0,r1,LSL #2
;;;1560   {
;;;1561     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1562     uint32_t tmpreg_CH_CNTRL1;
;;;1563   
;;;1564     /* Check the parameters */
;;;1565     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1566     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1567     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1568   
;;;1569     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
;;;1570   
;;;1571     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
0003a2  6b01              LDR      r1,[r0,#0x30]
;;;1572     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NINV;
0003a4  f4215180          BIC      r1,r1,#0x1000
;;;1573     tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_NINV_Pos;
0003a8  eb013102          ADD      r1,r1,r2,LSL #12
;;;1574     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
0003ac  6301              STR      r1,[r0,#0x30]
;;;1575   }
0003ae  4770              BX       lr
;;;1576   
                          ENDP

                  TIMER_ChnOutDTGConfig PROC
;;;1595     */
;;;1596   void TIMER_ChnOutDTGConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel,
0003b0  b510              PUSH     {r4,lr}
;;;1597                            uint32_t MainPrescaler, uint32_t AuxPrescaler, uint32_t ClockSource)
;;;1598   {
0003b2  9c02              LDR      r4,[sp,#8]
;;;1599     uint32_t tmpreg_CH_DTG;
;;;1600   
;;;1601     /* Check the parameters */
;;;1602     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1603     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1604     assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(MainPrescaler));
;;;1605     assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(AuxPrescaler));
;;;1606     assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(ClockSource));
;;;1607   
;;;1608     tmpreg_CH_DTG = (MainPrescaler << TIMER_CH_DTG_Pos)
0003b4  eb032202          ADD      r2,r3,r2,LSL #8
0003b8  4422              ADD      r2,r2,r4
;;;1609                   + (AuxPrescaler  << TIMER_CH_DTGX_Pos)
;;;1610                   + ClockSource;
;;;1611   
;;;1612     *(&TIMERx->CH1_DTG + Channel) = tmpreg_CH_DTG;
0003ba  eb000081          ADD      r0,r0,r1,LSL #2
0003be  6402              STR      r2,[r0,#0x40]
;;;1613   }
0003c0  bd10              POP      {r4,pc}
;;;1614   
                          ENDP

                  TIMER_GetStatus PROC
;;;1619     */
;;;1620   uint32_t TIMER_GetStatus(MDR_TIMER_TypeDef* TIMERx)
0003c2  6d40              LDR      r0,[r0,#0x54]
;;;1621   {
;;;1622     /* Check the parameters */
;;;1623     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1624   
;;;1625     return TIMERx->STATUS;
;;;1626   }
0003c4  4770              BX       lr
;;;1627   
                          ENDP

                  TIMER_GetFlagStatus PROC
;;;1651     */
;;;1652   FlagStatus TIMER_GetFlagStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t Flag)
0003c6  6d40              LDR      r0,[r0,#0x54]
;;;1653   {
;;;1654     FlagStatus bitstatus;
;;;1655   
;;;1656     /* Check the parameters */
;;;1657     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1658     assert_param(IS_TIMER_STATUS_FLAG(Flag));
;;;1659   
;;;1660     if ((TIMERx->STATUS & Flag) == 0)
0003c8  4208              TST      r0,r1
0003ca  d001              BEQ      |L1.976|
;;;1661     {
;;;1662       bitstatus = RESET;
;;;1663     }
;;;1664     else
;;;1665     {
;;;1666       bitstatus = SET;
0003cc  2001              MOVS     r0,#1
;;;1667     }
;;;1668   
;;;1669     return bitstatus;
;;;1670   }
0003ce  4770              BX       lr
                  |L1.976|
0003d0  2000              MOVS     r0,#0                 ;1662
0003d2  4770              BX       lr
;;;1671   
                          ENDP

                  TIMER_ClearFlag PROC
;;;1695     */
;;;1696   void TIMER_ClearFlag(MDR_TIMER_TypeDef* TIMERx, uint32_t Flags)
0003d4  6d42              LDR      r2,[r0,#0x54]
;;;1697   {
;;;1698     /* Check the parameters */
;;;1699     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1700     assert_param(IS_TIMER_STATUS(Flags));
;;;1701   
;;;1702     TIMERx->STATUS &= ~Flags;
0003d6  438a              BICS     r2,r2,r1
0003d8  6542              STR      r2,[r0,#0x54]
;;;1703   }
0003da  4770              BX       lr
;;;1704   
                          ENDP

                  TIMER_DMACmd PROC
;;;1730     */
;;;1731   void TIMER_DMACmd(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_DMASource, FunctionalState NewState)
0003dc  6dc3              LDR      r3,[r0,#0x5c]
;;;1732   {
;;;1733     uint32_t tmpreg_DMA_RE;
;;;1734   
;;;1735     /* Check the parameters */
;;;1736     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1737     assert_param(IS_TIMER_STATUS(TIMER_DMASource));
;;;1738     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1739   
;;;1740     tmpreg_DMA_RE = TIMERx->DMA_RE;
;;;1741   
;;;1742     /* Form new value */
;;;1743     if (NewState != DISABLE)
0003de  b10a              CBZ      r2,|L1.996|
;;;1744     {
;;;1745       /* Enable TIMERx DMA Requests by setting bits in the DMA_RE register */
;;;1746       tmpreg_DMA_RE |= TIMER_DMASource;
0003e0  430b              ORRS     r3,r3,r1
0003e2  e000              B        |L1.998|
                  |L1.996|
;;;1747     }
;;;1748     else
;;;1749     {
;;;1750       /* Disable TIMERx DMA Requests by clearing bits in the DMA_RE register */
;;;1751       tmpreg_DMA_RE &= ~TIMER_DMASource;
0003e4  438b              BICS     r3,r3,r1
                  |L1.998|
;;;1752     }
;;;1753   
;;;1754     /* Configure CNTRL register with new value */
;;;1755     TIMERx->DMA_RE = tmpreg_DMA_RE;
0003e6  65c3              STR      r3,[r0,#0x5c]
;;;1756   }
0003e8  4770              BX       lr
;;;1757   
                          ENDP

                  TIMER_ITConfig PROC
;;;1783     */
;;;1784   void TIMER_ITConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT, FunctionalState NewState)
0003ea  6d83              LDR      r3,[r0,#0x58]
;;;1785   {
;;;1786     uint32_t tmpreg_IE;
;;;1787   
;;;1788     /* Check the parameters */
;;;1789     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1790     assert_param(IS_TIMER_STATUS(TIMER_IT));
;;;1791     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1792   
;;;1793     tmpreg_IE = TIMERx->IE;
;;;1794   
;;;1795     /* Form new value */
;;;1796     if (NewState != DISABLE)
0003ec  b10a              CBZ      r2,|L1.1010|
;;;1797     {
;;;1798       /* Enable the TIMERx Interrupt requests by setting bits in the IE register */
;;;1799       tmpreg_IE |= TIMER_IT;
0003ee  430b              ORRS     r3,r3,r1
0003f0  e000              B        |L1.1012|
                  |L1.1010|
;;;1800     }
;;;1801     else
;;;1802     {
;;;1803       /* Disable the TIMERx Interrupt requests by clearing bits in the IE register */
;;;1804       tmpreg_IE &= ~TIMER_IT;
0003f2  438b              BICS     r3,r3,r1
                  |L1.1012|
;;;1805     }
;;;1806   
;;;1807     /* Configure CNTRL register with new value */
;;;1808     TIMERx->IE = tmpreg_IE;
0003f4  6583              STR      r3,[r0,#0x58]
;;;1809   }
0003f6  4770              BX       lr
;;;1810   
                          ENDP

                  TIMER_GetITStatus PROC
;;;1834     */
;;;1835   ITStatus TIMER_GetITStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT)
0003f8  6d42              LDR      r2,[r0,#0x54]
;;;1836   {
;;;1837     ITStatus bitstatus;
;;;1838     uint32_t tmpreg;
;;;1839   
;;;1840     /* Check the parameters */
;;;1841     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1842     assert_param(IS_TIMER_STATUS_FLAG(TIMER_IT));
;;;1843   
;;;1844     tmpreg = TIMERx->STATUS & TIMERx->IE & TIMER_IT;
0003fa  6d80              LDR      r0,[r0,#0x58]
0003fc  4002              ANDS     r2,r2,r0
0003fe  400a              ANDS     r2,r2,r1
;;;1845   
;;;1846     if (tmpreg == 0)
000400  b10a              CBZ      r2,|L1.1030|
;;;1847     {
;;;1848       bitstatus = RESET;
;;;1849     }
;;;1850     else
;;;1851     {
;;;1852       bitstatus = SET;
000402  2001              MOVS     r0,#1
;;;1853     }
;;;1854   
;;;1855     return bitstatus;
;;;1856   }
000404  4770              BX       lr
                  |L1.1030|
000406  2000              MOVS     r0,#0                 ;1848
000408  4770              BX       lr
;;;1857   
                          ENDP

                  TIMER_BRGInit PROC
;;;1873     */
;;;1874   void TIMER_BRGInit(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_BRG)
00040a  b510              PUSH     {r4,lr}
;;;1875   {
;;;1876     uint32_t tmpreg;
;;;1877   
;;;1878     /* Check the parameters */
;;;1879     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1880     assert_param(IS_TIMER_CLOCK_BRG(TIMER_BRG));
;;;1881   
;;;1882     tmpreg = MDR_RST_CLK->TIM_CLOCK;
00040c  4b0f              LDR      r3,|L1.1100|
00040e  6a5a              LDR      r2,[r3,#0x24]
;;;1883   
;;;1884     if (TIMERx == MDR_TIMER1)
000410  4c0f              LDR      r4,|L1.1104|
000412  42a0              CMP      r0,r4
000414  d105              BNE      |L1.1058|
;;;1885     {
;;;1886       tmpreg &= ~RST_CLK_TIM_CLOCK_TIM1_BRG_Msk;
000416  f02200ff          BIC      r0,r2,#0xff
;;;1887       tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM1_BRG_Pos;
00041a  4308              ORRS     r0,r0,r1
;;;1888       tmpreg |= RST_CLK_TIM_CLOCK_TIM1_CLK_EN;
00041c  f0407280          ORR      r2,r0,#0x1000000
000420  e012              B        |L1.1096|
                  |L1.1058|
;;;1889     }
;;;1890     else if (TIMERx == MDR_TIMER2)
000422  4c0c              LDR      r4,|L1.1108|
000424  42a0              CMP      r0,r4
000426  d106              BNE      |L1.1078|
;;;1891     {
;;;1892       tmpreg &= ~RST_CLK_TIM_CLOCK_TIM2_BRG_Msk;
000428  f422407f          BIC      r0,r2,#0xff00
;;;1893       tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM2_BRG_Pos;
00042c  ea402001          ORR      r0,r0,r1,LSL #8
;;;1894       tmpreg |= RST_CLK_TIM_CLOCK_TIM2_CLK_EN;
000430  f0407200          ORR      r2,r0,#0x2000000
000434  e008              B        |L1.1096|
                  |L1.1078|
;;;1895     }
;;;1896     else if (TIMERx == MDR_TIMER3)
000436  4c08              LDR      r4,|L1.1112|
000438  42a0              CMP      r0,r4
00043a  d105              BNE      |L1.1096|
;;;1897     {
;;;1898       tmpreg &= ~RST_CLK_TIM_CLOCK_TIM3_BRG_Msk;
00043c  f422007f          BIC      r0,r2,#0xff0000
;;;1899       tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM3_BRG_Pos;
000440  ea404001          ORR      r0,r0,r1,LSL #16
;;;1900       tmpreg |= RST_CLK_TIM_CLOCK_TIM3_CLK_EN;
000444  f0406280          ORR      r2,r0,#0x4000000
                  |L1.1096|
;;;1901     }
;;;1902   
;;;1903     MDR_RST_CLK->TIM_CLOCK = tmpreg;
000448  625a              STR      r2,[r3,#0x24]
;;;1904   }
00044a  bd10              POP      {r4,pc}
;;;1905   
                          ENDP

                  |L1.1100|
                          DCD      0x40020000
                  |L1.1104|
                          DCD      0x40070000
                  |L1.1108|
                          DCD      0x40078000
                  |L1.1112|
                          DCD      0x40080000

;*** Start embedded assembler ***

#line 1 "..\\Library\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_timer.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_MDR32F9Qx_timer_c_566b03da____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____REVSH|
#line 130
|__asm___17_MDR32F9Qx_timer_c_566b03da____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
