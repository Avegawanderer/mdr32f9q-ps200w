; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\mdr32f9qx_timer.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\mdr32f9qx_timer.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\mdr32f9qx_timer.crf ..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_timer.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIMER_DeInit PROC
;;;45       */
;;;46     void TIMER_DeInit(MDR_TIMER_TypeDef* TIMERx)
000000  2100              MOVS     r1,#0
;;;47     {
;;;48       /* Check the parameters */
;;;49       assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;50     
;;;51       TIMERx->CNTRL = 0;
000002  60c1              STR      r1,[r0,#0xc]
;;;52       TIMERx->CNT = 0;
000004  6001              STR      r1,[r0,#0]
;;;53       TIMERx->PSG = 0;
000006  6041              STR      r1,[r0,#4]
;;;54       TIMERx->ARR = 0;
000008  6081              STR      r1,[r0,#8]
;;;55     
;;;56       TIMERx->CH1_CNTRL = 0;
00000a  6201              STR      r1,[r0,#0x20]
;;;57       TIMERx->CH2_CNTRL = 0;
00000c  6241              STR      r1,[r0,#0x24]
;;;58       TIMERx->CH3_CNTRL = 0;
00000e  6281              STR      r1,[r0,#0x28]
;;;59       TIMERx->CH4_CNTRL = 0;
000010  62c1              STR      r1,[r0,#0x2c]
;;;60       TIMERx->CH1_CNTRL1 = 0;
000012  6301              STR      r1,[r0,#0x30]
;;;61       TIMERx->CH2_CNTRL1 = 0;
000014  6341              STR      r1,[r0,#0x34]
;;;62       TIMERx->CH3_CNTRL1 = 0;
000016  6381              STR      r1,[r0,#0x38]
;;;63       TIMERx->CH4_CNTRL1 = 0;
000018  63c1              STR      r1,[r0,#0x3c]
;;;64       TIMERx->CH1_CNTRL2 = 0;
00001a  6601              STR      r1,[r0,#0x60]
;;;65       TIMERx->CH2_CNTRL2 = 0;
00001c  6641              STR      r1,[r0,#0x64]
;;;66       TIMERx->CH3_CNTRL2 = 0;
00001e  6681              STR      r1,[r0,#0x68]
;;;67       TIMERx->CH4_CNTRL2 = 0;
000020  66c1              STR      r1,[r0,#0x6c]
;;;68     
;;;69       TIMERx->CCR1 = 0;
000022  6101              STR      r1,[r0,#0x10]
;;;70       TIMERx->CCR2 = 0;
000024  6141              STR      r1,[r0,#0x14]
;;;71       TIMERx->CCR3 = 0;
000026  6181              STR      r1,[r0,#0x18]
;;;72       TIMERx->CCR4 = 0;
000028  61c1              STR      r1,[r0,#0x1c]
;;;73       TIMERx->CCR11 = 0;
00002a  6701              STR      r1,[r0,#0x70]
;;;74       TIMERx->CCR21 = 0;
00002c  6741              STR      r1,[r0,#0x74]
;;;75       TIMERx->CCR31 = 0;
00002e  6781              STR      r1,[r0,#0x78]
;;;76       TIMERx->CCR41 = 0;
000030  67c1              STR      r1,[r0,#0x7c]
;;;77       TIMERx->CH1_DTG = 0;
000032  6401              STR      r1,[r0,#0x40]
;;;78       TIMERx->CH2_DTG = 0;
000034  6441              STR      r1,[r0,#0x44]
;;;79       TIMERx->CH3_DTG = 0;
000036  6481              STR      r1,[r0,#0x48]
;;;80       TIMERx->CH4_DTG = 0;
000038  64c1              STR      r1,[r0,#0x4c]
;;;81       TIMERx->BRKETR_CNTRL = 0;
00003a  6501              STR      r1,[r0,#0x50]
;;;82       TIMERx->STATUS = 0;
00003c  6541              STR      r1,[r0,#0x54]
;;;83       TIMERx->IE = 0;
00003e  6581              STR      r1,[r0,#0x58]
;;;84       TIMERx->DMA_RE = 0;
000040  65c1              STR      r1,[r0,#0x5c]
;;;85     }
000042  4770              BX       lr
;;;86     
                          ENDP

                  TIMER_CntInit PROC
;;;95       */
;;;96     void TIMER_CntInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_CntInitTypeDef* TIMER_CntInitStruct)
000044  b530              PUSH     {r4,r5,lr}
;;;97     {
;;;98       uint32_t tmpreg_CNTRL;
;;;99       uint32_t tmpreg_BRKETR_CNTRL;
;;;100    
;;;101      /* Check the parameters */
;;;102      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;103      assert_param(IS_TIMER_COUNTER_MODE(TIMER_CntInitStruct->TIMER_CounterMode));
;;;104      assert_param(IS_TIMER_COUNTER_DIR(TIMER_CntInitStruct->TIMER_CounterDirection));
;;;105      assert_param(IS_TIMER_EVENT_SOURCE(TIMER_CntInitStruct->TIMER_EventSource));
;;;106      assert_param(IS_TIMER_FILTER_SAMPLING(TIMER_CntInitStruct->TIMER_FilterSampling));
;;;107      assert_param(IS_TIMER_ARR_UPDATE_MODE(TIMER_CntInitStruct->TIMER_ARR_UpdateMode));
;;;108      assert_param(IS_TIMER_FILTER_CONF(TIMER_CntInitStruct->TIMER_ETR_FilterConf));
;;;109      assert_param(IS_TIMER_ETR_PRESCALER(TIMER_CntInitStruct->TIMER_ETR_Prescaler));
;;;110      assert_param(IS_TIMER_ETR_POLARITY(TIMER_CntInitStruct->TIMER_ETR_Polarity));
;;;111      assert_param(IS_TIMER_BRK_POLARITY(TIMER_CntInitStruct->TIMER_BRK_Polarity));
;;;112    
;;;113      TIMERx->CNT = TIMER_CntInitStruct->TIMER_IniCounter;
000046  880c              LDRH     r4,[r1,#0]
000048  6004              STR      r4,[r0,#0]
;;;114      TIMERx->PSG = TIMER_CntInitStruct->TIMER_Prescaler;
00004a  884c              LDRH     r4,[r1,#2]
00004c  6044              STR      r4,[r0,#4]
;;;115      TIMERx->ARR = TIMER_CntInitStruct->TIMER_Period;
00004e  888c              LDRH     r4,[r1,#4]
000050  6084              STR      r4,[r0,#8]
;;;116    
;;;117      /* Form new value for the TIMERx_CNTRL register */
;;;118      tmpreg_CNTRL = TIMER_CntInitStruct->TIMER_CounterMode
000052  88cc              LDRH     r4,[r1,#6]
000054  890d              LDRH     r5,[r1,#8]
000056  442c              ADD      r4,r4,r5
000058  894d              LDRH     r5,[r1,#0xa]
00005a  442c              ADD      r4,r4,r5
00005c  898d              LDRH     r5,[r1,#0xc]
00005e  442c              ADD      r4,r4,r5
000060  89cd              LDRH     r5,[r1,#0xe]
000062  1963              ADDS     r3,r4,r5
;;;119                   + TIMER_CntInitStruct->TIMER_CounterDirection
;;;120                   + TIMER_CntInitStruct->TIMER_EventSource
;;;121                   + TIMER_CntInitStruct->TIMER_FilterSampling
;;;122                   + TIMER_CntInitStruct->TIMER_ARR_UpdateMode;
;;;123    
;;;124      /* Configure TIMERx_CNTRL register with new value */
;;;125      TIMERx->CNTRL = tmpreg_CNTRL;
000064  60c3              STR      r3,[r0,#0xc]
;;;126    
;;;127      /* Form new value for the TIMERx_BRKETR_CNTRL register */
;;;128      tmpreg_BRKETR_CNTRL = (TIMER_CntInitStruct->TIMER_ETR_FilterConf << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos)
000066  8a4c              LDRH     r4,[r1,#0x12]
000068  8a0d              LDRH     r5,[r1,#0x10]
00006a  eb041405          ADD      r4,r4,r5,LSL #4
00006e  8a8d              LDRH     r5,[r1,#0x14]
000070  442c              ADD      r4,r4,r5
000072  8acd              LDRH     r5,[r1,#0x16]
000074  1962              ADDS     r2,r4,r5
;;;129                          + TIMER_CntInitStruct->TIMER_ETR_Prescaler
;;;130                          + TIMER_CntInitStruct->TIMER_ETR_Polarity
;;;131                          + TIMER_CntInitStruct->TIMER_BRK_Polarity;
;;;132    
;;;133      /* Configure TIMERx_BRKETR_CNTRL register with new value */
;;;134      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000076  6502              STR      r2,[r0,#0x50]
;;;135    }
000078  bd30              POP      {r4,r5,pc}
;;;136    
                          ENDP

                  TIMER_CntStructInit PROC
;;;142      */
;;;143    void TIMER_CntStructInit(TIMER_CntInitTypeDef* TIMER_CntInitStruct)
00007a  2100              MOVS     r1,#0
;;;144    {
;;;145      TIMER_CntInitStruct->TIMER_IniCounter = 0;
00007c  8001              STRH     r1,[r0,#0]
;;;146      TIMER_CntInitStruct->TIMER_Prescaler  = 0;
00007e  8041              STRH     r1,[r0,#2]
;;;147      TIMER_CntInitStruct->TIMER_Period     = 0;
000080  8081              STRH     r1,[r0,#4]
;;;148      TIMER_CntInitStruct->TIMER_CounterMode      = TIMER_CntMode_ClkFixedDir;
000082  80c1              STRH     r1,[r0,#6]
;;;149      TIMER_CntInitStruct->TIMER_CounterDirection = TIMER_CntDir_Up;
000084  8101              STRH     r1,[r0,#8]
;;;150      TIMER_CntInitStruct->TIMER_EventSource      = TIMER_EvSrc_None;
000086  8141              STRH     r1,[r0,#0xa]
;;;151      TIMER_CntInitStruct->TIMER_FilterSampling   = TIMER_FDTS_TIMER_CLK_div_1;
000088  8181              STRH     r1,[r0,#0xc]
;;;152      TIMER_CntInitStruct->TIMER_ARR_UpdateMode   = TIMER_ARR_Update_Immediately;
00008a  81c1              STRH     r1,[r0,#0xe]
;;;153      TIMER_CntInitStruct->TIMER_ETR_FilterConf   = TIMER_Filter_1FF_at_TIMER_CLK;
00008c  8201              STRH     r1,[r0,#0x10]
;;;154      TIMER_CntInitStruct->TIMER_ETR_Prescaler    = TIMER_ETR_Prescaler_None;
00008e  8241              STRH     r1,[r0,#0x12]
;;;155      TIMER_CntInitStruct->TIMER_ETR_Polarity     = TIMER_ETRPolarity_NonInverted;
000090  8281              STRH     r1,[r0,#0x14]
;;;156      TIMER_CntInitStruct->TIMER_BRK_Polarity     = TIMER_BRKPolarity_NonInverted;
000092  82c1              STRH     r1,[r0,#0x16]
;;;157    }
000094  4770              BX       lr
;;;158    
                          ENDP

                  TIMER_Cmd PROC
;;;165      */
;;;166    void TIMER_Cmd(MDR_TIMER_TypeDef* TIMERx, FunctionalState NewState)
000096  460a              MOV      r2,r1
;;;167    {
;;;168      uint32_t tmpreg_CNTRL;
;;;169    
;;;170      /* Check the parameters */
;;;171      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;172      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;173    
;;;174      tmpreg_CNTRL = TIMERx->CNTRL;
000098  68c1              LDR      r1,[r0,#0xc]
;;;175    
;;;176      /* Form new value */
;;;177      if (NewState != DISABLE)
00009a  b112              CBZ      r2,|L1.162|
;;;178      {
;;;179        /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
;;;180        tmpreg_CNTRL |= TIMER_CNTRL_CNT_EN;
00009c  f0410101          ORR      r1,r1,#1
0000a0  e001              B        |L1.166|
                  |L1.162|
;;;181      }
;;;182      else
;;;183      {
;;;184        /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
;;;185        tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_EN;
0000a2  f0210101          BIC      r1,r1,#1
                  |L1.166|
;;;186      }
;;;187    
;;;188      /* Configure CNTRL register with new value */
;;;189      TIMERx->CNTRL = tmpreg_CNTRL;
0000a6  60c1              STR      r1,[r0,#0xc]
;;;190    }
0000a8  4770              BX       lr
;;;191    
                          ENDP

                  TIMER_SetCounter PROC
;;;197      */
;;;198    void TIMER_SetCounter(MDR_TIMER_TypeDef* TIMERx, uint16_t Counter)
0000aa  6001              STR      r1,[r0,#0]
;;;199    {
;;;200      /* Check the parameters */
;;;201      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;202    
;;;203      TIMERx->CNT = Counter;
;;;204    }
0000ac  4770              BX       lr
;;;205    
                          ENDP

                  TIMER_SetCntPrescaler PROC
;;;211      */
;;;212    void TIMER_SetCntPrescaler(MDR_TIMER_TypeDef* TIMERx, uint16_t Prescaler)
0000ae  6041              STR      r1,[r0,#4]
;;;213    {
;;;214      /* Check the parameters */
;;;215      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;216    
;;;217      TIMERx->PSG = Prescaler;
;;;218    }
0000b0  4770              BX       lr
;;;219    
                          ENDP

                  TIMER_SetCntAutoreload PROC
;;;225      */
;;;226    void TIMER_SetCntAutoreload(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload)
0000b2  6081              STR      r1,[r0,#8]
;;;227    {
;;;228      /* Check the parameters */
;;;229      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;230    
;;;231      TIMERx->ARR = Autoreload;
;;;232    }
0000b4  4770              BX       lr
;;;233    
                          ENDP

                  TIMER_CntAutoreloadConfig PROC
;;;243      */
;;;244    void TIMER_CntAutoreloadConfig(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload, uint32_t UpdateMode)
0000b6  b510              PUSH     {r4,lr}
;;;245    {
0000b8  460b              MOV      r3,r1
;;;246      uint32_t tmpreg_CNTRL;
;;;247    
;;;248      /* Check the parameters */
;;;249      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;250      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;251    
;;;252      tmpreg_CNTRL = TIMERx->CNTRL;
0000ba  68c1              LDR      r1,[r0,#0xc]
;;;253      tmpreg_CNTRL &= ~TIMER_CNTRL_ARRB_EN;
0000bc  f0210102          BIC      r1,r1,#2
;;;254      tmpreg_CNTRL += UpdateMode;
0000c0  4411              ADD      r1,r1,r2
;;;255      TIMERx->CNTRL = tmpreg_CNTRL;
0000c2  60c1              STR      r1,[r0,#0xc]
;;;256    
;;;257      TIMERx->ARR = Autoreload;
0000c4  6083              STR      r3,[r0,#8]
;;;258    }
0000c6  bd10              POP      {r4,pc}
;;;259    
                          ENDP

                  TIMER_GetCounter PROC
;;;264      */
;;;265    uint16_t TIMER_GetCounter(MDR_TIMER_TypeDef* TIMERx)
0000c8  4601              MOV      r1,r0
;;;266    {
;;;267      /* Check the parameters */
;;;268      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;269    
;;;270      return TIMERx->CNT;
0000ca  6808              LDR      r0,[r1,#0]
0000cc  b280              UXTH     r0,r0
;;;271    }
0000ce  4770              BX       lr
;;;272    
                          ENDP

                  TIMER_CntEventSourceConfig PROC
;;;288      */
;;;289    void TIMER_CntEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t EventSource)
0000d0  460a              MOV      r2,r1
;;;290    {
;;;291      uint32_t tmpreg_CNTRL;
;;;292    
;;;293      /* Check the parameters */
;;;294      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;295      assert_param(IS_TIMER_EVENT_SOURCE(EventSource));
;;;296    
;;;297      tmpreg_CNTRL = TIMERx->CNTRL;
0000d2  68c1              LDR      r1,[r0,#0xc]
;;;298      tmpreg_CNTRL &= ~TIMER_CNTRL_EVENT_SEL_Msk;
0000d4  f4216170          BIC      r1,r1,#0xf00
;;;299      tmpreg_CNTRL += EventSource;
0000d8  4411              ADD      r1,r1,r2
;;;300      TIMERx->CNTRL = tmpreg_CNTRL;
0000da  60c1              STR      r1,[r0,#0xc]
;;;301    }
0000dc  4770              BX       lr
;;;302    
                          ENDP

                  TIMER_FilterSamplingConfig PROC
;;;313      */
;;;314    void TIMER_FilterSamplingConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
0000de  460a              MOV      r2,r1
;;;315    {
;;;316      uint32_t tmpreg_CNTRL;
;;;317    
;;;318      /* Check the parameters */
;;;319      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;320      assert_param(IS_TIMER_FILTER_SAMPLING(Prescaler));
;;;321    
;;;322      tmpreg_CNTRL = TIMERx->CNTRL;
0000e0  68c1              LDR      r1,[r0,#0xc]
;;;323      tmpreg_CNTRL &= ~TIMER_CNTRL_FDTS_Msk;
0000e2  f0210130          BIC      r1,r1,#0x30
;;;324      tmpreg_CNTRL += Prescaler;
0000e6  4411              ADD      r1,r1,r2
;;;325      TIMERx->CNTRL = tmpreg_CNTRL;
0000e8  60c1              STR      r1,[r0,#0xc]
;;;326    }
0000ea  4770              BX       lr
;;;327    
                          ENDP

                  TIMER_CounterModeConfig PROC
;;;338      */
;;;339    void TIMER_CounterModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Mode)
0000ec  460a              MOV      r2,r1
;;;340    {
;;;341      uint32_t tmpreg_CNTRL;
;;;342    
;;;343      /* Check the parameters */
;;;344      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;345      assert_param(IS_TIMER_COUNTER_MODE(Mode));
;;;346    
;;;347      tmpreg_CNTRL = TIMERx->CNTRL;
0000ee  68c1              LDR      r1,[r0,#0xc]
;;;348      tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_MODE_Msk;
0000f0  f02101c0          BIC      r1,r1,#0xc0
;;;349      tmpreg_CNTRL += Mode;
0000f4  4411              ADD      r1,r1,r2
;;;350      TIMERx->CNTRL = tmpreg_CNTRL;
0000f6  60c1              STR      r1,[r0,#0xc]
;;;351    }
0000f8  4770              BX       lr
;;;352    
                          ENDP

                  TIMER_SetCounterDirection PROC
;;;361      */
;;;362    void TIMER_SetCounterDirection(MDR_TIMER_TypeDef* TIMERx, uint32_t Direction)
0000fa  460a              MOV      r2,r1
;;;363    {
;;;364      uint32_t tmpreg_CNTRL;
;;;365    
;;;366      /* Check the parameters */
;;;367      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;368      assert_param(IS_TIMER_COUNTER_DIR(Direction));
;;;369    
;;;370      tmpreg_CNTRL = TIMERx->CNTRL;
0000fc  68c1              LDR      r1,[r0,#0xc]
;;;371      tmpreg_CNTRL &= ~TIMER_CNTRL_DIR;
0000fe  f0210108          BIC      r1,r1,#8
;;;372      tmpreg_CNTRL += Direction;
000102  4411              ADD      r1,r1,r2
;;;373      TIMERx->CNTRL = tmpreg_CNTRL;
000104  60c1              STR      r1,[r0,#0xc]
;;;374    }
000106  4770              BX       lr
;;;375    
                          ENDP

                  TIMER_ETRInputConfig PROC
;;;408      */
;;;409    void TIMER_ETRInputConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler, uint32_t Polarity, uint32_t Filter)
000108  b530              PUSH     {r4,r5,lr}
;;;410    {
00010a  460c              MOV      r4,r1
;;;411      uint32_t tmpreg_BRKETR_CNTRL;
;;;412    
;;;413      /* Check the parameters */
;;;414      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;415      assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
;;;416      assert_param(IS_TIMER_ETR_POLARITY(Polarity));
;;;417      assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;418    
;;;419      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
00010c  6d01              LDR      r1,[r0,#0x50]
;;;420      tmpreg_BRKETR_CNTRL &= ~(TIMER_BRKETR_CNTRL_ETR_PSC_Msk + TIMER_BRKETR_CNTRL_ETR_INV + TIMER_BRKETR_CNTRL_ETR_FILTER_Msk);
00010e  f02101fe          BIC      r1,r1,#0xfe
;;;421      tmpreg_BRKETR_CNTRL += Prescaler + Polarity + (Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos);
000112  18a5              ADDS     r5,r4,r2
000114  eb051503          ADD      r5,r5,r3,LSL #4
000118  4429              ADD      r1,r1,r5
;;;422      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00011a  6501              STR      r1,[r0,#0x50]
;;;423    }
00011c  bd30              POP      {r4,r5,pc}
;;;424    
                          ENDP

                  TIMER_ETRFilterConfig PROC
;;;447      */
;;;448    void TIMER_ETRFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Filter)
00011e  460a              MOV      r2,r1
;;;449    {
;;;450      uint32_t tmpreg_BRKETR_CNTRL;
;;;451    
;;;452      /* Check the parameters */
;;;453      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;454      assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;455    
;;;456      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000120  6d01              LDR      r1,[r0,#0x50]
;;;457      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_FILTER_Msk;
000122  f02101f0          BIC      r1,r1,#0xf0
;;;458      tmpreg_BRKETR_CNTRL += Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos;
000126  eb011102          ADD      r1,r1,r2,LSL #4
;;;459      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00012a  6501              STR      r1,[r0,#0x50]
;;;460    }
00012c  4770              BX       lr
;;;461    
                          ENDP

                  TIMER_ETRPrescalerConfig PROC
;;;472      */
;;;473    void TIMER_ETRPrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
00012e  460a              MOV      r2,r1
;;;474    {
;;;475      uint32_t tmpreg_BRKETR_CNTRL;
;;;476    
;;;477      /* Check the parameters */
;;;478      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;479      assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
;;;480    
;;;481      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000130  6d01              LDR      r1,[r0,#0x50]
;;;482      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_PSC_Msk;
000132  f021010c          BIC      r1,r1,#0xc
;;;483      tmpreg_BRKETR_CNTRL += Prescaler;
000136  4411              ADD      r1,r1,r2
;;;484      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000138  6501              STR      r1,[r0,#0x50]
;;;485    }
00013a  4770              BX       lr
;;;486    
                          ENDP

                  TIMER_ETRPolarityConfig PROC
;;;495      */
;;;496    void TIMER_ETRPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
00013c  460a              MOV      r2,r1
;;;497    {
;;;498      uint32_t tmpreg_BRKETR_CNTRL;
;;;499    
;;;500      /* Check the parameters */
;;;501      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;502      assert_param(IS_TIMER_ETR_POLARITY(Polarity));
;;;503    
;;;504      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
00013e  6d01              LDR      r1,[r0,#0x50]
;;;505      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_INV;
000140  f0210102          BIC      r1,r1,#2
;;;506      tmpreg_BRKETR_CNTRL += Polarity;
000144  4411              ADD      r1,r1,r2
;;;507      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000146  6501              STR      r1,[r0,#0x50]
;;;508    }
000148  4770              BX       lr
;;;509    
                          ENDP

                  TIMER_BRKPolarityConfig PROC
;;;518      */
;;;519    void TIMER_BRKPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
00014a  460a              MOV      r2,r1
;;;520    {
;;;521      uint32_t tmpreg_BRKETR_CNTRL;
;;;522    
;;;523      /* Check the parameters */
;;;524      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;525      assert_param(IS_TIMER_BRK_POLARITY(Polarity));
;;;526    
;;;527      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
00014c  6d01              LDR      r1,[r0,#0x50]
;;;528      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_BRK_INV;
00014e  f0210101          BIC      r1,r1,#1
;;;529      tmpreg_BRKETR_CNTRL += Polarity;
000152  4411              ADD      r1,r1,r2
;;;530      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000154  6501              STR      r1,[r0,#0x50]
;;;531    }
000156  4770              BX       lr
;;;532    
                          ENDP

                  TIMER_GetCounterDirection PROC
;;;537      */
;;;538    uint32_t TIMER_GetCounterDirection(MDR_TIMER_TypeDef* TIMERx)
000158  4601              MOV      r1,r0
;;;539    {
;;;540      uint32_t bitstatus;
;;;541    
;;;542      /* Check the parameters */
;;;543      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;544    
;;;545      if ((TIMERx->CNTRL & TIMER_CNTRL_DIR) == 0)
00015a  68ca              LDR      r2,[r1,#0xc]
00015c  f0120f08          TST      r2,#8
000160  d101              BNE      |L1.358|
;;;546      {
;;;547        bitstatus = TIMER_CntDir_Up;
000162  2000              MOVS     r0,#0
000164  e000              B        |L1.360|
                  |L1.358|
;;;548      }
;;;549      else
;;;550      {
;;;551        bitstatus = TIMER_CntDir_Dn;
000166  2008              MOVS     r0,#8
                  |L1.360|
;;;552      }
;;;553    
;;;554      return bitstatus;
;;;555    }
000168  4770              BX       lr
;;;556    
                          ENDP

                  TIMER_GetCntWriteComplete PROC
;;;561      */
;;;562    FlagStatus TIMER_GetCntWriteComplete(MDR_TIMER_TypeDef* TIMERx)
00016a  4601              MOV      r1,r0
;;;563    {
;;;564      FlagStatus bitstatus;
;;;565    
;;;566      /* Check the parameters */
;;;567      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;568    
;;;569      if ((TIMERx->CNTRL & TIMER_CNTRL_WR_CMPL) == 0)
00016c  68ca              LDR      r2,[r1,#0xc]
00016e  f0120f04          TST      r2,#4
000172  d101              BNE      |L1.376|
;;;570      {
;;;571        bitstatus = RESET;
000174  2000              MOVS     r0,#0
000176  e000              B        |L1.378|
                  |L1.376|
;;;572      }
;;;573      else
;;;574      {
;;;575        bitstatus = SET;
000178  2001              MOVS     r0,#1
                  |L1.378|
;;;576      }
;;;577    
;;;578      return bitstatus;
;;;579    }
00017a  4770              BX       lr
;;;580    
                          ENDP

                  TIMER_ChnInit PROC
;;;589      */
;;;590    void TIMER_ChnInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
00017c  b570              PUSH     {r4-r6,lr}
;;;591    {
;;;592      uint32_t tmpreg_CH_Number;
;;;593      uint32_t tmpreg_CH_CNTRL;
;;;594      uint32_t tmpreg_CH_CNTRL2;
;;;595    
;;;596      /* Check the parameters */
;;;597      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;598      assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnInitStruct->TIMER_CH_Number));
;;;599      assert_param(IS_TIMER_CHANNEL_MODE(TIMER_ChnInitStruct->TIMER_CH_Mode));
;;;600      assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_ETR_Ena));
;;;601      assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_ETR_Reset));
;;;602      assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_BRK_Reset));
;;;603      assert_param(IS_TIMER_CHANNEL_REF_FORMAT(TIMER_ChnInitStruct->TIMER_CH_REF_Format));
;;;604      assert_param(IS_TIMER_CHANNEL_PRESCALER(TIMER_ChnInitStruct->TIMER_CH_Prescaler));
;;;605      assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_EventSource));
;;;606      assert_param(IS_TIMER_FILTER_CONF(TIMER_ChnInitStruct->TIMER_CH_FilterConf));
;;;607      assert_param(IS_TIMER_CHANNEL_CCR_UPDATE_MODE(TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode));
;;;608      assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena));
;;;609      assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource));
;;;610    
;;;611      tmpreg_CH_CNTRL = TIMER_ChnInitStruct->TIMER_CH_Mode
00017e  884d              LDRH     r5,[r1,#2]
000180  88ce              LDRH     r6,[r1,#6]
000182  4435              ADD      r5,r5,r6
000184  890e              LDRH     r6,[r1,#8]
000186  4435              ADD      r5,r5,r6
000188  894e              LDRH     r6,[r1,#0xa]
00018a  4435              ADD      r5,r5,r6
00018c  898e              LDRH     r6,[r1,#0xc]
00018e  eb051586          ADD      r5,r5,r6,LSL #6
000192  89ce              LDRH     r6,[r1,#0xe]
000194  4435              ADD      r5,r5,r6
000196  8a0e              LDRH     r6,[r1,#0x10]
000198  19ac              ADDS     r4,r5,r6
;;;612                      + TIMER_ChnInitStruct->TIMER_CH_ETR_Reset
;;;613                      + TIMER_ChnInitStruct->TIMER_CH_BRK_Reset
;;;614                      + TIMER_ChnInitStruct->TIMER_CH_REF_Format
;;;615                      + (TIMER_ChnInitStruct->TIMER_CH_Prescaler << TIMER_CH_CNTRL_CHPSC_Pos)
;;;616                      + TIMER_ChnInitStruct->TIMER_CH_EventSource
;;;617                      + (TIMER_ChnInitStruct->TIMER_CH_FilterConf << TIMER_CH_CNTRL_CHFLTR_Pos);
;;;618    
;;;619      if (TIMER_ChnInitStruct->TIMER_CH_ETR_Ena != DISABLE)
00019a  888d              LDRH     r5,[r1,#4]
00019c  b10d              CBZ      r5,|L1.418|
;;;620      {
;;;621        tmpreg_CH_CNTRL += TIMER_CH_CNTRL_ETREN;
00019e  f5045400          ADD      r4,r4,#0x2000
                  |L1.418|
;;;622      }
;;;623    
;;;624      tmpreg_CH_Number = TIMER_ChnInitStruct->TIMER_CH_Number;
0001a2  880a              LDRH     r2,[r1,#0]
;;;625    
;;;626      *(&TIMERx->CH1_CNTRL + tmpreg_CH_Number) = tmpreg_CH_CNTRL;
0001a4  f1000520          ADD      r5,r0,#0x20
0001a8  f8454022          STR      r4,[r5,r2,LSL #2]
;;;627    
;;;628      tmpreg_CH_CNTRL2 = TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode
0001ac  8a4d              LDRH     r5,[r1,#0x12]
0001ae  8ace              LDRH     r6,[r1,#0x16]
0001b0  19ab              ADDS     r3,r5,r6
;;;629                       + TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource;
;;;630    
;;;631      if (TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena != DISABLE)
0001b2  8a8d              LDRH     r5,[r1,#0x14]
0001b4  b105              CBZ      r5,|L1.440|
;;;632      {
;;;633        tmpreg_CH_CNTRL2 += TIMER_CH_CNTRL2_CCR1_EN;
0001b6  1d1b              ADDS     r3,r3,#4
                  |L1.440|
;;;634      }
;;;635    
;;;636      *(&TIMERx->CH1_CNTRL2 + tmpreg_CH_Number) = tmpreg_CH_CNTRL2;
0001b8  f1000560          ADD      r5,r0,#0x60
0001bc  f8453022          STR      r3,[r5,r2,LSL #2]
;;;637    }
0001c0  bd70              POP      {r4-r6,pc}
;;;638    
                          ENDP

                  TIMER_ChnStructInit PROC
;;;644      */
;;;645    void TIMER_ChnStructInit(TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
0001c2  2100              MOVS     r1,#0
;;;646    {
;;;647      TIMER_ChnInitStruct->TIMER_CH_Number           = TIMER_CHANNEL1;
0001c4  8001              STRH     r1,[r0,#0]
;;;648      TIMER_ChnInitStruct->TIMER_CH_Mode             = TIMER_CH_MODE_PWM;
0001c6  8041              STRH     r1,[r0,#2]
;;;649      TIMER_ChnInitStruct->TIMER_CH_ETR_Ena          = DISABLE;
0001c8  8081              STRH     r1,[r0,#4]
;;;650      TIMER_ChnInitStruct->TIMER_CH_ETR_Reset        = TIMER_CH_ETR_RESET_Disable;
0001ca  80c1              STRH     r1,[r0,#6]
;;;651      TIMER_ChnInitStruct->TIMER_CH_BRK_Reset        = TIMER_CH_BRK_RESET_Disable;
0001cc  8101              STRH     r1,[r0,#8]
;;;652      TIMER_ChnInitStruct->TIMER_CH_REF_Format       = TIMER_CH_REF_Format0;
0001ce  8141              STRH     r1,[r0,#0xa]
;;;653      TIMER_ChnInitStruct->TIMER_CH_Prescaler        = TIMER_CH_Prescaler_None;
0001d0  8181              STRH     r1,[r0,#0xc]
;;;654      TIMER_ChnInitStruct->TIMER_CH_EventSource      = TIMER_CH_EvSrc_PE;
0001d2  81c1              STRH     r1,[r0,#0xe]
;;;655      TIMER_ChnInitStruct->TIMER_CH_FilterConf       = TIMER_Filter_1FF_at_TIMER_CLK;
0001d4  8201              STRH     r1,[r0,#0x10]
;;;656      TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode   = TIMER_CH_CCR_Update_Immediately;
0001d6  8241              STRH     r1,[r0,#0x12]
;;;657      TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena         = DISABLE;
0001d8  8281              STRH     r1,[r0,#0x14]
;;;658      TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource = TIMER_CH_CCR1EvSrc_PE;
0001da  82c1              STRH     r1,[r0,#0x16]
;;;659    }
0001dc  4770              BX       lr
;;;660    
                          ENDP

                  TIMER_SetChnCompare PROC
;;;672      */
;;;673    void TIMER_SetChnCompare(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
0001de  b510              PUSH     {r4,lr}
;;;674    {
;;;675      __IO uint32_t *tmpreg_CCRx;
;;;676    
;;;677      /* Check the parameters */
;;;678      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;679      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;680    
;;;681      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
0001e0  f1000410          ADD      r4,r0,#0x10
0001e4  eb040381          ADD      r3,r4,r1,LSL #2
;;;682      *tmpreg_CCRx = Compare;
0001e8  601a              STR      r2,[r3,#0]
;;;683    }
0001ea  bd10              POP      {r4,pc}
;;;684    
                          ENDP

                  TIMER_SetChnCompare1 PROC
;;;696      */
;;;697    void TIMER_SetChnCompare1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
0001ec  b510              PUSH     {r4,lr}
;;;698    {
;;;699      __IO uint32_t *tmpreg_CCR1x;
;;;700    
;;;701      /* Check the parameters */
;;;702      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;703      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;704    
;;;705      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
0001ee  f1000470          ADD      r4,r0,#0x70
0001f2  eb040381          ADD      r3,r4,r1,LSL #2
;;;706      *tmpreg_CCR1x = Compare;
0001f6  601a              STR      r2,[r3,#0]
;;;707    }
0001f8  bd10              POP      {r4,pc}
;;;708    
                          ENDP

                  TIMER_ChnCompareConfig PROC
;;;724      */
;;;725    void TIMER_ChnCompareConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
0001fa  b5f0              PUSH     {r4-r7,lr}
;;;726    {
0001fc  4614              MOV      r4,r2
;;;727      __IO uint32_t *tmpreg_CNTRL2x;
;;;728      __IO uint32_t *tmpreg_CCRx;
;;;729      uint32_t tmpreg_CNTRL2;
;;;730    
;;;731      /* Check the parameters */
;;;732      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;733      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;734      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;735    
;;;736      tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
0001fe  f1000760          ADD      r7,r0,#0x60
000202  eb070581          ADD      r5,r7,r1,LSL #2
;;;737    
;;;738      tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
000206  682a              LDR      r2,[r5,#0]
;;;739      tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
000208  f0220208          BIC      r2,r2,#8
;;;740      tmpreg_CNTRL2 += UpdateMode;
00020c  441a              ADD      r2,r2,r3
;;;741      *tmpreg_CNTRL2x = tmpreg_CNTRL2;
00020e  602a              STR      r2,[r5,#0]
;;;742    
;;;743      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
000210  3f50              SUBS     r7,r7,#0x50
000212  eb070681          ADD      r6,r7,r1,LSL #2
;;;744    
;;;745      *tmpreg_CCRx = Compare;
000216  6034              STR      r4,[r6,#0]
;;;746    }
000218  bdf0              POP      {r4-r7,pc}
;;;747    
                          ENDP

                  TIMER_ChnCompare1Config PROC
;;;763      */
;;;764    void TIMER_ChnCompare1Config(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
00021a  b5f0              PUSH     {r4-r7,lr}
;;;765    {
00021c  4614              MOV      r4,r2
;;;766      __IO uint32_t *tmpreg_CNTRL2x;
;;;767      __IO uint32_t *tmpreg_CCR1x;
;;;768      uint32_t tmpreg_CNTRL2;
;;;769    
;;;770      /* Check the parameters */
;;;771      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;772      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;773      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;774    
;;;775      tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
00021e  f1000760          ADD      r7,r0,#0x60
000222  eb070581          ADD      r5,r7,r1,LSL #2
;;;776    
;;;777      tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
000226  682a              LDR      r2,[r5,#0]
;;;778      tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
000228  f0220208          BIC      r2,r2,#8
;;;779      tmpreg_CNTRL2 += UpdateMode;
00022c  441a              ADD      r2,r2,r3
;;;780      *tmpreg_CNTRL2x = tmpreg_CNTRL2;
00022e  602a              STR      r2,[r5,#0]
;;;781    
;;;782      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
000230  3710              ADDS     r7,r7,#0x10
000232  eb070681          ADD      r6,r7,r1,LSL #2
;;;783    
;;;784      *tmpreg_CCR1x = Compare;
000236  6034              STR      r4,[r6,#0]
;;;785    }
000238  bdf0              POP      {r4-r7,pc}
;;;786    
                          ENDP

                  TIMER_GetChnCapture PROC
;;;797      */
;;;798    uint16_t TIMER_GetChnCapture(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
00023a  b510              PUSH     {r4,lr}
;;;799    {
00023c  4602              MOV      r2,r0
;;;800      __IO uint32_t *tmpreg_CCRx;
;;;801      uint32_t tmpreg;
;;;802    
;;;803      /* Check the parameters */
;;;804      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;805      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;806    
;;;807      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
00023e  f1020010          ADD      r0,r2,#0x10
000242  eb000381          ADD      r3,r0,r1,LSL #2
;;;808      tmpreg = *tmpreg_CCRx;
000246  681c              LDR      r4,[r3,#0]
;;;809    
;;;810      return tmpreg;
000248  b2a0              UXTH     r0,r4
;;;811    }
00024a  bd10              POP      {r4,pc}
;;;812    
                          ENDP

                  TIMER_GetChnCapture1 PROC
;;;823      */
;;;824    uint16_t TIMER_GetChnCapture1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
00024c  b510              PUSH     {r4,lr}
;;;825    {
00024e  4602              MOV      r2,r0
;;;826      __IO uint32_t *tmpreg_CCR1x;
;;;827      uint32_t tmpreg;
;;;828    
;;;829      /* Check the parameters */
;;;830      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;831      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;832    
;;;833      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
000250  f1020070          ADD      r0,r2,#0x70
000254  eb000381          ADD      r3,r0,r1,LSL #2
;;;834      tmpreg = *tmpreg_CCR1x;
000258  681c              LDR      r4,[r3,#0]
;;;835    
;;;836      return tmpreg;
00025a  b2a0              UXTH     r0,r4
;;;837    }
00025c  bd10              POP      {r4,pc}
;;;838    
                          ENDP

                  TIMER_ChnETR_Cmd PROC
;;;851      */
;;;852    void TIMER_ChnETR_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
00025e  b530              PUSH     {r4,r5,lr}
;;;853    {
000260  4603              MOV      r3,r0
;;;854      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;855      uint32_t tmpreg_CH_CNTRL;
;;;856    
;;;857      /* Check the parameters */
;;;858      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;859      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;860      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;861    
;;;862      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000262  f1030520          ADD      r5,r3,#0x20
000266  eb050481          ADD      r4,r5,r1,LSL #2
;;;863    
;;;864      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00026a  6820              LDR      r0,[r4,#0]
;;;865    
;;;866      /* Form new value */
;;;867      if (NewState != DISABLE)
00026c  b112              CBZ      r2,|L1.628|
;;;868      {
;;;869        /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
;;;870        tmpreg_CH_CNTRL |= TIMER_CH_CNTRL_OCCE;
00026e  f4407080          ORR      r0,r0,#0x100
000272  e001              B        |L1.632|
                  |L1.628|
;;;871      }
;;;872      else
;;;873      {
;;;874        /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
;;;875        tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCE;
000274  f4207080          BIC      r0,r0,#0x100
                  |L1.632|
;;;876      }
;;;877    
;;;878      /* Configure CNTRL register with new value */
;;;879      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000278  6020              STR      r0,[r4,#0]
;;;880    }
00027a  bd30              POP      {r4,r5,pc}
;;;881    
                          ENDP

                  TIMER_ChnETRResetConfig PROC
;;;896      */
;;;897    void TIMER_ChnETRResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
00027c  b530              PUSH     {r4,r5,lr}
;;;898    {
00027e  4603              MOV      r3,r0
;;;899      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;900      uint32_t tmpreg_CH_CNTRL;
;;;901    
;;;902      /* Check the parameters */
;;;903      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;904      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;905      assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(NewState));
;;;906    
;;;907      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000280  f1030520          ADD      r5,r3,#0x20
000284  eb050481          ADD      r4,r5,r1,LSL #2
;;;908    
;;;909      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
000288  6820              LDR      r0,[r4,#0]
;;;910      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_ETREN;
00028a  f4205000          BIC      r0,r0,#0x2000
;;;911      tmpreg_CH_CNTRL += NewState;
00028e  4410              ADD      r0,r0,r2
;;;912      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000290  6020              STR      r0,[r4,#0]
;;;913    }
000292  bd30              POP      {r4,r5,pc}
;;;914    
                          ENDP

                  TIMER_ChnBRKResetConfig PROC
;;;929      */
;;;930    void TIMER_ChnBRKResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
000294  b530              PUSH     {r4,r5,lr}
;;;931    {
000296  4603              MOV      r3,r0
;;;932      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;933      uint32_t tmpreg_CH_CNTRL;
;;;934    
;;;935      /* Check the parameters */
;;;936      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;937      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;938      assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(NewState));
;;;939    
;;;940      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000298  f1030520          ADD      r5,r3,#0x20
00029c  eb050481          ADD      r4,r5,r1,LSL #2
;;;941    
;;;942      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
0002a0  6820              LDR      r0,[r4,#0]
;;;943      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_BRKEN;
0002a2  f4205080          BIC      r0,r0,#0x1000
;;;944      tmpreg_CH_CNTRL += NewState;
0002a6  4410              ADD      r0,r0,r2
;;;945      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
0002a8  6020              STR      r0,[r4,#0]
;;;946    }
0002aa  bd30              POP      {r4,r5,pc}
;;;947    
                          ENDP

                  TIMER_ChnREFFormatConfig PROC
;;;960      */
;;;961    void TIMER_ChnREFFormatConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Format)
0002ac  b530              PUSH     {r4,r5,lr}
;;;962    {
0002ae  4603              MOV      r3,r0
;;;963      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;964      uint32_t tmpreg_CH_CNTRL;
;;;965    
;;;966      /* Check the parameters */
;;;967      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;968      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;969      assert_param(IS_TIMER_CHANNEL_REF_FORMAT(Format));
;;;970    
;;;971      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
0002b0  f1030520          ADD      r5,r3,#0x20
0002b4  eb050481          ADD      r4,r5,r1,LSL #2
;;;972    
;;;973      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
0002b8  6820              LDR      r0,[r4,#0]
;;;974      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCM_Msk;
0002ba  f4206060          BIC      r0,r0,#0xe00
;;;975      tmpreg_CH_CNTRL += Format;
0002be  4410              ADD      r0,r0,r2
;;;976      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
0002c0  6020              STR      r0,[r4,#0]
;;;977    }
0002c2  bd30              POP      {r4,r5,pc}
;;;978    
                          ENDP

                  TIMER_ChnCapturePrescalerConfig PROC
;;;995      */
;;;996    void TIMER_ChnCapturePrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Prescaler)
0002c4  b530              PUSH     {r4,r5,lr}
;;;997    {
0002c6  4603              MOV      r3,r0
;;;998      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;999      uint32_t tmpreg_CH_CNTRL;
;;;1000   
;;;1001     /* Check the parameters */
;;;1002     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1003     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1004     assert_param(IS_TIMER_CHANNEL_PRESCALER(Prescaler));
;;;1005   
;;;1006     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
0002c8  f1030520          ADD      r5,r3,#0x20
0002cc  eb050481          ADD      r4,r5,r1,LSL #2
;;;1007   
;;;1008     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
0002d0  6820              LDR      r0,[r4,#0]
;;;1009     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHPSC_Msk;
0002d2  f02000c0          BIC      r0,r0,#0xc0
;;;1010     tmpreg_CH_CNTRL += Prescaler << TIMER_CH_CNTRL_CHPSC_Pos;
0002d6  eb001082          ADD      r0,r0,r2,LSL #6
;;;1011     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
0002da  6020              STR      r0,[r4,#0]
;;;1012   }
0002dc  bd30              POP      {r4,r5,pc}
;;;1013   
                          ENDP

                  TIMER_ChnEventSourceConfig PROC
;;;1030     */
;;;1031   void TIMER_ChnEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
0002de  b530              PUSH     {r4,r5,lr}
;;;1032   {
0002e0  4603              MOV      r3,r0
;;;1033     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1034     uint32_t tmpreg_CH_CNTRL;
;;;1035   
;;;1036     /* Check the parameters */
;;;1037     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1038     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1039     assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(EventSource));
;;;1040   
;;;1041     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
0002e2  f1030520          ADD      r5,r3,#0x20
0002e6  eb050481          ADD      r4,r5,r1,LSL #2
;;;1042   
;;;1043     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
0002ea  6820              LDR      r0,[r4,#0]
;;;1044     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHSEL_Msk;
0002ec  f0200030          BIC      r0,r0,#0x30
;;;1045     tmpreg_CH_CNTRL += EventSource;
0002f0  4410              ADD      r0,r0,r2
;;;1046     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
0002f2  6020              STR      r0,[r4,#0]
;;;1047   }
0002f4  bd30              POP      {r4,r5,pc}
;;;1048   
                          ENDP

                  TIMER_ChnFilterConfig PROC
;;;1077     */
;;;1078   void TIMER_ChnFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Filter)
0002f6  b530              PUSH     {r4,r5,lr}
;;;1079   {
0002f8  4603              MOV      r3,r0
;;;1080     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1081     uint32_t tmpreg_CH_CNTRL;
;;;1082   
;;;1083     /* Check the parameters */
;;;1084     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1085     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1086     assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;1087   
;;;1088     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
0002fa  f1030520          ADD      r5,r3,#0x20
0002fe  eb050481          ADD      r4,r5,r1,LSL #2
;;;1089   
;;;1090     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
000302  6820              LDR      r0,[r4,#0]
;;;1091     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHFLTR_Msk;
000304  f020000f          BIC      r0,r0,#0xf
;;;1092     tmpreg_CH_CNTRL += Filter << TIMER_CH_CNTRL_CHFLTR_Pos;
000308  4410              ADD      r0,r0,r2
;;;1093     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
00030a  6020              STR      r0,[r4,#0]
;;;1094   }
00030c  bd30              POP      {r4,r5,pc}
;;;1095   
                          ENDP

                  TIMER_GetChnWriteComplete PROC
;;;1106     */
;;;1107   FlagStatus TIMER_GetChnWriteComplete(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
00030e  b510              PUSH     {r4,lr}
;;;1108   {
000310  4602              MOV      r2,r0
;;;1109     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1110     FlagStatus bitstatus;
;;;1111   
;;;1112     /* Check the parameters */
;;;1113     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1114     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1115   
;;;1116     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000312  f1020420          ADD      r4,r2,#0x20
000316  eb040381          ADD      r3,r4,r1,LSL #2
;;;1117   
;;;1118     if ((*tmpreg_CH_CNTRLx & TIMER_CH_CNTRL_WR_CMPL) == 0)
00031a  681c              LDR      r4,[r3,#0]
00031c  f4144f80          TST      r4,#0x4000
000320  d101              BNE      |L1.806|
;;;1119     {
;;;1120       bitstatus = RESET;
000322  2000              MOVS     r0,#0
000324  e000              B        |L1.808|
                  |L1.806|
;;;1121     }
;;;1122     else
;;;1123     {
;;;1124       bitstatus = SET;
000326  2001              MOVS     r0,#1
                  |L1.808|
;;;1125     }
;;;1126   
;;;1127     return bitstatus;
;;;1128   }
000328  bd10              POP      {r4,pc}
;;;1129   
                          ENDP

                  TIMER_ChnCCR1_EventSourceConfig PROC
;;;1146     */
;;;1147   void TIMER_ChnCCR1_EventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
00032a  b530              PUSH     {r4,r5,lr}
;;;1148   {
00032c  4603              MOV      r3,r0
;;;1149     __IO uint32_t *tmpreg_CH_CNTRL2x;
;;;1150     uint32_t tmpreg_CH_CNTRL2;
;;;1151   
;;;1152     /* Check the parameters */
;;;1153     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1154     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1155     assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(EventSource));
;;;1156   
;;;1157     tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
00032e  f1030560          ADD      r5,r3,#0x60
000332  eb050481          ADD      r4,r5,r1,LSL #2
;;;1158   
;;;1159     tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
000336  6820              LDR      r0,[r4,#0]
;;;1160     tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CHSEL1_Msk;
000338  f0200003          BIC      r0,r0,#3
;;;1161     tmpreg_CH_CNTRL2 += EventSource;
00033c  4410              ADD      r0,r0,r2
;;;1162     *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
00033e  6020              STR      r0,[r4,#0]
;;;1163   }
000340  bd30              POP      {r4,r5,pc}
;;;1164   
                          ENDP

                  TIMER_ChnCCR1_Cmd PROC
;;;1177     */
;;;1178   void TIMER_ChnCCR1_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
000342  b530              PUSH     {r4,r5,lr}
;;;1179   {
000344  4603              MOV      r3,r0
;;;1180     __IO uint32_t *tmpreg_CH_CNTRL2x;
;;;1181     uint32_t tmpreg_CH_CNTRL2;
;;;1182   
;;;1183     /* Check the parameters */
;;;1184     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1185     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1186     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1187   
;;;1188     tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
000346  f1030560          ADD      r5,r3,#0x60
00034a  eb050481          ADD      r4,r5,r1,LSL #2
;;;1189   
;;;1190     tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
00034e  6820              LDR      r0,[r4,#0]
;;;1191   
;;;1192     /* Form new value */
;;;1193     if (NewState != DISABLE)
000350  b112              CBZ      r2,|L1.856|
;;;1194     {
;;;1195       /* Enable TIMERx by setting the CCR1_EN bit in the CNTRL2 register */
;;;1196       tmpreg_CH_CNTRL2 |= TIMER_CH_CNTRL2_CCR1_EN;
000352  f0400004          ORR      r0,r0,#4
000356  e001              B        |L1.860|
                  |L1.856|
;;;1197     }
;;;1198     else
;;;1199     {
;;;1200       /* Disable TIMERx by resetting the CCR1_EN bit in the CNTRL2 register */
;;;1201       tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CCR1_EN;
000358  f0200004          BIC      r0,r0,#4
                  |L1.860|
;;;1202     }
;;;1203   
;;;1204     /* Configure CNTRL register with new value */
;;;1205     *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
00035c  6020              STR      r0,[r4,#0]
;;;1206   }
00035e  bd30              POP      {r4,r5,pc}
;;;1207   
                          ENDP

                  TIMER_ChnOutInit PROC
;;;1216     */
;;;1217   void TIMER_ChnOutInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
000360  b570              PUSH     {r4-r6,lr}
;;;1218   {
;;;1219     uint32_t tmpreg_CH_Number;
;;;1220     uint32_t tmpreg_CH_CNTRL1;
;;;1221     uint32_t tmpreg_CH_DTG;
;;;1222   
;;;1223     /* Check the parameters */
;;;1224     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1225     assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnOutInitStruct->TIMER_CH_Number));
;;;1226     assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity));
;;;1227     assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source));
;;;1228     assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode));
;;;1229     assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity));
;;;1230     assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source));
;;;1231     assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode));
;;;1232     assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler));
;;;1233     assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler));
;;;1234     assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource));
;;;1235   
;;;1236     tmpreg_CH_CNTRL1 = (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity << TIMER_CH_CNTRL1_INV_Pos)
000362  884d              LDRH     r5,[r1,#2]
000364  012d              LSLS     r5,r5,#4
000366  888e              LDRH     r6,[r1,#4]
000368  eb050586          ADD      r5,r5,r6,LSL #2
00036c  88ce              LDRH     r6,[r1,#6]
00036e  4435              ADD      r5,r5,r6
000370  890e              LDRH     r6,[r1,#8]
000372  eb053506          ADD      r5,r5,r6,LSL #12
000376  894e              LDRH     r6,[r1,#0xa]
000378  eb052586          ADD      r5,r5,r6,LSL #10
00037c  898e              LDRH     r6,[r1,#0xc]
00037e  eb052306          ADD      r3,r5,r6,LSL #8
;;;1237                      + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source   << TIMER_CH_CNTRL1_SELO_Pos)
;;;1238                      + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode     << TIMER_CH_CNTRL1_SELOE_Pos)
;;;1239                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity << TIMER_CH_CNTRL1_NINV_Pos)
;;;1240                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source   << TIMER_CH_CNTRL1_NSELO_Pos)
;;;1241                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode     << TIMER_CH_CNTRL1_NSELOE_Pos);
;;;1242   
;;;1243     tmpreg_CH_Number = TIMER_ChnOutInitStruct->TIMER_CH_Number;
000382  880a              LDRH     r2,[r1,#0]
;;;1244   
;;;1245     *(&TIMERx->CH1_CNTRL1 + tmpreg_CH_Number) = tmpreg_CH_CNTRL1;
000384  f1000530          ADD      r5,r0,#0x30
000388  f8453022          STR      r3,[r5,r2,LSL #2]
;;;1246   
;;;1247     tmpreg_CH_DTG = (TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler << TIMER_CH_DTG_Pos)
00038c  8a0d              LDRH     r5,[r1,#0x10]
00038e  89ce              LDRH     r6,[r1,#0xe]
000390  eb052506          ADD      r5,r5,r6,LSL #8
000394  8a4e              LDRH     r6,[r1,#0x12]
000396  19ac              ADDS     r4,r5,r6
;;;1248                   + (TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  << TIMER_CH_DTGX_Pos)
;;;1249                   + TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource;
;;;1250   
;;;1251     *(&TIMERx->CH1_DTG + tmpreg_CH_Number) = tmpreg_CH_DTG;
000398  f1000540          ADD      r5,r0,#0x40
00039c  f8454022          STR      r4,[r5,r2,LSL #2]
;;;1252   }
0003a0  bd70              POP      {r4-r6,pc}
;;;1253   
                          ENDP

                  TIMER_ChnOutStructInit PROC
;;;1259     */
;;;1260   void TIMER_ChnOutStructInit(TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
0003a2  2100              MOVS     r1,#0
;;;1261   {
;;;1262     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity   = TIMER_CHOPolarity_NonInverted;
0003a4  8041              STRH     r1,[r0,#2]
;;;1263     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source     = TIMER_CH_OutSrc_Only_0;
0003a6  8081              STRH     r1,[r0,#4]
;;;1264     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode       = TIMER_CH_OutMode_Input;
0003a8  80c1              STRH     r1,[r0,#6]
;;;1265     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity   = TIMER_CHOPolarity_NonInverted;
0003aa  8101              STRH     r1,[r0,#8]
;;;1266     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source     = TIMER_CH_OutSrc_Only_0;
0003ac  8141              STRH     r1,[r0,#0xa]
;;;1267     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode       = TIMER_CH_OutMode_Input;
0003ae  8181              STRH     r1,[r0,#0xc]
;;;1268     TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler = 0;
0003b0  81c1              STRH     r1,[r0,#0xe]
;;;1269     TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  = 0;
0003b2  8201              STRH     r1,[r0,#0x10]
;;;1270     TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource   = TIMER_CH_DTG_ClkSrc_TIMER_CLK;
0003b4  8241              STRH     r1,[r0,#0x12]
;;;1271   }
0003b6  4770              BX       lr
;;;1272   
                          ENDP

                  TIMER_ChnOutConfig PROC
;;;1299     */
;;;1300   void TIMER_ChnOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
0003b8  b5f0              PUSH     {r4-r7,lr}
;;;1301   {
0003ba  4604              MOV      r4,r0
0003bc  9e05              LDR      r6,[sp,#0x14]
;;;1302     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1303     uint32_t tmpreg_CH_CNTRL1;
;;;1304   
;;;1305     /* Check the parameters */
;;;1306     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1307     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1308     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1309     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1310     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1311   
;;;1312     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
0003be  f1040730          ADD      r7,r4,#0x30
0003c2  eb070581          ADD      r5,r7,r1,LSL #2
;;;1313   
;;;1314     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
0003c6  6828              LDR      r0,[r5,#0]
;;;1315     tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_INV + TIMER_CH_CNTRL1_SELO_Msk + TIMER_CH_CNTRL1_SELOE_Msk);
0003c8  f020001f          BIC      r0,r0,#0x1f
;;;1316     tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_INV_Pos)
0003cc  0137              LSLS     r7,r6,#4
0003ce  eb070782          ADD      r7,r7,r2,LSL #2
0003d2  441f              ADD      r7,r7,r3
0003d4  4438              ADD      r0,r0,r7
;;;1317                       + (OutSource << TIMER_CH_CNTRL1_SELO_Pos)
;;;1318                       + (Mode      << TIMER_CH_CNTRL1_SELOE_Pos);
;;;1319     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
0003d6  6028              STR      r0,[r5,#0]
;;;1320   }
0003d8  bdf0              POP      {r4-r7,pc}
;;;1321   
                          ENDP

                  TIMER_ChnOutSourceConfig PROC
;;;1338     */
;;;1339   void TIMER_ChnOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
0003da  b530              PUSH     {r4,r5,lr}
;;;1340   {
0003dc  4603              MOV      r3,r0
;;;1341     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1342     uint32_t tmpreg_CH_CNTRL1;
;;;1343   
;;;1344     /* Check the parameters */
;;;1345     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1346     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1347     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1348   
;;;1349     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
0003de  f1030530          ADD      r5,r3,#0x30
0003e2  eb050481          ADD      r4,r5,r1,LSL #2
;;;1350   
;;;1351     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
0003e6  6820              LDR      r0,[r4,#0]
;;;1352     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELO_Msk;
0003e8  f020000c          BIC      r0,r0,#0xc
;;;1353     tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_SELO_Pos;
0003ec  eb000082          ADD      r0,r0,r2,LSL #2
;;;1354     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
0003f0  6020              STR      r0,[r4,#0]
;;;1355   }
0003f2  bd30              POP      {r4,r5,pc}
;;;1356   
                          ENDP

                  TIMER_ChnOutModeConfig PROC
;;;1373     */
;;;1374   void TIMER_ChnOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
0003f4  b530              PUSH     {r4,r5,lr}
;;;1375   {
0003f6  4603              MOV      r3,r0
;;;1376     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1377     uint32_t tmpreg_CH_CNTRL1;
;;;1378   
;;;1379     /* Check the parameters */
;;;1380     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1381     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1382     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1383   
;;;1384     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
0003f8  f1030530          ADD      r5,r3,#0x30
0003fc  eb050481          ADD      r4,r5,r1,LSL #2
;;;1385   
;;;1386     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000400  6820              LDR      r0,[r4,#0]
;;;1387     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELOE_Msk;
000402  f0200003          BIC      r0,r0,#3
;;;1388     tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_SELOE_Pos;
000406  4410              ADD      r0,r0,r2
;;;1389     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000408  6020              STR      r0,[r4,#0]
;;;1390   }
00040a  bd30              POP      {r4,r5,pc}
;;;1391   
                          ENDP

                  TIMER_ChnOutPolarityConfig PROC
;;;1406     */
;;;1407   void TIMER_ChnOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
00040c  b530              PUSH     {r4,r5,lr}
;;;1408   {
00040e  4603              MOV      r3,r0
;;;1409     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1410     uint32_t tmpreg_CH_CNTRL1;
;;;1411   
;;;1412     /* Check the parameters */
;;;1413     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1414     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1415     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1416   
;;;1417     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000410  f1030530          ADD      r5,r3,#0x30
000414  eb050481          ADD      r4,r5,r1,LSL #2
;;;1418   
;;;1419     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000418  6820              LDR      r0,[r4,#0]
;;;1420     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_INV;
00041a  f0200010          BIC      r0,r0,#0x10
;;;1421     tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_INV_Pos;
00041e  eb001002          ADD      r0,r0,r2,LSL #4
;;;1422     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000422  6020              STR      r0,[r4,#0]
;;;1423   }
000424  bd30              POP      {r4,r5,pc}
;;;1424   
                          ENDP

                  TIMER_ChnNOutConfig PROC
;;;1451     */
;;;1452   void TIMER_ChnNOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
000426  b5f0              PUSH     {r4-r7,lr}
;;;1453   {
000428  4604              MOV      r4,r0
00042a  9e05              LDR      r6,[sp,#0x14]
;;;1454     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1455     uint32_t tmpreg_CH_CNTRL1;
;;;1456   
;;;1457     /* Check the parameters */
;;;1458     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1459     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1460     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1461     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1462     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1463   
;;;1464     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
00042c  f1040730          ADD      r7,r4,#0x30
000430  eb070581          ADD      r5,r7,r1,LSL #2
;;;1465   
;;;1466     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000434  6828              LDR      r0,[r5,#0]
;;;1467     tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_NINV + TIMER_CH_CNTRL1_NSELO_Msk + TIMER_CH_CNTRL1_NSELOE_Msk);
000436  f42050f8          BIC      r0,r0,#0x1f00
;;;1468     tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_NINV_Pos)
00043a  0337              LSLS     r7,r6,#12
00043c  eb072782          ADD      r7,r7,r2,LSL #10
000440  eb072703          ADD      r7,r7,r3,LSL #8
000444  4438              ADD      r0,r0,r7
;;;1469                       + (OutSource << TIMER_CH_CNTRL1_NSELO_Pos)
;;;1470                       + (Mode      << TIMER_CH_CNTRL1_NSELOE_Pos);
;;;1471     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000446  6028              STR      r0,[r5,#0]
;;;1472   }
000448  bdf0              POP      {r4-r7,pc}
;;;1473   
                          ENDP

                  TIMER_ChnNOutSourceConfig PROC
;;;1490     */
;;;1491   void TIMER_ChnNOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
00044a  b530              PUSH     {r4,r5,lr}
;;;1492   {
00044c  4603              MOV      r3,r0
;;;1493     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1494     uint32_t tmpreg_CH_CNTRL1;
;;;1495   
;;;1496     /* Check the parameters */
;;;1497     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1498     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1499     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1500   
;;;1501     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
00044e  f1030530          ADD      r5,r3,#0x30
000452  eb050481          ADD      r4,r5,r1,LSL #2
;;;1502   
;;;1503     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000456  6820              LDR      r0,[r4,#0]
;;;1504     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELO_Msk;
000458  f4206040          BIC      r0,r0,#0xc00
;;;1505     tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_NSELO_Pos;
00045c  eb002082          ADD      r0,r0,r2,LSL #10
;;;1506     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000460  6020              STR      r0,[r4,#0]
;;;1507   }
000462  bd30              POP      {r4,r5,pc}
;;;1508   
                          ENDP

                  TIMER_ChnNOutModeConfig PROC
;;;1525     */
;;;1526   void TIMER_ChnNOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
000464  b530              PUSH     {r4,r5,lr}
;;;1527   {
000466  4603              MOV      r3,r0
;;;1528     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1529     uint32_t tmpreg_CH_CNTRL1;
;;;1530   
;;;1531     /* Check the parameters */
;;;1532     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1533     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1534     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1535   
;;;1536     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000468  f1030530          ADD      r5,r3,#0x30
00046c  eb050481          ADD      r4,r5,r1,LSL #2
;;;1537   
;;;1538     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
000470  6820              LDR      r0,[r4,#0]
;;;1539     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELOE_Msk;
000472  f4207040          BIC      r0,r0,#0x300
;;;1540     tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_NSELOE_Pos;
000476  eb002002          ADD      r0,r0,r2,LSL #8
;;;1541     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
00047a  6020              STR      r0,[r4,#0]
;;;1542   }
00047c  bd30              POP      {r4,r5,pc}
;;;1543   
                          ENDP

                  TIMER_ChnNOutPolarityConfig PROC
;;;1558     */
;;;1559   void TIMER_ChnNOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
00047e  b530              PUSH     {r4,r5,lr}
;;;1560   {
000480  4603              MOV      r3,r0
;;;1561     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1562     uint32_t tmpreg_CH_CNTRL1;
;;;1563   
;;;1564     /* Check the parameters */
;;;1565     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1566     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1567     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1568   
;;;1569     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000482  f1030530          ADD      r5,r3,#0x30
000486  eb050481          ADD      r4,r5,r1,LSL #2
;;;1570   
;;;1571     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00048a  6820              LDR      r0,[r4,#0]
;;;1572     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NINV;
00048c  f4205080          BIC      r0,r0,#0x1000
;;;1573     tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_NINV_Pos;
000490  eb003002          ADD      r0,r0,r2,LSL #12
;;;1574     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000494  6020              STR      r0,[r4,#0]
;;;1575   }
000496  bd30              POP      {r4,r5,pc}
;;;1576   
                          ENDP

                  TIMER_ChnOutDTGConfig PROC
;;;1595     */
;;;1596   void TIMER_ChnOutDTGConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel,
000498  b570              PUSH     {r4-r6,lr}
;;;1597                            uint32_t MainPrescaler, uint32_t AuxPrescaler, uint32_t ClockSource)
;;;1598   {
00049a  9c04              LDR      r4,[sp,#0x10]
;;;1599     uint32_t tmpreg_CH_DTG;
;;;1600   
;;;1601     /* Check the parameters */
;;;1602     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1603     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1604     assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(MainPrescaler));
;;;1605     assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(AuxPrescaler));
;;;1606     assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(ClockSource));
;;;1607   
;;;1608     tmpreg_CH_DTG = (MainPrescaler << TIMER_CH_DTG_Pos)
00049c  eb032602          ADD      r6,r3,r2,LSL #8
0004a0  1935              ADDS     r5,r6,r4
;;;1609                   + (AuxPrescaler  << TIMER_CH_DTGX_Pos)
;;;1610                   + ClockSource;
;;;1611   
;;;1612     *(&TIMERx->CH1_DTG + Channel) = tmpreg_CH_DTG;
0004a2  f1000640          ADD      r6,r0,#0x40
0004a6  f8465021          STR      r5,[r6,r1,LSL #2]
;;;1613   }
0004aa  bd70              POP      {r4-r6,pc}
;;;1614   
                          ENDP

                  TIMER_GetStatus PROC
;;;1619     */
;;;1620   uint32_t TIMER_GetStatus(MDR_TIMER_TypeDef* TIMERx)
0004ac  4601              MOV      r1,r0
;;;1621   {
;;;1622     /* Check the parameters */
;;;1623     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1624   
;;;1625     return TIMERx->STATUS;
0004ae  6d48              LDR      r0,[r1,#0x54]
;;;1626   }
0004b0  4770              BX       lr
;;;1627   
                          ENDP

                  TIMER_GetFlagStatus PROC
;;;1651     */
;;;1652   FlagStatus TIMER_GetFlagStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t Flag)
0004b2  4602              MOV      r2,r0
;;;1653   {
;;;1654     FlagStatus bitstatus;
;;;1655   
;;;1656     /* Check the parameters */
;;;1657     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1658     assert_param(IS_TIMER_STATUS_FLAG(Flag));
;;;1659   
;;;1660     if ((TIMERx->STATUS & Flag) == 0)
0004b4  6d53              LDR      r3,[r2,#0x54]
0004b6  420b              TST      r3,r1
0004b8  d101              BNE      |L1.1214|
;;;1661     {
;;;1662       bitstatus = RESET;
0004ba  2000              MOVS     r0,#0
0004bc  e000              B        |L1.1216|
                  |L1.1214|
;;;1663     }
;;;1664     else
;;;1665     {
;;;1666       bitstatus = SET;
0004be  2001              MOVS     r0,#1
                  |L1.1216|
;;;1667     }
;;;1668   
;;;1669     return bitstatus;
;;;1670   }
0004c0  4770              BX       lr
;;;1671   
                          ENDP

                  TIMER_ClearFlag PROC
;;;1695     */
;;;1696   void TIMER_ClearFlag(MDR_TIMER_TypeDef* TIMERx, uint32_t Flags)
0004c2  6d42              LDR      r2,[r0,#0x54]
;;;1697   {
;;;1698     /* Check the parameters */
;;;1699     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1700     assert_param(IS_TIMER_STATUS(Flags));
;;;1701   
;;;1702     TIMERx->STATUS &= ~Flags;
0004c4  438a              BICS     r2,r2,r1
0004c6  6542              STR      r2,[r0,#0x54]
;;;1703   }
0004c8  4770              BX       lr
;;;1704   
                          ENDP

                  TIMER_DMACmd PROC
;;;1730     */
;;;1731   void TIMER_DMACmd(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_DMASource, FunctionalState NewState)
0004ca  b510              PUSH     {r4,lr}
;;;1732   {
0004cc  4613              MOV      r3,r2
;;;1733     uint32_t tmpreg_DMA_RE;
;;;1734   
;;;1735     /* Check the parameters */
;;;1736     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1737     assert_param(IS_TIMER_STATUS(TIMER_DMASource));
;;;1738     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1739   
;;;1740     tmpreg_DMA_RE = TIMERx->DMA_RE;
0004ce  6dc2              LDR      r2,[r0,#0x5c]
;;;1741   
;;;1742     /* Form new value */
;;;1743     if (NewState != DISABLE)
0004d0  b10b              CBZ      r3,|L1.1238|
;;;1744     {
;;;1745       /* Enable TIMERx DMA Requests by setting bits in the DMA_RE register */
;;;1746       tmpreg_DMA_RE |= TIMER_DMASource;
0004d2  430a              ORRS     r2,r2,r1
0004d4  e000              B        |L1.1240|
                  |L1.1238|
;;;1747     }
;;;1748     else
;;;1749     {
;;;1750       /* Disable TIMERx DMA Requests by clearing bits in the DMA_RE register */
;;;1751       tmpreg_DMA_RE &= ~TIMER_DMASource;
0004d6  438a              BICS     r2,r2,r1
                  |L1.1240|
;;;1752     }
;;;1753   
;;;1754     /* Configure CNTRL register with new value */
;;;1755     TIMERx->DMA_RE = tmpreg_DMA_RE;
0004d8  65c2              STR      r2,[r0,#0x5c]
;;;1756   }
0004da  bd10              POP      {r4,pc}
;;;1757   
                          ENDP

                  TIMER_ITConfig PROC
;;;1783     */
;;;1784   void TIMER_ITConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT, FunctionalState NewState)
0004dc  b510              PUSH     {r4,lr}
;;;1785   {
0004de  4613              MOV      r3,r2
;;;1786     uint32_t tmpreg_IE;
;;;1787   
;;;1788     /* Check the parameters */
;;;1789     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1790     assert_param(IS_TIMER_STATUS(TIMER_IT));
;;;1791     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1792   
;;;1793     tmpreg_IE = TIMERx->IE;
0004e0  6d82              LDR      r2,[r0,#0x58]
;;;1794   
;;;1795     /* Form new value */
;;;1796     if (NewState != DISABLE)
0004e2  b10b              CBZ      r3,|L1.1256|
;;;1797     {
;;;1798       /* Enable the TIMERx Interrupt requests by setting bits in the IE register */
;;;1799       tmpreg_IE |= TIMER_IT;
0004e4  430a              ORRS     r2,r2,r1
0004e6  e000              B        |L1.1258|
                  |L1.1256|
;;;1800     }
;;;1801     else
;;;1802     {
;;;1803       /* Disable the TIMERx Interrupt requests by clearing bits in the IE register */
;;;1804       tmpreg_IE &= ~TIMER_IT;
0004e8  438a              BICS     r2,r2,r1
                  |L1.1258|
;;;1805     }
;;;1806   
;;;1807     /* Configure CNTRL register with new value */
;;;1808     TIMERx->IE = tmpreg_IE;
0004ea  6582              STR      r2,[r0,#0x58]
;;;1809   }
0004ec  bd10              POP      {r4,pc}
;;;1810   
                          ENDP

                  TIMER_GetITStatus PROC
;;;1834     */
;;;1835   ITStatus TIMER_GetITStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT)
0004ee  b530              PUSH     {r4,r5,lr}
;;;1836   {
0004f0  4602              MOV      r2,r0
;;;1837     ITStatus bitstatus;
;;;1838     uint32_t tmpreg;
;;;1839   
;;;1840     /* Check the parameters */
;;;1841     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1842     assert_param(IS_TIMER_STATUS_FLAG(TIMER_IT));
;;;1843   
;;;1844     tmpreg = TIMERx->STATUS & TIMERx->IE & TIMER_IT;
0004f2  6d54              LDR      r4,[r2,#0x54]
0004f4  6d95              LDR      r5,[r2,#0x58]
0004f6  402c              ANDS     r4,r4,r5
0004f8  ea040301          AND      r3,r4,r1
;;;1845   
;;;1846     if (tmpreg == 0)
0004fc  b90b              CBNZ     r3,|L1.1282|
;;;1847     {
;;;1848       bitstatus = RESET;
0004fe  2000              MOVS     r0,#0
000500  e000              B        |L1.1284|
                  |L1.1282|
;;;1849     }
;;;1850     else
;;;1851     {
;;;1852       bitstatus = SET;
000502  2001              MOVS     r0,#1
                  |L1.1284|
;;;1853     }
;;;1854   
;;;1855     return bitstatus;
;;;1856   }
000504  bd30              POP      {r4,r5,pc}
;;;1857   
                          ENDP

                  TIMER_BRGInit PROC
;;;1873     */
;;;1874   void TIMER_BRGInit(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_BRG)
000506  4602              MOV      r2,r0
;;;1875   {
;;;1876     uint32_t tmpreg;
;;;1877   
;;;1878     /* Check the parameters */
;;;1879     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1880     assert_param(IS_TIMER_CLOCK_BRG(TIMER_BRG));
;;;1881   
;;;1882     tmpreg = MDR_RST_CLK->TIM_CLOCK;
000508  4b10              LDR      r3,|L1.1356|
00050a  6a58              LDR      r0,[r3,#0x24]
;;;1883   
;;;1884     if (TIMERx == MDR_TIMER1)
00050c  4b10              LDR      r3,|L1.1360|
00050e  429a              CMP      r2,r3
000510  d105              BNE      |L1.1310|
;;;1885     {
;;;1886       tmpreg &= ~RST_CLK_TIM_CLOCK_TIM1_BRG_Msk;
000512  f02000ff          BIC      r0,r0,#0xff
;;;1887       tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM1_BRG_Pos;
000516  4308              ORRS     r0,r0,r1
;;;1888       tmpreg |= RST_CLK_TIM_CLOCK_TIM1_CLK_EN;
000518  f0407080          ORR      r0,r0,#0x1000000
00051c  e012              B        |L1.1348|
                  |L1.1310|
;;;1889     }
;;;1890     else if (TIMERx == MDR_TIMER2)
00051e  4b0d              LDR      r3,|L1.1364|
000520  429a              CMP      r2,r3
000522  d106              BNE      |L1.1330|
;;;1891     {
;;;1892       tmpreg &= ~RST_CLK_TIM_CLOCK_TIM2_BRG_Msk;
000524  f420407f          BIC      r0,r0,#0xff00
;;;1893       tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM2_BRG_Pos;
000528  ea402001          ORR      r0,r0,r1,LSL #8
;;;1894       tmpreg |= RST_CLK_TIM_CLOCK_TIM2_CLK_EN;
00052c  f0407000          ORR      r0,r0,#0x2000000
000530  e008              B        |L1.1348|
                  |L1.1330|
;;;1895     }
;;;1896     else if (TIMERx == MDR_TIMER3)
000532  4b09              LDR      r3,|L1.1368|
000534  429a              CMP      r2,r3
000536  d105              BNE      |L1.1348|
;;;1897     {
;;;1898       tmpreg &= ~RST_CLK_TIM_CLOCK_TIM3_BRG_Msk;
000538  f420007f          BIC      r0,r0,#0xff0000
;;;1899       tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM3_BRG_Pos;
00053c  ea404001          ORR      r0,r0,r1,LSL #16
;;;1900       tmpreg |= RST_CLK_TIM_CLOCK_TIM3_CLK_EN;
000540  f0406080          ORR      r0,r0,#0x4000000
                  |L1.1348|
;;;1901     }
;;;1902   
;;;1903     MDR_RST_CLK->TIM_CLOCK = tmpreg;
000544  4b01              LDR      r3,|L1.1356|
000546  6258              STR      r0,[r3,#0x24]
;;;1904   }
000548  4770              BX       lr
;;;1905   
                          ENDP

00054a  0000              DCW      0x0000
                  |L1.1356|
                          DCD      0x40020000
                  |L1.1360|
                          DCD      0x40070000
                  |L1.1364|
                          DCD      0x40078000
                  |L1.1368|
                          DCD      0x40080000

;*** Start embedded assembler ***

#line 1 "..\\Library\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_timer.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_MDR32F9Qx_timer_c_566b03da____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____REVSH|
#line 130
|__asm___17_MDR32F9Qx_timer_c_566b03da____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
