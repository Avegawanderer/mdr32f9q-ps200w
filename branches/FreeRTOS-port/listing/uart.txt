; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\uart.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\uart.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -I.\src\gui -I.\src\gui\guiCore -I.\src\gui\guiWidgets -I.\src\gui\guiGraphics -I.\src\gui\utils -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\uart.crf src\uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART_Init_RX_buffer PROC
;;;65     
;;;66     static void UART_Init_RX_buffer(uart_dma_rx_buffer_t *rx_buffer, uint16_t *data, uint32_t size)
000000  6041              STR      r1,[r0,#4]
;;;67     {
;;;68     	rx_buffer->data = data;
;;;69     	rx_buffer->size = size;
000002  8042              STRH     r2,[r0,#2]
;;;70     	rx_buffer->read_index = 0;
000004  2300              MOVS     r3,#0
000006  8003              STRH     r3,[r0,#0]
;;;71     	
;;;72     	// Fill buffer with invalid data
;;;73     	while(size)
;;;74     	{
;;;75     		data[--size] = EMPTY_DATA;
000008  f64f70ff          MOV      r0,#0xffff
00000c  e002              B        |L1.20|
                  |L1.14|
00000e  1e52              SUBS     r2,r2,#1
000010  f8210012          STRH     r0,[r1,r2,LSL #1]
                  |L1.20|
000014  2a00              CMP      r2,#0                 ;73
000016  d1fa              BNE      |L1.14|
;;;76     	}
;;;77     }
000018  4770              BX       lr
;;;78     
                          ENDP

                  UART_Get_from_RX_buffer PROC
;;;79     uint8_t UART_Get_from_RX_buffer(uart_dma_rx_buffer_t *rx_buffer, uint16_t *rx_word)
00001a  8803              LDRH     r3,[r0,#0]
;;;80     {
;;;81     	*rx_word = rx_buffer->data[rx_buffer->read_index];
00001c  6842              LDR      r2,[r0,#4]
00001e  f8322013          LDRH     r2,[r2,r3,LSL #1]
000022  800a              STRH     r2,[r1,#0]
;;;82     	if (*rx_word != EMPTY_DATA)
000024  f64f71ff          MOV      r1,#0xffff
000028  428a              CMP      r2,r1
00002a  d00e              BEQ      |L1.74|
;;;83     	{
;;;84     		// Valid data had been put into buffer by DMA
;;;85     		rx_buffer->data[rx_buffer->read_index] = EMPTY_DATA;	
00002c  8803              LDRH     r3,[r0,#0]
00002e  6842              LDR      r2,[r0,#4]
000030  f8221013          STRH     r1,[r2,r3,LSL #1]
;;;86     		rx_buffer->read_index = (rx_buffer->read_index < (rx_buffer->size - 1)) ? rx_buffer->read_index + 1 : 0;
000034  8842              LDRH     r2,[r0,#2]
000036  8801              LDRH     r1,[r0,#0]
000038  1e52              SUBS     r2,r2,#1
00003a  4291              CMP      r1,r2
00003c  da01              BGE      |L1.66|
00003e  1c49              ADDS     r1,r1,#1
000040  e000              B        |L1.68|
                  |L1.66|
000042  2100              MOVS     r1,#0
                  |L1.68|
000044  8001              STRH     r1,[r0,#0]
;;;87     		return 1;
000046  2001              MOVS     r0,#1
;;;88     	}
;;;89     	return 0;
;;;90     }
000048  4770              BX       lr
                  |L1.74|
00004a  2000              MOVS     r0,#0                 ;89
00004c  4770              BX       lr
;;;91     
                          ENDP

                  UART_init_RX_DMA PROC
;;;93     // DMA channel UARTx RX configuration 
;;;94     static void UART_init_RX_DMA(MDR_UART_TypeDef *MDR_UARTx, uart_dma_rx_buffer_t *rx_buffer, uint32_t *saved_tcb)
00004e  b530              PUSH     {r4,r5,lr}
;;;95     {
000050  b08f              SUB      sp,sp,#0x3c
000052  4614              MOV      r4,r2
;;;96     	DMA_ChannelInitTypeDef DMA_InitStr;
;;;97     	DMA_CtrlDataInitTypeDef DMA_PriCtrlStr;
;;;98     	uint32_t *tcb_ptr;
;;;99     	uint32_t DMA_Channel_UARTn_RX = (MDR_UARTx == MDR_UART1) ? DMA_Channel_UART1_RX : DMA_Channel_UART2_RX;
000054  4afa              LDR      r2,|L1.1088|
000056  4290              CMP      r0,r2
000058  d101              BNE      |L1.94|
00005a  2501              MOVS     r5,#1
00005c  e000              B        |L1.96|
                  |L1.94|
00005e  2503              MOVS     r5,#3
                  |L1.96|
;;;100    	
;;;101    	// Setup Primary Control Data 
;;;102    	DMA_PriCtrlStr.DMA_SourceBaseAddr = (uint32_t)(&(MDR_UARTx->DR));
000060  9001              STR      r0,[sp,#4]
;;;103    	DMA_PriCtrlStr.DMA_DestBaseAddr = (uint32_t)rx_buffer->data;			// dest (buffer of 16-bit shorts)
000062  6848              LDR      r0,[r1,#4]
000064  9002              STR      r0,[sp,#8]
;;;104    	DMA_PriCtrlStr.DMA_SourceIncSize = DMA_SourceIncNo;
000066  f04f6040          MOV      r0,#0xc000000
00006a  9003              STR      r0,[sp,#0xc]
;;;105    	DMA_PriCtrlStr.DMA_DestIncSize = DMA_DestIncHalfword ;
00006c  f04f4080          MOV      r0,#0x40000000
000070  9004              STR      r0,[sp,#0x10]
;;;106    	DMA_PriCtrlStr.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
000072  f04f5088          MOV      r0,#0x11000000
000076  9005              STR      r0,[sp,#0x14]
;;;107    	DMA_PriCtrlStr.DMA_Mode = DMA_Mode_Basic;								// 
000078  2201              MOVS     r2,#1
00007a  9206              STR      r2,[sp,#0x18]
;;;108    	DMA_PriCtrlStr.DMA_CycleSize = rx_buffer->size;							// count of 16-bit shorts
00007c  8848              LDRH     r0,[r1,#2]
00007e  9007              STR      r0,[sp,#0x1c]
;;;109    	DMA_PriCtrlStr.DMA_NumContinuous = DMA_Transfers_1;
000080  2000              MOVS     r0,#0
000082  9008              STR      r0,[sp,#0x20]
;;;110    	DMA_PriCtrlStr.DMA_SourceProtCtrl = DMA_SourcePrivileged;				// ?
000084  0491              LSLS     r1,r2,#18
000086  9109              STR      r1,[sp,#0x24]
;;;111    	DMA_PriCtrlStr.DMA_DestProtCtrl = DMA_DestPrivileged;					// ?
000088  00c9              LSLS     r1,r1,#3
00008a  910a              STR      r1,[sp,#0x28]
;;;112    	
;;;113    	// Setup Channel Structure
;;;114    	DMA_InitStr.DMA_PriCtrlData = &DMA_PriCtrlStr;
00008c  a901              ADD      r1,sp,#4
00008e  910b              STR      r1,[sp,#0x2c]
;;;115    	DMA_InitStr.DMA_AltCtrlData = 0;										// Not used
000090  900c              STR      r0,[sp,#0x30]
;;;116    	DMA_InitStr.DMA_ProtCtrl = 0;											// Not used
000092  900d              STR      r0,[sp,#0x34]
;;;117    	DMA_InitStr.DMA_Priority = DMA_Priority_High ;
000094  f88d2038          STRB     r2,[sp,#0x38]
;;;118    	DMA_InitStr.DMA_UseBurst = DMA_BurstClear;								// Enable single words trasfer
000098  f88d0039          STRB     r0,[sp,#0x39]
;;;119    	DMA_InitStr.DMA_SelectDataStructure = DMA_CTRL_DATA_PRIMARY;
00009c  f88d003a          STRB     r0,[sp,#0x3a]
;;;120    	
;;;121    	// Init DMA channel
;;;122    	my_DMA_ChannelInit(DMA_Channel_UARTn_RX, &DMA_InitStr);
0000a0  a90b              ADD      r1,sp,#0x2c
0000a2  b2e8              UXTB     r0,r5
0000a4  f7fffffe          BL       my_DMA_ChannelInit
;;;123    	
;;;124    	// Save created RX UART DMA control block for reinit in DMA ISR
;;;125    	tcb_ptr = (uint32_t*)&DMA_ControlTable[DMA_Channel_UARTn_RX];
0000a8  48e6              LDR      r0,|L1.1092|
0000aa  eb001005          ADD      r0,r0,r5,LSL #4
;;;126    	saved_tcb[0] = *tcb_ptr++;
0000ae  6801              LDR      r1,[r0,#0]
0000b0  6021              STR      r1,[r4,#0]
;;;127    	saved_tcb[1] = *tcb_ptr++;
0000b2  6841              LDR      r1,[r0,#4]
0000b4  6061              STR      r1,[r4,#4]
;;;128    	saved_tcb[2] = *tcb_ptr;
0000b6  6880              LDR      r0,[r0,#8]
0000b8  60a0              STR      r0,[r4,#8]
;;;129    }
0000ba  b00f              ADD      sp,sp,#0x3c
0000bc  bd30              POP      {r4,r5,pc}
;;;130    
                          ENDP

                  UART_init_TX_DMA PROC
;;;133    // DMA channel UARTx TX configuration 
;;;134    static void UART_init_TX_DMA(MDR_UART_TypeDef *MDR_UARTx, DMA_CtrlDataInitTypeDef *DMA_PriCtrlStr_p)
0000be  b51f              PUSH     {r0-r4,lr}
;;;135    {
;;;136    	uint32_t DMA_Channel_UARTn_TX = (MDR_UARTx == MDR_UART1) ? DMA_Channel_UART1_TX : DMA_Channel_UART2_TX;
0000c0  4adf              LDR      r2,|L1.1088|
0000c2  4290              CMP      r0,r2
0000c4  d101              BNE      |L1.202|
0000c6  2300              MOVS     r3,#0
0000c8  e000              B        |L1.204|
                  |L1.202|
0000ca  2302              MOVS     r3,#2
                  |L1.204|
;;;137    	DMA_ChannelInitTypeDef DMA_InitStr;
;;;138    	
;;;139    	// Setup Primary Control Data 
;;;140    	DMA_PriCtrlStr_p->DMA_SourceBaseAddr = 0;									// Will be set before channel start
0000cc  2200              MOVS     r2,#0
0000ce  600a              STR      r2,[r1,#0]
;;;141    	DMA_PriCtrlStr_p->DMA_DestBaseAddr = (uint32_t)(&(MDR_UARTx->DR));			
0000d0  6048              STR      r0,[r1,#4]
;;;142    	DMA_PriCtrlStr_p->DMA_SourceIncSize = DMA_SourceIncByte;
0000d2  608a              STR      r2,[r1,#8]
;;;143    	DMA_PriCtrlStr_p->DMA_DestIncSize = DMA_DestIncNo;
0000d4  f04f4040          MOV      r0,#0xc0000000
0000d8  60c8              STR      r0,[r1,#0xc]
;;;144    	DMA_PriCtrlStr_p->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
0000da  610a              STR      r2,[r1,#0x10]
;;;145    	DMA_PriCtrlStr_p->DMA_Mode = DMA_Mode_Basic; 
0000dc  2001              MOVS     r0,#1
0000de  6148              STR      r0,[r1,#0x14]
;;;146    	DMA_PriCtrlStr_p->DMA_CycleSize = 0;										// Will be set before channel start
0000e0  618a              STR      r2,[r1,#0x18]
;;;147    	DMA_PriCtrlStr_p->DMA_NumContinuous = DMA_Transfers_1;
0000e2  61ca              STR      r2,[r1,#0x1c]
;;;148    	DMA_PriCtrlStr_p->DMA_SourceProtCtrl = DMA_SourcePrivileged;				// ?
0000e4  0484              LSLS     r4,r0,#18
0000e6  620c              STR      r4,[r1,#0x20]
;;;149    	DMA_PriCtrlStr_p->DMA_DestProtCtrl = DMA_DestPrivileged;					// ?
0000e8  0544              LSLS     r4,r0,#21
0000ea  624c              STR      r4,[r1,#0x24]
;;;150    	
;;;151    	// Setup Channel Structure
;;;152    	DMA_InitStr.DMA_PriCtrlData = 0;										// Will be set before channel start
0000ec  9200              STR      r2,[sp,#0]
;;;153    	DMA_InitStr.DMA_AltCtrlData = 0;										// Not used
0000ee  9201              STR      r2,[sp,#4]
;;;154    	DMA_InitStr.DMA_ProtCtrl = 0;											// Not used
0000f0  9202              STR      r2,[sp,#8]
;;;155    	DMA_InitStr.DMA_Priority = DMA_Priority_High;
0000f2  f88d000c          STRB     r0,[sp,#0xc]
;;;156    	DMA_InitStr.DMA_UseBurst = DMA_BurstClear;								// Enable single words trasfer
0000f6  f88d200d          STRB     r2,[sp,#0xd]
;;;157    	DMA_InitStr.DMA_SelectDataStructure = DMA_CTRL_DATA_PRIMARY;
0000fa  f88d200e          STRB     r2,[sp,#0xe]
;;;158    	
;;;159    	// Init DMA channel
;;;160    	my_DMA_ChannelInit(DMA_Channel_UARTn_TX, &DMA_InitStr);
0000fe  4669              MOV      r1,sp
000100  b2d8              UXTB     r0,r3
000102  f7fffffe          BL       my_DMA_ChannelInit
;;;161    }
000106  bd1f              POP      {r0-r4,pc}
;;;162    
                          ENDP

                  parseKeyCode PROC
;;;163    
;;;164    uint16_t parseKeyCode(char *arg)
000108  b510              PUSH     {r4,lr}
;;;165    {
00010a  4604              MOV      r4,r0
;;;166    	if (strcmp(arg, "btn_esc") == 0)
00010c  a1ce              ADR      r1,|L1.1096|
00010e  4620              MOV      r0,r4
000110  f7fffffe          BL       strcmp
000114  b1a8              CBZ      r0,|L1.322|
;;;167    		return BTN_ESC;
;;;168    	else if (strcmp(arg, "btn_ok") == 0)
000116  a1ce              ADR      r1,|L1.1104|
000118  4620              MOV      r0,r4
00011a  f7fffffe          BL       strcmp
00011e  b190              CBZ      r0,|L1.326|
;;;169    		return BTN_OK;
;;;170    	else if (strcmp(arg, "btn_left") == 0)
000120  a1cd              ADR      r1,|L1.1112|
000122  4620              MOV      r0,r4
000124  f7fffffe          BL       strcmp
000128  b178              CBZ      r0,|L1.330|
;;;171    		return BTN_LEFT;
;;;172    	else if (strcmp(arg, "btn_right") == 0)
00012a  a1ce              ADR      r1,|L1.1124|
00012c  4620              MOV      r0,r4
00012e  f7fffffe          BL       strcmp
000132  b160              CBZ      r0,|L1.334|
;;;173    		return BTN_RIGHT;
;;;174    	else if (strcmp(arg, "btn_encoder") == 0)
000134  a1ce              ADR      r1,|L1.1136|
000136  4620              MOV      r0,r4
000138  f7fffffe          BL       strcmp
00013c  b148              CBZ      r0,|L1.338|
;;;175    		return BTN_ENCODER;	
;;;176    	else
;;;177    		return 0;
00013e  2000              MOVS     r0,#0
;;;178    }
000140  bd10              POP      {r4,pc}
                  |L1.322|
000142  2001              MOVS     r0,#1                 ;167
000144  bd10              POP      {r4,pc}
                  |L1.326|
000146  2008              MOVS     r0,#8                 ;169
000148  bd10              POP      {r4,pc}
                  |L1.330|
00014a  2002              MOVS     r0,#2                 ;171
00014c  bd10              POP      {r4,pc}
                  |L1.334|
00014e  2004              MOVS     r0,#4                 ;173
000150  bd10              POP      {r4,pc}
                  |L1.338|
000152  2010              MOVS     r0,#0x10              ;175
000154  bd10              POP      {r4,pc}
;;;179    
                          ENDP

                  parseKeyType PROC
;;;180    uint16_t parseKeyType(char *arg)
000156  b510              PUSH     {r4,lr}
;;;181    {
000158  4604              MOV      r4,r0
;;;182    	if (strcmp(arg, "down") == 0)
00015a  a1c8              ADR      r1,|L1.1148|
00015c  4620              MOV      r0,r4
00015e  f7fffffe          BL       strcmp
000162  b1d0              CBZ      r0,|L1.410|
;;;183    		return BTN_EVENT_DOWN;
;;;184    	else if (strcmp(arg, "up") == 0)
000164  a1c7              ADR      r1,|L1.1156|
000166  4620              MOV      r0,r4
000168  f7fffffe          BL       strcmp
00016c  b1b8              CBZ      r0,|L1.414|
;;;185    		return BTN_EVENT_UP;
;;;186    	else if (strcmp(arg, "up_short") == 0)
00016e  a1c6              ADR      r1,|L1.1160|
000170  4620              MOV      r0,r4
000172  f7fffffe          BL       strcmp
000176  b1a0              CBZ      r0,|L1.418|
;;;187    		return BTN_EVENT_UP_SHORT;
;;;188    	else if (strcmp(arg, "up_long") == 0)
000178  a1c6              ADR      r1,|L1.1172|
00017a  4620              MOV      r0,r4
00017c  f7fffffe          BL       strcmp
000180  b188              CBZ      r0,|L1.422|
;;;189    		return BTN_EVENT_UP_LONG;
;;;190    	else if (strcmp(arg, "hold") == 0)
000182  a1c6              ADR      r1,|L1.1180|
000184  4620              MOV      r0,r4
000186  f7fffffe          BL       strcmp
00018a  b170              CBZ      r0,|L1.426|
;;;191    		return BTN_EVENT_HOLD;
;;;192    	else if (strcmp(arg, "repeat") == 0)
00018c  a1c5              ADR      r1,|L1.1188|
00018e  4620              MOV      r0,r4
000190  f7fffffe          BL       strcmp
000194  b158              CBZ      r0,|L1.430|
;;;193    		return BTN_EVENT_REPEAT;
;;;194    	else
;;;195    		return 0;
000196  2000              MOVS     r0,#0
;;;196    }
000198  bd10              POP      {r4,pc}
                  |L1.410|
00019a  2001              MOVS     r0,#1                 ;183
00019c  bd10              POP      {r4,pc}
                  |L1.414|
00019e  2002              MOVS     r0,#2                 ;185
0001a0  bd10              POP      {r4,pc}
                  |L1.418|
0001a2  2003              MOVS     r0,#3                 ;187
0001a4  bd10              POP      {r4,pc}
                  |L1.422|
0001a6  2004              MOVS     r0,#4                 ;189
0001a8  bd10              POP      {r4,pc}
                  |L1.426|
0001aa  2005              MOVS     r0,#5                 ;191
0001ac  bd10              POP      {r4,pc}
                  |L1.430|
0001ae  2006              MOVS     r0,#6                 ;193
0001b0  bd10              POP      {r4,pc}
;;;197    
                          ENDP

                  UART_sendStrAlloc PROC
;;;447    
;;;448    static void UART_sendStrAlloc(char *str)
0001b2  b51c              PUSH     {r2-r4,lr}
;;;449    {
0001b4  4604              MOV      r4,r0
;;;450    	uart_transmiter_msg_t msg;
;;;451    	uint32_t str_length = strlen(str);
0001b6  4620              MOV      r0,r4
0001b8  f7fffffe          BL       strlen
;;;452    	msg.pdata = pvPortMalloc(str_length);		// heap_3 or heap_4 should be used
0001bc  f7fffffe          BL       pvPortMalloc
0001c0  9001              STR      r0,[sp,#4]
;;;453    	if (msg.pdata == 0)
0001c2  9801              LDR      r0,[sp,#4]
0001c4  2800              CMP      r0,#0
0001c6  d012              BEQ      |L1.494|
;;;454    		return;
;;;455    	strcpy(msg.pdata, str);
0001c8  4621              MOV      r1,r4
0001ca  9801              LDR      r0,[sp,#4]
0001cc  f7fffffe          BL       strcpy
;;;456    	msg.type = SEND_ALLOCATED_STRING;
0001d0  2002              MOVS     r0,#2
0001d2  f8ad0000          STRH     r0,[sp,#0]
;;;457    	if (xQueueSendToBack(xQueueUART1TX, &msg, 0) == errQUEUE_FULL)
0001d6  48b5              LDR      r0,|L1.1196|
0001d8  2300              MOVS     r3,#0
0001da  461a              MOV      r2,r3
0001dc  4669              MOV      r1,sp
0001de  6800              LDR      r0,[r0,#0]  ; xQueueUART1TX
0001e0  f7fffffe          BL       xQueueGenericSend
0001e4  2800              CMP      r0,#0
0001e6  d102              BNE      |L1.494|
;;;458    		vPortFree(msg.pdata);
0001e8  9801              LDR      r0,[sp,#4]
0001ea  f7fffffe          BL       vPortFree
                  |L1.494|
;;;459    }
0001ee  bd1c              POP      {r2-r4,pc}
;;;460    
                          ENDP

                  vTaskUARTReceiver PROC
;;;200    
;;;201    void vTaskUARTReceiver(void *pvParameters) 
0001f0  b0bc              SUB      sp,sp,#0xf0
;;;202    {
;;;203    	char received_msg[RX_MESSAGE_MAX_LENGTH];
;;;204    	uint16_t msg_length = 0;
0001f2  2400              MOVS     r4,#0
;;;205    	char *argv[MAX_WORDS_IN_MESSAGE];		// Array of pointers to separate words
;;;206    	uint16_t argc = 0;						// Count of words in message
0001f4  2500              MOVS     r5,#0
;;;207    	char temp_char;
;;;208    	uint16_t uart_rx_word;
;;;209    	uint16_t search_for_word = 1;
0001f6  2601              MOVS     r6,#1
;;;210    	
;;;211    	uint16_t keyCmdType;
;;;212    	uint16_t keyCmdCode;
;;;213    	
;;;214    	// Debug
;;;215    	uint16_t i;
;;;216    	uint32_t temp32u;
;;;217    	
;;;218    	char temp_str[50];
;;;219    	
;;;220    	portTickType lastExecutionTime = xTaskGetTickCount();
0001f8  f7fffffe          BL       xTaskGetTickCount
0001fc  9005              STR      r0,[sp,#0x14]
;;;221    	dispatch_incoming_msg_t dispatcher_msg;
;;;222    	uart_transmiter_msg_t transmitter_msg;
;;;223    	
;;;224    	// Setup and init receiver buffer
;;;225    	UART_Init_RX_buffer(&uart1_rx_dma_buffer, uart1_rx_data_buff, RX_BUFFER_SIZE);
0001fe  48ab              LDR      r0,|L1.1196|
000200  22c8              MOVS     r2,#0xc8
000202  49ab              LDR      r1,|L1.1200|
000204  3008              ADDS     r0,r0,#8
000206  f7fffffe          BL       UART_Init_RX_buffer
;;;226    	
;;;227    	// Setup DMA channel
;;;228    	UART_init_RX_DMA(MDR_UART1, &uart1_rx_dma_buffer, UART1_RX_saved_TCB);
00020a  49a8              LDR      r1,|L1.1196|
00020c  4f8c              LDR      r7,|L1.1088|
00020e  4aa9              LDR      r2,|L1.1204|
000210  3108              ADDS     r1,r1,#8
000212  4638              MOV      r0,r7
000214  f7fffffe          BL       UART_init_RX_DMA
;;;229    	// Enable DMA channel
;;;230    	DMA_Cmd(DMA_Channel_UART1_RX, ENABLE);
000218  2101              MOVS     r1,#1
00021a  4608              MOV      r0,r1
00021c  f7fffffe          BL       DMA_Cmd
;;;231    	// Enable UARTn DMA Rx request
;;;232    	UART_DMACmd(MDR_UART1,UART_DMA_RXE, ENABLE);
000220  2201              MOVS     r2,#1
000222  4611              MOV      r1,r2
000224  4638              MOV      r0,r7
000226  f7fffffe          BL       UART_DMACmd
00022a  f10d08a0          ADD      r8,sp,#0xa0           ;203
00022e  46a1              MOV      r9,r4                 ;204
000230  2701              MOVS     r7,#1                 ;209
                  |L1.562|
;;;233    	
;;;234    	
;;;235    	//HW_NVIC_check();		// FIXME - debug
;;;236    	
;;;237    	
;;;238    	while(1)
;;;239    	{
;;;240    		/////////////////////////
;;;241    	/*	while(1)
;;;242    		{
;;;243    			vTaskDelayUntil(&lastExecutionTime, 5);
;;;244    			
;;;245    			transmitter_msg.type = UNKNOWN_CMD;
;;;246    			xQueueSendToBack(xQueueUART1TX, &transmitter_msg, 0); 
;;;247    			xQueueSendToBack(xQueueUART1TX, &transmitter_msg, 0); 
;;;248    			xQueueSendToBack(xQueueUART1TX, &transmitter_msg, 0); 
;;;249    			xQueueSendToBack(xQueueUART1TX, &transmitter_msg, 0); 
;;;250    			xQueueSendToBack(xQueueUART1TX, &transmitter_msg, 0); 
;;;251    		}
;;;252    		*/
;;;253    		/////////////////////////
;;;254    		vTaskDelayUntil(&lastExecutionTime, 5);		// 10ms period
000232  2105              MOVS     r1,#5
000234  a805              ADD      r0,sp,#0x14
000236  f7fffffe          BL       vTaskDelayUntil
;;;255    
;;;256    		// Read full message from buffer
;;;257    		while(UART_Get_from_RX_buffer(&uart1_rx_dma_buffer, &uart_rx_word))
00023a  e07e              B        |L1.826|
                  |L1.572|
;;;258    		{
;;;259    			if ((uart_rx_word & ( (1<<UART_Data_BE) | (1<<UART_Data_PE) | (1<<UART_Data_FE) )) != 0)
00023c  f8bd004c          LDRH     r0,[sp,#0x4c]
000240  f4106fe0          TST      r0,#0x700
000244  d179              BNE      |L1.826|
;;;260    				continue;
;;;261    				
;;;262    			temp_char = (char)(uart_rx_word);
000246  b2c0              UXTB     r0,r0
;;;263    			
;;;264    			if (temp_char == SPACING_SYMBOL)
000248  2820              CMP      r0,#0x20
00024a  d006              BEQ      |L1.602|
;;;265    			{
;;;266    				received_msg[msg_length++] = '\0';
;;;267    				search_for_word = 1;
;;;268    			}
;;;269    			else if ((temp_char == MESSAGE_END_SYMBOL) || (temp_char == MESSAGE_NEW_LINE))
00024c  280d              CMP      r0,#0xd
00024e  d00b              BEQ      |L1.616|
000250  280a              CMP      r0,#0xa
000252  d009              BEQ      |L1.616|
;;;270    			{
;;;271    				received_msg[msg_length++] = '\0';
;;;272    			}
;;;273    			else
;;;274    			{
;;;275    				// Normal char
;;;276    				if (search_for_word == 1)
000254  2e01              CMP      r6,#1
000256  d00d              BEQ      |L1.628|
000258  e015              B        |L1.646|
                  |L1.602|
00025a  4621              MOV      r1,r4                 ;266
00025c  1c64              ADDS     r4,r4,#1              ;266
00025e  b2a4              UXTH     r4,r4                 ;266
000260  f8089001          STRB     r9,[r8,r1]            ;266
000264  2601              MOVS     r6,#1                 ;267
000266  e013              B        |L1.656|
                  |L1.616|
000268  4621              MOV      r1,r4                 ;271
00026a  1c64              ADDS     r4,r4,#1              ;271
00026c  b2a4              UXTH     r4,r4                 ;271
00026e  f8089001          STRB     r9,[r8,r1]            ;271
000272  e00d              B        |L1.656|
                  |L1.628|
;;;277    				{
;;;278    					argv[argc++] = &received_msg[msg_length];		// Found start position of a word
000274  4629              MOV      r1,r5
000276  ab14              ADD      r3,sp,#0x50
000278  eb080204          ADD      r2,r8,r4
00027c  1c6d              ADDS     r5,r5,#1
00027e  b2ad              UXTH     r5,r5
000280  f8432021          STR      r2,[r3,r1,LSL #2]
;;;279    					search_for_word = 0;
000284  2600              MOVS     r6,#0
                  |L1.646|
;;;280    				}
;;;281    				received_msg[msg_length++] = temp_char;
000286  4621              MOV      r1,r4
000288  1c64              ADDS     r4,r4,#1
00028a  b2a4              UXTH     r4,r4
00028c  f8080001          STRB     r0,[r8,r1]
                  |L1.656|
;;;282    			}
;;;283    			
;;;284    			
;;;285    			if ((temp_char == MESSAGE_END_SYMBOL) || (temp_char == MESSAGE_NEW_LINE) || (msg_length == RX_MESSAGE_MAX_LENGTH))
000290  280d              CMP      r0,#0xd
000292  d003              BEQ      |L1.668|
000294  280a              CMP      r0,#0xa
000296  d001              BEQ      |L1.668|
000298  2c50              CMP      r4,#0x50
00029a  d14e              BNE      |L1.826|
                  |L1.668|
;;;286    			{
;;;287    				// Received full message OR maximum allowed message length is reached
;;;288    				// Parse message
;;;289    				if (argc != 0)
00029c  2d00              CMP      r5,#0
00029e  d049              BEQ      |L1.820|
;;;290    				{
;;;291    					dispatcher_msg.type = 0;
0002a0  f8cd900c          STR      r9,[sp,#0xc]
;;;292    					transmitter_msg.type = RESPONSE_OK;
0002a4  f44f7080          MOV      r0,#0x100
0002a8  f8ad0004          STRH     r0,[sp,#4]
;;;293    					
;;;294    					
;;;295    					//---------- Converter control -----------//
;;;296    					if (strcmp(argv[0], "on") == 0)							// Turn converter ON	
0002ac  a182              ADR      r1,|L1.1208|
0002ae  9814              LDR      r0,[sp,#0x50]
0002b0  f7fffffe          BL       strcmp
0002b4  2800              CMP      r0,#0
0002b6  d049              BEQ      |L1.844|
;;;297    					{
;;;298    						dispatcher_msg.type = DP_CONVERTER_TURN_ON;
;;;299    					}
;;;300    					else if (strcmp(argv[0], "off") == 0)					// Turn converter OFF
0002b8  a180              ADR      r1,|L1.1212|
0002ba  9814              LDR      r0,[sp,#0x50]
0002bc  f7fffffe          BL       strcmp
0002c0  2800              CMP      r0,#0
0002c2  d045              BEQ      |L1.848|
;;;301    					{
;;;302    						dispatcher_msg.type = DP_CONVERTER_TURN_OFF;
;;;303    					}
;;;304    					else if (strcmp(argv[0], "set_voltage") == 0)			// Setting converter voltage
0002c4  a17e              ADR      r1,|L1.1216|
0002c6  9814              LDR      r0,[sp,#0x50]
0002c8  f7fffffe          BL       strcmp
0002cc  2800              CMP      r0,#0
0002ce  d042              BEQ      |L1.854|
;;;305    					{
;;;306    						if (argc < 2)
;;;307    						{
;;;308    							transmitter_msg.type = SEND_STRING;
;;;309    							transmitter_msg.pdata = "ERR: missing argument [mV]\r";
;;;310    						}
;;;311    						else
;;;312    						{
;;;313    							// Second argument is voltage value [mV]
;;;314    							dispatcher_msg.type = DP_CONVERTER_SET_VOLTAGE;
;;;315    							dispatcher_msg.data = strtoul(argv[1], 0, 0);
;;;316    						}
;;;317    					}
;;;318    					else if (strcmp(argv[0], "set_current") == 0)			// Setting converter current
0002d0  a17e              ADR      r1,|L1.1228|
0002d2  9814              LDR      r0,[sp,#0x50]
0002d4  f7fffffe          BL       strcmp
0002d8  2800              CMP      r0,#0
0002da  d04c              BEQ      |L1.886|
;;;319    					{
;;;320    						if (argc < 2)
;;;321    						{
;;;322    							transmitter_msg.type = SEND_STRING;
;;;323    							transmitter_msg.pdata = "ERR: missing argument [mA]\r";
;;;324    						}
;;;325    						else
;;;326    						{
;;;327    							// Second argument is current value [mA]
;;;328    							dispatcher_msg.type = DP_CONVERTER_SET_CURRENT;
;;;329    							dispatcher_msg.data = strtoul(argv[1], 0, 0);
;;;330    						}
;;;331    					}
;;;332    					else if (strcmp(argv[0], "set_current_limit") == 0)			// Setting converter current limit
0002dc  a17e              ADR      r1,|L1.1240|
0002de  9814              LDR      r0,[sp,#0x50]
0002e0  f7fffffe          BL       strcmp
0002e4  2800              CMP      r0,#0
0002e6  d056              BEQ      |L1.918|
;;;333    					{
;;;334    						if (argc < 2)
;;;335    						{
;;;336    							transmitter_msg.type = SEND_STRING;
;;;337    							transmitter_msg.pdata = "ERR: missing argument (20/40)[A]\r";
;;;338    						}
;;;339    						else
;;;340    						{
;;;341    							// Second argument is current limit value [A]
;;;342    							dispatcher_msg.type = DP_CONVERTER_SET_CURRENT_LIMIT;
;;;343    							dispatcher_msg.data = strtoul(argv[1], 0, 0);
;;;344    						}
;;;345    					}
;;;346    					//----- button and encoder emulation -----//	
;;;347    					else if (strcmp(argv[0], "key") == 0)				// KEY command
0002e8  a180              ADR      r1,|L1.1260|
0002ea  9814              LDR      r0,[sp,#0x50]
0002ec  f7fffffe          BL       strcmp
0002f0  2800              CMP      r0,#0
0002f2  d060              BEQ      |L1.950|
;;;348    					{
;;;349    						// There should be 2 parameters - key code specifier and key event specifier
;;;350    						if (argc < 3)
;;;351    						{
;;;352    							transmitter_msg.type = SEND_STRING;
;;;353    							transmitter_msg.pdata = "ERR: missing key command arguments\r";
;;;354    						}
;;;355    						else
;;;356    						{
;;;357    							keyCmdCode = parseKeyType(argv[1]);
;;;358    							if (keyCmdCode == 0)
;;;359    							{
;;;360    								transmitter_msg.type = SEND_STRING;
;;;361    								transmitter_msg.pdata = "ERR: unknown key code\r";
;;;362    							}
;;;363    							else
;;;364    							{
;;;365    								keyCmdType = parseKeyCode(argv[2]);
;;;366    								if (keyCmdType == 0)
;;;367    								{
;;;368    									transmitter_msg.type = SEND_STRING;
;;;369    									transmitter_msg.pdata = "ERR: unknown key type\r";
;;;370    								}
;;;371    								else
;;;372    								{
;;;373    									// Send parsed key command to dispatcher
;;;374    									// msg.data[31:16] = key code, 	msg.data[15:0] = key event type
;;;375    									dispatcher_msg.type = DISPATCHER_EMULATE_BUTTON;
;;;376    									dispatcher_msg.data = ((uint32_t)keyCmdCode << 16) | keyCmdType;
;;;377    								}
;;;378    							}
;;;379    						}
;;;380    					}
;;;381    					else if (strcmp(argv[0], "encoder_delta") == 0)			// Encoder delta
0002f4  a17e              ADR      r1,|L1.1264|
0002f6  9814              LDR      r0,[sp,#0x50]
0002f8  f7fffffe          BL       strcmp
0002fc  2800              CMP      r0,#0
0002fe  d07c              BEQ      |L1.1018|
;;;382    					{
;;;383    						if (argc < 2)
;;;384    						{
;;;385    							transmitter_msg.type = SEND_STRING;
;;;386    							transmitter_msg.pdata = "ERR: missing argument [ticks]\r";
;;;387    						}
;;;388    						else
;;;389    						{
;;;390    							// Second argument is encoder ticks (signed)
;;;391    							dispatcher_msg.type = DP_EMU_ENC_DELTA;
;;;392    							dispatcher_msg.data = (uint32_t)strtol(argv[1], 0, 0);
;;;393    						}
;;;394    					}
;;;395    					//----------------- misc -----------------//
;;;396    					else if (strcmp(argv[0], "get_time_profiling") == 0)			// Time profiling
000300  a17f              ADR      r1,|L1.1280|
000302  9814              LDR      r0,[sp,#0x50]
000304  f7fffffe          BL       strcmp
000308  2800              CMP      r0,#0
00030a  d06b              BEQ      |L1.996|
;;;397    					{
;;;398    						// FIXME
;;;399    						sprintf(temp_str,"Systick hook max ticks: %d\r",time_profile.max_ticks_in_Systick_hook);
;;;400    						UART_sendStrAlloc(temp_str);
;;;401    						sprintf(temp_str,"Timer2 ISR max ticks: %d\r",time_profile.max_ticks_in_Timer2_ISR);
;;;402    						UART_sendStrAlloc(temp_str);
;;;403    					}
;;;404    					//------------ unknown command -----------//
;;;405    					else
;;;406    					{
;;;407    						transmitter_msg.type = UNKNOWN_CMD;
00030c  f2401001          MOV      r0,#0x101
000310  f8ad0004          STRH     r0,[sp,#4]
                  |L1.788|
;;;408    					}
;;;409    					
;;;410    					//----------------------------------------//
;;;411    					
;;;412    					// Send result to dispatcher
;;;413    					if (dispatcher_msg.type)
000314  9803              LDR      r0,[sp,#0xc]
000316  b130              CBZ      r0,|L1.806|
;;;414    						xQueueSendToBack(xQueueDispatcher, &dispatcher_msg, 0);
000318  487e              LDR      r0,|L1.1300|
00031a  2300              MOVS     r3,#0
00031c  461a              MOV      r2,r3
00031e  a903              ADD      r1,sp,#0xc
000320  6800              LDR      r0,[r0,#0]  ; xQueueDispatcher
000322  f7fffffe          BL       xQueueGenericSend
                  |L1.806|
;;;415    					
;;;416    					// Send response over UART
;;;417    					xQueueSendToBack(xQueueUART1TX, &transmitter_msg, 0); 
000326  4861              LDR      r0,|L1.1196|
000328  2300              MOVS     r3,#0
00032a  461a              MOV      r2,r3
00032c  a901              ADD      r1,sp,#4
00032e  6800              LDR      r0,[r0,#0]  ; xQueueUART1TX
000330  f7fffffe          BL       xQueueGenericSend
                  |L1.820|
;;;418    			
;;;419    				}			
;;;420    				msg_length = 0;
000334  2400              MOVS     r4,#0
;;;421    				argc = 0;
000336  2500              MOVS     r5,#0
;;;422    				search_for_word = 1;
000338  2601              MOVS     r6,#1
                  |L1.826|
00033a  485c              LDR      r0,|L1.1196|
00033c  a913              ADD      r1,sp,#0x4c           ;257
00033e  3008              ADDS     r0,r0,#8              ;257
000340  f7fffffe          BL       UART_Get_from_RX_buffer
000344  2800              CMP      r0,#0                 ;257
000346  f43faf74          BEQ      |L1.562|
00034a  e777              B        |L1.572|
                  |L1.844|
00034c  9703              STR      r7,[sp,#0xc]          ;298
00034e  e7e1              B        |L1.788|
                  |L1.848|
000350  2002              MOVS     r0,#2                 ;302
000352  9003              STR      r0,[sp,#0xc]          ;302
000354  e7de              B        |L1.788|
                  |L1.854|
000356  2d02              CMP      r5,#2                 ;306
000358  d204              BCS      |L1.868|
00035a  f8ad7004          STRH     r7,[sp,#4]            ;308
00035e  a06e              ADR      r0,|L1.1304|
000360  9002              STR      r0,[sp,#8]            ;309
000362  e7d7              B        |L1.788|
                  |L1.868|
000364  2003              MOVS     r0,#3                 ;314
000366  9003              STR      r0,[sp,#0xc]          ;314
000368  2200              MOVS     r2,#0                 ;315
00036a  4611              MOV      r1,r2                 ;315
00036c  9815              LDR      r0,[sp,#0x54]         ;315
00036e  f7fffffe          BL       strtoul
000372  9004              STR      r0,[sp,#0x10]         ;315
000374  e7ce              B        |L1.788|
                  |L1.886|
000376  2d02              CMP      r5,#2                 ;320
000378  d204              BCS      |L1.900|
00037a  f8ad7004          STRH     r7,[sp,#4]            ;322
00037e  a06d              ADR      r0,|L1.1332|
000380  9002              STR      r0,[sp,#8]            ;323
000382  e7c7              B        |L1.788|
                  |L1.900|
000384  2004              MOVS     r0,#4                 ;328
000386  9003              STR      r0,[sp,#0xc]          ;328
000388  2200              MOVS     r2,#0                 ;329
00038a  4611              MOV      r1,r2                 ;329
00038c  9815              LDR      r0,[sp,#0x54]         ;329
00038e  f7fffffe          BL       strtoul
000392  9004              STR      r0,[sp,#0x10]         ;329
000394  e7be              B        |L1.788|
                  |L1.918|
000396  2d02              CMP      r5,#2                 ;334
000398  d204              BCS      |L1.932|
00039a  f8ad7004          STRH     r7,[sp,#4]            ;336
00039e  a06c              ADR      r0,|L1.1360|
0003a0  9002              STR      r0,[sp,#8]            ;337
0003a2  e7b7              B        |L1.788|
                  |L1.932|
0003a4  2005              MOVS     r0,#5                 ;342
0003a6  9003              STR      r0,[sp,#0xc]          ;342
0003a8  2200              MOVS     r2,#0                 ;343
0003aa  4611              MOV      r1,r2                 ;343
0003ac  9815              LDR      r0,[sp,#0x54]         ;343
0003ae  f7fffffe          BL       strtoul
0003b2  9004              STR      r0,[sp,#0x10]         ;343
0003b4  e7ae              B        |L1.788|
                  |L1.950|
0003b6  2d03              CMP      r5,#3                 ;350
0003b8  d204              BCS      |L1.964|
0003ba  f8ad7004          STRH     r7,[sp,#4]            ;352
0003be  a06d              ADR      r0,|L1.1396|
0003c0  9002              STR      r0,[sp,#8]            ;353
0003c2  e7a7              B        |L1.788|
                  |L1.964|
0003c4  9815              LDR      r0,[sp,#0x54]         ;357
0003c6  f7fffffe          BL       parseKeyType
0003ca  4604              MOV      r4,r0                 ;357
0003cc  b15c              CBZ      r4,|L1.998|
0003ce  9816              LDR      r0,[sp,#0x58]         ;365
0003d0  f7fffffe          BL       parseKeyCode
0003d4  b160              CBZ      r0,|L1.1008|
0003d6  2108              MOVS     r1,#8                 ;375
0003d8  9103              STR      r1,[sp,#0xc]          ;375
0003da  ea404004          ORR      r0,r0,r4,LSL #16      ;376
0003de  9004              STR      r0,[sp,#0x10]         ;376
0003e0  e798              B        |L1.788|
0003e2  e00a              B        |L1.1018|
                  |L1.996|
0003e4  e019              B        |L1.1050|
                  |L1.998|
0003e6  f8ad7004          STRH     r7,[sp,#4]            ;360
0003ea  a06b              ADR      r0,|L1.1432|
0003ec  9002              STR      r0,[sp,#8]            ;361
0003ee  e791              B        |L1.788|
                  |L1.1008|
0003f0  f8ad7004          STRH     r7,[sp,#4]            ;368
0003f4  a06e              ADR      r0,|L1.1456|
0003f6  9002              STR      r0,[sp,#8]            ;369
0003f8  e78c              B        |L1.788|
                  |L1.1018|
0003fa  2d02              CMP      r5,#2                 ;383
0003fc  d204              BCS      |L1.1032|
0003fe  f8ad7004          STRH     r7,[sp,#4]            ;385
000402  a071              ADR      r0,|L1.1480|
000404  9002              STR      r0,[sp,#8]            ;386
000406  e785              B        |L1.788|
                  |L1.1032|
000408  2007              MOVS     r0,#7                 ;391
00040a  9003              STR      r0,[sp,#0xc]          ;391
00040c  2200              MOVS     r2,#0                 ;392
00040e  4611              MOV      r1,r2                 ;392
000410  9815              LDR      r0,[sp,#0x54]         ;392
000412  f7fffffe          BL       strtol
000416  9004              STR      r0,[sp,#0x10]         ;392
000418  e77c              B        |L1.788|
                  |L1.1050|
00041a  4c73              LDR      r4,|L1.1512|
00041c  a173              ADR      r1,|L1.1516|
00041e  a806              ADD      r0,sp,#0x18           ;399
000420  6822              LDR      r2,[r4,#0]            ;399  ; time_profile
000422  f7fffffe          BL       __2sprintf
000426  a806              ADD      r0,sp,#0x18           ;400
000428  f7fffffe          BL       UART_sendStrAlloc
00042c  a176              ADR      r1,|L1.1544|
00042e  a806              ADD      r0,sp,#0x18           ;401
000430  6862              LDR      r2,[r4,#4]            ;401  ; time_profile
000432  f7fffffe          BL       __2sprintf
000436  a806              ADD      r0,sp,#0x18           ;402
000438  f7fffffe          BL       UART_sendStrAlloc
00043c  e76a              B        |L1.788|
00043e  0000              DCW      0x0000
                  |L1.1088|
                          DCD      0x40030000
                  |L1.1092|
                          DCD      DMA_ControlTable
                  |L1.1096|
000448  62746e5f          DCB      "btn_esc",0
00044c  65736300
                  |L1.1104|
000450  62746e5f          DCB      "btn_ok",0
000454  6f6b00  
000457  00                DCB      0
                  |L1.1112|
000458  62746e5f          DCB      "btn_left",0
00045c  6c656674
000460  00      
000461  00                DCB      0
000462  00                DCB      0
000463  00                DCB      0
                  |L1.1124|
000464  62746e5f          DCB      "btn_right",0
000468  72696768
00046c  7400    
00046e  00                DCB      0
00046f  00                DCB      0
                  |L1.1136|
000470  62746e5f          DCB      "btn_encoder",0
000474  656e636f
000478  64657200
                  |L1.1148|
00047c  646f776e          DCB      "down",0
000480  00      
000481  00                DCB      0
000482  00                DCB      0
000483  00                DCB      0
                  |L1.1156|
000484  757000            DCB      "up",0
000487  00                DCB      0
                  |L1.1160|
000488  75705f73          DCB      "up_short",0
00048c  686f7274
000490  00      
000491  00                DCB      0
000492  00                DCB      0
000493  00                DCB      0
                  |L1.1172|
000494  75705f6c          DCB      "up_long",0
000498  6f6e6700
                  |L1.1180|
00049c  686f6c64          DCB      "hold",0
0004a0  00      
0004a1  00                DCB      0
0004a2  00                DCB      0
0004a3  00                DCB      0
                  |L1.1188|
0004a4  72657065          DCB      "repeat",0
0004a8  617400  
0004ab  00                DCB      0
                  |L1.1196|
                          DCD      ||area_number.7||
                  |L1.1200|
                          DCD      ||.bss||+0x64
                  |L1.1204|
                          DCD      ||.bss||+0x1f4
                  |L1.1208|
0004b8  6f6e00            DCB      "on",0
0004bb  00                DCB      0
                  |L1.1212|
0004bc  6f666600          DCB      "off",0
                  |L1.1216|
0004c0  7365745f          DCB      "set_voltage",0
0004c4  766f6c74
0004c8  61676500
                  |L1.1228|
0004cc  7365745f          DCB      "set_current",0
0004d0  63757272
0004d4  656e7400
                  |L1.1240|
0004d8  7365745f          DCB      "set_current_limit",0
0004dc  63757272
0004e0  656e745f
0004e4  6c696d69
0004e8  7400    
0004ea  00                DCB      0
0004eb  00                DCB      0
                  |L1.1260|
0004ec  6b657900          DCB      "key",0
                  |L1.1264|
0004f0  656e636f          DCB      "encoder_delta",0
0004f4  6465725f
0004f8  64656c74
0004fc  6100    
0004fe  00                DCB      0
0004ff  00                DCB      0
                  |L1.1280|
000500  6765745f          DCB      "get_time_profiling",0
000504  74696d65
000508  5f70726f
00050c  66696c69
000510  6e6700  
000513  00                DCB      0
                  |L1.1300|
                          DCD      xQueueDispatcher
                  |L1.1304|
000518  4552523a          DCB      "ERR: missing argument [mV]\r",0
00051c  206d6973
000520  73696e67
000524  20617267
000528  756d656e
00052c  74205b6d
000530  565d0d00
                  |L1.1332|
000534  4552523a          DCB      "ERR: missing argument [mA]\r",0
000538  206d6973
00053c  73696e67
000540  20617267
000544  756d656e
000548  74205b6d
00054c  415d0d00
                  |L1.1360|
000550  4552523a          DCB      "ERR: missing argument (20/40)[A]\r",0
000554  206d6973
000558  73696e67
00055c  20617267
000560  756d656e
000564  74202832
000568  302f3430
00056c  295b415d
000570  0d00    
000572  00                DCB      0
000573  00                DCB      0
                  |L1.1396|
000574  4552523a          DCB      "ERR: missing key command arguments\r",0
000578  206d6973
00057c  73696e67
000580  206b6579
000584  20636f6d
000588  6d616e64
00058c  20617267
000590  756d656e
000594  74730d00
                  |L1.1432|
000598  4552523a          DCB      "ERR: unknown key code\r",0
00059c  20756e6b
0005a0  6e6f776e
0005a4  206b6579
0005a8  20636f64
0005ac  650d00  
0005af  00                DCB      0
                  |L1.1456|
0005b0  4552523a          DCB      "ERR: unknown key type\r",0
0005b4  20756e6b
0005b8  6e6f776e
0005bc  206b6579
0005c0  20747970
0005c4  650d00  
0005c7  00                DCB      0
                  |L1.1480|
0005c8  4552523a          DCB      "ERR: missing argument [ticks]\r",0
0005cc  206d6973
0005d0  73696e67
0005d4  20617267
0005d8  756d656e
0005dc  74205b74
0005e0  69636b73
0005e4  5d0d00  
0005e7  00                DCB      0
                  |L1.1512|
                          DCD      time_profile
                  |L1.1516|
0005ec  53797374          DCB      "Systick hook max ticks: %d\r",0
0005f0  69636b20
0005f4  686f6f6b
0005f8  206d6178
0005fc  20746963
000600  6b733a20
000604  25640d00
                  |L1.1544|
000608  54696d65          DCB      "Timer2 ISR max ticks: %d\r",0
00060c  72322049
000610  5352206d
000614  61782074
000618  69636b73
00061c  3a202564
000620  0d00    
000622  00                DCB      0
000623  00                DCB      0
                          ENDP

                  vTaskUARTTransmitter PROC
;;;463    
;;;464    void vTaskUARTTransmitter(void *pvParameters) 
000624  b08c              SUB      sp,sp,#0x30
;;;465    {
;;;466    	uart_transmiter_msg_t income_msg;
;;;467    	//uint32_t src_address;
;;;468    	char *string_to_send;
;;;469    	uint32_t n;
;;;470    	
;;;471    	DMA_CtrlDataInitTypeDef DMA_PriCtrlStr;
;;;472    	
;;;473    	// Setup DMA channel
;;;474    	UART_init_TX_DMA(MDR_UART1, &DMA_PriCtrlStr);
000626  f8df9130          LDR      r9,|L1.1880|
00062a  4669              MOV      r1,sp
00062c  4648              MOV      r0,r9
00062e  f7fffffe          BL       UART_init_TX_DMA
;;;475    	
;;;476    	// Initialize OS items
;;;477    	xQueueUART1TX = xQueueCreate( 10, sizeof( uart_transmiter_msg_t ) );
000632  2200              MOVS     r2,#0
000634  2108              MOVS     r1,#8
000636  200a              MOVS     r0,#0xa
000638  f7fffffe          BL       xQueueGenericCreate
00063c  4e47              LDR      r6,|L1.1884|
00063e  6030              STR      r0,[r6,#0]  ; xQueueUART1TX
;;;478    	if( xQueueUART1TX == 0 )
000640  b3b8              CBZ      r0,|L1.1714|
;;;479    	{
;;;480    		// Queue was not created and must not be used.
;;;481    		while(1);
;;;482    	}
;;;483    	
;;;484    	vSemaphoreCreateBinary( xSemaphoreUART1TX );
000642  2203              MOVS     r2,#3
000644  2100              MOVS     r1,#0
000646  2001              MOVS     r0,#1
000648  f7fffffe          BL       xQueueGenericCreate
00064c  6070              STR      r0,[r6,#4]  ; xSemaphoreUART1TX
00064e  b120              CBZ      r0,|L1.1626|
000650  2300              MOVS     r3,#0
000652  461a              MOV      r2,r3
000654  4619              MOV      r1,r3
000656  f7fffffe          BL       xQueueGenericSend
                  |L1.1626|
;;;485    	if( xSemaphoreUART1TX == 0 )
00065a  6870              LDR      r0,[r6,#4]  ; xSemaphoreUART1TX
00065c  b350              CBZ      r0,|L1.1716|
;;;486        {
;;;487            while(1);
;;;488        }
;;;489    	
;;;490    	xSemaphoreTake(xSemaphoreUART1TX, 0);	
00065e  2300              MOVS     r3,#0
000660  461a              MOV      r2,r3
000662  4619              MOV      r1,r3
000664  f7fffffe          BL       xQueueGenericReceive
;;;491    	
;;;492    	while(1)
;;;493    	{
;;;494    		xQueueReceive(xQueueUART1TX, &income_msg, portMAX_DELAY);
;;;495    		if ( (income_msg.type == SEND_STRING) || (income_msg.type == SEND_ALLOCATED_STRING) )
;;;496    		{
;;;497    			string_to_send = income_msg.pdata;
;;;498    		}
;;;499    		else if (income_msg.type == RESPONSE_OK)
;;;500    		{
;;;501    			string_to_send = (char *)_resp_OK;
;;;502    		}
;;;503    		else //if (income_msg.type == UNKNOWN_CMD)
;;;504    		{
;;;505    			string_to_send = (char *)_resp_UNKN_CMD;
;;;506    		}
;;;507    		
;;;508    		// Get number of chars to transmit
;;;509    		n = strlen(string_to_send);
;;;510    		// DMA cannot read from program memory, copy data to temporary buffer
;;;511    		if ((uint32_t)string_to_send < 0x20000000UL)
000668  f04f5800          MOV      r8,#0x20000000
00066c  f04f37ff          MOV      r7,#0xffffffff        ;494
                  |L1.1648|
000670  2300              MOVS     r3,#0                 ;494
000672  463a              MOV      r2,r7                 ;494
000674  a90a              ADD      r1,sp,#0x28           ;494
000676  6830              LDR      r0,[r6,#0]            ;494  ; xQueueUART1TX
000678  f7fffffe          BL       xQueueGenericReceive
00067c  f8bd0028          LDRH     r0,[sp,#0x28]         ;495
000680  2801              CMP      r0,#1                 ;495
000682  d01a              BEQ      |L1.1722|
000684  2802              CMP      r0,#2                 ;495
000686  d018              BEQ      |L1.1722|
000688  f5b07f80          CMP      r0,#0x100             ;499
00068c  d017              BEQ      |L1.1726|
00068e  4c34              LDR      r4,|L1.1888|
                  |L1.1680|
000690  4620              MOV      r0,r4                 ;509
000692  f7fffffe          BL       strlen
000696  4605              MOV      r5,r0                 ;509
000698  4544              CMP      r4,r8
00069a  d213              BCS      |L1.1732|
;;;512    		{
;;;513    			if (n > TX_BUFFER_SIZE)
00069c  2d64              CMP      r5,#0x64
00069e  d900              BLS      |L1.1698|
;;;514    				n = TX_BUFFER_SIZE;
0006a0  2564              MOVS     r5,#0x64
                  |L1.1698|
;;;515    			strncpy(uart1_tx_data_buff, string_to_send, n);
0006a2  462a              MOV      r2,r5
0006a4  4621              MOV      r1,r4
0006a6  482f              LDR      r0,|L1.1892|
0006a8  f7fffffe          BL       strncpy
;;;516    			DMA_PriCtrlStr.DMA_SourceBaseAddr = (uint32_t)&uart1_tx_data_buff;
0006ac  482d              LDR      r0,|L1.1892|
0006ae  9000              STR      r0,[sp,#0]
0006b0  e009              B        |L1.1734|
                  |L1.1714|
0006b2  e000              B        |L1.1718|
                  |L1.1716|
0006b4  e000              B        |L1.1720|
                  |L1.1718|
0006b6  e7fe              B        |L1.1718|
                  |L1.1720|
0006b8  e7fe              B        |L1.1720|
                  |L1.1722|
0006ba  9c0b              LDR      r4,[sp,#0x2c]         ;497
0006bc  e7e8              B        |L1.1680|
                  |L1.1726|
0006be  4c28              LDR      r4,|L1.1888|
0006c0  1f24              SUBS     r4,r4,#4              ;501
0006c2  e7e5              B        |L1.1680|
                  |L1.1732|
;;;517    		}
;;;518    		else
;;;519    		{
;;;520    			DMA_PriCtrlStr.DMA_SourceBaseAddr = (uint32_t)string_to_send;
0006c4  9400              STR      r4,[sp,#0]
                  |L1.1734|
;;;521    		}
;;;522    		// Setup DMA control block
;;;523    		DMA_PriCtrlStr.DMA_CycleSize = n;
0006c6  9506              STR      r5,[sp,#0x18]
;;;524    		// Start DMA
;;;525    		DMA_CtrlInit (DMA_Channel_UART1_TX, DMA_CTRL_DATA_PRIMARY, &DMA_PriCtrlStr);
0006c8  2100              MOVS     r1,#0
0006ca  466a              MOV      r2,sp
0006cc  4608              MOV      r0,r1
0006ce  f7fffffe          BL       DMA_CtrlInit
;;;526    		DMA_Cmd(DMA_Channel_UART1_TX, ENABLE);
0006d2  2101              MOVS     r1,#1
0006d4  2000              MOVS     r0,#0
0006d6  f7fffffe          BL       DMA_Cmd
;;;527    		// Enable UART1 DMA Tx request
;;;528    		UART_DMACmd(MDR_UART1,UART_DMA_TXE, ENABLE);
0006da  2201              MOVS     r2,#1
0006dc  2102              MOVS     r1,#2
0006de  4648              MOV      r0,r9
0006e0  f7fffffe          BL       UART_DMACmd
;;;529    			
;;;530    		// Wait for DMA
;;;531    		xSemaphoreTake(xSemaphoreUART1TX, portMAX_DELAY);
0006e4  2300              MOVS     r3,#0
0006e6  463a              MOV      r2,r7
0006e8  4619              MOV      r1,r3
0006ea  6870              LDR      r0,[r6,#4]  ; xSemaphoreUART1TX
0006ec  f7fffffe          BL       xQueueGenericReceive
;;;532    	
;;;533    		// Free memory if required
;;;534    		if (income_msg.type == SEND_ALLOCATED_STRING)
0006f0  f8bd0028          LDRH     r0,[sp,#0x28]
0006f4  2802              CMP      r0,#2
0006f6  d1bb              BNE      |L1.1648|
;;;535    		{
;;;536    			vPortFree(income_msg.pdata);		// heap_3 or heap_4 should be used
0006f8  980b              LDR      r0,[sp,#0x2c]
0006fa  f7fffffe          BL       vPortFree
0006fe  e7b7              B        |L1.1648|
;;;537    		}
;;;538    	}
;;;539    }
;;;540    
                          ENDP

                  DMA_IRQHandler PROC
;;;545    
;;;546    void DMA_IRQHandler(void)
000700  b538              PUSH     {r3-r5,lr}
;;;547    {
;;;548    	uint32_t *tcb_ptr;
;;;549    	portBASE_TYPE xHigherPriorityTaskWokenByPost = pdFALSE;
000702  2000              MOVS     r0,#0
000704  9000              STR      r0,[sp,#0]
;;;550    	
;;;551    	if ((MDR_DMA->CHNL_ENABLE_SET & (1<<DMA_Channel_UART1_TX)) == 0)	
000706  4c18              LDR      r4,|L1.1896|
000708  6aa0              LDR      r0,[r4,#0x28]
00070a  07c0              LSLS     r0,r0,#31
00070c  d10e              BNE      |L1.1836|
;;;552    	{
;;;553    		// UART 1 DMA transfer complete
;;;554    		if (MDR_UART1->DMACR & UART_DMACR_TXDMAE)
00070e  4812              LDR      r0,|L1.1880|
000710  6c81              LDR      r1,[r0,#0x48]
000712  0789              LSLS     r1,r1,#30
000714  d50a              BPL      |L1.1836|
;;;555    		{
;;;556    			// Disable UART1 DMA Tx request
;;;557    			MDR_UART1->DMACR &= ~UART_DMACR_TXDMAE;
000716  6c81              LDR      r1,[r0,#0x48]
000718  f0210102          BIC      r1,r1,#2
00071c  6481              STR      r1,[r0,#0x48]
;;;558    			xSemaphoreGiveFromISR( xSemaphoreUART1TX, &xHigherPriorityTaskWokenByPost );
00071e  480f              LDR      r0,|L1.1884|
000720  2300              MOVS     r3,#0
000722  466a              MOV      r2,sp
000724  4619              MOV      r1,r3
000726  6840              LDR      r0,[r0,#4]  ; xSemaphoreUART1TX
000728  f7fffffe          BL       xQueueGenericSendFromISR
                  |L1.1836|
;;;559    		}
;;;560    	}
;;;561    	/*
;;;562    	if (MDR_DMA->CHNL_ENABLE_SET & (1<<DMA_Channel_UART2_TX) == 0)	
;;;563    	{
;;;564    		// UART 2 DMA transfer complete
;;;565    		// Disable UART2 DMA Tx request
;;;566    		UART_DMACmd(MDR_UART2,UART_DMA_TXE, DISABLE);
;;;567    		// postSemaphoreFromISR(__complete__);
;;;568    	}	
;;;569    	*/
;;;570    	
;;;571    	if ((MDR_DMA->CHNL_ENABLE_SET & (1<<DMA_Channel_UART1_RX)) == 0)	
00072c  6aa0              LDR      r0,[r4,#0x28]
00072e  0780              LSLS     r0,r0,#30
000730  d409              BMI      |L1.1862|
;;;572    	{
;;;573    		// Reload TCB
;;;574    		tcb_ptr = (uint32_t*)&DMA_ControlTable[DMA_Channel_UART1_RX];
000732  480e              LDR      r0,|L1.1900|
;;;575    		*tcb_ptr++ = UART1_RX_saved_TCB[0];
000734  490e              LDR      r1,|L1.1904|
000736  680a              LDR      r2,[r1,#0]  ; UART1_RX_saved_TCB
000738  6102              STR      r2,[r0,#0x10]
;;;576    		*tcb_ptr++ = UART1_RX_saved_TCB[1];
00073a  684a              LDR      r2,[r1,#4]  ; UART1_RX_saved_TCB
00073c  6142              STR      r2,[r0,#0x14]
;;;577    		*tcb_ptr = UART1_RX_saved_TCB[2];
00073e  6889              LDR      r1,[r1,#8]  ; UART1_RX_saved_TCB
000740  6181              STR      r1,[r0,#0x18]
;;;578    		MDR_DMA->CHNL_ENABLE_SET = (1 << DMA_Channel_UART1_RX);
000742  2002              MOVS     r0,#2
000744  62a0              STR      r0,[r4,#0x28]
                  |L1.1862|
;;;579    	}
;;;580    		
;;;581    	
;;;582    	// Error handling
;;;583    	if (DMA_GetFlagStatus(0, DMA_FLAG_DMA_ERR) == SET)
000746  2102              MOVS     r1,#2
000748  2000              MOVS     r0,#0
00074a  f7fffffe          BL       DMA_GetFlagStatus
00074e  2801              CMP      r0,#1
000750  d101              BNE      |L1.1878|
;;;584    	{
;;;585    		DMA_ClearError();	// normally this should not happen
000752  f7fffffe          BL       DMA_ClearError
                  |L1.1878|
;;;586    	}
;;;587    	
;;;588    	// Force context switching if required
;;;589    	//portEND_SWITCHING_ISR(xHigherPriorityTaskWokenByPost);
;;;590    }
000756  bd38              POP      {r3-r5,pc}
;;;591    
                          ENDP

                  |L1.1880|
                          DCD      0x40030000
                  |L1.1884|
                          DCD      ||area_number.7||
                  |L1.1888|
                          DCD      ||.constdata||+0x4
                  |L1.1892|
                          DCD      ||.bss||
                  |L1.1896|
                          DCD      0x40028000
                  |L1.1900|
                          DCD      DMA_ControlTable
                  |L1.1904|
                          DCD      ||.bss||+0x1f4

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uart1_tx_data_buff
                          %        100
                  uart1_rx_data_buff
                          %        400
                  UART1_RX_saved_TCB
                          %        12

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  _resp_OK
000000  4f4b0d00          DCB      0x4f,0x4b,0x0d,0x00
                  _resp_UNKN_CMD
000004  556e6b6e          DCB      0x55,0x6e,0x6b,0x6e
000008  6f776e20          DCB      0x6f,0x77,0x6e,0x20
00000c  636d640d          DCB      0x63,0x6d,0x64,0x0d
000010  00                DCB      0x00

                          AREA ||.data||, DATA, ALIGN=0

                  test_mode
000000  00                DCB      0x00

                          AREA ||area_number.7||, DATA, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.data||
                  xQueueUART1TX
                          DCD      0x00000000
                  xSemaphoreUART1TX
                          DCD      0x00000000
                  uart1_rx_dma_buffer
                          %        8

;*** Start embedded assembler ***

#line 1 "src\\uart.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_uart_c__resp_OK____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_uart_c__resp_OK____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_uart_c__resp_OK____REVSH|
#line 130
|__asm___6_uart_c__resp_OK____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
