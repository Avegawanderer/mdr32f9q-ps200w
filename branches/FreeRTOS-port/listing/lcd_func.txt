; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\lcd_func.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\lcd_func.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\lcd_func.crf src\lcd_func.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  LcdPutPixel PROC
;;;40     //==============================================================//
;;;41     void LcdPutPixel (uint8_t x_pos, uint8_t y_pos, uint8_t mode, uint16_t *lcd_buffer)     
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;42     {
000004  4606              MOV      r6,r0
;;;43     int16_t buffer_index;
;;;44     uint8_t offset, data;
;;;45     	// Get byte index
;;;46     	#ifdef SOFT_HORIZ_REV
;;;47     		buffer_index = (y_pos / 8)*LCD_XSIZE + LCD_XSIZE - 1 - x_pos;
000006  460d              MOV      r5,r1
000008  ea4f7ce1          ASR      r12,r1,#31
00000c  eb017c5c          ADD      r12,r1,r12,LSR #29
000010  ea4f0cec          ASR      r12,r12,#3
000014  eb0c0c4c          ADD      r12,r12,r12,LSL #1
000018  f04f0860          MOV      r8,#0x60
00001c  eb081c4c          ADD      r12,r8,r12,LSL #5
000020  f1ac0c01          SUB      r12,r12,#1
000024  ebac0c06          SUB      r12,r12,r6
000028  fa0ff78c          SXTH     r7,r12
;;;48     	#else
;;;49     		buffer_index = (y_pos / 8)*LCD_XSIZE + x_pos;
;;;50     	#endif	
;;;51     	// Get bit offset
;;;52       offset  = y_pos % 8;                 
00002c  ea4f7ce1          ASR      r12,r1,#31
000030  eb017c5c          ADD      r12,r1,r12,LSR #29
000034  ea4f0cec          ASR      r12,r12,#3
000038  eba10ccc          SUB      r12,r1,r12,LSL #3
00003c  f00c04ff          AND      r4,r12,#0xff
;;;53       data = lcd_buffer[buffer_index];                     
000040  f8335017          LDRH     r5,[r3,r7,LSL #1]
000044  b2e8              UXTB     r0,r5
;;;54       if ( mode == PIXEL_OFF ) data &= ( ~( 0x01 << offset ) );		
000046  b91a              CBNZ     r2,|L1.80|
000048  2501              MOVS     r5,#1
00004a  40a5              LSLS     r5,r5,r4
00004c  43a8              BICS     r0,r0,r5
00004e  e00c              B        |L1.106|
                  |L1.80|
;;;55           else if ( mode == PIXEL_ON ) data |= ( 0x01 << offset );
000050  2a01              CMP      r2,#1
000052  d104              BNE      |L1.94|
000054  2501              MOVS     r5,#1
000056  40a5              LSLS     r5,r5,r4
000058  4305              ORRS     r5,r5,r0
00005a  b2e8              UXTB     r0,r5
00005c  e005              B        |L1.106|
                  |L1.94|
;;;56                else if ( mode  == PIXEL_XOR ) data ^= ( 0x01 << offset );
00005e  2a02              CMP      r2,#2
000060  d103              BNE      |L1.106|
000062  2501              MOVS     r5,#1
000064  40a5              LSLS     r5,r5,r4
000066  4045              EORS     r5,r5,r0
000068  b2e8              UXTB     r0,r5
                  |L1.106|
;;;57       lcd_buffer[buffer_index] = data;		          
00006a  f8230017          STRH     r0,[r3,r7,LSL #1]
;;;58     }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;59     
                          ENDP

                  LcdPutHorLine PROC
;;;61     
;;;62     void LcdPutHorLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t mode, uint16_t *lcd_buffer)
000072  e92d43f0          PUSH     {r4-r9,lr}
;;;63     {
000076  4604              MOV      r4,r0
000078  4688              MOV      r8,r1
00007a  4615              MOV      r5,r2
00007c  461e              MOV      r6,r3
00007e  f8dd901c          LDR      r9,[sp,#0x1c]
;;;64       uint8_t cnt_done=0;
000082  2700              MOVS     r7,#0
;;;65       while (cnt_done<length)
000084  e009              B        |L1.154|
                  |L1.134|
;;;66         LcdPutPixel(x_pos+cnt_done++,y_pos,mode,lcd_buffer);  
000086  4639              MOV      r1,r7
000088  1c7a              ADDS     r2,r7,#1
00008a  b2d7              UXTB     r7,r2
00008c  4421              ADD      r1,r1,r4
00008e  b2c8              UXTB     r0,r1
000090  464b              MOV      r3,r9
000092  4632              MOV      r2,r6
000094  4641              MOV      r1,r8
000096  f7fffffe          BL       LcdPutPixel
                  |L1.154|
00009a  42af              CMP      r7,r5                 ;65
00009c  dbf3              BLT      |L1.134|
;;;67     }
00009e  e8bd83f0          POP      {r4-r9,pc}
;;;68     
                          ENDP

                  LcdPutVertLine PROC
;;;69     void LcdPutVertLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t mode, uint16_t *lcd_buffer)
0000a2  e92d43f0          PUSH     {r4-r9,lr}
;;;70     {
0000a6  4680              MOV      r8,r0
0000a8  460c              MOV      r4,r1
0000aa  4615              MOV      r5,r2
0000ac  461e              MOV      r6,r3
0000ae  f8dd901c          LDR      r9,[sp,#0x1c]
;;;71       uint8_t cnt_done=0;
0000b2  2700              MOVS     r7,#0
;;;72       while (cnt_done<length)
0000b4  e009              B        |L1.202|
                  |L1.182|
;;;73         LcdPutPixel(x_pos,y_pos+cnt_done++,mode,lcd_buffer);  
0000b6  4638              MOV      r0,r7
0000b8  1c7a              ADDS     r2,r7,#1
0000ba  b2d7              UXTB     r7,r2
0000bc  4420              ADD      r0,r0,r4
0000be  b2c1              UXTB     r1,r0
0000c0  464b              MOV      r3,r9
0000c2  4632              MOV      r2,r6
0000c4  4640              MOV      r0,r8
0000c6  f7fffffe          BL       LcdPutPixel
                  |L1.202|
0000ca  42af              CMP      r7,r5                 ;72
0000cc  dbf3              BLT      |L1.182|
;;;74     }
0000ce  e8bd83f0          POP      {r4-r9,pc}
;;;75     
                          ENDP

                  LcdFillBuffer PROC
;;;87     //==============================================================//
;;;88     void LcdFillBuffer(uint16_t* lcd_buffer, uint8_t value)
0000d2  4602              MOV      r2,r0
;;;89     {
;;;90     	uint16_t i;
;;;91     	for (i=0;i<LCD_BUFFER_SIZE;i++)
0000d4  2000              MOVS     r0,#0
0000d6  e003              B        |L1.224|
                  |L1.216|
;;;92     	{
;;;93     		lcd_buffer[i] = value;
0000d8  f8221010          STRH     r1,[r2,r0,LSL #1]
0000dc  1c43              ADDS     r3,r0,#1              ;91
0000de  b298              UXTH     r0,r3                 ;91
                  |L1.224|
0000e0  f5b07f58          CMP      r0,#0x360             ;91
0000e4  dbf8              BLT      |L1.216|
;;;94     	}
;;;95     }
0000e6  4770              BX       lr
;;;96     
                          ENDP

                  LcdPutImage PROC
;;;144    //==============================================================//
;;;145    void LcdPutImage(uint8_t* img, uint8_t x_pos, uint8_t y_pos, uint8_t width, uint8_t height, uint16_t* lcd_buffer)
0000e8  e92d4fff          PUSH     {r0-r11,lr}
;;;146    {
0000ec  b082              SUB      sp,sp,#8
0000ee  461e              MOV      r6,r3
0000f0  9c0f              LDR      r4,[sp,#0x3c]
;;;147    	uint16_t vertical_bits_remain, counter_inc;
;;;148    	uint16_t picture_index, buffer_index;
;;;149    	uint16_t start_buffer_index;
;;;150    	uint16_t i;
;;;151    	uint16_t img_shift;
;;;152    	uint8_t mask, temp;
;;;153    	uint8_t offset = y_pos % 8;
0000f2  4692              MOV      r10,r2
0000f4  ea4f7be2          ASR      r11,r2,#31
0000f8  eb027b5b          ADD      r11,r2,r11,LSR #29
0000fc  ea4f0beb          ASR      r11,r11,#3
000100  eba20bcb          SUB      r11,r2,r11,LSL #3
000104  f00b03ff          AND      r3,r11,#0xff
;;;154    
;;;155    	#ifdef SOFT_HORIZ_REV
;;;156    		start_buffer_index = (y_pos / 8)*LCD_XSIZE + LCD_XSIZE - 1 - x_pos;
000108  ea4f7be2          ASR      r11,r2,#31
00010c  eb027b5b          ADD      r11,r2,r11,LSR #29
000110  ea4f0beb          ASR      r11,r11,#3
000114  eb0b0b4b          ADD      r11,r11,r11,LSL #1
000118  f04f0e60          MOV      lr,#0x60
00011c  eb0e1b4b          ADD      r11,lr,r11,LSL #5
000120  f1ab0b01          SUB      r11,r11,#1
000124  f8dde00c          LDR      lr,[sp,#0xc]
000128  ebab0b0e          SUB      r11,r11,lr
00012c  fa1ffb8b          UXTH     r11,r11
000130  f8cdb000          STR      r11,[sp,#0]
;;;157    	#else
;;;158    		start_buffer_index = (y_pos / 8)*LCD_XSIZE + x_pos;
;;;159    	#endif
;;;160    	
;;;161    	//-------------//
;;;162    	
;;;163    	// X-loop
;;;164    	for (i=0;i<width;i++)
000134  2500              MOVS     r5,#0
000136  e06d              B        |L1.532|
                  |L1.312|
;;;165    	{
;;;166    			img_shift = 0;
000138  f04f0800          MOV      r8,#0
;;;167    			picture_index = i;
00013c  462f              MOV      r7,r5
;;;168    			#ifdef SOFT_HORIZ_REV
;;;169    				buffer_index =  start_buffer_index - i;
00013e  f8dda000          LDR      r10,[sp,#0]
000142  ebaa0a05          SUB      r10,r10,r5
000146  fa1ffc8a          UXTH     r12,r10
;;;170    			#else
;;;171    				buffer_index =  start_buffer_index + i;
;;;172    			#endif
;;;173    			vertical_bits_remain = height;
00014a  4620              MOV      r0,r4
;;;174    			mask = -(1<<offset); 
00014c  f04f0a01          MOV      r10,#1
000150  fa0afa03          LSL      r10,r10,r3
000154  f1ca0a00          RSB      r10,r10,#0
000158  f00a09ff          AND      r9,r10,#0xff
;;;175    			
;;;176    			if (offset + height < 8 )
00015c  eb030a04          ADD      r10,r3,r4
000160  f1ba0f08          CMP      r10,#8
000164  da0d              BGE      |L1.386|
;;;177    			{
;;;178    				temp = (1<<(offset + height))-1;
000166  eb030b04          ADD      r11,r3,r4
00016a  f04f0a01          MOV      r10,#1
00016e  fa0afa0b          LSL      r10,r10,r11
000172  f1aa0a01          SUB      r10,r10,#1
000176  f00a01ff          AND      r1,r10,#0xff
;;;179    				mask &= temp;
00017a  ea090901          AND      r9,r9,r1
;;;180    				counter_inc = height;
00017e  9401              STR      r4,[sp,#4]
000180  e005              B        |L1.398|
                  |L1.386|
;;;181    			}
;;;182    			else
;;;183    			{
;;;184    				counter_inc = 8-offset;
000182  f1c30a08          RSB      r10,r3,#8
000186  fa1ffa8a          UXTH     r10,r10
00018a  f8cda004          STR      r10,[sp,#4]
                  |L1.398|
;;;185    			}
;;;186    		
;;;187    
;;;188    			// Y-loop
;;;189    			while(vertical_bits_remain)
00018e  e03b              B        |L1.520|
                  |L1.400|
;;;190    			{			  
;;;191    				temp = img[picture_index];						// get image byte			
000190  f8dda008          LDR      r10,[sp,#8]
000194  f81a1007          LDRB     r1,[r10,r7]
;;;192    				img_shift |= temp << offset;					// add shifted value to the 16-bit accumulator
000198  fa01fa03          LSL      r10,r1,r3
00019c  ea4a0a08          ORR      r10,r10,r8
0001a0  fa1ff88a          UXTH     r8,r10
;;;193    		
;;;194    				temp = lcd_buffer[buffer_index];			// get old value
0001a4  f8dda040          LDR      r10,[sp,#0x40]
0001a8  f83aa01c          LDRH     r10,[r10,r12,LSL #1]
0001ac  f00a01ff          AND      r1,r10,#0xff
;;;195    				temp &= ~mask	;												// clear only used bits
0001b0  ea210109          BIC      r1,r1,r9
;;;196    				temp |= img_shift & mask;							// add only used bits
0001b4  ea080a09          AND      r10,r8,r9
0001b8  ea4a0101          ORR      r1,r10,r1
;;;197    				lcd_buffer[buffer_index] = temp;			// write new value back
0001bc  f8dda040          LDR      r10,[sp,#0x40]
0001c0  f82a101c          STRH     r1,[r10,r12,LSL #1]
;;;198    		
;;;199    				img_shift = img_shift >> 8;						// shift 16-bit register
0001c4  ea4f2828          ASR      r8,r8,#8
;;;200    				buffer_index += LCD_XSIZE;
0001c8  f10c0a60          ADD      r10,r12,#0x60
0001cc  fa1ffc8a          UXTH     r12,r10
;;;201    				picture_index += width;	
0001d0  eb070a06          ADD      r10,r7,r6
0001d4  fa1ff78a          UXTH     r7,r10
;;;202    			
;;;203    				vertical_bits_remain -= counter_inc;
0001d8  f8dda004          LDR      r10,[sp,#4]
0001dc  eba00a0a          SUB      r10,r0,r10
0001e0  fa1ff08a          UXTH     r0,r10
;;;204    				if (vertical_bits_remain >= 8)
0001e4  2808              CMP      r0,#8
0001e6  db04              BLT      |L1.498|
;;;205    					counter_inc = 8;
0001e8  f04f0a08          MOV      r10,#8
0001ec  f8cda004          STR      r10,[sp,#4]
0001f0  e000              B        |L1.500|
                  |L1.498|
;;;206    				else
;;;207    					counter_inc = vertical_bits_remain;	
0001f2  9001              STR      r0,[sp,#4]
                  |L1.500|
;;;208    				mask = (1 << counter_inc)-1;
0001f4  f04f0b01          MOV      r11,#1
0001f8  f8dda004          LDR      r10,[sp,#4]
0001fc  fa0bfa0a          LSL      r10,r11,r10
000200  f1aa0a01          SUB      r10,r10,#1
000204  f00a09ff          AND      r9,r10,#0xff
                  |L1.520|
000208  2800              CMP      r0,#0                 ;189
00020a  d1c1              BNE      |L1.400|
00020c  f1050a01          ADD      r10,r5,#1             ;164
000210  fa1ff58a          UXTH     r5,r10                ;164
                  |L1.532|
000214  42b5              CMP      r5,r6                 ;164
000216  db8f              BLT      |L1.312|
;;;209    							
;;;210    			}
;;;211    	}
;;;212    }
000218  b006              ADD      sp,sp,#0x18
00021a  e8bd8ff0          POP      {r4-r11,pc}
;;;213    
                          ENDP

                  GetFontItem PROC
;;;241    
;;;242    tSpecialFontItem GetFontItem(tSpecialFont* myFont, char c)
00021e  b530              PUSH     {r4,r5,lr}
;;;243    {
000220  4603              MOV      r3,r0
;;;244    	uint16_t i;
;;;245    	for (i=0;i<myFont->count;i++)
000222  2000              MOVS     r0,#0
000224  e00d              B        |L1.578|
                  |L1.550|
;;;246    		if(myFont->Chars[i].code == c)
000226  684c              LDR      r4,[r1,#4]
000228  f8144030          LDRB     r4,[r4,r0,LSL #3]
00022c  4294              CMP      r4,r2
00022e  d106              BNE      |L1.574|
;;;247    			return myFont->Chars[i];
000230  684c              LDR      r4,[r1,#4]
000232  eb0405c0          ADD      r5,r4,r0,LSL #3
000236  cd30              LDM      r5,{r4,r5}
000238  e9c34500          STRD     r4,r5,[r3,#0]
                  |L1.572|
;;;248    	// If not found
;;;249    	return myFont->Chars[0];
;;;250    }
00023c  bd30              POP      {r4,r5,pc}
                  |L1.574|
00023e  1c44              ADDS     r4,r0,#1              ;245
000240  b2a0              UXTH     r0,r4                 ;245
                  |L1.578|
000242  784c              LDRB     r4,[r1,#1]            ;245
000244  4284              CMP      r4,r0                 ;245
000246  dcee              BGT      |L1.550|
000248  684d              LDR      r5,[r1,#4]            ;249
00024a  cd30              LDM      r5,{r4,r5}            ;249
00024c  e9c34500          STRD     r4,r5,[r3,#0]         ;249
000250  bf00              NOP                            ;249
000252  e7f3              B        |L1.572|
;;;251    
                          ENDP

                  LcdPutSpecialStr PROC
;;;253    
;;;254    void LcdPutSpecialStr(uint8_t x_pos, uint8_t y_pos, uint8_t* str, tSpecialFont* myFont, uint16_t* lcd_buffer)
000254  e92d43ff          PUSH     {r0-r9,lr}
;;;255    {
000258  4604              MOV      r4,r0
00025a  460f              MOV      r7,r1
00025c  4615              MOV      r5,r2
00025e  461e              MOV      r6,r3
000260  f8dd902c          LDR      r9,[sp,#0x2c]
;;;256    	uint16_t i = 0;
000264  f04f0800          MOV      r8,#0
;;;257    	tSpecialFontItem item_ptr;
;;;258    	while(str[i] != '\0')
000268  e01a              B        |L1.672|
                  |L1.618|
;;;259    	{
;;;260    		item_ptr = GetFontItem(myFont,str[i++]);
00026a  4640              MOV      r0,r8
00026c  1c41              ADDS     r1,r0,#1
00026e  fa1ff881          UXTH     r8,r1
000272  5c2a              LDRB     r2,[r5,r0]
000274  4631              MOV      r1,r6
000276  4668              MOV      r0,sp
000278  f7fffffe          BL       GetFontItem
00027c  e9dd0100          LDRD     r0,r1,[sp,#0]
000280  e9cd0102          STRD     r0,r1,[sp,#8]
;;;261    		LcdPutImage((uint8_t*)item_ptr.data,x_pos,y_pos,item_ptr.width,myFont->height,lcd_buffer);
000284  7830              LDRB     r0,[r6,#0]
000286  e9cd0900          STRD     r0,r9,[sp,#0]
00028a  f89d3009          LDRB     r3,[sp,#9]
00028e  463a              MOV      r2,r7
000290  4621              MOV      r1,r4
000292  9803              LDR      r0,[sp,#0xc]
000294  f7fffffe          BL       LcdPutImage
;;;262    		x_pos += item_ptr.width;
000298  f89d0009          LDRB     r0,[sp,#9]
00029c  4420              ADD      r0,r0,r4
00029e  b2c4              UXTB     r4,r0
                  |L1.672|
0002a0  f8150008          LDRB     r0,[r5,r8]            ;258
0002a4  2800              CMP      r0,#0                 ;258
0002a6  d1e0              BNE      |L1.618|
;;;263    	}
;;;264    }
0002a8  e8bd83ff          POP      {r0-r9,pc}
;;;265    
                          ENDP

                  LcdPutNormalStr PROC
;;;266    
;;;267    void LcdPutNormalStr(uint8_t x_pos, uint8_t y_pos, uint8_t* str, tNormalFont* myFont, uint16_t* lcd_buffer)
0002ac  e92d47fc          PUSH     {r2-r10,lr}
;;;268    {
0002b0  4605              MOV      r5,r0
0002b2  460f              MOV      r7,r1
0002b4  4616              MOV      r6,r2
0002b6  461c              MOV      r4,r3
0002b8  f8dda028          LDR      r10,[sp,#0x28]
;;;269    	uint16_t i = 0;
0002bc  f04f0800          MOV      r8,#0
;;;270    	uint16_t charPointer;
;;;271    	
;;;272    	while(str[i] != '\0')
0002c0  e015              B        |L1.750|
                  |L1.706|
;;;273    	{
;;;274    		charPointer = str[i++] * myFont->bytesPerChar;
0002c2  4640              MOV      r0,r8
0002c4  1c41              ADDS     r1,r0,#1
0002c6  fa1ff881          UXTH     r8,r1
0002ca  5c30              LDRB     r0,[r6,r0]
0002cc  78e1              LDRB     r1,[r4,#3]
0002ce  fb00f901          MUL      r9,r0,r1
;;;275    		LcdPutImage((uint8_t*)&myFont->data[charPointer],x_pos,y_pos,myFont->width,myFont->height,lcd_buffer);
0002d2  7860              LDRB     r0,[r4,#1]
0002d4  e9cd0a00          STRD     r0,r10,[sp,#0]
0002d8  7823              LDRB     r3,[r4,#0]
0002da  6861              LDR      r1,[r4,#4]
0002dc  eb010009          ADD      r0,r1,r9
0002e0  463a              MOV      r2,r7
0002e2  4629              MOV      r1,r5
0002e4  f7fffffe          BL       LcdPutImage
;;;276    		x_pos += myFont->width;
0002e8  7820              LDRB     r0,[r4,#0]
0002ea  4428              ADD      r0,r0,r5
0002ec  b2c5              UXTB     r5,r0
                  |L1.750|
0002ee  f8160008          LDRB     r0,[r6,r8]            ;272
0002f2  2800              CMP      r0,#0                 ;272
0002f4  d1e5              BNE      |L1.706|
;;;277    	}
;;;278    
;;;279    	
;;;280    }
0002f6  e8bd87fc          POP      {r2-r10,pc}
;;;281    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  lcd0_buffer
                          %        1728
                  lcd1_buffer
                          %        1728

;*** Start embedded assembler ***

#line 1 "src\\lcd_func.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_lcd_func_c_8f1eeab9____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_lcd_func_c_8f1eeab9____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_lcd_func_c_8f1eeab9____REVSH|
#line 130
|__asm___10_lcd_func_c_8f1eeab9____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
