; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\lcd_func.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\lcd_func.d --cpu=Cortex-M3 --apcs=interwork -O1 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\lcd_func.crf src\lcd_func.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  LcdPutPixel PROC
;;;40     //==============================================================//
;;;41     void LcdPutPixel (uint8_t x_pos, uint8_t y_pos, uint8_t mode, uint16_t *lcd_buffer)     
000000  b530              PUSH     {r4,r5,lr}
;;;42     {
;;;43     int16_t buffer_index;
;;;44     uint8_t offset, data;
;;;45     	// Get byte index
;;;46     	#ifdef SOFT_HORIZ_REV
;;;47     		buffer_index = (y_pos / 8)*LCD_XSIZE + LCD_XSIZE - 1 - x_pos;
000002  08cc              LSRS     r4,r1,#3
000004  eb040444          ADD      r4,r4,r4,LSL #1
000008  ebc01544          RSB      r5,r0,r4,LSL #5
00000c  355f              ADDS     r5,r5,#0x5f
;;;48     	#else
;;;49     		buffer_index = (y_pos / 8)*LCD_XSIZE + x_pos;
;;;50     	#endif	
;;;51     	// Get bit offset
;;;52       offset  = y_pos % 8;                 
;;;53       data = lcd_buffer[buffer_index];                     
00000e  f8330015          LDRH     r0,[r3,r5,LSL #1]
000012  b2c0              UXTB     r0,r0
;;;54       if ( mode == PIXEL_OFF ) data &= ( ~( 0x01 << offset ) );		
000014  2401              MOVS     r4,#1
000016  f0010107          AND      r1,r1,#7              ;52
00001a  408c              LSLS     r4,r4,r1
00001c  b122              CBZ      r2,|L1.40|
;;;55           else if ( mode == PIXEL_ON ) data |= ( 0x01 << offset );
00001e  2a01              CMP      r2,#1
000020  d004              BEQ      |L1.44|
;;;56                else if ( mode  == PIXEL_XOR ) data ^= ( 0x01 << offset );
000022  2a02              CMP      r2,#2
000024  d005              BEQ      |L1.50|
000026  e006              B        |L1.54|
                  |L1.40|
000028  43a0              BICS     r0,r0,r4              ;54
00002a  e004              B        |L1.54|
                  |L1.44|
00002c  4304              ORRS     r4,r4,r0              ;55
00002e  b2e0              UXTB     r0,r4                 ;55
000030  e001              B        |L1.54|
                  |L1.50|
000032  4044              EORS     r4,r4,r0
000034  b2e0              UXTB     r0,r4
                  |L1.54|
;;;57       lcd_buffer[buffer_index] = data;		          
000036  f8230015          STRH     r0,[r3,r5,LSL #1]
;;;58     }
00003a  bd30              POP      {r4,r5,pc}
;;;59     
                          ENDP

                  LcdPutHorLine PROC
;;;61     
;;;62     void LcdPutHorLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t mode, uint16_t *lcd_buffer)
00003c  e92d43f0          PUSH     {r4-r9,lr}
;;;63     {
000040  4605              MOV      r5,r0
000042  f8dd901c          LDR      r9,[sp,#0x1c]
000046  4688              MOV      r8,r1
000048  4616              MOV      r6,r2
00004a  461f              MOV      r7,r3
;;;64       uint8_t cnt_done=0;
00004c  2400              MOVS     r4,#0
;;;65       while (cnt_done<length)
00004e  e009              B        |L1.100|
                  |L1.80|
;;;66         LcdPutPixel(x_pos+cnt_done++,y_pos,mode,lcd_buffer);  
000050  4620              MOV      r0,r4
000052  1c64              ADDS     r4,r4,#1
000054  4428              ADD      r0,r0,r5
000056  b2e4              UXTB     r4,r4
000058  b2c0              UXTB     r0,r0
00005a  464b              MOV      r3,r9
00005c  463a              MOV      r2,r7
00005e  4641              MOV      r1,r8
000060  f7fffffe          BL       LcdPutPixel
                  |L1.100|
000064  42b4              CMP      r4,r6                 ;65
000066  d3f3              BCC      |L1.80|
                  |L1.104|
;;;67     }
000068  e8bd83f0          POP      {r4-r9,pc}
;;;68     
                          ENDP

                  LcdPutVertLine PROC
;;;69     void LcdPutVertLine(uint8_t x_pos, uint8_t y_pos, uint8_t length, uint8_t mode, uint16_t *lcd_buffer)
00006c  e92d43f0          PUSH     {r4-r9,lr}
;;;70     {
000070  4680              MOV      r8,r0
000072  f8dd901c          LDR      r9,[sp,#0x1c]
000076  460d              MOV      r5,r1
000078  4616              MOV      r6,r2
00007a  461f              MOV      r7,r3
;;;71       uint8_t cnt_done=0;
00007c  2400              MOVS     r4,#0
;;;72       while (cnt_done<length)
00007e  e009              B        |L1.148|
                  |L1.128|
;;;73         LcdPutPixel(x_pos,y_pos+cnt_done++,mode,lcd_buffer);  
000080  4620              MOV      r0,r4
000082  4428              ADD      r0,r0,r5
000084  1c64              ADDS     r4,r4,#1
000086  b2c1              UXTB     r1,r0
000088  b2e4              UXTB     r4,r4
00008a  464b              MOV      r3,r9
00008c  463a              MOV      r2,r7
00008e  4640              MOV      r0,r8
000090  f7fffffe          BL       LcdPutPixel
                  |L1.148|
000094  42b4              CMP      r4,r6                 ;72
000096  d3f3              BCC      |L1.128|
;;;74     }
000098  e7e6              B        |L1.104|
;;;75     
                          ENDP

                  LcdFillBuffer PROC
;;;87     //==============================================================//
;;;88     void LcdFillBuffer(uint16_t* lcd_buffer, uint8_t value)
00009a  2200              MOVS     r2,#0
;;;89     {
;;;90     	uint16_t i;
;;;91     	for (i=0;i<LCD_BUFFER_SIZE;i++)
00009c  f44f7358          MOV      r3,#0x360
                  |L1.160|
;;;92     	{
;;;93     		lcd_buffer[i] = value;
0000a0  f8201012          STRH     r1,[r0,r2,LSL #1]
0000a4  1c52              ADDS     r2,r2,#1              ;91
0000a6  b292              UXTH     r2,r2                 ;91
0000a8  429a              CMP      r2,r3                 ;91
0000aa  d3f9              BCC      |L1.160|
;;;94     	}
;;;95     }
0000ac  4770              BX       lr
;;;96     
                          ENDP

                  LcdPutImage PROC
;;;144    //==============================================================//
;;;145    void LcdPutImage(uint8_t* img, uint8_t x_pos, uint8_t y_pos, uint8_t width, uint8_t height, uint16_t* lcd_buffer)
0000ae  e92d4fff          PUSH     {r0-r11,lr}
;;;146    {
0000b2  e9dd8a0d          LDRD     r8,r10,[sp,#0x34]
;;;147    	uint16_t vertical_bits_remain, counter_inc;
;;;148    	uint16_t picture_index, buffer_index;
;;;149    	uint16_t start_buffer_index;
;;;150    	uint16_t i;
;;;151    	uint16_t img_shift;
;;;152    	uint8_t mask, temp;
;;;153    	uint8_t offset = y_pos % 8;
0000b6  f0020707          AND      r7,r2,#7
;;;154    
;;;155    	#ifdef SOFT_HORIZ_REV
;;;156    		start_buffer_index = (y_pos / 8)*LCD_XSIZE + LCD_XSIZE - 1 - x_pos;
0000ba  08d0              LSRS     r0,r2,#3
0000bc  eb000040          ADD      r0,r0,r0,LSL #1
0000c0  ebc11040          RSB      r0,r1,r0,LSL #5
0000c4  305f              ADDS     r0,r0,#0x5f
0000c6  fa1ffe80          UXTH     lr,r0
;;;157    	#else
;;;158    		start_buffer_index = (y_pos / 8)*LCD_XSIZE + x_pos;
;;;159    	#endif
;;;160    	
;;;161    	//-------------//
;;;162    	
;;;163    	// X-loop
;;;164    	for (i=0;i<width;i++)
0000ca  2500              MOVS     r5,#0
;;;165    	{
;;;166    			img_shift = 0;
;;;167    			picture_index = i;
;;;168    			#ifdef SOFT_HORIZ_REV
;;;169    				buffer_index =  start_buffer_index - i;
;;;170    			#else
;;;171    				buffer_index =  start_buffer_index + i;
;;;172    			#endif
;;;173    			vertical_bits_remain = height;
;;;174    			mask = -(1<<offset); 
0000cc  f04f0b01          MOV      r11,#1
0000d0  e045              B        |L1.350|
                  |L1.210|
0000d2  f04f0c00          MOV      r12,#0                ;166
0000d6  462e              MOV      r6,r5                 ;167
0000d8  ebae0005          SUB      r0,lr,r5              ;169
0000dc  b284              UXTH     r4,r0                 ;169
0000de  4640              MOV      r0,r8                 ;173
0000e0  fa0bf107          LSL      r1,r11,r7
0000e4  4249              RSBS     r1,r1,#0
0000e6  b2ca              UXTB     r2,r1
;;;175    			
;;;176    			if (offset + height < 8 )
0000e8  eb070908          ADD      r9,r7,r8
0000ec  f1b90f08          CMP      r9,#8
0000f0  d206              BCS      |L1.256|
;;;177    			{
;;;178    				temp = (1<<(offset + height))-1;
0000f2  fa0bf109          LSL      r1,r11,r9
0000f6  1e49              SUBS     r1,r1,#1
0000f8  b2c9              UXTB     r1,r1
;;;179    				mask &= temp;
0000fa  400a              ANDS     r2,r2,r1
;;;180    				counter_inc = height;
0000fc  4641              MOV      r1,r8
0000fe  e02a              B        |L1.342|
                  |L1.256|
;;;181    			}
;;;182    			else
;;;183    			{
;;;184    				counter_inc = 8-offset;
000100  f1c70108          RSB      r1,r7,#8
000104  b289              UXTH     r1,r1
000106  e026              B        |L1.342|
                  |L1.264|
;;;185    			}
;;;186    		
;;;187    
;;;188    			// Y-loop
;;;189    			while(vertical_bits_remain)
;;;190    			{			  
;;;191    				temp = img[picture_index];						// get image byte			
000108  f8dd9000          LDR      r9,[sp,#0]
00010c  f8199006          LDRB     r9,[r9,r6]
;;;192    				img_shift |= temp << offset;					// add shifted value to the 16-bit accumulator
000110  fa09f907          LSL      r9,r9,r7
000114  ea49090c          ORR      r9,r9,r12
000118  fa1ffc89          UXTH     r12,r9
;;;193    		
;;;194    				temp = lcd_buffer[buffer_index];			// get old value
00011c  f83a9014          LDRH     r9,[r10,r4,LSL #1]
000120  f00909ff          AND      r9,r9,#0xff
;;;195    				temp &= ~mask	;												// clear only used bits
000124  ea290902          BIC      r9,r9,r2
;;;196    				temp |= img_shift & mask;							// add only used bits
000128  ea0c0202          AND      r2,r12,r2
00012c  ea420209          ORR      r2,r2,r9
;;;197    				lcd_buffer[buffer_index] = temp;			// write new value back
000130  f82a2014          STRH     r2,[r10,r4,LSL #1]
;;;198    		
;;;199    				img_shift = img_shift >> 8;						// shift 16-bit register
000134  ea4f2c1c          LSR      r12,r12,#8
;;;200    				buffer_index += LCD_XSIZE;
000138  3460              ADDS     r4,r4,#0x60
00013a  b2a4              UXTH     r4,r4
;;;201    				picture_index += width;	
00013c  18f2              ADDS     r2,r6,r3
00013e  b296              UXTH     r6,r2
;;;202    			
;;;203    				vertical_bits_remain -= counter_inc;
000140  1a40              SUBS     r0,r0,r1
000142  b280              UXTH     r0,r0
;;;204    				if (vertical_bits_remain >= 8)
000144  2808              CMP      r0,#8
000146  d301              BCC      |L1.332|
;;;205    					counter_inc = 8;
000148  2108              MOVS     r1,#8
00014a  e000              B        |L1.334|
                  |L1.332|
;;;206    				else
;;;207    					counter_inc = vertical_bits_remain;	
00014c  4601              MOV      r1,r0
                  |L1.334|
;;;208    				mask = (1 << counter_inc)-1;
00014e  fa0bf201          LSL      r2,r11,r1
000152  1e52              SUBS     r2,r2,#1
000154  b2d2              UXTB     r2,r2
                  |L1.342|
000156  2800              CMP      r0,#0                 ;189
000158  d1d6              BNE      |L1.264|
00015a  1c6d              ADDS     r5,r5,#1              ;164
00015c  b2ad              UXTH     r5,r5                 ;164
                  |L1.350|
00015e  429d              CMP      r5,r3                 ;164
000160  d3b7              BCC      |L1.210|
;;;209    							
;;;210    			}
;;;211    	}
;;;212    }
000162  e8bd8fff          POP      {r0-r11,pc}
;;;213    
                          ENDP

                  GetFontItem PROC
;;;241    
;;;242    tSpecialFontItem GetFontItem(tSpecialFont* myFont, char c)
000166  b530              PUSH     {r4,r5,lr}
;;;243    {
;;;244    	uint16_t i;
;;;245    	for (i=0;i<myFont->count;i++)
000168  2300              MOVS     r3,#0
00016a  684c              LDR      r4,[r1,#4]
00016c  7849              LDRB     r1,[r1,#1]
00016e  e00a              B        |L1.390|
                  |L1.368|
;;;246    		if(myFont->Chars[i].code == c)
000170  f8145033          LDRB     r5,[r4,r3,LSL #3]
000174  4295              CMP      r5,r2
000176  d104              BNE      |L1.386|
;;;247    			return myFont->Chars[i];
000178  eb0401c3          ADD      r1,r4,r3,LSL #3
00017c  c906              LDM      r1,{r1,r2}
00017e  c006              STM      r0!,{r1,r2}
;;;248    	// If not found
;;;249    	return myFont->Chars[0];
;;;250    }
000180  bd30              POP      {r4,r5,pc}
                  |L1.386|
000182  1c5b              ADDS     r3,r3,#1              ;245
000184  b29b              UXTH     r3,r3                 ;245
                  |L1.390|
000186  4299              CMP      r1,r3                 ;245
000188  d8f2              BHI      |L1.368|
00018a  cc06              LDM      r4!,{r1,r2}           ;249
00018c  c006              STM      r0!,{r1,r2}           ;249
00018e  bd30              POP      {r4,r5,pc}
;;;251    
                          ENDP

                  LcdPutSpecialStr PROC
;;;253    
;;;254    void LcdPutSpecialStr(uint8_t x_pos, uint8_t y_pos, uint8_t* str, tSpecialFont* myFont, uint16_t* lcd_buffer)
000190  e92d47ff          PUSH     {r0-r10,lr}
;;;255    {
000194  4605              MOV      r5,r0
000196  f8dd9030          LDR      r9,[sp,#0x30]
00019a  468a              MOV      r10,r1
00019c  4616              MOV      r6,r2
00019e  4698              MOV      r8,r3
;;;256    	uint16_t i = 0;
0001a0  2400              MOVS     r4,#0
;;;257    	tSpecialFontItem item_ptr;
;;;258    	while(str[i] != '\0')
0001a2  e019              B        |L1.472|
                  |L1.420|
;;;259    	{
;;;260    		item_ptr = GetFontItem(myFont,str[i++]);
0001a4  4620              MOV      r0,r4
0001a6  1c64              ADDS     r4,r4,#1
0001a8  5c32              LDRB     r2,[r6,r0]
0001aa  b2a4              UXTH     r4,r4
0001ac  4641              MOV      r1,r8
0001ae  4668              MOV      r0,sp
0001b0  f7fffffe          BL       GetFontItem
0001b4  e9dd0100          LDRD     r0,r1,[sp,#0]
0001b8  e9cd0102          STRD     r0,r1,[sp,#8]
;;;261    		LcdPutImage((uint8_t*)item_ptr.data,x_pos,y_pos,item_ptr.width,myFont->height,lcd_buffer);
0001bc  f8980000          LDRB     r0,[r8,#0]
0001c0  e9cd0900          STRD     r0,r9,[sp,#0]
0001c4  f89d7009          LDRB     r7,[sp,#9]
0001c8  4652              MOV      r2,r10
0001ca  463b              MOV      r3,r7
0001cc  4629              MOV      r1,r5
0001ce  9803              LDR      r0,[sp,#0xc]
0001d0  f7fffffe          BL       LcdPutImage
;;;262    		x_pos += item_ptr.width;
0001d4  1978              ADDS     r0,r7,r5
0001d6  b2c5              UXTB     r5,r0
                  |L1.472|
0001d8  5d30              LDRB     r0,[r6,r4]            ;258
0001da  2800              CMP      r0,#0                 ;258
0001dc  d1e2              BNE      |L1.420|
;;;263    	}
;;;264    }
0001de  e8bd87ff          POP      {r0-r10,pc}
;;;265    
                          ENDP

                  LcdPutNormalStr PROC
;;;266    
;;;267    void LcdPutNormalStr(uint8_t x_pos, uint8_t y_pos, uint8_t* str, tNormalFont* myFont, uint16_t* lcd_buffer)
0001e2  e92d43fc          PUSH     {r2-r9,lr}
;;;268    {
0001e6  4606              MOV      r6,r0
0001e8  f8dd8024          LDR      r8,[sp,#0x24]
0001ec  4689              MOV      r9,r1
0001ee  4617              MOV      r7,r2
0001f0  461c              MOV      r4,r3
;;;269    	uint16_t i = 0;
0001f2  2500              MOVS     r5,#0
;;;270    	uint16_t charPointer;
;;;271    	
;;;272    	while(str[i] != '\0')
0001f4  e012              B        |L1.540|
                  |L1.502|
;;;273    	{
;;;274    		charPointer = str[i++] * myFont->bytesPerChar;
0001f6  4628              MOV      r0,r5
0001f8  1c6d              ADDS     r5,r5,#1
0001fa  5c38              LDRB     r0,[r7,r0]
0001fc  78e1              LDRB     r1,[r4,#3]
0001fe  b2ad              UXTH     r5,r5
000200  4348              MULS     r0,r1,r0
;;;275    		LcdPutImage((uint8_t*)&myFont->data[charPointer],x_pos,y_pos,myFont->width,myFont->height,lcd_buffer);
000202  7861              LDRB     r1,[r4,#1]
000204  e9cd1800          STRD     r1,r8,[sp,#0]
000208  6861              LDR      r1,[r4,#4]
00020a  7823              LDRB     r3,[r4,#0]
00020c  4408              ADD      r0,r0,r1
00020e  464a              MOV      r2,r9
000210  4631              MOV      r1,r6
000212  f7fffffe          BL       LcdPutImage
;;;276    		x_pos += myFont->width;
000216  7820              LDRB     r0,[r4,#0]
000218  4430              ADD      r0,r0,r6
00021a  b2c6              UXTB     r6,r0
                  |L1.540|
00021c  5d78              LDRB     r0,[r7,r5]            ;272
00021e  2800              CMP      r0,#0                 ;272
000220  d1e9              BNE      |L1.502|
;;;277    	}
;;;278    
;;;279    	
;;;280    }
000222  e8bd83fc          POP      {r2-r9,pc}
;;;281    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  lcd0_buffer
                          %        1728

                          AREA ||area_number.4||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.4||, ||.bss||
                  lcd1_buffer
                          %        1728

;*** Start embedded assembler ***

#line 1 "src\\lcd_func.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_lcd_func_c_8f1eeab9____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_lcd_func_c_8f1eeab9____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_lcd_func_c_8f1eeab9____REVSH|
#line 130
|__asm___10_lcd_func_c_8f1eeab9____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
