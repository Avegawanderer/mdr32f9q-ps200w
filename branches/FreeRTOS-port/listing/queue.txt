; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\FLASH\queue.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\FLASH\queue.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\src\fonts -I.\ -I.\src -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -I..\Library\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\startup\arm -I..\Library\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\portable\RVDS\ARM_CM3\ -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source -I..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\include -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Milandr\MDR32F9x --omf_browse=.\FLASH\queue.crf ..\Library\FreeRTOSV7.5.3\FreeRTOS\Source\queue.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  xQueueGenericReset PROC
;;;238    
;;;239    portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;240    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;241    xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
000006  462c              MOV      r4,r5
;;;242    
;;;243    	configASSERT( pxQueue );
;;;244    
;;;245    	taskENTER_CRITICAL();
000008  f7fffffe          BL       vPortEnterCritical
;;;246    	{
;;;247    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
00000c  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
000010  6820              LDR      r0,[r4,#0]
000012  fb010002          MLA      r0,r1,r2,r0
000016  6060              STR      r0,[r4,#4]
;;;248    		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
000018  2000              MOVS     r0,#0
00001a  63a0              STR      r0,[r4,#0x38]
;;;249    		pxQueue->pcWriteTo = pxQueue->pcHead;
00001c  6820              LDR      r0,[r4,#0]
00001e  60a0              STR      r0,[r4,#8]
;;;250    		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
000020  6be0              LDR      r0,[r4,#0x3c]
000022  1e40              SUBS     r0,r0,#1
000024  6c22              LDR      r2,[r4,#0x40]
000026  6821              LDR      r1,[r4,#0]
000028  fb001002          MLA      r0,r0,r2,r1
00002c  60e0              STR      r0,[r4,#0xc]
;;;251    		pxQueue->xRxLock = queueUNLOCKED;
00002e  f04f30ff          MOV      r0,#0xffffffff
000032  6460              STR      r0,[r4,#0x44]
;;;252    		pxQueue->xTxLock = queueUNLOCKED;
000034  64a0              STR      r0,[r4,#0x48]
;;;253    
;;;254    		if( xNewQueue == pdFALSE )
000036  b976              CBNZ     r6,|L1.86|
;;;255    		{
;;;256    			/* If there are tasks blocked waiting to read from the queue, then
;;;257    			the tasks will remain blocked as after this function exits the queue
;;;258    			will still be empty.  If there are tasks blocked waiting to	write to
;;;259    			the queue, then one should be unblocked as after this function exits
;;;260    			it will be possible to write to it. */
;;;261    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000038  6920              LDR      r0,[r4,#0x10]
00003a  b908              CBNZ     r0,|L1.64|
00003c  2001              MOVS     r0,#1
00003e  e000              B        |L1.66|
                  |L1.64|
000040  2000              MOVS     r0,#0
                  |L1.66|
000042  b980              CBNZ     r0,|L1.102|
;;;262    			{
;;;263    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
000044  f1040010          ADD      r0,r4,#0x10
000048  f7fffffe          BL       xTaskRemoveFromEventList
00004c  2801              CMP      r0,#1
00004e  d10a              BNE      |L1.102|
;;;264    				{
;;;265    					portYIELD_WITHIN_API();
000050  f7fffffe          BL       vPortYield
000054  e007              B        |L1.102|
                  |L1.86|
;;;266    				}
;;;267    			}
;;;268    		}
;;;269    		else
;;;270    		{
;;;271    			/* Ensure the event queues start in the correct state. */
;;;272    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
000056  f1040010          ADD      r0,r4,#0x10
00005a  f7fffffe          BL       vListInitialise
;;;273    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
00005e  f1040024          ADD      r0,r4,#0x24
000062  f7fffffe          BL       vListInitialise
                  |L1.102|
;;;274    		}
;;;275    	}
;;;276    	taskEXIT_CRITICAL();
000066  f7fffffe          BL       vPortExitCritical
;;;277    
;;;278    	/* A value is returned for calling semantic consistency with previous
;;;279    	versions. */
;;;280    	return pdPASS;
00006a  2001              MOVS     r0,#1
;;;281    }
00006c  bd70              POP      {r4-r6,pc}
;;;282    /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericCreate PROC
;;;283    
;;;284    xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
00006e  e92d47f0          PUSH     {r4-r10,lr}
;;;285    {
000072  4605              MOV      r5,r0
000074  460e              MOV      r6,r1
000076  4691              MOV      r9,r2
;;;286    xQUEUE *pxNewQueue;
;;;287    size_t xQueueSizeInBytes;
;;;288    xQueueHandle xReturn = NULL;
000078  f04f0800          MOV      r8,#0
;;;289    
;;;290    	/* Remove compiler warnings about unused parameters should
;;;291    	configUSE_TRACE_FACILITY not be set to 1. */
;;;292    	( void ) ucQueueType;
;;;293    
;;;294    	/* Allocate the new queue structure. */
;;;295    	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
00007c  b1c5              CBZ      r5,|L1.176|
;;;296    	{
;;;297    		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
00007e  204c              MOVS     r0,#0x4c
000080  f7fffffe          BL       pvPortMalloc
000084  4604              MOV      r4,r0
;;;298    		if( pxNewQueue != NULL )
000086  b19c              CBZ      r4,|L1.176|
;;;299    		{
;;;300    			/* Create the list of pointers to queue items.  The queue is one byte
;;;301    			longer than asked for to make wrap checking easier/faster. */
;;;302    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000088  fb05f006          MUL      r0,r5,r6
00008c  1c47              ADDS     r7,r0,#1
;;;303    
;;;304    			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
00008e  4638              MOV      r0,r7
000090  f7fffffe          BL       pvPortMalloc
000094  6020              STR      r0,[r4,#0]
;;;305    			if( pxNewQueue->pcHead != NULL )
000096  6820              LDR      r0,[r4,#0]
000098  b138              CBZ      r0,|L1.170|
;;;306    			{
;;;307    				/* Initialise the queue members as described above where the
;;;308    				queue type is defined. */
;;;309    				pxNewQueue->uxLength = uxQueueLength;
00009a  63e5              STR      r5,[r4,#0x3c]
;;;310    				pxNewQueue->uxItemSize = uxItemSize;
00009c  6426              STR      r6,[r4,#0x40]
;;;311    				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
00009e  2101              MOVS     r1,#1
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       xQueueGenericReset
;;;312    
;;;313    				#if ( configUSE_TRACE_FACILITY == 1 )
;;;314    				{
;;;315    					pxNewQueue->ucQueueType = ucQueueType;
;;;316    				}
;;;317    				#endif /* configUSE_TRACE_FACILITY */
;;;318    
;;;319    				#if( configUSE_QUEUE_SETS == 1 )
;;;320    				{
;;;321    					pxNewQueue->pxQueueSetContainer = NULL;
;;;322    				}
;;;323    				#endif /* configUSE_QUEUE_SETS */
;;;324    
;;;325    				traceQUEUE_CREATE( pxNewQueue );
;;;326    				xReturn = pxNewQueue;
0000a6  46a0              MOV      r8,r4
0000a8  e002              B        |L1.176|
                  |L1.170|
;;;327    			}
;;;328    			else
;;;329    			{
;;;330    				traceQUEUE_CREATE_FAILED( ucQueueType );
;;;331    				vPortFree( pxNewQueue );
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       vPortFree
                  |L1.176|
;;;332    			}
;;;333    		}
;;;334    	}
;;;335    
;;;336    	configASSERT( xReturn );
;;;337    
;;;338    	return xReturn;
0000b0  4640              MOV      r0,r8
;;;339    }
0000b2  e8bd87f0          POP      {r4-r10,pc}
;;;340    /*-----------------------------------------------------------*/
                          ENDP

                  prvUnlockQueue PROC
;;;1471   
;;;1472   static void prvUnlockQueue( xQUEUE *pxQueue )
0000b6  b510              PUSH     {r4,lr}
;;;1473   {
0000b8  4604              MOV      r4,r0
;;;1474   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;1475   
;;;1476   	/* The lock counts contains the number of extra data items placed or
;;;1477   	removed from the queue while the queue was locked.  When a queue is
;;;1478   	locked items can be added or removed, but the event lists cannot be
;;;1479   	updated. */
;;;1480   	taskENTER_CRITICAL();
0000ba  f7fffffe          BL       vPortEnterCritical
;;;1481   	{
;;;1482   		/* See if data was added to the queue while it was locked. */
;;;1483   		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
0000be  e011              B        |L1.228|
                  |L1.192|
;;;1484   		{
;;;1485   			/* Data was posted while the queue was locked.  Are any tasks
;;;1486   			blocked waiting for data to become available? */
;;;1487   			#if ( configUSE_QUEUE_SETS == 1 )
;;;1488   			{
;;;1489   				if( pxQueue->pxQueueSetContainer != NULL )
;;;1490   				{
;;;1491   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
;;;1492   					{
;;;1493   						/* The queue is a member of a queue set, and posting to
;;;1494   						the queue set caused a higher priority task to unblock.
;;;1495   						A context switch is required. */
;;;1496   						vTaskMissedYield();
;;;1497   					}
;;;1498   				}
;;;1499   				else
;;;1500   				{
;;;1501   					/* Tasks that are removed from the event list will get added to
;;;1502   					the pending ready list as the scheduler is still suspended. */
;;;1503   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1504   					{
;;;1505   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1506   						{
;;;1507   							/* The task waiting has a higher priority so record that a
;;;1508   							context	switch is required. */
;;;1509   							vTaskMissedYield();
;;;1510   						}
;;;1511   					}
;;;1512   					else
;;;1513   					{
;;;1514   						break;
;;;1515   					}
;;;1516   				}
;;;1517   			}
;;;1518   			#else /* configUSE_QUEUE_SETS */
;;;1519   			{
;;;1520   				/* Tasks that are removed from the event list will get added to
;;;1521   				the pending ready list as the scheduler is still suspended. */
;;;1522   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0000c0  6a60              LDR      r0,[r4,#0x24]
0000c2  b908              CBNZ     r0,|L1.200|
0000c4  2001              MOVS     r0,#1
0000c6  e000              B        |L1.202|
                  |L1.200|
0000c8  2000              MOVS     r0,#0
                  |L1.202|
0000ca  b938              CBNZ     r0,|L1.220|
;;;1523   				{
;;;1524   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000cc  f1040024          ADD      r0,r4,#0x24
0000d0  f7fffffe          BL       xTaskRemoveFromEventList
0000d4  b118              CBZ      r0,|L1.222|
;;;1525   					{
;;;1526   						/* The task waiting has a higher priority so record that a
;;;1527   						context	switch is required. */
;;;1528   						vTaskMissedYield();
0000d6  f7fffffe          BL       vTaskMissedYield
0000da  e000              B        |L1.222|
                  |L1.220|
;;;1529   					}
;;;1530   				}
;;;1531   				else
;;;1532   				{
;;;1533   					break;
0000dc  e005              B        |L1.234|
                  |L1.222|
;;;1534   				}
;;;1535   			}
;;;1536   			#endif /* configUSE_QUEUE_SETS */
;;;1537   
;;;1538   			--( pxQueue->xTxLock );
0000de  6ca0              LDR      r0,[r4,#0x48]
0000e0  1e40              SUBS     r0,r0,#1
0000e2  64a0              STR      r0,[r4,#0x48]
                  |L1.228|
0000e4  6ca0              LDR      r0,[r4,#0x48]         ;1483
0000e6  2800              CMP      r0,#0                 ;1483
0000e8  dcea              BGT      |L1.192|
                  |L1.234|
0000ea  bf00              NOP                            ;1533
;;;1539   		}
;;;1540   
;;;1541   		pxQueue->xTxLock = queueUNLOCKED;
0000ec  f04f30ff          MOV      r0,#0xffffffff
0000f0  64a0              STR      r0,[r4,#0x48]
;;;1542   	}
;;;1543   	taskEXIT_CRITICAL();
0000f2  f7fffffe          BL       vPortExitCritical
;;;1544   
;;;1545   	/* Do the same for the Rx lock. */
;;;1546   	taskENTER_CRITICAL();
0000f6  f7fffffe          BL       vPortEnterCritical
;;;1547   	{
;;;1548   		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
0000fa  e011              B        |L1.288|
                  |L1.252|
;;;1549   		{
;;;1550   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
0000fc  6920              LDR      r0,[r4,#0x10]
0000fe  b908              CBNZ     r0,|L1.260|
000100  2001              MOVS     r0,#1
000102  e000              B        |L1.262|
                  |L1.260|
000104  2000              MOVS     r0,#0
                  |L1.262|
000106  b950              CBNZ     r0,|L1.286|
;;;1551   			{
;;;1552   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000108  f1040010          ADD      r0,r4,#0x10
00010c  f7fffffe          BL       xTaskRemoveFromEventList
000110  b108              CBZ      r0,|L1.278|
;;;1553   				{
;;;1554   					vTaskMissedYield();
000112  f7fffffe          BL       vTaskMissedYield
                  |L1.278|
;;;1555   				}
;;;1556   
;;;1557   				--( pxQueue->xRxLock );
000116  6c60              LDR      r0,[r4,#0x44]
000118  1e40              SUBS     r0,r0,#1
00011a  6460              STR      r0,[r4,#0x44]
00011c  e000              B        |L1.288|
                  |L1.286|
;;;1558   			}
;;;1559   			else
;;;1560   			{
;;;1561   				break;
00011e  e002              B        |L1.294|
                  |L1.288|
000120  6c60              LDR      r0,[r4,#0x44]         ;1548
000122  2800              CMP      r0,#0                 ;1548
000124  dcea              BGT      |L1.252|
                  |L1.294|
000126  bf00              NOP      
;;;1562   			}
;;;1563   		}
;;;1564   
;;;1565   		pxQueue->xRxLock = queueUNLOCKED;
000128  f04f30ff          MOV      r0,#0xffffffff
00012c  6460              STR      r0,[r4,#0x44]
;;;1566   	}
;;;1567   	taskEXIT_CRITICAL();
00012e  f7fffffe          BL       vPortExitCritical
;;;1568   }
000132  bd10              POP      {r4,pc}
;;;1569   /*-----------------------------------------------------------*/
                          ENDP

                  prvIsQueueFull PROC
;;;1609   
;;;1610   static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
000134  b570              PUSH     {r4-r6,lr}
;;;1611   {
000136  4605              MOV      r5,r0
;;;1612   signed portBASE_TYPE xReturn;
;;;1613   
;;;1614   	taskENTER_CRITICAL();
000138  f7fffffe          BL       vPortEnterCritical
;;;1615   	{
;;;1616   		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
00013c  6ba8              LDR      r0,[r5,#0x38]
00013e  6be9              LDR      r1,[r5,#0x3c]
000140  4288              CMP      r0,r1
000142  d101              BNE      |L1.328|
;;;1617   		{
;;;1618   			xReturn = pdTRUE;
000144  2401              MOVS     r4,#1
000146  e000              B        |L1.330|
                  |L1.328|
;;;1619   		}
;;;1620   		else
;;;1621   		{
;;;1622   			xReturn = pdFALSE;
000148  2400              MOVS     r4,#0
                  |L1.330|
;;;1623   		}
;;;1624   	}
;;;1625   	taskEXIT_CRITICAL();
00014a  f7fffffe          BL       vPortExitCritical
;;;1626   
;;;1627   	return xReturn;
00014e  4620              MOV      r0,r4
;;;1628   }
000150  bd70              POP      {r4-r6,pc}
;;;1629   /*-----------------------------------------------------------*/
                          ENDP

                  prvCopyDataToQueue PROC
;;;1407   
;;;1408   static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
000152  b570              PUSH     {r4-r6,lr}
;;;1409   {
000154  4604              MOV      r4,r0
000156  460e              MOV      r6,r1
000158  4615              MOV      r5,r2
;;;1410   	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
00015a  6c20              LDR      r0,[r4,#0x40]
00015c  b340              CBZ      r0,|L1.432|
;;;1411   	{
;;;1412   		#if ( configUSE_MUTEXES == 1 )
;;;1413   		{
;;;1414   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1415   			{
;;;1416   				/* The mutex is no longer being held. */
;;;1417   				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
;;;1418   				pxQueue->pxMutexHolder = NULL;
;;;1419   			}
;;;1420   		}
;;;1421   		#endif /* configUSE_MUTEXES */
;;;1422   	}
;;;1423   	else if( xPosition == queueSEND_TO_BACK )
00015e  b97d              CBNZ     r5,|L1.384|
;;;1424   	{
;;;1425   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
000160  4631              MOV      r1,r6
000162  6c22              LDR      r2,[r4,#0x40]
000164  68a0              LDR      r0,[r4,#8]
000166  f7fffffe          BL       __aeabi_memcpy
;;;1426   		pxQueue->pcWriteTo += pxQueue->uxItemSize;
00016a  6c21              LDR      r1,[r4,#0x40]
00016c  68a0              LDR      r0,[r4,#8]
00016e  4408              ADD      r0,r0,r1
000170  60a0              STR      r0,[r4,#8]
;;;1427   		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
000172  e9d41001          LDRD     r1,r0,[r4,#4]
000176  4288              CMP      r0,r1
000178  d31a              BCC      |L1.432|
;;;1428   		{
;;;1429   			pxQueue->pcWriteTo = pxQueue->pcHead;
00017a  6820              LDR      r0,[r4,#0]
00017c  60a0              STR      r0,[r4,#8]
00017e  e017              B        |L1.432|
                  |L1.384|
;;;1430   		}
;;;1431   	}
;;;1432   	else
;;;1433   	{
;;;1434   		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000180  4631              MOV      r1,r6
000182  6c22              LDR      r2,[r4,#0x40]
000184  68e0              LDR      r0,[r4,#0xc]
000186  f7fffffe          BL       __aeabi_memcpy
;;;1435   		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
00018a  6c21              LDR      r1,[r4,#0x40]
00018c  68e0              LDR      r0,[r4,#0xc]
00018e  1a40              SUBS     r0,r0,r1
000190  60e0              STR      r0,[r4,#0xc]
;;;1436   		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
000192  6821              LDR      r1,[r4,#0]
000194  68e0              LDR      r0,[r4,#0xc]
000196  4288              CMP      r0,r1
000198  d203              BCS      |L1.418|
;;;1437   		{
;;;1438   			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
00019a  6c21              LDR      r1,[r4,#0x40]
00019c  6860              LDR      r0,[r4,#4]
00019e  1a40              SUBS     r0,r0,r1
0001a0  60e0              STR      r0,[r4,#0xc]
                  |L1.418|
;;;1439   		}
;;;1440   
;;;1441   		if( xPosition == queueOVERWRITE )
0001a2  2d02              CMP      r5,#2
0001a4  d104              BNE      |L1.432|
;;;1442   		{
;;;1443   			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
0001a6  6ba0              LDR      r0,[r4,#0x38]
0001a8  b110              CBZ      r0,|L1.432|
;;;1444   			{
;;;1445   				/* An item is not being added but overwritten, so subtract
;;;1446   				one from the recorded number of items in the queue so when
;;;1447   				one is added again below the number of recorded items remains
;;;1448   				correct. */
;;;1449   				--( pxQueue->uxMessagesWaiting );
0001aa  6ba0              LDR      r0,[r4,#0x38]
0001ac  1e40              SUBS     r0,r0,#1
0001ae  63a0              STR      r0,[r4,#0x38]
                  |L1.432|
;;;1450   			}
;;;1451   		}
;;;1452   	}
;;;1453   
;;;1454   	++( pxQueue->uxMessagesWaiting );
0001b0  6ba0              LDR      r0,[r4,#0x38]
0001b2  1c40              ADDS     r0,r0,#1
0001b4  63a0              STR      r0,[r4,#0x38]
;;;1455   }
0001b6  bd70              POP      {r4-r6,pc}
;;;1456   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericSend PROC
;;;553    
;;;554    signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
0001b8  e92d41ff          PUSH     {r0-r8,lr}
;;;555    {
0001bc  b082              SUB      sp,sp,#8
0001be  4606              MOV      r6,r0
0001c0  460f              MOV      r7,r1
0001c2  461d              MOV      r5,r3
;;;556    signed portBASE_TYPE xEntryTimeSet = pdFALSE;
0001c4  f04f0800          MOV      r8,#0
;;;557    xTimeOutType xTimeOut;
;;;558    xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
0001c8  4634              MOV      r4,r6
;;;559    
;;;560    	configASSERT( pxQueue );
;;;561    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;562    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;563    
;;;564    	/* This function relaxes the coding standard somewhat to allow return
;;;565    	statements within the function itself.  This is done in the interest
;;;566    	of execution time efficiency. */
;;;567    	for( ;; )
0001ca  bf00              NOP      
                  |L1.460|
;;;568    	{
;;;569    		taskENTER_CRITICAL();
0001cc  f7fffffe          BL       vPortEnterCritical
;;;570    		{
;;;571    			/* Is there room on the queue now?  The running task must be
;;;572    			the highest priority task wanting to access the queue.  If
;;;573    			the head item in the queue is to be overwritten then it does
;;;574    			not matter if the queue is full. */
;;;575    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
0001d0  6ba0              LDR      r0,[r4,#0x38]
0001d2  6be1              LDR      r1,[r4,#0x3c]
0001d4  4288              CMP      r0,r1
0001d6  d301              BCC      |L1.476|
0001d8  2d02              CMP      r5,#2
0001da  d118              BNE      |L1.526|
                  |L1.476|
;;;576    			{
;;;577    				traceQUEUE_SEND( pxQueue );
;;;578    				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
0001dc  462a              MOV      r2,r5
0001de  4639              MOV      r1,r7
0001e0  4620              MOV      r0,r4
0001e2  f7fffffe          BL       prvCopyDataToQueue
;;;579    
;;;580    				#if ( configUSE_QUEUE_SETS == 1 )
;;;581    				{
;;;582    					if( pxQueue->pxQueueSetContainer != NULL )
;;;583    					{
;;;584    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;585    						{
;;;586    							/* The queue is a member of a queue set, and posting
;;;587    							to the queue set caused a higher priority task to
;;;588    							unblock. A context switch is required. */
;;;589    							portYIELD_WITHIN_API();
;;;590    						}
;;;591    					}
;;;592    					else
;;;593    					{
;;;594    						/* If there was a task waiting for data to arrive on the
;;;595    						queue then unblock it now. */
;;;596    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;597    						{
;;;598    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
;;;599    							{
;;;600    								/* The unblocked task has a priority higher than
;;;601    								our own so yield immediately.  Yes it is ok to
;;;602    								do this from within the critical section - the
;;;603    								kernel takes care of that. */
;;;604    								portYIELD_WITHIN_API();
;;;605    							}
;;;606    						}
;;;607    					}
;;;608    				}
;;;609    				#else /* configUSE_QUEUE_SETS */
;;;610    				{
;;;611    					/* If there was a task waiting for data to arrive on the
;;;612    					queue then unblock it now. */
;;;613    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0001e6  6a60              LDR      r0,[r4,#0x24]
0001e8  b908              CBNZ     r0,|L1.494|
0001ea  2001              MOVS     r0,#1
0001ec  e000              B        |L1.496|
                  |L1.494|
0001ee  2000              MOVS     r0,#0
                  |L1.496|
0001f0  b938              CBNZ     r0,|L1.514|
;;;614    					{
;;;615    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
0001f2  f1040024          ADD      r0,r4,#0x24
0001f6  f7fffffe          BL       xTaskRemoveFromEventList
0001fa  2801              CMP      r0,#1
0001fc  d101              BNE      |L1.514|
;;;616    						{
;;;617    							/* The unblocked task has a priority higher than
;;;618    							our own so yield immediately.  Yes it is ok to do
;;;619    							this from within the critical section - the kernel
;;;620    							takes care of that. */
;;;621    							portYIELD_WITHIN_API();
0001fe  f7fffffe          BL       vPortYield
                  |L1.514|
;;;622    						}
;;;623    					}
;;;624    				}
;;;625    				#endif /* configUSE_QUEUE_SETS */
;;;626    
;;;627    				taskEXIT_CRITICAL();
000202  f7fffffe          BL       vPortExitCritical
;;;628    
;;;629    				/* Return to the original privilege level before exiting the
;;;630    				function. */
;;;631    				return pdPASS;
000206  2001              MOVS     r0,#1
                  |L1.520|
;;;632    			}
;;;633    			else
;;;634    			{
;;;635    				if( xTicksToWait == ( portTickType ) 0 )
;;;636    				{
;;;637    					/* The queue was full and no block time is specified (or
;;;638    					the block time has expired) so leave now. */
;;;639    					taskEXIT_CRITICAL();
;;;640    
;;;641    					/* Return to the original privilege level before exiting
;;;642    					the function. */
;;;643    					traceQUEUE_SEND_FAILED( pxQueue );
;;;644    					return errQUEUE_FULL;
;;;645    				}
;;;646    				else if( xEntryTimeSet == pdFALSE )
;;;647    				{
;;;648    					/* The queue was full and a block time was specified so
;;;649    					configure the timeout structure. */
;;;650    					vTaskSetTimeOutState( &xTimeOut );
;;;651    					xEntryTimeSet = pdTRUE;
;;;652    				}
;;;653    				else
;;;654    				{
;;;655    					/* Entry time was already set. */
;;;656    				}
;;;657    			}
;;;658    		}
;;;659    		taskEXIT_CRITICAL();
;;;660    
;;;661    		/* Interrupts and other tasks can send to and receive from the queue
;;;662    		now the critical section has been exited. */
;;;663    
;;;664    		vTaskSuspendAll();
;;;665    		prvLockQueue( pxQueue );
;;;666    
;;;667    		/* Update the timeout state to see if it has expired yet. */
;;;668    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;669    		{
;;;670    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;671    			{
;;;672    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;673    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;674    
;;;675    				/* Unlocking the queue means queue events can effect the
;;;676    				event list.  It is possible	that interrupts occurring now
;;;677    				remove this task from the event	list again - but as the
;;;678    				scheduler is suspended the task will go onto the pending
;;;679    				ready last instead of the actual ready list. */
;;;680    				prvUnlockQueue( pxQueue );
;;;681    
;;;682    				/* Resuming the scheduler will move tasks from the pending
;;;683    				ready list into the ready list - so it is feasible that this
;;;684    				task is already in a ready list before it yields - in which
;;;685    				case the yield will not cause a context switch unless there
;;;686    				is also a higher priority task in the pending ready list. */
;;;687    				if( xTaskResumeAll() == pdFALSE )
;;;688    				{
;;;689    					portYIELD_WITHIN_API();
;;;690    				}
;;;691    			}
;;;692    			else
;;;693    			{
;;;694    				/* Try again. */
;;;695    				prvUnlockQueue( pxQueue );
;;;696    				( void ) xTaskResumeAll();
;;;697    			}
;;;698    		}
;;;699    		else
;;;700    		{
;;;701    			/* The timeout has expired. */
;;;702    			prvUnlockQueue( pxQueue );
;;;703    			( void ) xTaskResumeAll();
;;;704    
;;;705    			/* Return to the original privilege level before exiting the
;;;706    			function. */
;;;707    			traceQUEUE_SEND_FAILED( pxQueue );
;;;708    			return errQUEUE_FULL;
;;;709    		}
;;;710    	}
;;;711    }
000208  b006              ADD      sp,sp,#0x18
00020a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.526|
00020e  9804              LDR      r0,[sp,#0x10]         ;635
000210  b918              CBNZ     r0,|L1.538|
000212  f7fffffe          BL       vPortExitCritical
000216  2000              MOVS     r0,#0                 ;644
000218  e7f6              B        |L1.520|
                  |L1.538|
00021a  f1b80f00          CMP      r8,#0                 ;646
00021e  d104              BNE      |L1.554|
000220  4668              MOV      r0,sp                 ;650
000222  f7fffffe          BL       vTaskSetTimeOutState
000226  f04f0801          MOV      r8,#1                 ;651
                  |L1.554|
00022a  f7fffffe          BL       vPortExitCritical
00022e  f7fffffe          BL       vTaskSuspendAll
000232  f7fffffe          BL       vPortEnterCritical
000236  6c60              LDR      r0,[r4,#0x44]         ;665
000238  1c40              ADDS     r0,r0,#1              ;665
00023a  d100              BNE      |L1.574|
00023c  6460              STR      r0,[r4,#0x44]         ;665
                  |L1.574|
00023e  6ca0              LDR      r0,[r4,#0x48]         ;665
000240  1c40              ADDS     r0,r0,#1              ;665
000242  d100              BNE      |L1.582|
000244  64a0              STR      r0,[r4,#0x48]         ;665
                  |L1.582|
000246  f7fffffe          BL       vPortExitCritical
00024a  a904              ADD      r1,sp,#0x10           ;668
00024c  4668              MOV      r0,sp                 ;668
00024e  f7fffffe          BL       xTaskCheckForTimeOut
000252  b9c0              CBNZ     r0,|L1.646|
000254  4620              MOV      r0,r4                 ;670
000256  f7fffffe          BL       prvIsQueueFull
00025a  b170              CBZ      r0,|L1.634|
00025c  f1040010          ADD      r0,r4,#0x10           ;673
000260  9904              LDR      r1,[sp,#0x10]         ;673
000262  f7fffffe          BL       vTaskPlaceOnEventList
000266  4620              MOV      r0,r4                 ;680
000268  f7fffffe          BL       prvUnlockQueue
00026c  f7fffffe          BL       xTaskResumeAll
000270  2800              CMP      r0,#0                 ;687
000272  d1ab              BNE      |L1.460|
000274  f7fffffe          BL       vPortYield
000278  e7a8              B        |L1.460|
                  |L1.634|
00027a  4620              MOV      r0,r4                 ;695
00027c  f7fffffe          BL       prvUnlockQueue
000280  f7fffffe          BL       xTaskResumeAll
000284  e7a2              B        |L1.460|
                  |L1.646|
000286  4620              MOV      r0,r4                 ;702
000288  f7fffffe          BL       prvUnlockQueue
00028c  f7fffffe          BL       xTaskResumeAll
000290  2000              MOVS     r0,#0                 ;708
000292  e7b9              B        |L1.520|
;;;712    /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericSendFromISR PROC
;;;923    
;;;924    signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
000294  e92d47f0          PUSH     {r4-r10,lr}
;;;925    {
000298  4605              MOV      r5,r0
00029a  4689              MOV      r9,r1
00029c  4616              MOV      r6,r2
00029e  461f              MOV      r7,r3
;;;926    signed portBASE_TYPE xReturn;
;;;927    unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;928    xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
0002a0  462c              MOV      r4,r5
;;;929    
;;;930    	configASSERT( pxQueue );
;;;931    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;932    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;933    
;;;934    	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;935    	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;936    	above the maximum system call priority are keep permanently enabled, even
;;;937    	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;938    	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;939    	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;940    	failure if a FreeRTOS API function is called from an interrupt that has been
;;;941    	assigned a priority above the configured maximum system call priority.
;;;942    	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;943    	that have been assigned a priority at or (logically) below the maximum
;;;944    	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;945    	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;946    	More information (albeit Cortex-M specific) is provided on the following
;;;947    	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;948    	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;949    
;;;950    	/* Similar to xQueueGenericSend, except we don't block if there is no room
;;;951    	in the queue.  Also we don't directly wake a task that was blocked on a
;;;952    	queue read, instead we return a flag to say whether a context switch is
;;;953    	required or not (i.e. has a task with a higher priority than us been woken
;;;954    	by this	post). */
;;;955    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0002a2  f7fffffe          BL       ulPortSetInterruptMask
0002a6  4682              MOV      r10,r0
;;;956    	{
;;;957    		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
0002a8  6ba0              LDR      r0,[r4,#0x38]
0002aa  6be1              LDR      r1,[r4,#0x3c]
0002ac  4288              CMP      r0,r1
0002ae  d301              BCC      |L1.692|
0002b0  2f02              CMP      r7,#2
0002b2  d11c              BNE      |L1.750|
                  |L1.692|
;;;958    		{
;;;959    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;960    
;;;961    			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
0002b4  463a              MOV      r2,r7
0002b6  4649              MOV      r1,r9
0002b8  4620              MOV      r0,r4
0002ba  f7fffffe          BL       prvCopyDataToQueue
;;;962    
;;;963    			/* If the queue is locked we do not alter the event list.  This will
;;;964    			be done when the queue is unlocked later. */
;;;965    			if( pxQueue->xTxLock == queueUNLOCKED )
0002be  6ca0              LDR      r0,[r4,#0x48]
0002c0  1c40              ADDS     r0,r0,#1
0002c2  d10e              BNE      |L1.738|
;;;966    			{
;;;967    				#if ( configUSE_QUEUE_SETS == 1 )
;;;968    				{
;;;969    					if( pxQueue->pxQueueSetContainer != NULL )
;;;970    					{
;;;971    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;972    						{
;;;973    							/* The queue is a member of a queue set, and posting
;;;974    							to the queue set caused a higher priority task to
;;;975    							unblock.  A context switch is required. */
;;;976    							if( pxHigherPriorityTaskWoken != NULL )
;;;977    							{
;;;978    								*pxHigherPriorityTaskWoken = pdTRUE;
;;;979    							}
;;;980    						}
;;;981    					}
;;;982    					else
;;;983    					{
;;;984    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;985    						{
;;;986    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;987    							{
;;;988    								/* The task waiting has a higher priority so record that a
;;;989    								context	switch is required. */
;;;990    								if( pxHigherPriorityTaskWoken != NULL )
;;;991    								{
;;;992    									*pxHigherPriorityTaskWoken = pdTRUE;
;;;993    								}
;;;994    							}
;;;995    						}
;;;996    					}
;;;997    				}
;;;998    				#else /* configUSE_QUEUE_SETS */
;;;999    				{
;;;1000   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0002c4  6a60              LDR      r0,[r4,#0x24]
0002c6  b908              CBNZ     r0,|L1.716|
0002c8  2001              MOVS     r0,#1
0002ca  e000              B        |L1.718|
                  |L1.716|
0002cc  2000              MOVS     r0,#0
                  |L1.718|
0002ce  b958              CBNZ     r0,|L1.744|
;;;1001   					{
;;;1002   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0002d0  f1040024          ADD      r0,r4,#0x24
0002d4  f7fffffe          BL       xTaskRemoveFromEventList
0002d8  b130              CBZ      r0,|L1.744|
;;;1003   						{
;;;1004   							/* The task waiting has a higher priority so record that a
;;;1005   							context	switch is required. */
;;;1006   							if( pxHigherPriorityTaskWoken != NULL )
0002da  b12e              CBZ      r6,|L1.744|
;;;1007   							{
;;;1008   								*pxHigherPriorityTaskWoken = pdTRUE;
0002dc  2001              MOVS     r0,#1
0002de  6030              STR      r0,[r6,#0]
0002e0  e002              B        |L1.744|
                  |L1.738|
;;;1009   							}
;;;1010   						}
;;;1011   					}
;;;1012   				}
;;;1013   				#endif /* configUSE_QUEUE_SETS */
;;;1014   			}
;;;1015   			else
;;;1016   			{
;;;1017   				/* Increment the lock count so the task that unlocks the queue
;;;1018   				knows that data was posted while it was locked. */
;;;1019   				++( pxQueue->xTxLock );
0002e2  6ca0              LDR      r0,[r4,#0x48]
0002e4  1c40              ADDS     r0,r0,#1
0002e6  64a0              STR      r0,[r4,#0x48]
                  |L1.744|
;;;1020   			}
;;;1021   
;;;1022   			xReturn = pdPASS;
0002e8  f04f0801          MOV      r8,#1
0002ec  e001              B        |L1.754|
                  |L1.750|
;;;1023   		}
;;;1024   		else
;;;1025   		{
;;;1026   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1027   			xReturn = errQUEUE_FULL;
0002ee  f04f0800          MOV      r8,#0
                  |L1.754|
;;;1028   		}
;;;1029   	}
;;;1030   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0002f2  4650              MOV      r0,r10
0002f4  f7fffffe          BL       vPortClearInterruptMask
;;;1031   
;;;1032   	return xReturn;
0002f8  4640              MOV      r0,r8
;;;1033   }
0002fa  e8bd87f0          POP      {r4-r10,pc}
;;;1034   /*-----------------------------------------------------------*/
                          ENDP

                  prvIsQueueEmpty PROC
;;;1570   
;;;1571   static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
0002fe  b570              PUSH     {r4-r6,lr}
;;;1572   {
000300  4605              MOV      r5,r0
;;;1573   signed portBASE_TYPE xReturn;
;;;1574   
;;;1575   	taskENTER_CRITICAL();
000302  f7fffffe          BL       vPortEnterCritical
;;;1576   	{
;;;1577   		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
000306  6ba8              LDR      r0,[r5,#0x38]
000308  b908              CBNZ     r0,|L1.782|
;;;1578   		{
;;;1579   			xReturn = pdTRUE;
00030a  2401              MOVS     r4,#1
00030c  e000              B        |L1.784|
                  |L1.782|
;;;1580   		}
;;;1581   		else
;;;1582   		{
;;;1583   			xReturn = pdFALSE;
00030e  2400              MOVS     r4,#0
                  |L1.784|
;;;1584   		}
;;;1585   	}
;;;1586   	taskEXIT_CRITICAL();
000310  f7fffffe          BL       vPortExitCritical
;;;1587   
;;;1588   	return xReturn;
000314  4620              MOV      r0,r4
;;;1589   }
000316  bd70              POP      {r4-r6,pc}
;;;1590   /*-----------------------------------------------------------*/
                          ENDP

                  prvCopyDataFromQueue PROC
;;;1457   
;;;1458   static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
000318  b570              PUSH     {r4-r6,lr}
;;;1459   {
00031a  4604              MOV      r4,r0
00031c  460d              MOV      r5,r1
;;;1460   	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
00031e  6820              LDR      r0,[r4,#0]
000320  b170              CBZ      r0,|L1.832|
;;;1461   	{
;;;1462   		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
000322  6c21              LDR      r1,[r4,#0x40]
000324  68e0              LDR      r0,[r4,#0xc]
000326  4408              ADD      r0,r0,r1
000328  60e0              STR      r0,[r4,#0xc]
;;;1463   		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
00032a  6861              LDR      r1,[r4,#4]
00032c  68e0              LDR      r0,[r4,#0xc]
00032e  4288              CMP      r0,r1
000330  d301              BCC      |L1.822|
;;;1464   		{
;;;1465   			pxQueue->u.pcReadFrom = pxQueue->pcHead;
000332  6820              LDR      r0,[r4,#0]
000334  60e0              STR      r0,[r4,#0xc]
                  |L1.822|
;;;1466   		}
;;;1467   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
000336  4628              MOV      r0,r5
000338  6c22              LDR      r2,[r4,#0x40]
00033a  68e1              LDR      r1,[r4,#0xc]
00033c  f7fffffe          BL       __aeabi_memcpy
                  |L1.832|
;;;1468   	}
;;;1469   }
000340  bd70              POP      {r4-r6,pc}
;;;1470   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericReceive PROC
;;;1035   
;;;1036   signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, const void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
000342  e92d43ff          PUSH     {r0-r9,lr}
;;;1037   {
000346  b083              SUB      sp,sp,#0xc
000348  4605              MOV      r5,r0
00034a  4688              MOV      r8,r1
00034c  461e              MOV      r6,r3
;;;1038   signed portBASE_TYPE xEntryTimeSet = pdFALSE;
00034e  f04f0900          MOV      r9,#0
;;;1039   xTimeOutType xTimeOut;
;;;1040   signed char *pcOriginalReadPosition;
;;;1041   xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
000352  462c              MOV      r4,r5
;;;1042   
;;;1043   	configASSERT( pxQueue );
;;;1044   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;1045   
;;;1046   	/* This function relaxes the coding standard somewhat to allow return
;;;1047   	statements within the function itself.  This is done in the interest
;;;1048   	of execution time efficiency. */
;;;1049   
;;;1050   	for( ;; )
000354  bf00              NOP      
                  |L1.854|
;;;1051   	{
;;;1052   		taskENTER_CRITICAL();
000356  f7fffffe          BL       vPortEnterCritical
;;;1053   		{
;;;1054   			/* Is there data in the queue now?  To be running we must be
;;;1055   			the highest priority task wanting to access the queue. */
;;;1056   			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
00035a  6ba0              LDR      r0,[r4,#0x38]
00035c  b358              CBZ      r0,|L1.950|
;;;1057   			{
;;;1058   				/* Remember the read position in case the queue is only being
;;;1059   				peeked. */
;;;1060   				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
00035e  68e7              LDR      r7,[r4,#0xc]
;;;1061   
;;;1062   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000360  4641              MOV      r1,r8
000362  4620              MOV      r0,r4
000364  f7fffffe          BL       prvCopyDataFromQueue
;;;1063   
;;;1064   				if( xJustPeeking == pdFALSE )
000368  b98e              CBNZ     r6,|L1.910|
;;;1065   				{
;;;1066   					traceQUEUE_RECEIVE( pxQueue );
;;;1067   
;;;1068   					/* Actually removing data, not just peeking. */
;;;1069   					--( pxQueue->uxMessagesWaiting );
00036a  6ba0              LDR      r0,[r4,#0x38]
00036c  1e40              SUBS     r0,r0,#1
00036e  63a0              STR      r0,[r4,#0x38]
;;;1070   
;;;1071   					#if ( configUSE_MUTEXES == 1 )
;;;1072   					{
;;;1073   						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1074   						{
;;;1075   							/* Record the information required to implement
;;;1076   							priority inheritance should it become necessary. */
;;;1077   							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
;;;1078   						}
;;;1079   					}
;;;1080   					#endif
;;;1081   
;;;1082   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000370  6920              LDR      r0,[r4,#0x10]
000372  b908              CBNZ     r0,|L1.888|
000374  2001              MOVS     r0,#1
000376  e000              B        |L1.890|
                  |L1.888|
000378  2000              MOVS     r0,#0
                  |L1.890|
00037a  b9b0              CBNZ     r0,|L1.938|
;;;1083   					{
;;;1084   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
00037c  f1040010          ADD      r0,r4,#0x10
000380  f7fffffe          BL       xTaskRemoveFromEventList
000384  2801              CMP      r0,#1
000386  d110              BNE      |L1.938|
;;;1085   						{
;;;1086   							portYIELD_WITHIN_API();
000388  f7fffffe          BL       vPortYield
00038c  e00d              B        |L1.938|
                  |L1.910|
;;;1087   						}
;;;1088   					}
;;;1089   				}
;;;1090   				else
;;;1091   				{
;;;1092   					traceQUEUE_PEEK( pxQueue );
;;;1093   
;;;1094   					/* The data is not being removed, so reset the read
;;;1095   					pointer. */
;;;1096   					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
00038e  60e7              STR      r7,[r4,#0xc]
;;;1097   
;;;1098   					/* The data is being left in the queue, so see if there are
;;;1099   					any other tasks waiting for the data. */
;;;1100   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000390  6a60              LDR      r0,[r4,#0x24]
000392  b908              CBNZ     r0,|L1.920|
000394  2001              MOVS     r0,#1
000396  e000              B        |L1.922|
                  |L1.920|
000398  2000              MOVS     r0,#0
                  |L1.922|
00039a  b930              CBNZ     r0,|L1.938|
;;;1101   					{
;;;1102   						/* Tasks that are removed from the event list will get added to
;;;1103   						the pending ready list as the scheduler is still suspended. */
;;;1104   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00039c  f1040024          ADD      r0,r4,#0x24
0003a0  f7fffffe          BL       xTaskRemoveFromEventList
0003a4  b108              CBZ      r0,|L1.938|
;;;1105   						{
;;;1106   							/* The task waiting has a higher priority than this task. */
;;;1107   							portYIELD_WITHIN_API();
0003a6  f7fffffe          BL       vPortYield
                  |L1.938|
;;;1108   						}
;;;1109   					}
;;;1110   				}
;;;1111   
;;;1112   				taskEXIT_CRITICAL();
0003aa  f7fffffe          BL       vPortExitCritical
;;;1113   				return pdPASS;
0003ae  2001              MOVS     r0,#1
                  |L1.944|
;;;1114   			}
;;;1115   			else
;;;1116   			{
;;;1117   				if( xTicksToWait == ( portTickType ) 0 )
;;;1118   				{
;;;1119   					/* The queue was empty and no block time is specified (or
;;;1120   					the block time has expired) so leave now. */
;;;1121   					taskEXIT_CRITICAL();
;;;1122   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1123   					return errQUEUE_EMPTY;
;;;1124   				}
;;;1125   				else if( xEntryTimeSet == pdFALSE )
;;;1126   				{
;;;1127   					/* The queue was empty and a block time was specified so
;;;1128   					configure the timeout structure. */
;;;1129   					vTaskSetTimeOutState( &xTimeOut );
;;;1130   					xEntryTimeSet = pdTRUE;
;;;1131   				}
;;;1132   				else
;;;1133   				{
;;;1134   					/* Entry time was already set. */
;;;1135   				}
;;;1136   			}
;;;1137   		}
;;;1138   		taskEXIT_CRITICAL();
;;;1139   
;;;1140   		/* Interrupts and other tasks can send to and receive from the queue
;;;1141   		now the critical section has been exited. */
;;;1142   
;;;1143   		vTaskSuspendAll();
;;;1144   		prvLockQueue( pxQueue );
;;;1145   
;;;1146   		/* Update the timeout state to see if it has expired yet. */
;;;1147   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1148   		{
;;;1149   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1150   			{
;;;1151   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1152   
;;;1153   				#if ( configUSE_MUTEXES == 1 )
;;;1154   				{
;;;1155   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1156   					{
;;;1157   						portENTER_CRITICAL();
;;;1158   						{
;;;1159   							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1160   						}
;;;1161   						portEXIT_CRITICAL();
;;;1162   					}
;;;1163   				}
;;;1164   				#endif
;;;1165   
;;;1166   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1167   				prvUnlockQueue( pxQueue );
;;;1168   				if( xTaskResumeAll() == pdFALSE )
;;;1169   				{
;;;1170   					portYIELD_WITHIN_API();
;;;1171   				}
;;;1172   			}
;;;1173   			else
;;;1174   			{
;;;1175   				/* Try again. */
;;;1176   				prvUnlockQueue( pxQueue );
;;;1177   				( void ) xTaskResumeAll();
;;;1178   			}
;;;1179   		}
;;;1180   		else
;;;1181   		{
;;;1182   			prvUnlockQueue( pxQueue );
;;;1183   			( void ) xTaskResumeAll();
;;;1184   			traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1185   			return errQUEUE_EMPTY;
;;;1186   		}
;;;1187   	}
;;;1188   }
0003b0  b007              ADD      sp,sp,#0x1c
0003b2  e8bd83f0          POP      {r4-r9,pc}
                  |L1.950|
0003b6  9805              LDR      r0,[sp,#0x14]         ;1117
0003b8  b918              CBNZ     r0,|L1.962|
0003ba  f7fffffe          BL       vPortExitCritical
0003be  2000              MOVS     r0,#0                 ;1123
0003c0  e7f6              B        |L1.944|
                  |L1.962|
0003c2  f1b90f00          CMP      r9,#0                 ;1125
0003c6  d104              BNE      |L1.978|
0003c8  a801              ADD      r0,sp,#4              ;1129
0003ca  f7fffffe          BL       vTaskSetTimeOutState
0003ce  f04f0901          MOV      r9,#1                 ;1130
                  |L1.978|
0003d2  f7fffffe          BL       vPortExitCritical
0003d6  f7fffffe          BL       vTaskSuspendAll
0003da  f7fffffe          BL       vPortEnterCritical
0003de  6c60              LDR      r0,[r4,#0x44]         ;1144
0003e0  1c40              ADDS     r0,r0,#1              ;1144
0003e2  d100              BNE      |L1.998|
0003e4  6460              STR      r0,[r4,#0x44]         ;1144
                  |L1.998|
0003e6  6ca0              LDR      r0,[r4,#0x48]         ;1144
0003e8  1c40              ADDS     r0,r0,#1              ;1144
0003ea  d100              BNE      |L1.1006|
0003ec  64a0              STR      r0,[r4,#0x48]         ;1144
                  |L1.1006|
0003ee  f7fffffe          BL       vPortExitCritical
0003f2  a905              ADD      r1,sp,#0x14           ;1147
0003f4  a801              ADD      r0,sp,#4              ;1147
0003f6  f7fffffe          BL       xTaskCheckForTimeOut
0003fa  b9c0              CBNZ     r0,|L1.1070|
0003fc  4620              MOV      r0,r4                 ;1149
0003fe  f7fffffe          BL       prvIsQueueEmpty
000402  b170              CBZ      r0,|L1.1058|
000404  f1040024          ADD      r0,r4,#0x24           ;1166
000408  9905              LDR      r1,[sp,#0x14]         ;1166
00040a  f7fffffe          BL       vTaskPlaceOnEventList
00040e  4620              MOV      r0,r4                 ;1167
000410  f7fffffe          BL       prvUnlockQueue
000414  f7fffffe          BL       xTaskResumeAll
000418  2800              CMP      r0,#0                 ;1168
00041a  d19c              BNE      |L1.854|
00041c  f7fffffe          BL       vPortYield
000420  e799              B        |L1.854|
                  |L1.1058|
000422  4620              MOV      r0,r4                 ;1176
000424  f7fffffe          BL       prvUnlockQueue
000428  f7fffffe          BL       xTaskResumeAll
00042c  e793              B        |L1.854|
                  |L1.1070|
00042e  4620              MOV      r0,r4                 ;1182
000430  f7fffffe          BL       prvUnlockQueue
000434  f7fffffe          BL       xTaskResumeAll
000438  2000              MOVS     r0,#0                 ;1185
00043a  e7b9              B        |L1.944|
;;;1189   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueReceiveFromISR PROC
;;;1190   
;;;1191   signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, const void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
00043c  e92d47f0          PUSH     {r4-r10,lr}
;;;1192   {
000440  4605              MOV      r5,r0
000442  4688              MOV      r8,r1
000444  4616              MOV      r6,r2
;;;1193   signed portBASE_TYPE xReturn;
;;;1194   unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1195   xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
000446  462c              MOV      r4,r5
;;;1196   
;;;1197   	configASSERT( pxQueue );
;;;1198   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;1199   
;;;1200   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1201   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1202   	above the maximum system call priority are keep permanently enabled, even
;;;1203   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1204   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1205   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1206   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1207   	assigned a priority above the configured maximum system call priority.
;;;1208   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1209   	that have been assigned a priority at or (logically) below the maximum
;;;1210   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1211   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1212   	More information (albeit Cortex-M specific) is provided on the following
;;;1213   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1214   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1215   
;;;1216   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000448  f7fffffe          BL       ulPortSetInterruptMask
00044c  4681              MOV      r9,r0
;;;1217   	{
;;;1218   		/* Cannot block in an ISR, so check there is data available. */
;;;1219   		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
00044e  6ba0              LDR      r0,[r4,#0x38]
000450  b1e8              CBZ      r0,|L1.1166|
;;;1220   		{
;;;1221   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1222   
;;;1223   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000452  4641              MOV      r1,r8
000454  4620              MOV      r0,r4
000456  f7fffffe          BL       prvCopyDataFromQueue
;;;1224   			--( pxQueue->uxMessagesWaiting );
00045a  6ba0              LDR      r0,[r4,#0x38]
00045c  1e40              SUBS     r0,r0,#1
00045e  63a0              STR      r0,[r4,#0x38]
;;;1225   
;;;1226   			/* If the queue is locked the event list will not be modified.
;;;1227   			Instead update the lock count so the task that unlocks the queue
;;;1228   			will know that an ISR has removed data while the queue was
;;;1229   			locked. */
;;;1230   			if( pxQueue->xRxLock == queueUNLOCKED )
000460  6c60              LDR      r0,[r4,#0x44]
000462  1c40              ADDS     r0,r0,#1
000464  d10e              BNE      |L1.1156|
;;;1231   			{
;;;1232   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000466  6920              LDR      r0,[r4,#0x10]
000468  b908              CBNZ     r0,|L1.1134|
00046a  2001              MOVS     r0,#1
00046c  e000              B        |L1.1136|
                  |L1.1134|
00046e  2000              MOVS     r0,#0
                  |L1.1136|
000470  b958              CBNZ     r0,|L1.1162|
;;;1233   				{
;;;1234   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000472  f1040010          ADD      r0,r4,#0x10
000476  f7fffffe          BL       xTaskRemoveFromEventList
00047a  b130              CBZ      r0,|L1.1162|
;;;1235   					{
;;;1236   						/* The task waiting has a higher priority than us so
;;;1237   						force a context switch. */
;;;1238   						if( pxHigherPriorityTaskWoken != NULL )
00047c  b12e              CBZ      r6,|L1.1162|
;;;1239   						{
;;;1240   							*pxHigherPriorityTaskWoken = pdTRUE;
00047e  2001              MOVS     r0,#1
000480  6030              STR      r0,[r6,#0]
000482  e002              B        |L1.1162|
                  |L1.1156|
;;;1241   						}
;;;1242   					}
;;;1243   				}
;;;1244   			}
;;;1245   			else
;;;1246   			{
;;;1247   				/* Increment the lock count so the task that unlocks the queue
;;;1248   				knows that data was removed while it was locked. */
;;;1249   				++( pxQueue->xRxLock );
000484  6c60              LDR      r0,[r4,#0x44]
000486  1c40              ADDS     r0,r0,#1
000488  6460              STR      r0,[r4,#0x44]
                  |L1.1162|
;;;1250   			}
;;;1251   
;;;1252   			xReturn = pdPASS;
00048a  2701              MOVS     r7,#1
00048c  e000              B        |L1.1168|
                  |L1.1166|
;;;1253   		}
;;;1254   		else
;;;1255   		{
;;;1256   			xReturn = pdFAIL;
00048e  2700              MOVS     r7,#0
                  |L1.1168|
;;;1257   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1258   		}
;;;1259   	}
;;;1260   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000490  4648              MOV      r0,r9
000492  f7fffffe          BL       vPortClearInterruptMask
;;;1261   
;;;1262   	return xReturn;
000496  4638              MOV      r0,r7
;;;1263   }
000498  e8bd87f0          POP      {r4-r10,pc}
;;;1264   /*-----------------------------------------------------------*/
                          ENDP

                  xQueuePeekFromISR PROC
;;;1265   
;;;1266   signed portBASE_TYPE xQueuePeekFromISR( xQueueHandle xQueue, const void * const pvBuffer )
00049c  e92d47f0          PUSH     {r4-r10,lr}
;;;1267   {
0004a0  4605              MOV      r5,r0
0004a2  4688              MOV      r8,r1
;;;1268   signed portBASE_TYPE xReturn;
;;;1269   unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1270   signed char *pcOriginalReadPosition;
;;;1271   xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
0004a4  462c              MOV      r4,r5
;;;1272   
;;;1273   	configASSERT( pxQueue );
;;;1274   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;1275   
;;;1276   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1277   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1278   	above the maximum system call priority are keep permanently enabled, even
;;;1279   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1280   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1281   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1282   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1283   	assigned a priority above the configured maximum system call priority.
;;;1284   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1285   	that have been assigned a priority at or (logically) below the maximum
;;;1286   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1287   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1288   	More information (albeit Cortex-M specific) is provided on the following
;;;1289   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1290   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1291   
;;;1292   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0004a6  f7fffffe          BL       ulPortSetInterruptMask
0004aa  4681              MOV      r9,r0
;;;1293   	{
;;;1294   		/* Cannot block in an ISR, so check there is data available. */
;;;1295   		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
0004ac  6ba0              LDR      r0,[r4,#0x38]
0004ae  b138              CBZ      r0,|L1.1216|
;;;1296   		{
;;;1297   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1298   
;;;1299   			/* Remember the read position so it can be reset as nothing is
;;;1300   			actually being removed from the queue. */
;;;1301   			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
0004b0  68e7              LDR      r7,[r4,#0xc]
;;;1302   			prvCopyDataFromQueue( pxQueue, pvBuffer );
0004b2  4641              MOV      r1,r8
0004b4  4620              MOV      r0,r4
0004b6  f7fffffe          BL       prvCopyDataFromQueue
;;;1303   			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
0004ba  60e7              STR      r7,[r4,#0xc]
;;;1304   
;;;1305   			xReturn = pdPASS;
0004bc  2601              MOVS     r6,#1
0004be  e000              B        |L1.1218|
                  |L1.1216|
;;;1306   		}
;;;1307   		else
;;;1308   		{
;;;1309   			xReturn = pdFAIL;
0004c0  2600              MOVS     r6,#0
                  |L1.1218|
;;;1310   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1311   		}
;;;1312   	}
;;;1313   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0004c2  4648              MOV      r0,r9
0004c4  f7fffffe          BL       vPortClearInterruptMask
;;;1314   
;;;1315   	return xReturn;
0004c8  4630              MOV      r0,r6
;;;1316   }
0004ca  e8bd87f0          POP      {r4-r10,pc}
;;;1317   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueMessagesWaiting PROC
;;;1318   
;;;1319   unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
0004ce  b570              PUSH     {r4-r6,lr}
;;;1320   {
0004d0  4604              MOV      r4,r0
;;;1321   unsigned portBASE_TYPE uxReturn;
;;;1322   
;;;1323   	configASSERT( xQueue );
;;;1324   
;;;1325   	taskENTER_CRITICAL();
0004d2  f7fffffe          BL       vPortEnterCritical
;;;1326   		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
0004d6  6ba5              LDR      r5,[r4,#0x38]
;;;1327   	taskEXIT_CRITICAL();
0004d8  f7fffffe          BL       vPortExitCritical
;;;1328   
;;;1329   	return uxReturn;
0004dc  4628              MOV      r0,r5
;;;1330   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
0004de  bd70              POP      {r4-r6,pc}
;;;1331   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueSpacesAvailable PROC
;;;1332   
;;;1333   unsigned portBASE_TYPE uxQueueSpacesAvailable( const xQueueHandle xQueue )
0004e0  b570              PUSH     {r4-r6,lr}
;;;1334   {
0004e2  4604              MOV      r4,r0
;;;1335   unsigned portBASE_TYPE uxReturn;
;;;1336   xQUEUE *pxQueue;
;;;1337   
;;;1338   	pxQueue = ( xQUEUE * ) xQueue;
0004e4  4625              MOV      r5,r4
;;;1339   	configASSERT( pxQueue );
;;;1340   
;;;1341   	taskENTER_CRITICAL();
0004e6  f7fffffe          BL       vPortEnterCritical
;;;1342   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
0004ea  e9d5100e          LDRD     r1,r0,[r5,#0x38]
0004ee  1a46              SUBS     r6,r0,r1
;;;1343   	taskEXIT_CRITICAL();
0004f0  f7fffffe          BL       vPortExitCritical
;;;1344   
;;;1345   	return uxReturn;
0004f4  4630              MOV      r0,r6
;;;1346   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
0004f6  bd70              POP      {r4-r6,pc}
;;;1347   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueMessagesWaitingFromISR PROC
;;;1348   
;;;1349   unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
0004f8  4601              MOV      r1,r0
;;;1350   {
;;;1351   unsigned portBASE_TYPE uxReturn;
;;;1352   
;;;1353   	configASSERT( xQueue );
;;;1354   
;;;1355   	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
0004fa  6b88              LDR      r0,[r1,#0x38]
;;;1356   
;;;1357   	return uxReturn;
;;;1358   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
0004fc  4770              BX       lr
;;;1359   /*-----------------------------------------------------------*/
                          ENDP

                  vQueueDelete PROC
;;;1360   
;;;1361   void vQueueDelete( xQueueHandle xQueue )
0004fe  b570              PUSH     {r4-r6,lr}
;;;1362   {
000500  4604              MOV      r4,r0
;;;1363   xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
000502  4625              MOV      r5,r4
;;;1364   
;;;1365   	configASSERT( pxQueue );
;;;1366   
;;;1367   	traceQUEUE_DELETE( pxQueue );
;;;1368   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1369   	{
;;;1370   		vQueueUnregisterQueue( pxQueue );
;;;1371   	}
;;;1372   	#endif
;;;1373   	vPortFree( pxQueue->pcHead );
000504  6828              LDR      r0,[r5,#0]
000506  f7fffffe          BL       vPortFree
;;;1374   	vPortFree( pxQueue );
00050a  4628              MOV      r0,r5
00050c  f7fffffe          BL       vPortFree
;;;1375   }
000510  bd70              POP      {r4-r6,pc}
;;;1376   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueIsQueueEmptyFromISR PROC
;;;1591   
;;;1592   signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
000512  4601              MOV      r1,r0
;;;1593   {
;;;1594   signed portBASE_TYPE xReturn;
;;;1595   
;;;1596   	configASSERT( xQueue );
;;;1597   	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
000514  6b8a              LDR      r2,[r1,#0x38]
000516  b90a              CBNZ     r2,|L1.1308|
;;;1598   	{
;;;1599   		xReturn = pdTRUE;
000518  2001              MOVS     r0,#1
00051a  e000              B        |L1.1310|
                  |L1.1308|
;;;1600   	}
;;;1601   	else
;;;1602   	{
;;;1603   		xReturn = pdFALSE;
00051c  2000              MOVS     r0,#0
                  |L1.1310|
;;;1604   	}
;;;1605   
;;;1606   	return xReturn;
;;;1607   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00051e  4770              BX       lr
;;;1608   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueIsQueueFullFromISR PROC
;;;1630   
;;;1631   signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
000520  4601              MOV      r1,r0
;;;1632   {
;;;1633   signed portBASE_TYPE xReturn;
;;;1634   
;;;1635   	configASSERT( xQueue );
;;;1636   	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
000522  6b8a              LDR      r2,[r1,#0x38]
000524  6bcb              LDR      r3,[r1,#0x3c]
000526  429a              CMP      r2,r3
000528  d101              BNE      |L1.1326|
;;;1637   	{
;;;1638   		xReturn = pdTRUE;
00052a  2001              MOVS     r0,#1
00052c  e000              B        |L1.1328|
                  |L1.1326|
;;;1639   	}
;;;1640   	else
;;;1641   	{
;;;1642   		xReturn = pdFALSE;
00052e  2000              MOVS     r0,#0
                  |L1.1328|
;;;1643   	}
;;;1644   
;;;1645   	return xReturn;
;;;1646   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000530  4770              BX       lr
;;;1647   /*-----------------------------------------------------------*/
                          ENDP

